var definePropertyIfExistsInObject = (
  propertyDefinitionHandler,
  propertyKey,
  propertyValue,
) =>
  propertyKey in propertyDefinitionHandler
    ? Object.defineProperty(propertyDefinitionHandler, propertyKey, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: propertyValue,
      })
    : (propertyDefinitionHandler[propertyKey] = propertyValue);
var resettableValueUpdater =
  (initializeAndResetValue, initializeAndResettableValue) => () => {
    if (initializeAndResetValue) {
      initializeAndResettableValue = initializeAndResetValue(
        (initializeAndResetValue = 0),
      );
    }
    return initializeAndResettableValue;
  };
var lazyModuleInitializer =
  (initializeModule, initializeAndGetModuleExports) => () => {
    if (!initializeAndGetModuleExports) {
      initializeModule(
        (initializeAndGetModuleExports = {
          exports: {},
        }).exports,
        initializeAndGetModuleExports,
      );
    }
    return initializeAndGetModuleExports.exports;
  };
var defineGettersForProperties = (
  definePropertiesFromSource,
  propertyDefinitions,
) => {
  for (var ___propertyKey in propertyDefinitions) {
    Object.defineProperty(definePropertiesFromSource, ___propertyKey, {
      get: propertyDefinitions[___propertyKey],
      enumerable: true,
    });
  }
};
var definePropertiesFromObject = (
  safelyDefineProperties,
  sourceObject,
  excludedPropertyKey,
  _propertyDescriptor,
) => {
  if (
    (sourceObject && typeof sourceObject == "object") ||
    typeof sourceObject == "function"
  ) {
    for (let propertyName of Object.getOwnPropertyNames(sourceObject)) {
      if (
        !Object.prototype.hasOwnProperty.call(
          safelyDefineProperties,
          propertyName,
        ) &&
        propertyName !== excludedPropertyKey
      ) {
        Object.defineProperty(safelyDefineProperties, propertyName, {
          get: () => sourceObject[propertyName],
          enumerable:
            !(_propertyDescriptor = Object.getOwnPropertyDescriptor(
              sourceObject,
              propertyName,
            )) || _propertyDescriptor.enumerable,
        });
      }
    }
  }
  return safelyDefineProperties;
};
var mergePropertiesWithDefaults = (
  sourcePropertyMappings,
  basePropertyMappings,
  extraPropertyMappings,
) => {
  definePropertiesFromObject(
    sourcePropertyMappings,
    basePropertyMappings,
    "default",
  );
  return (
    extraPropertyMappings &&
    definePropertiesFromObject(
      extraPropertyMappings,
      basePropertyMappings,
      "default",
    )
  );
};
var initializeObjectWithProperties = (
  inputSourceObject,
  propertiesToDefine,
  initializedObject,
) => {
  if (inputSourceObject != null) {
    initializedObject = Object.create(Object.getPrototypeOf(inputSourceObject));
  } else {
    initializedObject = {};
  }
  return definePropertiesFromObject(
    propertiesToDefine || !inputSourceObject || !inputSourceObject.__esModule
      ? Object.defineProperty(initializedObject, "default", {
          value: inputSourceObject,
          enumerable: true,
        })
      : initializedObject,
    inputSourceObject,
  );
};
var defineESModuleWithProperties = (defineExportedProperties) =>
  definePropertiesFromObject(
    Object.defineProperty({}, "__esModule", {
      value: true,
    }),
    defineExportedProperties,
  );
var setPropertyIfSymbolExists = (
  defineAndReturnObjectProperty,
  defineAndReturnObjectPropertyValue,
  propertyValue,
) => {
  definePropertyIfExistsInObject(
    defineAndReturnObjectProperty,
    typeof defineAndReturnObjectPropertyValue != "symbol"
      ? defineAndReturnObjectPropertyValue + ""
      : defineAndReturnObjectPropertyValue,
    propertyValue,
  );
  return propertyValue;
};
var lazyLoadModuleWithSymbolSupportCheck = lazyModuleInitializer(
  (validateSymbolSupport, validateSymbolSupportImplementation) => {
    validateSymbolSupportImplementation.exports = function () {
      if (
        typeof Symbol != "function" ||
        typeof Object.getOwnPropertySymbols != "function"
      ) {
        return false;
      }
      if (typeof Symbol.iterator == "symbol") {
        return true;
      }
      var symbolPropertiesStorage = {};
      var uniqueTestSymbol = Symbol("test");
      var symbolAsObject = Object(uniqueTestSymbol);
      if (
        typeof uniqueTestSymbol == "string" ||
        Object.prototype.toString.call(uniqueTestSymbol) !==
          "[object Symbol]" ||
        Object.prototype.toString.call(symbolAsObject) !== "[object Symbol]"
      ) {
        return false;
      }
      var symbolAssignedValue = 42;
      symbolPropertiesStorage[uniqueTestSymbol] = symbolAssignedValue;
      for (uniqueTestSymbol in symbolPropertiesStorage) {
        return false;
      }
      if (
        (typeof Object.keys == "function" &&
          Object.keys(symbolPropertiesStorage).length !== 0) ||
        (typeof Object.getOwnPropertyNames == "function" &&
          Object.getOwnPropertyNames(symbolPropertiesStorage).length !== 0)
      ) {
        return false;
      }
      var getSymbolPropertyNames = Object.getOwnPropertySymbols(
        symbolPropertiesStorage,
      );
      if (
        getSymbolPropertyNames.length !== 1 ||
        getSymbolPropertyNames[0] !== uniqueTestSymbol ||
        !Object.prototype.propertyIsEnumerable.call(
          symbolPropertiesStorage,
          uniqueTestSymbol,
        )
      ) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var symbolPropertyDescriptor = Object.getOwnPropertyDescriptor(
          symbolPropertiesStorage,
          uniqueTestSymbol,
        );
        if (
          symbolPropertyDescriptor.value !== symbolAssignedValue ||
          symbolPropertyDescriptor.enumerable !== true
        ) {
          return false;
        }
      }
      return true;
    };
  },
);
var conditionalModuleLoaderWithSymbolSupport = lazyModuleInitializer(
  (isToStringTagSymbolSupported, checkToStringTagSymbolAvailability) => {
    var _isToStringTagSymbolSupported = lazyLoadModuleWithSymbolSupportCheck();
    checkToStringTagSymbolAvailability.exports = function () {
      return _isToStringTagSymbolSupported() && !!Symbol.toStringTag;
    };
  },
);
var conditionalSymbolModuleLoader = lazyModuleInitializer(
  (validateSymbolSupport, validateAndLoadModuleWithSymbolSupport) => {
    var isSymbolSupported = typeof Symbol !== "undefined" && Symbol;
    var loadModuleIfSymbolSupported = lazyLoadModuleWithSymbolSupportCheck();
    validateAndLoadModuleWithSymbolSupport.exports = function () {
      if (
        typeof isSymbolSupported != "function" ||
        typeof Symbol != "function" ||
        typeof isSymbolSupported("foo") != "symbol" ||
        typeof Symbol("bar") != "symbol"
      ) {
        return false;
      } else {
        return loadModuleIfSymbolSupported();
      }
    };
  },
);
var initializeBoundFunctionWithSymbolSupport = lazyModuleInitializer(
  (createBoundFunctionWithContext, _createBoundFunctionWithContext) => {
    var invalidFunctionBindContextErrorMessage =
      "Function.prototype.bind called on incompatible ";
    var getArgumentsArray = Array.prototype.slice;
    var getObjectTypeString = Object.prototype.toString;
    var EXPECTED_FUNCTION_TYPE_STRING = "[object Function]";
    _createBoundFunctionWithContext.exports = function (
      loadModuleWithSymbolValidation,
    ) {
      var validateAndInvokeFunctionWithArgs = this;
      if (
        typeof validateAndInvokeFunctionWithArgs != "function" ||
        getObjectTypeString.call(validateAndInvokeFunctionWithArgs) !==
          EXPECTED_FUNCTION_TYPE_STRING
      ) {
        throw new TypeError(
          invalidFunctionBindContextErrorMessage +
            validateAndInvokeFunctionWithArgs,
        );
      }
      var initialArgumentList = getArgumentsArray.call(arguments, 1);
      var createFunctionInvokerWithArguments;
      function executeBoundFunctionWithArguments() {
        if (this instanceof createFunctionInvokerWithArguments) {
          var validatedResult = validateAndInvokeFunctionWithArgs.apply(
            this,
            initialArgumentList.concat(getArgumentsArray.call(arguments)),
          );
          if (Object(validatedResult) === validatedResult) {
            return validatedResult;
          } else {
            return this;
          }
        } else {
          return validateAndInvokeFunctionWithArgs.apply(
            loadModuleWithSymbolValidation,
            initialArgumentList.concat(getArgumentsArray.call(arguments)),
          );
        }
      }
      for (
        var totalArgumentsToPass = Math.max(
            0,
            validateAndInvokeFunctionWithArgs.length -
              initialArgumentList.length,
          ),
          generatedArgumentPlaceholders = [],
          currentArgumentIndex = 0;
        currentArgumentIndex < totalArgumentsToPass;
        currentArgumentIndex++
      ) {
        generatedArgumentPlaceholders.push("$" + currentArgumentIndex);
      }
      createFunctionInvokerWithArguments = Function(
        "binder",
        "return function (" +
          generatedArgumentPlaceholders.join(",") +
          "){ return binder.apply(this,arguments); }",
      )(executeBoundFunctionWithArguments);
      if (validateAndInvokeFunctionWithArgs.prototype) {
        function runTask() {}
        runTask.prototype = validateAndInvokeFunctionWithArgs.prototype;
        createFunctionInvokerWithArguments.prototype = new runTask();
        runTask.prototype = null;
      }
      return createFunctionInvokerWithArguments;
    };
  },
);
var createBoundFunctionWithFallback = lazyModuleInitializer(
  (initializeBindingWithFallbackSupport, initializeBindingWithFallback) => {
    var initializeBindingWithFallbackSupportFunction =
      initializeBoundFunctionWithSymbolSupport();
    initializeBindingWithFallback.exports =
      Function.prototype.bind || initializeBindingWithFallbackSupportFunction;
  },
);
var initializeHasOwnPropertyValidator = lazyModuleInitializer(
  (bindAndExportHasOwnProperty, _bindAndExportHasOwnProperty) => {
    var bindAndExportOwnPropertyValidation = createBoundFunctionWithFallback();
    _bindAndExportHasOwnProperty.exports =
      bindAndExportOwnPropertyValidation.call(
        Function.call,
        Object.prototype.hasOwnProperty,
      );
  },
);
var initializeAndValidateBoundFunction = lazyModuleInitializer(
  (manageModuleLoadingBasedOnConditions, ___conditionalModuleLoader) => {
    var ____conditionalModuleLoader;
    var _SyntaxError = SyntaxError;
    var createStrictFunctionFromSource = Function;
    var _TypeError = TypeError;
    function extractConstructorFromBoundFunction(
      _getConstructorFromBoundFunction,
    ) {
      try {
        return createStrictFunctionFromSource(
          '"use strict"; return (' +
            _getConstructorFromBoundFunction +
            ").constructor;",
        )();
      } catch {}
    }
    var getObjectPropertyDescriptor = Object.getOwnPropertyDescriptor;
    if (getObjectPropertyDescriptor) {
      try {
        getObjectPropertyDescriptor({}, "");
      } catch {
        getObjectPropertyDescriptor = null;
      }
    }
    function raiseTypeError() {
      throw new _TypeError();
    }
    var getCurrentFunctionCallee = getObjectPropertyDescriptor
      ? (function () {
          try {
            arguments.callee;
            return raiseTypeError;
          } catch {
            try {
              return getObjectPropertyDescriptor(arguments, "callee").get;
            } catch {
              return raiseTypeError;
            }
          }
        })()
      : raiseTypeError;
    var loadModuleConditionally = conditionalSymbolModuleLoader()();
    var conditionalModuleLoaderBasedOnConditions =
      Object.getPrototypeOf ||
      function (getPrototypeUsingBinding) {
        return getPrototypeUsingBinding.__proto__;
      };
    var _____conditionalModuleLoader = {};
    var _conditionalModuleLoaderBasedOnConditions =
      typeof Uint8Array === "undefined"
        ? ____conditionalModuleLoader
        : conditionalModuleLoaderBasedOnConditions(Uint8Array);
    var conditionalModuleLoaderBasedOnEnvironment = {
      "%AggregateError%":
        typeof AggregateError === "undefined"
          ? ____conditionalModuleLoader
          : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%":
        typeof ArrayBuffer === "undefined"
          ? ____conditionalModuleLoader
          : ArrayBuffer,
      "%ArrayIteratorPrototype%": loadModuleConditionally
        ? conditionalModuleLoaderBasedOnConditions([][Symbol.iterator]())
        : ____conditionalModuleLoader,
      "%AsyncFromSyncIteratorPrototype%": ____conditionalModuleLoader,
      "%AsyncFunction%": _____conditionalModuleLoader,
      "%AsyncGenerator%": _____conditionalModuleLoader,
      "%AsyncGeneratorFunction%": _____conditionalModuleLoader,
      "%AsyncIteratorPrototype%": _____conditionalModuleLoader,
      "%Atomics%":
        typeof Atomics === "undefined" ? ____conditionalModuleLoader : Atomics,
      "%BigInt%":
        typeof BigInt === "undefined" ? ____conditionalModuleLoader : BigInt,
      "%Boolean%": Boolean,
      "%DataView%":
        typeof DataView === "undefined"
          ? ____conditionalModuleLoader
          : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%":
        typeof Float32Array === "undefined"
          ? ____conditionalModuleLoader
          : Float32Array,
      "%Float64Array%":
        typeof Float64Array === "undefined"
          ? ____conditionalModuleLoader
          : Float64Array,
      "%FinalizationRegistry%":
        typeof FinalizationRegistry === "undefined"
          ? ____conditionalModuleLoader
          : FinalizationRegistry,
      "%Function%": createStrictFunctionFromSource,
      "%GeneratorFunction%": _____conditionalModuleLoader,
      "%Int8Array%":
        typeof Int8Array === "undefined"
          ? ____conditionalModuleLoader
          : Int8Array,
      "%Int16Array%":
        typeof Int16Array === "undefined"
          ? ____conditionalModuleLoader
          : Int16Array,
      "%Int32Array%":
        typeof Int32Array === "undefined"
          ? ____conditionalModuleLoader
          : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": loadModuleConditionally
        ? conditionalModuleLoaderBasedOnConditions(
            conditionalModuleLoaderBasedOnConditions([][Symbol.iterator]()),
          )
        : ____conditionalModuleLoader,
      "%JSON%": typeof JSON == "object" ? JSON : ____conditionalModuleLoader,
      "%Map%": typeof Map === "undefined" ? ____conditionalModuleLoader : Map,
      "%MapIteratorPrototype%":
        typeof Map === "undefined" || !loadModuleConditionally
          ? ____conditionalModuleLoader
          : conditionalModuleLoaderBasedOnConditions(
              new Map()[Symbol.iterator](),
            ),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%":
        typeof Promise === "undefined" ? ____conditionalModuleLoader : Promise,
      "%Proxy%":
        typeof Proxy === "undefined" ? ____conditionalModuleLoader : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%":
        typeof Reflect === "undefined" ? ____conditionalModuleLoader : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? ____conditionalModuleLoader : Set,
      "%SetIteratorPrototype%":
        typeof Set === "undefined" || !loadModuleConditionally
          ? ____conditionalModuleLoader
          : conditionalModuleLoaderBasedOnConditions(
              new Set()[Symbol.iterator](),
            ),
      "%SharedArrayBuffer%":
        typeof SharedArrayBuffer === "undefined"
          ? ____conditionalModuleLoader
          : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": loadModuleConditionally
        ? conditionalModuleLoaderBasedOnConditions(""[Symbol.iterator]())
        : ____conditionalModuleLoader,
      "%Symbol%": loadModuleConditionally
        ? Symbol
        : ____conditionalModuleLoader,
      "%SyntaxError%": _SyntaxError,
      "%ThrowTypeError%": getCurrentFunctionCallee,
      "%TypedArray%": _conditionalModuleLoaderBasedOnConditions,
      "%TypeError%": _TypeError,
      "%Uint8Array%":
        typeof Uint8Array === "undefined"
          ? ____conditionalModuleLoader
          : Uint8Array,
      "%Uint8ClampedArray%":
        typeof Uint8ClampedArray === "undefined"
          ? ____conditionalModuleLoader
          : Uint8ClampedArray,
      "%Uint16Array%":
        typeof Uint16Array === "undefined"
          ? ____conditionalModuleLoader
          : Uint16Array,
      "%Uint32Array%":
        typeof Uint32Array === "undefined"
          ? ____conditionalModuleLoader
          : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%":
        typeof WeakMap === "undefined" ? ____conditionalModuleLoader : WeakMap,
      "%WeakRef%":
        typeof WeakRef === "undefined" ? ____conditionalModuleLoader : WeakRef,
      "%WeakSet%":
        typeof WeakSet === "undefined" ? ____conditionalModuleLoader : WeakSet,
    };
    var manageConditionalModuleLoading =
      function loadConditionalModuleForObjectPrototype(conditionalModuleName) {
        var constructorPrototype;
        if (conditionalModuleName === "%AsyncFunction%") {
          constructorPrototype = extractConstructorFromBoundFunction(
            "async function () {}",
          );
        } else if (conditionalModuleName === "%GeneratorFunction%") {
          constructorPrototype =
            extractConstructorFromBoundFunction("function* () {}");
        } else if (conditionalModuleName === "%AsyncGeneratorFunction%") {
          constructorPrototype = extractConstructorFromBoundFunction(
            "async function* () {}",
          );
        } else if (conditionalModuleName === "%AsyncGenerator%") {
          var asyncGeneratorFunctionPrototypeObject =
            loadConditionalModuleForObjectPrototype("%AsyncGeneratorFunction%");
          if (asyncGeneratorFunctionPrototypeObject) {
            constructorPrototype =
              asyncGeneratorFunctionPrototypeObject.prototype;
          }
        } else if (conditionalModuleName === "%AsyncIteratorPrototype%") {
          var asyncGeneratorPrototypeLoader =
            loadConditionalModuleForObjectPrototype("%AsyncGenerator%");
          if (asyncGeneratorPrototypeLoader) {
            constructorPrototype = conditionalModuleLoaderBasedOnConditions(
              asyncGeneratorPrototypeLoader.prototype,
            );
          }
        }
        conditionalModuleLoaderBasedOnEnvironment[conditionalModuleName] =
          constructorPrototype;
        return constructorPrototype;
      };
    var _manageConditionalModuleLoading = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": [
        "AsyncGeneratorFunction",
        "prototype",
        "prototype",
      ],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"],
    };
    var conditionalModuleLoaderBasedOnCriteria =
      createBoundFunctionWithFallback();
    var manageModuleLoadingConditionally = initializeHasOwnPropertyValidator();
    var conditionalModuleLoaderImplementation =
      conditionalModuleLoaderBasedOnCriteria.call(
        Function.call,
        Array.prototype.concat,
      );
    var ___________________conditionalModuleLoader =
      conditionalModuleLoaderBasedOnCriteria.call(
        Function.apply,
        Array.prototype.splice,
      );
    var ____________________conditionalModuleLoader =
      conditionalModuleLoaderBasedOnCriteria.call(
        Function.call,
        String.prototype.replace,
      );
    var conditionalModuleLoaderForDynamicImports =
      conditionalModuleLoaderBasedOnCriteria.call(
        Function.call,
        String.prototype.slice,
      );
    var _____________________conditionalModuleLoader =
      conditionalModuleLoaderBasedOnCriteria.call(
        Function.call,
        RegExp.prototype.exec,
      );
    var ______________________conditionalModuleLoader =
      /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var _______________________conditionalModuleLoader = /\\(\\)?/g;
    function validatePrototypeSyntaxAndBindings(prototypeSyntaxValidator) {
      var validateSyntaxAndCheckBindings =
        conditionalModuleLoaderForDynamicImports(
          prototypeSyntaxValidator,
          0,
          1,
        );
      var lastSyntaxSymbolCheck = conditionalModuleLoaderForDynamicImports(
        prototypeSyntaxValidator,
        -1,
      );
      if (
        validateSyntaxAndCheckBindings === "%" &&
        lastSyntaxSymbolCheck !== "%"
      ) {
        throw new _SyntaxError(
          "invalid intrinsic syntax, expected closing `%`",
        );
      }
      if (
        lastSyntaxSymbolCheck === "%" &&
        validateSyntaxAndCheckBindings !== "%"
      ) {
        throw new _SyntaxError(
          "invalid intrinsic syntax, expected opening `%`",
        );
      }
      var validatedPrototypes = [];
      ____________________conditionalModuleLoader(
        prototypeSyntaxValidator,
        ______________________conditionalModuleLoader,
        function (
          validateAndBindPrototypeFunction,
          bindAndValidatePrototypeFunctionCall,
          prototypeValidationResult,
          validateAndBindPrototype,
        ) {
          if (prototypeValidationResult) {
            validatedPrototypes[validatedPrototypes.length] =
              ____________________conditionalModuleLoader(
                validateAndBindPrototype,
                _______________________conditionalModuleLoader,
                "$1",
              );
          } else {
            validatedPrototypes[validatedPrototypes.length] =
              bindAndValidatePrototypeFunctionCall ||
              validateAndBindPrototypeFunction;
          }
        },
      );
      return validatedPrototypes;
    }
    function validateAndBindIntrinsicFunction(
      validateAndBindIntrinsicFunctions,
      validateAndBindFunctionBasedOnPrototype,
    ) {
      var validatedIntrinsicFunction = validateAndBindIntrinsicFunctions;
      var ________________________conditionalModuleLoader;
      if (
        manageModuleLoadingConditionally(
          _manageConditionalModuleLoading,
          validatedIntrinsicFunction,
        )
      ) {
        ________________________conditionalModuleLoader =
          _manageConditionalModuleLoading[validatedIntrinsicFunction];
        validatedIntrinsicFunction =
          "%" + ________________________conditionalModuleLoader[0] + "%";
      }
      if (
        manageModuleLoadingConditionally(
          conditionalModuleLoaderBasedOnEnvironment,
          validatedIntrinsicFunction,
        )
      ) {
        var loadedConditionalModule =
          conditionalModuleLoaderBasedOnEnvironment[validatedIntrinsicFunction];
        if (loadedConditionalModule === _____conditionalModuleLoader) {
          loadedConditionalModule = manageConditionalModuleLoading(
            validatedIntrinsicFunction,
          );
        }
        if (
          typeof loadedConditionalModule === "undefined" &&
          !validateAndBindFunctionBasedOnPrototype
        ) {
          throw new _TypeError(
            "intrinsic " +
              validateAndBindIntrinsicFunctions +
              " exists, but is not available. Please file an issue!",
          );
        }
        return {
          alias: ________________________conditionalModuleLoader,
          name: validatedIntrinsicFunction,
          value: loadedConditionalModule,
        };
      }
      throw new _SyntaxError(
        "intrinsic " + validateAndBindIntrinsicFunctions + " does not exist!",
      );
    }
    ___conditionalModuleLoader.exports = function (
      validateAndLoadPrototypes,
      validateAndBindFunction,
    ) {
      if (
        typeof validateAndLoadPrototypes != "string" ||
        validateAndLoadPrototypes.length === 0
      ) {
        throw new _TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof validateAndBindFunction != "boolean") {
        throw new _TypeError('"allowMissing" argument must be a boolean');
      }
      if (
        _____________________conditionalModuleLoader(
          /^%?[^%]*%?$/,
          validateAndLoadPrototypes,
        ) === null
      ) {
        throw new _SyntaxError(
          "`%` may not be present anywhere but at the beginning and end of the intrinsic name",
        );
      }
      var validatedPrototype = validatePrototypeSyntaxAndBindings(
        validateAndLoadPrototypes,
      );
      var validatedPrototypeName =
        validatedPrototype.length > 0 ? validatedPrototype[0] : "";
      var boundIntrinsicFunction = validateAndBindIntrinsicFunction(
        "%" + validatedPrototypeName + "%",
        validateAndBindFunction,
      );
      var intrinsicFunctionName = boundIntrinsicFunction.name;
      var intrinsicFunctionObject = boundIntrinsicFunction.value;
      var validateAndExtractPrototypes = false;
      var validateIntrinsicParametersAndBind = boundIntrinsicFunction.alias;
      if (validateIntrinsicParametersAndBind) {
        validatedPrototypeName = validateIntrinsicParametersAndBind[0];
        ___________________conditionalModuleLoader(
          validatedPrototype,
          conditionalModuleLoaderImplementation(
            [0, 1],
            validateIntrinsicParametersAndBind,
          ),
        );
      }
      for (
        var currentPrototypeIndex = 1, isPrototypeNameValid = true;
        currentPrototypeIndex < validatedPrototype.length;
        currentPrototypeIndex += 1
      ) {
        var currentValidatedPrototypeName =
          validatedPrototype[currentPrototypeIndex];
        var loadValidatedConditionalModule =
          conditionalModuleLoaderForDynamicImports(
            currentValidatedPrototypeName,
            0,
            1,
          );
        var conditionalModuleName = conditionalModuleLoaderForDynamicImports(
          currentValidatedPrototypeName,
          -1,
        );
        if (
          (loadValidatedConditionalModule === '"' ||
            loadValidatedConditionalModule === "'" ||
            loadValidatedConditionalModule === "`" ||
            conditionalModuleName === '"' ||
            conditionalModuleName === "'" ||
            conditionalModuleName === "`") &&
          loadValidatedConditionalModule !== conditionalModuleName
        ) {
          throw new _SyntaxError(
            "property names with quotes must have matching quotes",
          );
        }
        if (
          currentValidatedPrototypeName === "constructor" ||
          !isPrototypeNameValid
        ) {
          validateAndExtractPrototypes = true;
        }
        validatedPrototypeName += "." + currentValidatedPrototypeName;
        intrinsicFunctionName = "%" + validatedPrototypeName + "%";
        if (
          manageModuleLoadingConditionally(
            conditionalModuleLoaderBasedOnEnvironment,
            intrinsicFunctionName,
          )
        ) {
          intrinsicFunctionObject =
            conditionalModuleLoaderBasedOnEnvironment[intrinsicFunctionName];
        } else if (intrinsicFunctionObject != null) {
          if (!(currentValidatedPrototypeName in intrinsicFunctionObject)) {
            if (!validateAndBindFunction) {
              throw new _TypeError(
                "base intrinsic for " +
                  validateAndLoadPrototypes +
                  " exists, but the property is not available.",
              );
            }
            return;
          }
          if (
            getObjectPropertyDescriptor &&
            currentPrototypeIndex + 1 >= validatedPrototype.length
          ) {
            var validatedPrototypeDescriptor = getObjectPropertyDescriptor(
              intrinsicFunctionObject,
              currentValidatedPrototypeName,
            );
            isPrototypeNameValid = !!validatedPrototypeDescriptor;
            if (
              isPrototypeNameValid &&
              "get" in validatedPrototypeDescriptor &&
              !("originalValue" in validatedPrototypeDescriptor.get)
            ) {
              intrinsicFunctionObject = validatedPrototypeDescriptor.get;
            } else {
              intrinsicFunctionObject =
                intrinsicFunctionObject[currentValidatedPrototypeName];
            }
          } else {
            isPrototypeNameValid = manageModuleLoadingConditionally(
              intrinsicFunctionObject,
              currentValidatedPrototypeName,
            );
            intrinsicFunctionObject =
              intrinsicFunctionObject[currentValidatedPrototypeName];
          }
          if (isPrototypeNameValid && !validateAndExtractPrototypes) {
            conditionalModuleLoaderBasedOnEnvironment[intrinsicFunctionName] =
              intrinsicFunctionObject;
          }
        }
      }
      return intrinsicFunctionObject;
    };
  },
);
var validatePrototypeFunctionName = lazyModuleInitializer(
  (
    bindFunctionWithValidationAndFallback,
    exportedFunctionWithPrototypeValidation,
  ) => {
    var createValidatedBoundFunction = createBoundFunctionWithFallback();
    var initializeAndValidateFunction = initializeAndValidateBoundFunction();
    var getValidatedFunctionApplyMethod = initializeAndValidateFunction(
      "%Function.prototype.apply%",
    );
    var getFunctionCallMethod = initializeAndValidateFunction(
      "%Function.prototype.call%",
    );
    var getValidatedReflectApplyMethod =
      initializeAndValidateFunction("%Reflect.apply%", true) ||
      createValidatedBoundFunction.call(
        getFunctionCallMethod,
        getValidatedFunctionApplyMethod,
      );
    var getObjectPropertyDescriptorWithValidation =
      initializeAndValidateFunction("%Object.getOwnPropertyDescriptor%", true);
    var initializeAndValidateObjectPropertyDefinitionMethod =
      initializeAndValidateFunction("%Object.defineProperty%", true);
    var getValidatedMaxFunction = initializeAndValidateFunction("%Math.max%");
    if (initializeAndValidateObjectPropertyDefinitionMethod) {
      try {
        initializeAndValidateObjectPropertyDefinitionMethod({}, "a", {
          value: 1,
        });
      } catch {
        initializeAndValidateObjectPropertyDefinitionMethod = null;
      }
    }
    exportedFunctionWithPrototypeValidation.exports = function (
      _validateAndBindFunction,
    ) {
      var validatedBoundFunction = getValidatedReflectApplyMethod(
        createValidatedBoundFunction,
        getFunctionCallMethod,
        arguments,
      );
      if (
        getObjectPropertyDescriptorWithValidation &&
        initializeAndValidateObjectPropertyDefinitionMethod
      ) {
        var lengthDescriptorForBoundFunction =
          getObjectPropertyDescriptorWithValidation(
            validatedBoundFunction,
            "length",
          );
        if (lengthDescriptorForBoundFunction.configurable) {
          initializeAndValidateObjectPropertyDefinitionMethod(
            validatedBoundFunction,
            "length",
            {
              value:
                1 +
                getValidatedMaxFunction(
                  0,
                  _validateAndBindFunction.length - (arguments.length - 1),
                ),
            },
          );
        }
      }
      return validatedBoundFunction;
    };
    function invokeValidatedBoundFunctionWithArgs() {
      return getValidatedReflectApplyMethod(
        createValidatedBoundFunction,
        getValidatedFunctionApplyMethod,
        arguments,
      );
    }
    if (initializeAndValidateObjectPropertyDefinitionMethod) {
      initializeAndValidateObjectPropertyDefinitionMethod(
        exportedFunctionWithPrototypeValidation.exports,
        "apply",
        {
          value: invokeValidatedBoundFunctionWithArgs,
        },
      );
    } else {
      exportedFunctionWithPrototypeValidation.exports.apply =
        invokeValidatedBoundFunctionWithArgs;
    }
  },
);
var validateAndBindIntrinsicPropertyAccess = lazyModuleInitializer(
  (exportValidatedStringIndexFunction, _exportValidatedStringIndexFunction) => {
    var initializeAndValidateStringIndexOf =
      initializeAndValidateBoundFunction();
    var validateFunctionNameUsingPrototype = validatePrototypeFunctionName();
    var isStringPrototypeIndexOfValid = validateFunctionNameUsingPrototype(
      initializeAndValidateStringIndexOf("String.prototype.indexOf"),
    );
    _exportValidatedStringIndexFunction.exports = function (
      retrieveAndValidateIntrinsicProperty,
      retrieveAndValidateFunctionName,
    ) {
      var getValidatedStringIndexFunction = initializeAndValidateStringIndexOf(
        retrieveAndValidateIntrinsicProperty,
        !!retrieveAndValidateFunctionName,
      );
      if (
        typeof getValidatedStringIndexFunction == "function" &&
        isStringPrototypeIndexOfValid(
          retrieveAndValidateIntrinsicProperty,
          ".prototype.",
        ) > -1
      ) {
        return validateFunctionNameUsingPrototype(
          getValidatedStringIndexFunction,
        );
      } else {
        return getValidatedStringIndexFunction;
      }
    };
  },
);
var getValidatedIntrinsicProperty = lazyModuleInitializer(
  (isValidArgumentsInstance, isObjectArgumentsInstance) => {
    var supportsLegacyArgumentsFeature =
      conditionalModuleLoaderWithSymbolSupport()();
    var validateIntrinsicProperties = validateAndBindIntrinsicPropertyAccess();
    var getObjectType = validateIntrinsicProperties(
      "Object.prototype.toString",
    );
    function validateIfArgumentsObject(isArgumentsObjectValidator) {
      if (
        supportsLegacyArgumentsFeature &&
        isArgumentsObjectValidator &&
        typeof isArgumentsObjectValidator == "object" &&
        Symbol.toStringTag in isArgumentsObjectValidator
      ) {
        return false;
      } else {
        return (
          getObjectType(isArgumentsObjectValidator) === "[object Arguments]"
        );
      }
    }
    function _validateIntrinsicObject(validateIntrinsicObject) {
      if (validateIfArgumentsObject(validateIntrinsicObject)) {
        return true;
      } else {
        return (
          validateIntrinsicObject !== null &&
          typeof validateIntrinsicObject == "object" &&
          typeof validateIntrinsicObject.length == "number" &&
          validateIntrinsicObject.length >= 0 &&
          getObjectType(validateIntrinsicObject) !== "[object Array]" &&
          getObjectType(validateIntrinsicObject.callee) === "[object Function]"
        );
      }
    }
    var validateArgumentsObject = (function () {
      return validateIfArgumentsObject(arguments);
    })();
    validateIfArgumentsObject.isLegacyArguments = _validateIntrinsicObject;
    if (validateArgumentsObject) {
      isObjectArgumentsInstance.exports = validateIfArgumentsObject;
    } else {
      isObjectArgumentsInstance.exports = _validateIntrinsicObject;
    }
  },
);
var initializeLazyModule = lazyModuleInitializer(
  (checkIfFunctionIsGenerator, _checkIfFunctionIsGenerator) => {
    var _getObjectTypeString = Object.prototype.toString;
    var getFunctionStringRepresentation = Function.prototype.toString;
    var isFunctionGeneratorRegex = /^\s*(?:function)?\*/;
    var isGeneratorFunctionSupported =
      conditionalModuleLoaderWithSymbolSupport()();
    var getObjectPrototype = Object.getPrototypeOf;
    function checkGeneratorFunctionSupport() {
      if (!isGeneratorFunctionSupported) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch {}
    }
    var __isFunctionGenerator;
    _checkIfFunctionIsGenerator.exports = function (isFunctionGenerator) {
      if (typeof isFunctionGenerator != "function") {
        return false;
      }
      if (
        isFunctionGeneratorRegex.test(
          getFunctionStringRepresentation.call(isFunctionGenerator),
        )
      ) {
        return true;
      }
      if (!isGeneratorFunctionSupported) {
        var isFunctionGeneratorStringRepresentation =
          _getObjectTypeString.call(isFunctionGenerator);
        return (
          isFunctionGeneratorStringRepresentation ===
          "[object GeneratorFunction]"
        );
      }
      if (!getObjectPrototype) {
        return false;
      }
      if (typeof __isFunctionGenerator === "undefined") {
        var isGeneratorFunctionAvailable = checkGeneratorFunctionSupport();
        if (isGeneratorFunctionAvailable) {
          __isFunctionGenerator = getObjectPrototype(
            isGeneratorFunctionAvailable,
          );
        } else {
          __isFunctionGenerator = false;
        }
      }
      return getObjectPrototype(isFunctionGenerator) === __isFunctionGenerator;
    };
  },
);
var validateAndRetrieveIntrinsicProperty = lazyModuleInitializer(
  (validateAndRetrieveClassDefinition, _isIntrinsicPropertyValid) => {
    var getFunctionSourceCode = Function.prototype.toString;
    var isReflectApplyFunctionAvailable =
      typeof Reflect == "object" && Reflect !== null && Reflect.apply;
    var lengthAccessorDescriptor;
    var errorObjectForTesting;
    if (
      typeof isReflectApplyFunctionAvailable == "function" &&
      typeof Object.defineProperty == "function"
    ) {
      try {
        lengthAccessorDescriptor = Object.defineProperty({}, "length", {
          get() {
            throw errorObjectForTesting;
          },
        });
        errorObjectForTesting = {};
        isReflectApplyFunctionAvailable(
          function () {
            throw 42;
          },
          null,
          lengthAccessorDescriptor,
        );
      } catch (errorHandler) {
        if (errorHandler !== errorObjectForTesting) {
          isReflectApplyFunctionAvailable = null;
        }
      }
    } else {
      isReflectApplyFunctionAvailable = null;
    }
    var classDeclarationPattern = /^\s*class\b/;
    function isValidIntrinsicProperty(validateAndRetrieveIntrinsicProperty) {
      try {
        var functionSourceCodeString = getFunctionSourceCode.call(
          validateAndRetrieveIntrinsicProperty,
        );
        return classDeclarationPattern.test(functionSourceCodeString);
      } catch {
        return false;
      }
    }
    function checkAndRetrieveFunctionSource(retrieveClassFunctionString) {
      try {
        if (isValidIntrinsicProperty(retrieveClassFunctionString)) {
          return false;
        } else {
          getFunctionSourceCode.call(retrieveClassFunctionString);
          return true;
        }
      } catch {
        return false;
      }
    }
    var retrieveFunctionSourceCode = Object.prototype.toString;
    var _getFunctionSourceCode = "[object Object]";
    var getFunctionSourceCodeString = "[object Function]";
    var getFunctionSourceCodeAsString = "[object GeneratorFunction]";
    var retrieveFunctionSourceCodeRepresentation = "[object HTMLAllCollection]";
    var retrieveClassDefinitionFromFunction =
      "[object HTML document.all class]";
    var __getFunctionSourceCode = "[object HTMLCollection]";
    var _retrieveFunctionSourceCode =
      typeof Symbol == "function" && !!Symbol.toStringTag;
    var __retrieveFunctionSourceCode = !(0 in [,]);
    function isValidIntrinsicReference() {
      return false;
    }
    if (typeof document == "object") {
      getFunctionSourceCodeRepresentation = document.all;
      if (
        retrieveFunctionSourceCode.call(getFunctionSourceCodeRepresentation) ===
        retrieveFunctionSourceCode.call(document.all)
      ) {
        isValidIntrinsicReference = function (__isValidIntrinsicName) {
          if (
            (__retrieveFunctionSourceCode || !__isValidIntrinsicName) &&
            (typeof __isValidIntrinsicName === "undefined" ||
              typeof __isValidIntrinsicName == "object")
          ) {
            try {
              var isIntrinsicNameValidBasedOnFunctionSource =
                retrieveFunctionSourceCode.call(__isValidIntrinsicName);
              return (
                (isIntrinsicNameValidBasedOnFunctionSource ===
                  retrieveFunctionSourceCodeRepresentation ||
                  isIntrinsicNameValidBasedOnFunctionSource ===
                    retrieveClassDefinitionFromFunction ||
                  isIntrinsicNameValidBasedOnFunctionSource ===
                    __getFunctionSourceCode ||
                  isIntrinsicNameValidBasedOnFunctionSource ===
                    _getFunctionSourceCode) &&
                __isValidIntrinsicName("") == null
              );
            } catch {}
          }
          return false;
        };
      }
    }
    var getFunctionSourceCodeRepresentation;
    if (isReflectApplyFunctionAvailable) {
      _isIntrinsicPropertyValid.exports = function (_isFunctionGenerator) {
        if (isValidIntrinsicReference(_isFunctionGenerator)) {
          return true;
        }
        if (
          !_isFunctionGenerator ||
          (typeof _isFunctionGenerator != "function" &&
            typeof _isFunctionGenerator != "object")
        ) {
          return false;
        }
        try {
          isReflectApplyFunctionAvailable(
            _isFunctionGenerator,
            null,
            lengthAccessorDescriptor,
          );
        } catch (_handleError) {
          if (_handleError !== errorObjectForTesting) {
            return false;
          }
        }
        return (
          !isValidIntrinsicProperty(_isFunctionGenerator) &&
          checkAndRetrieveFunctionSource(_isFunctionGenerator)
        );
      };
    } else {
      _isIntrinsicPropertyValid.exports = function (_isValidGeneratorFunction) {
        if (isValidIntrinsicReference(_isValidGeneratorFunction)) {
          return true;
        }
        if (
          !_isValidGeneratorFunction ||
          (typeof _isValidGeneratorFunction != "function" &&
            typeof _isValidGeneratorFunction != "object")
        ) {
          return false;
        }
        if (_retrieveFunctionSourceCode) {
          return checkAndRetrieveFunctionSource(_isValidGeneratorFunction);
        }
        if (isValidIntrinsicProperty(_isValidGeneratorFunction)) {
          return false;
        }
        var functionSourceCodeRepresentation = retrieveFunctionSourceCode.call(
          _isValidGeneratorFunction,
        );
        if (
          functionSourceCodeRepresentation !== getFunctionSourceCodeString &&
          functionSourceCodeRepresentation !== getFunctionSourceCodeAsString &&
          !/^\[object HTML/.test(functionSourceCodeRepresentation)
        ) {
          return false;
        } else {
          return checkAndRetrieveFunctionSource(_isValidGeneratorFunction);
        }
      };
    }
  },
);
var __isValidGeneratorFunction = lazyModuleInitializer(
  (
    __validateAndProcessIntrinsicProperties,
    ___validateAndProcessIntrinsicProperties,
  ) => {
    var validatedIntrinsicProperties = validateAndRetrieveIntrinsicProperty();
    var retrieveObjectType = Object.prototype.toString;
    var _hasOwnPropertyCheck = Object.prototype.hasOwnProperty;
    function processIntrinsicPropertyValidation(
      ____validateAndRetrieveIntrinsicProperty,
      validateAndGetIntrinsicProperty,
      _validateAndRetrieveIntrinsicProperty,
    ) {
      for (
        var intrinsicPropertyIndex = 0,
          totalIntrinsicProperties =
            ____validateAndRetrieveIntrinsicProperty.length;
        intrinsicPropertyIndex < totalIntrinsicProperties;
        intrinsicPropertyIndex++
      ) {
        if (
          _hasOwnPropertyCheck.call(
            ____validateAndRetrieveIntrinsicProperty,
            intrinsicPropertyIndex,
          )
        ) {
          if (_validateAndRetrieveIntrinsicProperty == null) {
            validateAndGetIntrinsicProperty(
              ____validateAndRetrieveIntrinsicProperty[intrinsicPropertyIndex],
              intrinsicPropertyIndex,
              ____validateAndRetrieveIntrinsicProperty,
            );
          } else {
            validateAndGetIntrinsicProperty.call(
              _validateAndRetrieveIntrinsicProperty,
              ____validateAndRetrieveIntrinsicProperty[intrinsicPropertyIndex],
              intrinsicPropertyIndex,
              ____validateAndRetrieveIntrinsicProperty,
            );
          }
        }
      }
    }
    function iterateAndValidateClassInstantiations(
      validateAndProcessClassInstantiations,
      validateAndProcessClassStructure,
      ____validateAndRetrieveIntrinsicProperty,
    ) {
      for (
        var classInstantiationIndex = 0,
          numberOfClassInstantiations =
            validateAndProcessClassInstantiations.length;
        classInstantiationIndex < numberOfClassInstantiations;
        classInstantiationIndex++
      ) {
        if (____validateAndRetrieveIntrinsicProperty == null) {
          validateAndProcessClassStructure(
            validateAndProcessClassInstantiations.charAt(
              classInstantiationIndex,
            ),
            classInstantiationIndex,
            validateAndProcessClassInstantiations,
          );
        } else {
          validateAndProcessClassStructure.call(
            ____validateAndRetrieveIntrinsicProperty,
            validateAndProcessClassInstantiations.charAt(
              classInstantiationIndex,
            ),
            classInstantiationIndex,
            validateAndProcessClassInstantiations,
          );
        }
      }
    }
    function validateAndProcessObjectProperties(
      processAndValidateObjectProperties,
      processAndGetObjectPropertiesCount,
      validateAndRetrieveClassInstanceProperty,
    ) {
      for (var propertyName in processAndValidateObjectProperties) {
        if (
          _hasOwnPropertyCheck.call(
            processAndValidateObjectProperties,
            propertyName,
          )
        ) {
          if (validateAndRetrieveClassInstanceProperty == null) {
            processAndGetObjectPropertiesCount(
              processAndValidateObjectProperties[propertyName],
              propertyName,
              processAndValidateObjectProperties,
            );
          } else {
            processAndGetObjectPropertiesCount.call(
              validateAndRetrieveClassInstanceProperty,
              processAndValidateObjectProperties[propertyName],
              propertyName,
              processAndValidateObjectProperties,
            );
          }
        }
      }
    }
    function validateClassDefinitionAndProcessProperties(
      _validateAndProcessClassDefinition,
      isValidClassDefinition,
      checkAndIdentifyIntrinsicProperty,
    ) {
      if (!validatedIntrinsicProperties(isValidClassDefinition)) {
        throw new TypeError("iterator must be a function");
      }
      var intrinsicPropertyChecker;
      if (arguments.length >= 3) {
        intrinsicPropertyChecker = checkAndIdentifyIntrinsicProperty;
      }
      if (
        retrieveObjectType.call(_validateAndProcessClassDefinition) ===
        "[object Array]"
      ) {
        processIntrinsicPropertyValidation(
          _validateAndProcessClassDefinition,
          isValidClassDefinition,
          intrinsicPropertyChecker,
        );
      } else if (typeof _validateAndProcessClassDefinition == "string") {
        iterateAndValidateClassInstantiations(
          _validateAndProcessClassDefinition,
          isValidClassDefinition,
          intrinsicPropertyChecker,
        );
      } else {
        validateAndProcessObjectProperties(
          _validateAndProcessClassDefinition,
          isValidClassDefinition,
          intrinsicPropertyChecker,
        );
      }
    }
    ___validateAndProcessIntrinsicProperties.exports =
      validateClassDefinitionAndProcessProperties;
  },
);
var checkIfIntrinsicProperty = lazyModuleInitializer(
  (getAvailableTypedArrayNames, getAvailableSupportedTypedArrayNames) => {
    var availableTypedArrayConstructors = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray",
    ];
    var globalExecutionContext =
      typeof globalThis === "undefined" ? global : globalThis;
    getAvailableSupportedTypedArrayNames.exports = function () {
      var availableTypedArrayConstructorsList = [];
      for (
        var typedArrayIndex = 0;
        typedArrayIndex < availableTypedArrayConstructors.length;
        typedArrayIndex++
      ) {
        if (
          typeof globalExecutionContext[
            availableTypedArrayConstructors[typedArrayIndex]
          ] == "function"
        ) {
          availableTypedArrayConstructorsList[
            availableTypedArrayConstructorsList.length
          ] = availableTypedArrayConstructors[typedArrayIndex];
        }
      }
      return availableTypedArrayConstructorsList;
    };
  },
);
var isIntrinsicPropertyValid = lazyModuleInitializer(
  (initializeAndValidatePropertyDescriptor, validatedPropertyDescriptor) => {
    var initializeAndValidateGetOwnPropertyDescriptor =
      initializeAndValidateBoundFunction();
    var validateAndInitializePropertyDescriptor =
      initializeAndValidateGetOwnPropertyDescriptor(
        "%Object.getOwnPropertyDescriptor%",
        true,
      );
    if (validateAndInitializePropertyDescriptor) {
      try {
        validateAndInitializePropertyDescriptor([], "length");
      } catch {
        validateAndInitializePropertyDescriptor = null;
      }
    }
    validatedPropertyDescriptor.exports =
      validateAndInitializePropertyDescriptor;
  },
);
var isValidPropertyDescriptor = lazyModuleInitializer(
  (getIndexOfElementInArray, arrayElementIndexFinder) => {
    var ____isValidGeneratorFunction = __isValidGeneratorFunction();
    var retrieveIntrinsicObject = checkIfIntrinsicProperty();
    var retrieveValidatedPropertyAccess =
      validateAndBindIntrinsicPropertyAccess();
    var validateAndFormatPropertyAccess = retrieveValidatedPropertyAccess(
      "Object.prototype.toString",
    );
    var _conditionalModuleLoaderWithSymbolSupport =
      conditionalModuleLoaderWithSymbolSupport()();
    var executionEnvironment =
      typeof globalThis === "undefined" ? global : globalThis;
    var _retrieveIntrinsicObject = retrieveIntrinsicObject();
    var _getIndexOfElementInArray =
      retrieveValidatedPropertyAccess("Array.prototype.indexOf", true) ||
      function (isValidGeneratorFunctionCheck, _isValidGeneratorFunction) {
        for (
          var currentValidFunctionIndex = 0;
          currentValidFunctionIndex < isValidGeneratorFunctionCheck.length;
          currentValidFunctionIndex += 1
        ) {
          if (
            isValidGeneratorFunctionCheck[currentValidFunctionIndex] ===
            _isValidGeneratorFunction
          ) {
            return currentValidFunctionIndex;
          }
        }
        return -1;
      };
    var _findElementIndexInArray = retrieveValidatedPropertyAccess(
      "String.prototype.slice",
    );
    var isGeneratorFunctionValid = {};
    var getElementIndexFromArray = isIntrinsicPropertyValid();
    var getIndexInArray = Object.getPrototypeOf;
    if (
      _conditionalModuleLoaderWithSymbolSupport &&
      getElementIndexFromArray &&
      getIndexInArray
    ) {
      ____isValidGeneratorFunction(
        _retrieveIntrinsicObject,
        function (__isValidGeneratorFunction) {
          var generatorFunctionInstance = new executionEnvironment[
            __isValidGeneratorFunction
          ]();
          if (Symbol.toStringTag in generatorFunctionInstance) {
            var generatorFunctionElementIndex = getIndexInArray(
              generatorFunctionInstance,
            );
            var toStringTagElementIndex = getElementIndexFromArray(
              generatorFunctionElementIndex,
              Symbol.toStringTag,
            );
            if (!toStringTagElementIndex) {
              var generatorFunctionElementPosition = getIndexInArray(
                generatorFunctionElementIndex,
              );
              toStringTagElementIndex = getElementIndexFromArray(
                generatorFunctionElementPosition,
                Symbol.toStringTag,
              );
            }
            isGeneratorFunctionValid[__isValidGeneratorFunction] =
              toStringTagElementIndex.get;
          }
        },
      );
    }
    function validateIsGeneratorFunction(isValidGeneratorFunction) {
      var isGeneratorFunctionValidationCache = false;
      ____isValidGeneratorFunction(
        isGeneratorFunctionValid,
        function (
          checkIfGeneratorFunctionIsValid,
          _checkIfGeneratorFunctionIsValid,
        ) {
          if (!isGeneratorFunctionValidationCache) {
            try {
              isGeneratorFunctionValidationCache =
                checkIfGeneratorFunctionIsValid.call(
                  isValidGeneratorFunction,
                ) === _checkIfGeneratorFunctionIsValid;
            } catch {}
          }
        },
      );
      return isGeneratorFunctionValidationCache;
    }
    arrayElementIndexFinder.exports = function (validateIfGeneratorFunction) {
      if (
        !validateIfGeneratorFunction ||
        typeof validateIfGeneratorFunction != "object"
      ) {
        return false;
      }
      if (
        !_conditionalModuleLoaderWithSymbolSupport ||
        !(Symbol.toStringTag in validateIfGeneratorFunction)
      ) {
        var elementIndexInArray = _findElementIndexInArray(
          validateAndFormatPropertyAccess(validateIfGeneratorFunction),
          8,
          -1,
        );
        return (
          _getIndexOfElementInArray(
            _retrieveIntrinsicObject,
            elementIndexInArray,
          ) > -1
        );
      }
      if (getElementIndexFromArray) {
        return validateIsGeneratorFunction(validateIfGeneratorFunction);
      } else {
        return false;
      }
    };
  },
);
var ___isValidGeneratorFunction = lazyModuleInitializer(
  (createValidatedInstance, createValidatedInstanceFromIntrinsic) => {
    var _createValidatedInstance = __isValidGeneratorFunction();
    var retrieveIntrinsicObject = checkIfIntrinsicProperty();
    var validateAndBindPropertyAccess =
      validateAndBindIntrinsicPropertyAccess();
    var validateObjectTypeUsingToString = validateAndBindPropertyAccess(
      "Object.prototype.toString",
    );
    var conditionalModuleLoaderWithSymbolSupportInstance =
      conditionalModuleLoaderWithSymbolSupport()();
    var getGlobalObject =
      typeof globalThis === "undefined" ? global : globalThis;
    var intrinsicValue = retrieveIntrinsicObject();
    var validateAndBindStringSlice = validateAndBindPropertyAccess(
      "String.prototype.slice",
    );
    var validatedInstanceResults = {};
    var isIntrinsicPropertyNameValid = isIntrinsicPropertyValid();
    var retrieveObjectPrototype = Object.getPrototypeOf;
    if (
      conditionalModuleLoaderWithSymbolSupportInstance &&
      isIntrinsicPropertyNameValid &&
      retrieveObjectPrototype
    ) {
      _createValidatedInstance(
        intrinsicValue,
        function (validateAndRetrieveGeneratorFunctionProperties) {
          if (
            typeof getGlobalObject[
              validateAndRetrieveGeneratorFunctionProperties
            ] == "function"
          ) {
            var validatedObjectInstance = new getGlobalObject[
              validateAndRetrieveGeneratorFunctionProperties
            ]();
            if (Symbol.toStringTag in validatedObjectInstance) {
              var validatedObjectPrototype = retrieveObjectPrototype(
                validatedObjectInstance,
              );
              var isValidPrototype = isIntrinsicPropertyNameValid(
                validatedObjectPrototype,
                Symbol.toStringTag,
              );
              if (!isValidPrototype) {
                var retrievedValidatedObjectPrototype = retrieveObjectPrototype(
                  validatedObjectPrototype,
                );
                isValidPrototype = isIntrinsicPropertyNameValid(
                  retrievedValidatedObjectPrototype,
                  Symbol.toStringTag,
                );
              }
              validatedInstanceResults[
                validateAndRetrieveGeneratorFunctionProperties
              ] = isValidPrototype.get;
            }
          }
        },
      );
    }
    function handleInstanceValidationAndCreation(
      validateIntrinsicPropertiesAndGenerateInstance,
    ) {
      var hasValidInstance = false;
      _createValidatedInstance(
        validatedInstanceResults,
        function (
          validateAndInstantiateGeneratorFunction,
          validateAndProcessIntrinsicProperties,
        ) {
          if (!hasValidInstance) {
            try {
              var validatedCharacterInstance =
                validateAndInstantiateGeneratorFunction.call(
                  validateIntrinsicPropertiesAndGenerateInstance,
                );
              if (
                validatedCharacterInstance ===
                validateAndProcessIntrinsicProperties
              ) {
                hasValidInstance = validatedCharacterInstance;
              }
            } catch {}
          }
        },
      );
      return hasValidInstance;
    }
    var __createValidatedInstance = isValidPropertyDescriptor();
    createValidatedInstanceFromIntrinsic.exports = function (
      _validateAndRetrieveGeneratorFunctionProperties,
    ) {
      if (
        __createValidatedInstance(
          _validateAndRetrieveGeneratorFunctionProperties,
        )
      ) {
        if (
          !conditionalModuleLoaderWithSymbolSupportInstance ||
          !(
            Symbol.toStringTag in
            _validateAndRetrieveGeneratorFunctionProperties
          )
        ) {
          return validateAndBindStringSlice(
            validateObjectTypeUsingToString(
              _validateAndRetrieveGeneratorFunctionProperties,
            ),
            8,
            -1,
          );
        } else {
          return handleInstanceValidationAndCreation(
            _validateAndRetrieveGeneratorFunctionProperties,
          );
        }
      } else {
        return false;
      }
    };
  },
);
var validateAndGenerateInstance = lazyModuleInitializer(
  (______validateAndProcessIntrinsicProperties) => {
    var validatedIntrinsicPropertyValue = getValidatedIntrinsicProperty();
    var initializeConditionalProcessingModule = initializeLazyModule();
    var isGeneratorFunctionValidated = ___isValidGeneratorFunction();
    var isGeneratorFunctionPropertyValid = isValidPropertyDescriptor();
    function createValidationHandler(
      validateAndProcessGeneratorFunctionProperties,
    ) {
      return validateAndProcessGeneratorFunctionProperties.call.bind(
        validateAndProcessGeneratorFunctionProperties,
      );
    }
    var isBigIntFeatureAvailable = typeof BigInt !== "undefined";
    var isSymbolFeatureAvailable = typeof Symbol !== "undefined";
    var bindPropertyMethodToInstance = createValidationHandler(
      Object.prototype.toString,
    );
    var bindNumberValueFunction = createValidationHandler(
      Number.prototype.valueOf,
    );
    var bindStringValueToInstance = createValidationHandler(
      String.prototype.valueOf,
    );
    var bindBooleanValueFunction = createValidationHandler(
      Boolean.prototype.valueOf,
    );
    if (isBigIntFeatureAvailable) {
      bindValueMethodToPrototype = createValidationHandler(
        BigInt.prototype.valueOf,
      );
    }
    var bindValueMethodToPrototype;
    if (isSymbolFeatureAvailable) {
      _validatedIntrinsicPropertyValue = createValidationHandler(
        Symbol.prototype.valueOf,
      );
    }
    var _validatedIntrinsicPropertyValue;
    function _validateIntrinsicProperties(
      validateAndProcessHandlerIntrinsicProperties,
      isIntrinsicObjectLoaderBasedOnModuleValidation,
    ) {
      if (typeof validateAndProcessHandlerIntrinsicProperties != "object") {
        return false;
      }
      try {
        isIntrinsicObjectLoaderBasedOnModuleValidation(
          validateAndProcessHandlerIntrinsicProperties,
        );
        return true;
      } catch {
        return false;
      }
    }
    ______validateAndProcessIntrinsicProperties.isArgumentsObject =
      validatedIntrinsicPropertyValue;
    ______validateAndProcessIntrinsicProperties.isGeneratorFunction =
      initializeConditionalProcessingModule;
    ______validateAndProcessIntrinsicProperties.isTypedArray =
      isGeneratorFunctionPropertyValid;
    function isValidPromiseOrThenable(_validateIntrinsicObject) {
      return (
        (typeof Promise !== "undefined" &&
          _validateIntrinsicObject instanceof Promise) ||
        (_validateIntrinsicObject !== null &&
          typeof _validateIntrinsicObject == "object" &&
          typeof _validateIntrinsicObject.then == "function" &&
          typeof _validateIntrinsicObject.catch == "function")
      );
    }
    ______validateAndProcessIntrinsicProperties.isPromise =
      isValidPromiseOrThenable;
    function isIntrinsicObjectValid(validateAndProcessIntrinsicObject) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(validateAndProcessIntrinsicObject);
      } else {
        return (
          isGeneratorFunctionPropertyValid(validateAndProcessIntrinsicObject) ||
          checkIfDataViewIsSupported(validateAndProcessIntrinsicObject)
        );
      }
    }
    ______validateAndProcessIntrinsicProperties.isArrayBufferView =
      isIntrinsicObjectValid;
    function validateIfUint8ArrayIntrinsic(validateIntrinsicObjectProperties) {
      return (
        isGeneratorFunctionValidated(validateIntrinsicObjectProperties) ===
        "Uint8Array"
      );
    }
    ______validateAndProcessIntrinsicProperties.isUint8Array =
      validateIfUint8ArrayIntrinsic;
    function isGeneratorFunctionForUint8ClampedArray(gatherValidFunctionNames) {
      return (
        isGeneratorFunctionValidated(gatherValidFunctionNames) ===
        "Uint8ClampedArray"
      );
    }
    ______validateAndProcessIntrinsicProperties.isUint8ClampedArray =
      isGeneratorFunctionForUint8ClampedArray;
    function isUint16ArrayGeneratorFunctionValidated(isValidIntrinsicObject) {
      return (
        isGeneratorFunctionValidated(isValidIntrinsicObject) === "Uint16Array"
      );
    }
    ______validateAndProcessIntrinsicProperties.isUint16Array =
      isUint16ArrayGeneratorFunctionValidated;
    function isValidUint32Array(_isValidIntrinsicObject) {
      return (
        isGeneratorFunctionValidated(_isValidIntrinsicObject) === "Uint32Array"
      );
    }
    ______validateAndProcessIntrinsicProperties.isUint32Array =
      isValidUint32Array;
    function validateInt8ArrayGeneratorFunction(validateGeneratorFunction) {
      return (
        isGeneratorFunctionValidated(validateGeneratorFunction) === "Int8Array"
      );
    }
    ______validateAndProcessIntrinsicProperties.isInt8Array =
      validateInt8ArrayGeneratorFunction;
    function isValidInt16ArrayType(validateIntrinsicObjectType) {
      return (
        isGeneratorFunctionValidated(validateIntrinsicObjectType) ===
        "Int16Array"
      );
    }
    ______validateAndProcessIntrinsicProperties.isInt16Array =
      isValidInt16ArrayType;
    function isInt32ArrayGeneratorFunction(
      validateAndProcessUint8ArrayProperties,
    ) {
      return (
        isGeneratorFunctionValidated(validateAndProcessUint8ArrayProperties) ===
        "Int32Array"
      );
    }
    ______validateAndProcessIntrinsicProperties.isInt32Array =
      isInt32ArrayGeneratorFunction;
    function isFloat32ArrayGeneratorFunctionValidated(
      ___isValidGeneratorFunction,
    ) {
      return (
        isGeneratorFunctionValidated(___isValidGeneratorFunction) ===
        "Float32Array"
      );
    }
    ______validateAndProcessIntrinsicProperties.isFloat32Array =
      isFloat32ArrayGeneratorFunctionValidated;
    function isFloat64ArrayValidatedByGeneratorFunction(
      isGeneratorFunctionTypeCheck,
    ) {
      return (
        isGeneratorFunctionValidated(isGeneratorFunctionTypeCheck) ===
        "Float64Array"
      );
    }
    ______validateAndProcessIntrinsicProperties.isFloat64Array =
      isFloat64ArrayValidatedByGeneratorFunction;
    function validateIfBigInt64ArrayType(isValidArrayTypeCheck) {
      return (
        isGeneratorFunctionValidated(isValidArrayTypeCheck) === "BigInt64Array"
      );
    }
    ______validateAndProcessIntrinsicProperties.isBigInt64Array =
      validateIfBigInt64ArrayType;
    function isValidBigUint64Array(getArrayTypeOrDefault) {
      return (
        isGeneratorFunctionValidated(getArrayTypeOrDefault) === "BigUint64Array"
      );
    }
    ______validateAndProcessIntrinsicProperties.isBigUint64Array =
      isValidBigUint64Array;
    function isInstanceOfMap(isArrayOfTypeInt16) {
      return (
        bindPropertyMethodToInstance(isArrayOfTypeInt16) === "[object Map]"
      );
    }
    isInstanceOfMap.working =
      typeof Map !== "undefined" && isInstanceOfMap(new Map());
    function isValidMapInstanceBasedOnArrayType(isArrayTypeValid) {
      if (typeof Map === "undefined") {
        return false;
      } else if (isInstanceOfMap.working) {
        return isInstanceOfMap(isArrayTypeValid);
      } else {
        return isArrayTypeValid instanceof Map;
      }
    }
    ______validateAndProcessIntrinsicProperties.isMap =
      isValidMapInstanceBasedOnArrayType;
    function isInstanceOfSetUsingPropertyValidation(
      _validateAndProcessIntrinsicProperties,
    ) {
      return (
        bindPropertyMethodToInstance(_validateAndProcessIntrinsicProperties) ===
        "[object Set]"
      );
    }
    isInstanceOfSetUsingPropertyValidation.working =
      typeof Set !== "undefined" &&
      isInstanceOfSetUsingPropertyValidation(new Set());
    function ____isValidGeneratorFunction(isValidMapInstance) {
      if (typeof Set === "undefined") {
        return false;
      } else if (isInstanceOfSetUsingPropertyValidation.working) {
        return isInstanceOfSetUsingPropertyValidation(isValidMapInstance);
      } else {
        return isValidMapInstance instanceof Set;
      }
    }
    ______validateAndProcessIntrinsicProperties.isSet =
      ____isValidGeneratorFunction;
    function validateGeneratorFunctionReturnType(
      _____isValidGeneratorFunction,
    ) {
      return (
        bindPropertyMethodToInstance(_____isValidGeneratorFunction) ===
        "[object WeakMap]"
      );
    }
    validateGeneratorFunctionReturnType.working =
      typeof WeakMap !== "undefined" &&
      validateGeneratorFunctionReturnType(new WeakMap());
    function isGeneratorFunctionSupportedByWeakMap(isValidSetInstance) {
      if (typeof WeakMap === "undefined") {
        return false;
      } else if (validateGeneratorFunctionReturnType.working) {
        return validateGeneratorFunctionReturnType(isValidSetInstance);
      } else {
        return isValidSetInstance instanceof WeakMap;
      }
    }
    ______validateAndProcessIntrinsicProperties.isWeakMap =
      isGeneratorFunctionSupportedByWeakMap;
    function isWeakSetInstance(isGeneratorFunctionSupported) {
      return (
        bindPropertyMethodToInstance(isGeneratorFunctionSupported) ===
        "[object WeakSet]"
      );
    }
    isWeakSetInstance.working =
      typeof WeakSet !== "undefined" && isWeakSetInstance(new WeakSet());
    function ________isValidGeneratorFunction(______isValidGeneratorFunction) {
      return isWeakSetInstance(______isValidGeneratorFunction);
    }
    ______validateAndProcessIntrinsicProperties.isWeakSet =
      ________isValidGeneratorFunction;
    function checkIfArrayBufferType(___validateAndProcessIntrinsicProperties) {
      return (
        bindPropertyMethodToInstance(
          ___validateAndProcessIntrinsicProperties,
        ) === "[object ArrayBuffer]"
      );
    }
    checkIfArrayBufferType.working =
      typeof ArrayBuffer !== "undefined" &&
      checkIfArrayBufferType(new ArrayBuffer());
    function isIntrinsicPropertyArrayBuffer(
      ____validateAndProcessIntrinsicProperties,
    ) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      } else if (checkIfArrayBufferType.working) {
        return checkIfArrayBufferType(
          ____validateAndProcessIntrinsicProperties,
        );
      } else {
        return ____validateAndProcessIntrinsicProperties instanceof ArrayBuffer;
      }
    }
    ______validateAndProcessIntrinsicProperties.isArrayBuffer =
      isIntrinsicPropertyArrayBuffer;
    function isValidDataViewInstance(validateAndProcessIntrinsicPropertyTypes) {
      return (
        bindPropertyMethodToInstance(
          validateAndProcessIntrinsicPropertyTypes,
        ) === "[object DataView]"
      );
    }
    isValidDataViewInstance.working =
      typeof ArrayBuffer !== "undefined" &&
      typeof DataView !== "undefined" &&
      isValidDataViewInstance(new DataView(new ArrayBuffer(1), 0, 1));
    function checkIfDataViewIsSupported(conditionalModuleLoader) {
      if (typeof DataView === "undefined") {
        return false;
      } else if (isValidDataViewInstance.working) {
        return isValidDataViewInstance(conditionalModuleLoader);
      } else {
        return conditionalModuleLoader instanceof DataView;
      }
    }
    ______validateAndProcessIntrinsicProperties.isDataView =
      checkIfDataViewIsSupported;
    var _____validateAndRetrieveIntrinsicProperties =
      typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : undefined;
    function validateIfSharedArrayBuffer(
      validateAndRetrieveArrayBufferProperties,
    ) {
      return (
        bindPropertyMethodToInstance(
          validateAndRetrieveArrayBufferProperties,
        ) === "[object SharedArrayBuffer]"
      );
    }
    function _validateAndProcessIntrinsicProperty(
      _____validateAndProcessIntrinsicProperties,
    ) {
      if (typeof _____validateAndRetrieveIntrinsicProperties === "undefined") {
        return false;
      } else {
        if (typeof validateIfSharedArrayBuffer.working === "undefined") {
          validateIfSharedArrayBuffer.working = validateIfSharedArrayBuffer(
            new _____validateAndRetrieveIntrinsicProperties(),
          );
        }
        if (validateIfSharedArrayBuffer.working) {
          return validateIfSharedArrayBuffer(
            _____validateAndProcessIntrinsicProperties,
          );
        } else {
          return (
            _____validateAndProcessIntrinsicProperties instanceof
            _____validateAndRetrieveIntrinsicProperties
          );
        }
      }
    }
    ______validateAndProcessIntrinsicProperties.isSharedArrayBuffer =
      _validateAndProcessIntrinsicProperty;
    function isValidationFunctionAsync(
      validateAndRetrieveSharedArrayBufferProperties,
    ) {
      return (
        bindPropertyMethodToInstance(
          validateAndRetrieveSharedArrayBufferProperties,
        ) === "[object AsyncFunction]"
      );
    }
    ______validateAndProcessIntrinsicProperties.isAsyncFunction =
      isValidationFunctionAsync;
    function isValidMapIterator(validateAndCheckIntrinsicProperty) {
      return (
        bindPropertyMethodToInstance(validateAndCheckIntrinsicProperty) ===
        "[object Map Iterator]"
      );
    }
    ______validateAndProcessIntrinsicProperties.isMapIterator =
      isValidMapIterator;
    function isValidSetIterator(validateAndProcessIntrinsicProperty) {
      return (
        bindPropertyMethodToInstance(validateAndProcessIntrinsicProperty) ===
        "[object Set Iterator]"
      );
    }
    ______validateAndProcessIntrinsicProperties.isSetIterator =
      isValidSetIterator;
    function _______isValidGeneratorFunction(
      validateAndRetrieveIntrinsicProperties,
    ) {
      return (
        bindPropertyMethodToInstance(validateAndRetrieveIntrinsicProperties) ===
        "[object Generator]"
      );
    }
    ______validateAndProcessIntrinsicProperties.isGeneratorObject =
      _______isValidGeneratorFunction;
    function validateIfWebAssemblyModule(
      __validateAndRetrieveIntrinsicProperty,
    ) {
      return (
        bindPropertyMethodToInstance(__validateAndRetrieveIntrinsicProperty) ===
        "[object WebAssembly.Module]"
      );
    }
    ______validateAndProcessIntrinsicProperties.isWebAssemblyCompiledModule =
      validateIfWebAssemblyModule;
    function ___________________validateAndRetrieveIntrinsicProperty(
      ___validateAndRetrieveIntrinsicProperty,
    ) {
      return _validateIntrinsicProperties(
        ___validateAndRetrieveIntrinsicProperty,
        bindNumberValueFunction,
      );
    }
    ______validateAndProcessIntrinsicProperties.isNumberObject =
      ___________________validateAndRetrieveIntrinsicProperty;
    function __________________validateAndRetrieveIntrinsicProperty(
      _____validateAndRetrieveIntrinsicProperty,
    ) {
      return _validateIntrinsicProperties(
        _____validateAndRetrieveIntrinsicProperty,
        bindStringValueToInstance,
      );
    }
    ______validateAndProcessIntrinsicProperties.isStringObject =
      __________________validateAndRetrieveIntrinsicProperty;
    function _________________validateAndRetrieveIntrinsicProperty(
      validateAndRetrieveIntrinsicObject,
    ) {
      return _validateIntrinsicProperties(
        validateAndRetrieveIntrinsicObject,
        bindBooleanValueFunction,
      );
    }
    ______validateAndProcessIntrinsicProperties.isBooleanObject =
      _________________validateAndRetrieveIntrinsicProperty;
    function checkAndFetchBigIntProperty(
      ______validateAndRetrieveIntrinsicProperty,
    ) {
      return (
        isBigIntFeatureAvailable &&
        _validateIntrinsicProperties(
          ______validateAndRetrieveIntrinsicProperty,
          bindValueMethodToPrototype,
        )
      );
    }
    ______validateAndProcessIntrinsicProperties.isBigIntObject =
      checkAndFetchBigIntProperty;
    function ________________validateAndRetrieveIntrinsicProperty(
      validateAndRetrieveIntrinsicPropertyBasedOnType,
    ) {
      return (
        isSymbolFeatureAvailable &&
        _validateIntrinsicProperties(
          validateAndRetrieveIntrinsicPropertyBasedOnType,
          _validatedIntrinsicPropertyValue,
        )
      );
    }
    ______validateAndProcessIntrinsicProperties.isSymbolObject =
      ________________validateAndRetrieveIntrinsicProperty;
    function _validateAndRetrievePropertyByType(
      validateAndRetrieveIntrinsicPropertyByType,
    ) {
      return (
        ___________________validateAndRetrieveIntrinsicProperty(
          validateAndRetrieveIntrinsicPropertyByType,
        ) ||
        __________________validateAndRetrieveIntrinsicProperty(
          validateAndRetrieveIntrinsicPropertyByType,
        ) ||
        _________________validateAndRetrieveIntrinsicProperty(
          validateAndRetrieveIntrinsicPropertyByType,
        ) ||
        checkAndFetchBigIntProperty(
          validateAndRetrieveIntrinsicPropertyByType,
        ) ||
        ________________validateAndRetrieveIntrinsicProperty(
          validateAndRetrieveIntrinsicPropertyByType,
        )
      );
    }
    ______validateAndProcessIntrinsicProperties.isBoxedPrimitive =
      _validateAndRetrievePropertyByType;
    function isValidArrayBufferProperty(validateAndRetrievePropertyByType) {
      return (
        typeof Uint8Array !== "undefined" &&
        (isIntrinsicPropertyArrayBuffer(validateAndRetrievePropertyByType) ||
          _validateAndProcessIntrinsicProperty(
            validateAndRetrievePropertyByType,
          ))
      );
    }
    ______validateAndProcessIntrinsicProperties.isAnyArrayBuffer =
      isValidArrayBufferProperty;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(
      function (validateAndLoadIntrinsicProperty) {
        Object.defineProperty(
          ______validateAndProcessIntrinsicProperties,
          validateAndLoadIntrinsicProperty,
          {
            enumerable: false,
            value() {
              throw new Error(
                validateAndLoadIntrinsicProperty +
                  " is not supported in userland",
              );
            },
          },
        );
      },
    );
  },
);
var isValidIntrinsicProperty = lazyModuleInitializer(
  (checkIfValidTypedArray, _checkIfValidTypedArray) => {
    _checkIfValidTypedArray.exports = function (_validateTypedArray) {
      return (
        _validateTypedArray &&
        typeof _validateTypedArray == "object" &&
        typeof _validateTypedArray.copy == "function" &&
        typeof _validateTypedArray.fill == "function" &&
        typeof _validateTypedArray.readUInt8 == "function"
      );
    };
  },
);
var validateAndDetectArrayBufferType = lazyModuleInitializer(
  (initializeInheritanceStructure, _initializeInheritanceStructure) => {
    if (typeof Object.create == "function") {
      _initializeInheritanceStructure.exports = function (
        validateAndRetrievePropertyType,
        isTypedArrayValid,
      ) {
        if (isTypedArrayValid) {
          validateAndRetrievePropertyType.super_ = isTypedArrayValid;
          validateAndRetrievePropertyType.prototype = Object.create(
            isTypedArrayValid.prototype,
            {
              constructor: {
                value: validateAndRetrievePropertyType,
                enumerable: false,
                writable: true,
                configurable: true,
              },
            },
          );
        }
      };
    } else {
      _initializeInheritanceStructure.exports = function (
        isArrayBufferViewValid,
        validateAndDetectIntrinsicObjectProperties,
      ) {
        if (validateAndDetectIntrinsicObjectProperties) {
          isArrayBufferViewValid.super_ =
            validateAndDetectIntrinsicObjectProperties;
          function initializeUIComponent() {}
          initializeUIComponent.prototype =
            validateAndDetectIntrinsicObjectProperties.prototype;
          isArrayBufferViewValid.prototype = new initializeUIComponent();
          isArrayBufferViewValid.prototype.constructor = isArrayBufferViewValid;
        }
      };
    }
  },
);
var isPromiseValid = lazyModuleInitializer((StringFormatterUtility) => {
  var _retrievePropertyDescriptors =
    Object.getOwnPropertyDescriptors ||
    function (validateIntrinsicObject) {
      for (
        var validatedIntrinsicObjectPropertyDescriptors = Object.keys(
            validateIntrinsicObject,
          ),
          intrinsicObjectPropertyDescriptors = {},
          _currentPropertyDescriptorIndex = 0;
        _currentPropertyDescriptorIndex <
        validatedIntrinsicObjectPropertyDescriptors.length;
        _currentPropertyDescriptorIndex++
      ) {
        intrinsicObjectPropertyDescriptors[
          validatedIntrinsicObjectPropertyDescriptors[
            _currentPropertyDescriptorIndex
          ]
        ] = Object.getOwnPropertyDescriptor(
          validateIntrinsicObject,
          validatedIntrinsicObjectPropertyDescriptors[
            _currentPropertyDescriptorIndex
          ],
        );
      }
      return intrinsicObjectPropertyDescriptors;
    };
  var formatSpecifierRegex = /%[sdj%]/g;
  StringFormatterUtility.format = function (validatePromise) {
    if (!checkIfInputIsString(validatePromise)) {
      var arrayBufferInspectionConfigurations = [];
      for (
        var currentArgumentIndex = 0;
        currentArgumentIndex < arguments.length;
        currentArgumentIndex++
      ) {
        arrayBufferInspectionConfigurations.push(
          setupArrayBufferInspectionConfiguration(
            arguments[currentArgumentIndex],
          ),
        );
      }
      return arrayBufferInspectionConfigurations.join(" ");
    }
    for (
      var currentArgumentIndex = 1,
        functionArguments = arguments,
        totalArgumentsCount = functionArguments.length,
        formattedLogMessage = String(validatePromise).replace(
          formatSpecifierRegex,
          function (_isValidIntrinsicObject) {
            if (_isValidIntrinsicObject === "%%") {
              return "%";
            }
            if (currentArgumentIndex >= totalArgumentsCount) {
              return _isValidIntrinsicObject;
            }
            switch (_isValidIntrinsicObject) {
              case "%s":
                return String(functionArguments[currentArgumentIndex++]);
              case "%d":
                return Number(functionArguments[currentArgumentIndex++]);
              case "%j":
                try {
                  return JSON.stringify(
                    functionArguments[currentArgumentIndex++],
                  );
                } catch {
                  return "[Circular]";
                }
              default:
                return _isValidIntrinsicObject;
            }
          },
        ),
        currentFunctionArgument = functionArguments[currentArgumentIndex];
      currentArgumentIndex < totalArgumentsCount;
      currentFunctionArgument = functionArguments[++currentArgumentIndex]
    ) {
      if (
        checkIfNullAndReturnBoolean(currentFunctionArgument) ||
        !checkIfObjectAndNotNull(currentFunctionArgument)
      ) {
        formattedLogMessage += " " + currentFunctionArgument;
      } else {
        formattedLogMessage +=
          " " +
          setupArrayBufferInspectionConfiguration(currentFunctionArgument);
      }
    }
    return formattedLogMessage;
  };
  StringFormatterUtility.deprecate = function (
    isValidArrayType,
    createArrayValidationFunction,
  ) {
    if (typeof process !== "undefined" && process.noDeprecation === true) {
      return isValidArrayType;
    }
    if (typeof process === "undefined") {
      return function () {
        return StringFormatterUtility.deprecate(
          isValidArrayType,
          createArrayValidationFunction,
        ).apply(this, arguments);
      };
    }
    var isDeprecationWarningLogged = false;
    function logDeprecationWarningAndValidateArrayType() {
      if (!isDeprecationWarningLogged) {
        if (process.throwDeprecation) {
          throw new Error(createArrayValidationFunction);
        }
        if (process.traceDeprecation) {
          console.trace(createArrayValidationFunction);
        } else {
          console.error(createArrayValidationFunction);
        }
        isDeprecationWarningLogged = true;
      }
      return isValidArrayType.apply(this, arguments);
    }
    return logDeprecationWarningAndValidateArrayType;
  };
  var retrieveObjectPropertyDescriptors = {};
  var _retrieveObjectPropertyDescriptors = /^$/;
  __retrieveObjectPropertyDescriptors = "false";
  __retrieveObjectPropertyDescriptors = __retrieveObjectPropertyDescriptors
    .replace(/[|\\{}()[\]^$+?.]/g, "\\$&")
    .replace(/\*/g, ".*")
    .replace(/,/g, "$|^")
    .toUpperCase();
  _retrieveObjectPropertyDescriptors = new RegExp(
    "^" + __retrieveObjectPropertyDescriptors + "$",
    "i",
  );
  var __retrieveObjectPropertyDescriptors;
  StringFormatterUtility.debuglog = function (
    logDeprecationWarningAndValidateArrayType,
  ) {
    logDeprecationWarningAndValidateArrayType =
      logDeprecationWarningAndValidateArrayType.toUpperCase();
    if (
      !retrieveObjectPropertyDescriptors[
        logDeprecationWarningAndValidateArrayType
      ]
    ) {
      if (
        _retrieveObjectPropertyDescriptors.test(
          logDeprecationWarningAndValidateArrayType,
        )
      ) {
        var currentNodeProcessId = process.pid;
        retrieveObjectPropertyDescriptors[
          logDeprecationWarningAndValidateArrayType
        ] = function () {
          var _formattedLogMessage = StringFormatterUtility.format.apply(
            StringFormatterUtility,
            arguments,
          );
          console.error(
            "%s %d: %s",
            logDeprecationWarningAndValidateArrayType,
            currentNodeProcessId,
            _formattedLogMessage,
          );
        };
      } else {
        retrieveObjectPropertyDescriptors[
          logDeprecationWarningAndValidateArrayType
        ] = function () {};
      }
    }
    return retrieveObjectPropertyDescriptors[
      logDeprecationWarningAndValidateArrayType
    ];
  };
  function setupArrayBufferInspectionConfiguration(
    isValidArrayTypeAndLogDeprecation,
    isWeakMapValid,
  ) {
    var arrayBufferDebugConfig = {
      seen: [],
      stylize: checkIfDataViewStructureIsValid,
    };
    if (arguments.length >= 3) {
      arrayBufferDebugConfig.depth = arguments[2];
    }
    if (arguments.length >= 4) {
      arrayBufferDebugConfig.colors = arguments[3];
    }
    if (checkIfValueIsBoolean(isWeakMapValid)) {
      arrayBufferDebugConfig.showHidden = isWeakMapValid;
    } else if (isWeakMapValid) {
      StringFormatterUtility._extend(arrayBufferDebugConfig, isWeakMapValid);
    }
    if (isArrayBufferFormatStringNil(arrayBufferDebugConfig.showHidden)) {
      arrayBufferDebugConfig.showHidden = false;
    }
    if (isArrayBufferFormatStringNil(arrayBufferDebugConfig.depth)) {
      arrayBufferDebugConfig.depth = 2;
    }
    if (isArrayBufferFormatStringNil(arrayBufferDebugConfig.colors)) {
      arrayBufferDebugConfig.colors = false;
    }
    if (isArrayBufferFormatStringNil(arrayBufferDebugConfig.customInspect)) {
      arrayBufferDebugConfig.customInspect = true;
    }
    if (arrayBufferDebugConfig.colors) {
      arrayBufferDebugConfig.stylize = applyColorStylingToWeakMap;
    }
    return analyzeArrayBufferForInspection(
      arrayBufferDebugConfig,
      isValidArrayTypeAndLogDeprecation,
      arrayBufferDebugConfig.depth,
    );
  }
  StringFormatterUtility.inspect = setupArrayBufferInspectionConfiguration;
  setupArrayBufferInspectionConfiguration.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39],
  };
  setupArrayBufferInspectionConfiguration.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    regexp: "red",
  };
  function applyColorStylingToWeakMap(isWeakMapInstanceValid, isValidWeakMap) {
    var styleColorByWeakMapValidity =
      setupArrayBufferInspectionConfiguration.styles[isValidWeakMap];
    if (styleColorByWeakMapValidity) {
      return (
        "[" +
        setupArrayBufferInspectionConfiguration.colors[
          styleColorByWeakMapValidity
        ][0] +
        "m" +
        isWeakMapInstanceValid +
        "[" +
        setupArrayBufferInspectionConfiguration.colors[
          styleColorByWeakMapValidity
        ][1] +
        "m"
      );
    } else {
      return isWeakMapInstanceValid;
    }
  }
  function checkIfDataViewStructureIsValid(
    isDataViewStructure,
    configureArrayBufferInspectionSettings,
  ) {
    return isDataViewStructure;
  }
  function validateArrayBufferConfigurations(
    configureArrayBufferStyleAndValidation,
  ) {
    var validatedBufferConfigurationsMap = {};
    configureArrayBufferStyleAndValidation.forEach(
      function (
        configureArrayBufferInspectionAndFormatting,
        isDataViewInstance,
      ) {
        validatedBufferConfigurationsMap[
          configureArrayBufferInspectionAndFormatting
        ] = true;
      },
    );
    return validatedBufferConfigurationsMap;
  }
  function analyzeArrayBufferForInspection(
    isArrayBufferValidForInspection,
    isValidArrayBufferType,
    isValidDataView,
  ) {
    if (
      isArrayBufferValidForInspection.customInspect &&
      isValidArrayBufferType &&
      checkIfFunction(isValidArrayBufferType.inspect) &&
      isValidArrayBufferType.inspect !== StringFormatterUtility.inspect &&
      (!isValidArrayBufferType.constructor ||
        isValidArrayBufferType.constructor.prototype !== isValidArrayBufferType)
    ) {
      var arrayBufferInspectionAnalysis = isValidArrayBufferType.inspect(
        isValidDataView,
        isArrayBufferValidForInspection,
      );
      if (!checkIfInputIsString(arrayBufferInspectionAnalysis)) {
        arrayBufferInspectionAnalysis = analyzeArrayBufferForInspection(
          isArrayBufferValidForInspection,
          arrayBufferInspectionAnalysis,
          isValidDataView,
        );
      }
      return arrayBufferInspectionAnalysis;
    }
    var arrayBufferStyledResult = stylizeArrayBufferInspection(
      isArrayBufferValidForInspection,
      isValidArrayBufferType,
    );
    if (arrayBufferStyledResult) {
      return arrayBufferStyledResult;
    }
    var arrayBufferInspectionResult = Object.keys(isValidArrayBufferType);
    var arrayBufferInspectionResults = validateArrayBufferConfigurations(
      arrayBufferInspectionResult,
    );
    if (isArrayBufferValidForInspection.showHidden) {
      arrayBufferInspectionResult = Object.getOwnPropertyNames(
        isValidArrayBufferType,
      );
    }
    if (
      isValidErrorFormatString(isValidArrayBufferType) &&
      (arrayBufferInspectionResult.indexOf("message") >= 0 ||
        arrayBufferInspectionResult.indexOf("description") >= 0)
    ) {
      return convertErrorToString(isValidArrayBufferType);
    }
    if (arrayBufferInspectionResult.length === 0) {
      if (checkIfFunction(isValidArrayBufferType)) {
        var inspectableArrayBufferFunctionName = isValidArrayBufferType.name
          ? ": " + isValidArrayBufferType.name
          : "";
        return isArrayBufferValidForInspection.stylize(
          "[Function" + inspectableArrayBufferFunctionName + "]",
          "special",
        );
      }
      if (isValidRegexFormat(isValidArrayBufferType)) {
        return isArrayBufferValidForInspection.stylize(
          RegExp.prototype.toString.call(isValidArrayBufferType),
          "regexp",
        );
      }
      if (isDateObjectValid(isValidArrayBufferType)) {
        return isArrayBufferValidForInspection.stylize(
          Date.prototype.toString.call(isValidArrayBufferType),
          "date",
        );
      }
      if (isValidErrorFormatString(isValidArrayBufferType)) {
        return convertErrorToString(isValidArrayBufferType);
      }
    }
    var ___arrayBufferInspectionResult = "";
    var analyzeAndInspectArrayBuffer = false;
    var analyzeArrayBufferInspection = ["{", "}"];
    if (___validateAndFormatArrayBufferProperties(isValidArrayBufferType)) {
      analyzeAndInspectArrayBuffer = true;
      analyzeArrayBufferInspection = ["[", "]"];
    }
    if (checkIfFunction(isValidArrayBufferType)) {
      var arrayBufferFunctionName = isValidArrayBufferType.name
        ? ": " + isValidArrayBufferType.name
        : "";
      ___arrayBufferInspectionResult =
        " [Function" + arrayBufferFunctionName + "]";
    }
    if (isValidRegexFormat(isValidArrayBufferType)) {
      ___arrayBufferInspectionResult =
        " " + RegExp.prototype.toString.call(isValidArrayBufferType);
    }
    if (isDateObjectValid(isValidArrayBufferType)) {
      ___arrayBufferInspectionResult =
        " " + Date.prototype.toUTCString.call(isValidArrayBufferType);
    }
    if (isValidErrorFormatString(isValidArrayBufferType)) {
      ___arrayBufferInspectionResult =
        " " + convertErrorToString(isValidArrayBufferType);
    }
    if (
      arrayBufferInspectionResult.length === 0 &&
      (!analyzeAndInspectArrayBuffer || isValidArrayBufferType.length == 0)
    ) {
      return (
        analyzeArrayBufferInspection[0] +
        ___arrayBufferInspectionResult +
        analyzeArrayBufferInspection[1]
      );
    }
    if (isValidDataView < 0) {
      if (isValidRegexFormat(isValidArrayBufferType)) {
        return isArrayBufferValidForInspection.stylize(
          RegExp.prototype.toString.call(isValidArrayBufferType),
          "regexp",
        );
      } else {
        return isArrayBufferValidForInspection.stylize("[Object]", "special");
      }
    }
    isArrayBufferValidForInspection.seen.push(isValidArrayBufferType);
    var _analyzeAndInspectArrayBuffer;
    if (analyzeAndInspectArrayBuffer) {
      _analyzeAndInspectArrayBuffer = collectArrayBufferPropertyDescriptors(
        isArrayBufferValidForInspection,
        isValidArrayBufferType,
        isValidDataView,
        arrayBufferInspectionResults,
        arrayBufferInspectionResult,
      );
    } else {
      _analyzeAndInspectArrayBuffer = arrayBufferInspectionResult.map(
        function (isArrayTypeValidOrIterator) {
          return retrieveArrayBufferPropertyDescriptorWithValidation(
            isArrayBufferValidForInspection,
            isValidArrayBufferType,
            isValidDataView,
            arrayBufferInspectionResults,
            isArrayTypeValidOrIterator,
            analyzeAndInspectArrayBuffer,
          );
        },
      );
    }
    isArrayBufferValidForInspection.seen.pop();
    return validatePromisePropertiesAndCharacterCount(
      _analyzeAndInspectArrayBuffer,
      ___arrayBufferInspectionResult,
      analyzeArrayBufferInspection,
    );
  }
  function stylizeArrayBufferInspection(
    _isArrayBufferValidForInspection,
    isValidArrayBufferTypeCheck,
  ) {
    if (isArrayBufferFormatStringNil(isValidArrayBufferTypeCheck)) {
      return _isArrayBufferValidForInspection.stylize("undefined", "undefined");
    }
    if (checkIfInputIsString(isValidArrayBufferTypeCheck)) {
      var stringifiedArrayBufferValidationCheck =
        "'" +
        JSON.stringify(isValidArrayBufferTypeCheck)
          .replace(/^"|"$/g, "")
          .replace(/'/g, "\\'")
          .replace(/\\"/g, '"') +
        "'";
      return _isArrayBufferValidForInspection.stylize(
        stringifiedArrayBufferValidationCheck,
        "string",
      );
    }
    if (validateIsNumber(isValidArrayBufferTypeCheck)) {
      return _isArrayBufferValidForInspection.stylize(
        "" + isValidArrayBufferTypeCheck,
        "number",
      );
    }
    if (checkIfValueIsBoolean(isValidArrayBufferTypeCheck)) {
      return _isArrayBufferValidForInspection.stylize(
        "" + isValidArrayBufferTypeCheck,
        "boolean",
      );
    }
    if (checkIfNullAndReturnBoolean(isValidArrayBufferTypeCheck)) {
      return _isArrayBufferValidForInspection.stylize("null", "null");
    }
  }
  function convertErrorToString(_validateAndRetrieveArrayBufferProperties) {
    return (
      "[" +
      Error.prototype.toString.call(_validateAndRetrieveArrayBufferProperties) +
      "]"
    );
  }
  function collectArrayBufferPropertyDescriptors(
    isValidAndReadyForArrayBufferInspection,
    _isValidArrayBufferType,
    isPrimitiveWrappedInBox,
    isArrayBufferInspectionValid,
    _isArrayBufferInspectionValid,
  ) {
    var arrayBufferPropertyDescriptors = [];
    for (
      var currentBoxedPrimitiveTypeIndex = 0,
        totalValidArrayBufferTypes = _isValidArrayBufferType.length;
      currentBoxedPrimitiveTypeIndex < totalValidArrayBufferTypes;
      ++currentBoxedPrimitiveTypeIndex
    ) {
      if (
        checkIfDebugLoggerIsConfigured(
          _isValidArrayBufferType,
          String(currentBoxedPrimitiveTypeIndex),
        )
      ) {
        arrayBufferPropertyDescriptors.push(
          retrieveArrayBufferPropertyDescriptorWithValidation(
            isValidAndReadyForArrayBufferInspection,
            _isValidArrayBufferType,
            isPrimitiveWrappedInBox,
            isArrayBufferInspectionValid,
            String(currentBoxedPrimitiveTypeIndex),
            true,
          ),
        );
      } else {
        arrayBufferPropertyDescriptors.push("");
      }
    }
    _isArrayBufferInspectionValid.forEach(
      function (_______validateAndRetrieveIntrinsicProperty) {
        if (!_______validateAndRetrieveIntrinsicProperty.match(/^\d+$/)) {
          arrayBufferPropertyDescriptors.push(
            retrieveArrayBufferPropertyDescriptorWithValidation(
              isValidAndReadyForArrayBufferInspection,
              _isValidArrayBufferType,
              isPrimitiveWrappedInBox,
              isArrayBufferInspectionValid,
              _______validateAndRetrieveIntrinsicProperty,
              true,
            ),
          );
        }
      },
    );
    return arrayBufferPropertyDescriptors;
  }
  function retrieveArrayBufferPropertyDescriptorWithValidation(
    __validateAndRetrieveArrayBufferProperties,
    ___validateAndRetrieveArrayBufferProperties,
    ____validateAndRetrieveArrayBufferProperties,
    _____validateAndRetrieveArrayBufferProperties,
    validateAndExtractArrayBufferProperties,
    validateArrayBufferProperties,
  ) {
    var arrayBufferPropertyDescriptor;
    var arrayBufferPropertyDescriptorSummary;
    var propertyDescriptor;
    propertyDescriptor = Object.getOwnPropertyDescriptor(
      ___validateAndRetrieveArrayBufferProperties,
      validateAndExtractArrayBufferProperties,
    ) || {
      value:
        ___validateAndRetrieveArrayBufferProperties[
          validateAndExtractArrayBufferProperties
        ],
    };
    if (propertyDescriptor.get) {
      if (propertyDescriptor.set) {
        arrayBufferPropertyDescriptorSummary =
          __validateAndRetrieveArrayBufferProperties.stylize(
            "[Getter/Setter]",
            "special",
          );
      } else {
        arrayBufferPropertyDescriptorSummary =
          __validateAndRetrieveArrayBufferProperties.stylize(
            "[Getter]",
            "special",
          );
      }
    } else if (propertyDescriptor.set) {
      arrayBufferPropertyDescriptorSummary =
        __validateAndRetrieveArrayBufferProperties.stylize(
          "[Setter]",
          "special",
        );
    }
    if (
      !checkIfDebugLoggerIsConfigured(
        _____validateAndRetrieveArrayBufferProperties,
        validateAndExtractArrayBufferProperties,
      )
    ) {
      arrayBufferPropertyDescriptor =
        "[" + validateAndExtractArrayBufferProperties + "]";
    }
    if (!arrayBufferPropertyDescriptorSummary) {
      if (
        __validateAndRetrieveArrayBufferProperties.seen.indexOf(
          propertyDescriptor.value,
        ) < 0
      ) {
        if (
          checkIfNullAndReturnBoolean(
            ____validateAndRetrieveArrayBufferProperties,
          )
        ) {
          arrayBufferPropertyDescriptorSummary =
            analyzeArrayBufferForInspection(
              __validateAndRetrieveArrayBufferProperties,
              propertyDescriptor.value,
              null,
            );
        } else {
          arrayBufferPropertyDescriptorSummary =
            analyzeArrayBufferForInspection(
              __validateAndRetrieveArrayBufferProperties,
              propertyDescriptor.value,
              ____validateAndRetrieveArrayBufferProperties - 1,
            );
        }
        if (arrayBufferPropertyDescriptorSummary.indexOf("\n") > -1) {
          if (validateArrayBufferProperties) {
            arrayBufferPropertyDescriptorSummary =
              arrayBufferPropertyDescriptorSummary
                .split("\n")
                .map(function (_conditionalModuleLoader) {
                  return "  " + _conditionalModuleLoader;
                })
                .join("\n")
                .substr(2);
          } else {
            arrayBufferPropertyDescriptorSummary =
              "\n" +
              arrayBufferPropertyDescriptorSummary
                .split("\n")
                .map(function (validateAndRetrievePropertyDescriptorInfo) {
                  return "   " + validateAndRetrievePropertyDescriptorInfo;
                })
                .join("\n");
          }
        }
      } else {
        arrayBufferPropertyDescriptorSummary =
          __validateAndRetrieveArrayBufferProperties.stylize(
            "[Circular]",
            "special",
          );
      }
    }
    if (isArrayBufferFormatStringNil(arrayBufferPropertyDescriptor)) {
      if (
        validateArrayBufferProperties &&
        validateAndExtractArrayBufferProperties.match(/^\d+$/)
      ) {
        return arrayBufferPropertyDescriptorSummary;
      }
      arrayBufferPropertyDescriptor = JSON.stringify(
        "" + validateAndExtractArrayBufferProperties,
      );
      if (arrayBufferPropertyDescriptor.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        arrayBufferPropertyDescriptor = arrayBufferPropertyDescriptor.substr(
          1,
          arrayBufferPropertyDescriptor.length - 2,
        );
        arrayBufferPropertyDescriptor =
          __validateAndRetrieveArrayBufferProperties.stylize(
            arrayBufferPropertyDescriptor,
            "name",
          );
      } else {
        arrayBufferPropertyDescriptor = arrayBufferPropertyDescriptor
          .replace(/'/g, "\\'")
          .replace(/\\"/g, '"')
          .replace(/(^"|"$)/g, "'");
        arrayBufferPropertyDescriptor =
          __validateAndRetrieveArrayBufferProperties.stylize(
            arrayBufferPropertyDescriptor,
            "string",
          );
      }
    }
    return (
      arrayBufferPropertyDescriptor +
      ": " +
      arrayBufferPropertyDescriptorSummary
    );
  }
  function validatePromisePropertiesAndCharacterCount(
    validateAndFormatArrayBufferProperties,
    _validateAndFormatArrayBufferProperties,
    validateAndDetectIntrinsicType,
  ) {
    var currentLineIndex = 0;
    var totalFormattedCharacterCount =
      validateAndFormatArrayBufferProperties.reduce(function (
        retrieveAndValidateTypedArrayProperties,
        validateArrayBufferDescriptor,
      ) {
        currentLineIndex++;
        if (validateArrayBufferDescriptor.indexOf("\n") >= 0) {
          currentLineIndex++;
        }
        return (
          retrieveAndValidateTypedArrayProperties +
          validateArrayBufferDescriptor.replace(/\u001b\[\d\d?m/g, "").length +
          1
        );
      }, 0);
    if (totalFormattedCharacterCount > 60) {
      return (
        validateAndDetectIntrinsicType[0] +
        (_validateAndFormatArrayBufferProperties === ""
          ? ""
          : _validateAndFormatArrayBufferProperties + "\n ") +
        " " +
        validateAndFormatArrayBufferProperties.join(",\n  ") +
        " " +
        validateAndDetectIntrinsicType[1]
      );
    } else {
      return (
        validateAndDetectIntrinsicType[0] +
        _validateAndFormatArrayBufferProperties +
        " " +
        validateAndFormatArrayBufferProperties.join(", ") +
        " " +
        validateAndDetectIntrinsicType[1]
      );
    }
  }
  StringFormatterUtility.types = validateAndGenerateInstance();
  function ___validateAndFormatArrayBufferProperties(
    __validateAndFormatArrayBufferProperties,
  ) {
    return Array.isArray(__validateAndFormatArrayBufferProperties);
  }
  StringFormatterUtility.isArray = ___validateAndFormatArrayBufferProperties;
  function checkIfValueIsBoolean(validateAndStyleArrayBufferProperties) {
    return typeof validateAndStyleArrayBufferProperties == "boolean";
  }
  StringFormatterUtility.isBoolean = checkIfValueIsBoolean;
  function checkIfNullAndReturnBoolean(formatAndValidatePromiseProperties) {
    return formatAndValidatePromiseProperties === null;
  }
  StringFormatterUtility.isNull = checkIfNullAndReturnBoolean;
  function isPromiseValidationFormatterConfigured(
    validateAndFormatPromiseConfiguration,
  ) {
    return validateAndFormatPromiseConfiguration == null;
  }
  StringFormatterUtility.isNullOrUndefined =
    isPromiseValidationFormatterConfigured;
  function validateIsNumber(promiseConfigValidator) {
    return typeof promiseConfigValidator == "number";
  }
  StringFormatterUtility.isNumber = validateIsNumber;
  function checkIfInputIsString(retrieveAndFormatArrayBufferDescriptions) {
    return typeof retrieveAndFormatArrayBufferDescriptions == "string";
  }
  StringFormatterUtility.isString = checkIfInputIsString;
  function isSymbolType(retrieveAndCountArrayBufferProperties) {
    return typeof retrieveAndCountArrayBufferProperties == "symbol";
  }
  StringFormatterUtility.isSymbol = isSymbolType;
  function isArrayBufferFormatStringNil(formatStringWithArrayBufferProperties) {
    return formatStringWithArrayBufferProperties === undefined;
  }
  StringFormatterUtility.isUndefined = isArrayBufferFormatStringNil;
  function isValidRegexFormat(formatStringWithArgsForBufferProperties) {
    return (
      checkIfObjectAndNotNull(formatStringWithArgsForBufferProperties) &&
      getObjectTypeString(formatStringWithArgsForBufferProperties) ===
        "[object RegExp]"
    );
  }
  StringFormatterUtility.isRegExp = isValidRegexFormat;
  StringFormatterUtility.types.isRegExp = isValidRegexFormat;
  function checkIfObjectAndNotNull(formatAndValidateString) {
    return (
      typeof formatAndValidateString == "object" &&
      formatAndValidateString !== null
    );
  }
  StringFormatterUtility.isObject = checkIfObjectAndNotNull;
  function isDateObjectValid(formatStringWithArgs) {
    return (
      checkIfObjectAndNotNull(formatStringWithArgs) &&
      getObjectTypeString(formatStringWithArgs) === "[object Date]"
    );
  }
  StringFormatterUtility.isDate = isDateObjectValid;
  StringFormatterUtility.types.isDate = isDateObjectValid;
  function isValidErrorFormatString(formatStringForOutput) {
    return (
      checkIfObjectAndNotNull(formatStringForOutput) &&
      (getObjectTypeString(formatStringForOutput) === "[object Error]" ||
        formatStringForOutput instanceof Error)
    );
  }
  StringFormatterUtility.isError = isValidErrorFormatString;
  StringFormatterUtility.types.isNativeError = isValidErrorFormatString;
  function checkIfFunction(validateAndFormatPromiseArguments) {
    return typeof validateAndFormatPromiseArguments == "function";
  }
  StringFormatterUtility.isFunction = checkIfFunction;
  function checkIfValueIsPrimitive(validateAndFormatArgumentsForPromise) {
    return (
      validateAndFormatArgumentsForPromise === null ||
      typeof validateAndFormatArgumentsForPromise == "boolean" ||
      typeof validateAndFormatArgumentsForPromise == "number" ||
      typeof validateAndFormatArgumentsForPromise == "string" ||
      typeof validateAndFormatArgumentsForPromise == "symbol" ||
      typeof validateAndFormatArgumentsForPromise === "undefined"
    );
  }
  StringFormatterUtility.isPrimitive = checkIfValueIsPrimitive;
  StringFormatterUtility.isBuffer = isValidIntrinsicProperty();
  function getObjectTypeString(validateFormat) {
    return Object.prototype.toString.call(validateFormat);
  }
  function validateAndFormatArrayType(isValidArrayTypeFormat) {
    if (isValidArrayTypeFormat < 10) {
      return "0" + isValidArrayTypeFormat.toString(10);
    } else {
      return isValidArrayTypeFormat.toString(10);
    }
  }
  var ___retrieveObjectPropertyDescriptors = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
  ];
  function formatReadableDateTime() {
    var currentReadableDateTime = new Date();
    var formattedReadableTime = [
      validateAndFormatArrayType(currentReadableDateTime.getHours()),
      validateAndFormatArrayType(currentReadableDateTime.getMinutes()),
      validateAndFormatArrayType(currentReadableDateTime.getSeconds()),
    ].join(":");
    return [
      currentReadableDateTime.getDate(),
      ___retrieveObjectPropertyDescriptors[currentReadableDateTime.getMonth()],
      formattedReadableTime,
    ].join(" ");
  }
  StringFormatterUtility.log = function () {
    console.log(
      "%s - %s",
      formatReadableDateTime(),
      StringFormatterUtility.format.apply(StringFormatterUtility, arguments),
    );
  };
  StringFormatterUtility.inherits = validateAndDetectArrayBufferType();
  StringFormatterUtility._extend = function (
    createArrayTypeValidator,
    validateArgumentsType,
  ) {
    if (
      !validateArgumentsType ||
      !checkIfObjectAndNotNull(validateArgumentsType)
    ) {
      return createArrayTypeValidator;
    }
    var extractedValidationKeys = Object.keys(validateArgumentsType);
    for (
      var lastIndexOfValidationKeys = extractedValidationKeys.length;
      lastIndexOfValidationKeys--;

    ) {
      createArrayTypeValidator[
        extractedValidationKeys[lastIndexOfValidationKeys]
      ] =
        validateArgumentsType[
          extractedValidationKeys[lastIndexOfValidationKeys]
        ];
    }
    return createArrayTypeValidator;
  };
  function checkIfDebugLoggerIsConfigured(
    logDebugMessageOnSetInstance,
    formatCurrentDateTimeString,
  ) {
    return Object.prototype.hasOwnProperty.call(
      logDebugMessageOnSetInstance,
      formatCurrentDateTimeString,
    );
  }
  var ____retrieveObjectPropertyDescriptors =
    typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : undefined;
  StringFormatterUtility.promisify = function (logDebugInfoForInstance) {
    if (typeof logDebugInfoForInstance != "function") {
      throw new TypeError('The "original" argument must be of type Function');
    }
    if (
      ____retrieveObjectPropertyDescriptors &&
      logDebugInfoForInstance[____retrieveObjectPropertyDescriptors]
    ) {
      var logWithCompletionCallback =
        logDebugInfoForInstance[____retrieveObjectPropertyDescriptors];
      if (typeof logWithCompletionCallback != "function") {
        throw new TypeError(
          'The "util.promisify.custom" argument must be of type Function',
        );
      }
      Object.defineProperty(
        logWithCompletionCallback,
        ____retrieveObjectPropertyDescriptors,
        {
          value: logWithCompletionCallback,
          enumerable: false,
          writable: false,
          configurable: true,
        },
      );
      return logWithCompletionCallback;
    }
    function logWithCompletionCallback() {
      var onLogCompletion;
      var onLogError;
      var createLogPromise = new Promise(function (
        logDebugMessageWithTimestamp,
        validateAndDetectLoggingSettings,
      ) {
        onLogCompletion = logDebugMessageWithTimestamp;
        onLogError = validateAndDetectLoggingSettings;
      });
      var logArgumentsArray = [];
      for (
        var _argumentIndex = 0;
        _argumentIndex < arguments.length;
        _argumentIndex++
      ) {
        logArgumentsArray.push(arguments[_argumentIndex]);
      }
      logArgumentsArray.push(
        function (
          validateWeakMapParametersAndAddToArrayValidator,
          validateAndDeprecateValidationKeys,
        ) {
          if (validateWeakMapParametersAndAddToArrayValidator) {
            onLogError(validateWeakMapParametersAndAddToArrayValidator);
          } else {
            onLogCompletion(validateAndDeprecateValidationKeys);
          }
        },
      );
      try {
        logDebugInfoForInstance.apply(this, logArgumentsArray);
      } catch (errorDetails) {
        onLogError(errorDetails);
      }
      return createLogPromise;
    }
    Object.setPrototypeOf(
      logWithCompletionCallback,
      Object.getPrototypeOf(logDebugInfoForInstance),
    );
    if (____retrieveObjectPropertyDescriptors) {
      Object.defineProperty(
        logWithCompletionCallback,
        ____retrieveObjectPropertyDescriptors,
        {
          value: logWithCompletionCallback,
          enumerable: false,
          writable: false,
          configurable: true,
        },
      );
    }
    return Object.defineProperties(
      logWithCompletionCallback,
      _retrievePropertyDescriptors(logDebugInfoForInstance),
    );
  };
  StringFormatterUtility.promisify.custom =
    ____retrieveObjectPropertyDescriptors;
  function processLoggingValidationAndCallback(
    validateLoggingInstance,
    createLoggingWithCompletionCallback,
  ) {
    if (!validateLoggingInstance) {
      var promiseRejectionError = new Error(
        "Promise was rejected with a falsy value",
      );
      promiseRejectionError.reason = validateLoggingInstance;
      validateLoggingInstance = promiseRejectionError;
    }
    return createLoggingWithCompletionCallback(validateLoggingInstance);
  }
  function createStyledOutputHandler(logWithCompletionCallback) {
    if (typeof logWithCompletionCallback != "function") {
      throw new TypeError('The "original" argument must be of type Function');
    }
    function executeAndLogWithCallback() {
      var argumentsToCallWith = [];
      for (
        var _argumentsLength = 0;
        _argumentsLength < arguments.length;
        _argumentsLength++
      ) {
        argumentsToCallWith.push(arguments[_argumentsLength]);
      }
      var completionCallback = argumentsToCallWith.pop();
      if (typeof completionCallback != "function") {
        throw new TypeError("The last argument must be of type Function");
      }
      var _executionContext = this;
      function executeCompletionCallback() {
        return completionCallback.apply(_executionContext, arguments);
      }
      logWithCompletionCallback.apply(this, argumentsToCallWith).then(
        function (_logWithCompletionCallback) {
          process.nextTick(
            executeCompletionCallback.bind(
              null,
              null,
              _logWithCompletionCallback,
            ),
          );
        },
        function (__logWithCompletionCallback) {
          process.nextTick(
            processLoggingValidationAndCallback.bind(
              null,
              __logWithCompletionCallback,
              executeCompletionCallback,
            ),
          );
        },
      );
    }
    Object.setPrototypeOf(
      executeAndLogWithCallback,
      Object.getPrototypeOf(logWithCompletionCallback),
    );
    Object.defineProperties(
      executeAndLogWithCallback,
      _retrievePropertyDescriptors(logWithCompletionCallback),
    );
    return executeAndLogWithCallback;
  }
  StringFormatterUtility.callbackify = createStyledOutputHandler;
});
var handleLoggingCompletionWithStyle = lazyModuleInitializer(
  (getPaddedAndValidatedArrayBuffer, getPaddedAndValidatedLogBuffer) => {
    getPaddedAndValidatedLogBuffer.exports = function (
      handleAsyncLoggingValidation,
      isLogInstanceValid,
    ) {
      var formattedLoggerOutput = "000000000" + handleAsyncLoggingValidation;
      return formattedLoggerOutput.substr(
        formattedLoggerOutput.length - isLogInstanceValid,
      );
    };
  },
);
var handleLoggingAndFormatting = lazyModuleInitializer(
  (
    generateUserAgentKeyBasedOnMimeTypes,
    generateUserAgentKeyFromMimeTypeCount,
  ) => {
    var _globalExecutionContext =
      typeof _globalExecutionContext === "undefined"
        ? globalThis
        : _globalExecutionContext;
    var generateEncodedKeyBasedOnContextAndMimeTypes =
      handleLoggingCompletionWithStyle();
    var __executionContext =
      typeof _globalExecutionContext == "object"
        ? _globalExecutionContext
        : self;
    var executionContextKeysCount = Object.keys(__executionContext).length;
    var mimeTypesTotalCount = navigator.mimeTypes
      ? navigator.mimeTypes.length
      : 0;
    var createUniqueKeyFromUserAgentAndMimeCounts =
      generateEncodedKeyBasedOnContextAndMimeTypes(
        (mimeTypesTotalCount + navigator.userAgent.length).toString(36) +
          executionContextKeysCount.toString(36),
        4,
      );
    generateUserAgentKeyFromMimeTypeCount.exports = function () {
      return createUniqueKeyFromUserAgentAndMimeCounts;
    };
  },
);
var executeWithStyledOutputAndCallback = lazyModuleInitializer(
  (_createRandomNumberGenerator, createRandomNumber) => {
    var getRandomValue =
      typeof getRandomValue === "undefined" ? globalThis : getRandomValue;
    var __createRandomNumberGenerator;
    var isCryptographicallySecureSupported =
      (typeof getRandomValue !== "undefined" &&
        (getRandomValue.crypto || getRandomValue.msCrypto)) ||
      (typeof self !== "undefined" && self.crypto);
    if (isCryptographicallySecureSupported) {
      maxUint32Value = Math.pow(2, 32) - 1;
      __createRandomNumberGenerator = function () {
        return Math.abs(
          isCryptographicallySecureSupported.getRandomValues(
            new Uint32Array(1),
          )[0] / maxUint32Value,
        );
      };
    } else {
      __createRandomNumberGenerator = Math.random;
    }
    var maxUint32Value;
    createRandomNumber.exports = __createRandomNumberGenerator;
  },
);
var createStyledOutputHandler = lazyModuleInitializer(
  (generateUniqueSlug, generateUniqueSlugWithTimestampAndIndex) => {
    var generateAndLogUniqueSlug = handleLoggingAndFormatting();
    var generateSlugWithIndex = handleLoggingCompletionWithStyle();
    var getArrayBufferCount = executeWithStyledOutputAndCallback();
    var currentUniqueSlugCounter = 0;
    var maximumAllowedSlugLength = 4;
    var base36Radix = 36;
    var maximumUniqueSlugIndex = Math.pow(
      base36Radix,
      maximumAllowedSlugLength,
    );
    function createUniqueSlugFromBufferCount() {
      return generateSlugWithIndex(
        ((getArrayBufferCount() * maximumUniqueSlugIndex) << 0).toString(
          base36Radix,
        ),
        maximumAllowedSlugLength,
      );
    }
    function incrementUniqueSlugCounter() {
      if (currentUniqueSlugCounter < maximumUniqueSlugIndex) {
        currentUniqueSlugCounter = currentUniqueSlugCounter;
      } else {
        currentUniqueSlugCounter = 0;
      }
      currentUniqueSlugCounter++;
      return currentUniqueSlugCounter - 1;
    }
    function generateUniqueIdentifierSlug() {
      var slugPrefix = "c";
      var currentTimestampInBase36 = new Date().getTime().toString(base36Radix);
      var createUniqueSlugIdentifier = generateSlugWithIndex(
        incrementUniqueSlugCounter().toString(base36Radix),
        maximumAllowedSlugLength,
      );
      var generateAndLogUniqueSlugValidation = generateAndLogUniqueSlug();
      var concatenatedSlugSegments =
        createUniqueSlugFromBufferCount() + createUniqueSlugFromBufferCount();
      return (
        slugPrefix +
        currentTimestampInBase36 +
        createUniqueSlugIdentifier +
        generateAndLogUniqueSlugValidation +
        concatenatedSlugSegments
      );
    }
    generateUniqueIdentifierSlug.slug = function () {
      var timestampSlug = new Date().getTime().toString(36);
      var nextUniqueSlugIndex = incrementUniqueSlugCounter()
        .toString(36)
        .slice(-4);
      var firstAndLastUniqueCharacter =
        generateAndLogUniqueSlug().slice(0, 1) +
        generateAndLogUniqueSlug().slice(-1);
      var lastTwoSlugCharacters = createUniqueSlugFromBufferCount().slice(-2);
      return (
        timestampSlug.slice(-2) +
        nextUniqueSlugIndex +
        firstAndLastUniqueCharacter +
        lastTwoSlugCharacters
      );
    };
    generateUniqueIdentifierSlug.isCuid = function (
      isArrayBufferPropertyCheck,
    ) {
      if (typeof isArrayBufferPropertyCheck != "string") {
        return false;
      } else {
        return !!isArrayBufferPropertyCheck.startsWith("c");
      }
    };
    generateUniqueIdentifierSlug.isSlug = function (isCryptoApiAvailable) {
      if (typeof isCryptoApiAvailable != "string") {
        return false;
      }
      var cryptoApiIdentifierLength = isCryptoApiAvailable.length;
      return cryptoApiIdentifierLength >= 7 && cryptoApiIdentifierLength <= 10;
    };
    generateUniqueIdentifierSlug.fingerprint = generateAndLogUniqueSlug;
    generateUniqueSlugWithTimestampAndIndex.exports =
      generateUniqueIdentifierSlug;
  },
);
var createRandomNumberGenerator = lazyModuleInitializer((Base64Utility) => {
  Base64Utility.byteLength = getBase64DecodedDataLength;
  Base64Utility.toByteArray = convertBase64ToTypedArrayWithWeights;
  Base64Utility.fromByteArray = encodeBase64InChunks;
  var base64CharSet = [];
  var base64CharacterValueMap = [];
  var Base64TypedArray = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var base64CharacterSet =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  currentBase64CharacterIndex = 0;
  base64CharacterSetSize = base64CharacterSet.length;
  for (
    ;
    currentBase64CharacterIndex < base64CharacterSetSize;
    ++currentBase64CharacterIndex
  ) {
    base64CharSet[currentBase64CharacterIndex] =
      base64CharacterSet[currentBase64CharacterIndex];
    base64CharacterValueMap[
      base64CharacterSet.charCodeAt(currentBase64CharacterIndex)
    ] = currentBase64CharacterIndex;
  }
  var currentBase64CharacterIndex;
  var base64CharacterSetSize;
  base64CharacterValueMap["-".charCodeAt(0)] = 62;
  base64CharacterValueMap["_".charCodeAt(0)] = 63;
  function checkBase64StringPadding(generateUniqueSlug) {
    var getBase64StringLength = generateUniqueSlug.length;
    if (getBase64StringLength % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var lastPaddingCharacterIndex = generateUniqueSlug.indexOf("=");
    if (lastPaddingCharacterIndex === -1) {
      lastPaddingCharacterIndex = getBase64StringLength;
    }
    var paddingRequired =
      lastPaddingCharacterIndex === getBase64StringLength
        ? 0
        : 4 - (lastPaddingCharacterIndex % 4);
    return [lastPaddingCharacterIndex, paddingRequired];
  }
  function getBase64DecodedDataLength(validateAndRetrieveUniqueSlugCharacter) {
    var decodedBase64DataAndLength = checkBase64StringPadding(
      validateAndRetrieveUniqueSlugCharacter,
    );
    var base64DecodedDataLength = decodedBase64DataAndLength[0];
    var decodedBase64Data = decodedBase64DataAndLength[1];
    return (
      ((base64DecodedDataLength + decodedBase64Data) * 3) / 4 -
      decodedBase64Data
    );
  }
  function computeSlugWeightsForBufferValidation(
    generateAndValidateUniqueSlug,
    validateAndFormatArrayBufferProperty,
    validateAndEncodeUniqueSlug,
  ) {
    return (
      ((validateAndFormatArrayBufferProperty + validateAndEncodeUniqueSlug) *
        3) /
        4 -
      validateAndEncodeUniqueSlug
    );
  }
  function convertBase64ToTypedArrayWithWeights(
    ________validateAndRetrieveIntrinsicProperty,
  ) {
    var _base64DecodedByte;
    var base64DecodedByteArray = checkBase64StringPadding(
      ________validateAndRetrieveIntrinsicProperty,
    );
    var base64DecodedByteCount = base64DecodedByteArray[0];
    var base64DecodedByteLength = base64DecodedByteArray[1];
    var generateTypedArrayFromBase64 = new Base64TypedArray(
      computeSlugWeightsForBufferValidation(
        ________validateAndRetrieveIntrinsicProperty,
        base64DecodedByteCount,
        base64DecodedByteLength,
      ),
    );
    var currentByteIndex = 0;
    var maxDecodeByteCount =
      base64DecodedByteLength > 0
        ? base64DecodedByteCount - 4
        : base64DecodedByteCount;
    var _currentBase64CharacterIndex;
    for (
      _currentBase64CharacterIndex = 0;
      _currentBase64CharacterIndex < maxDecodeByteCount;
      _currentBase64CharacterIndex += 4
    ) {
      _base64DecodedByte =
        (base64CharacterValueMap[
          ________validateAndRetrieveIntrinsicProperty.charCodeAt(
            _currentBase64CharacterIndex,
          )
        ] <<
          18) |
        (base64CharacterValueMap[
          ________validateAndRetrieveIntrinsicProperty.charCodeAt(
            _currentBase64CharacterIndex + 1,
          )
        ] <<
          12) |
        (base64CharacterValueMap[
          ________validateAndRetrieveIntrinsicProperty.charCodeAt(
            _currentBase64CharacterIndex + 2,
          )
        ] <<
          6) |
        base64CharacterValueMap[
          ________validateAndRetrieveIntrinsicProperty.charCodeAt(
            _currentBase64CharacterIndex + 3,
          )
        ];
      generateTypedArrayFromBase64[currentByteIndex++] =
        (_base64DecodedByte >> 16) & 255;
      generateTypedArrayFromBase64[currentByteIndex++] =
        (_base64DecodedByte >> 8) & 255;
      generateTypedArrayFromBase64[currentByteIndex++] =
        _base64DecodedByte & 255;
    }
    if (base64DecodedByteLength === 2) {
      _base64DecodedByte =
        (base64CharacterValueMap[
          ________validateAndRetrieveIntrinsicProperty.charCodeAt(
            _currentBase64CharacterIndex,
          )
        ] <<
          2) |
        (base64CharacterValueMap[
          ________validateAndRetrieveIntrinsicProperty.charCodeAt(
            _currentBase64CharacterIndex + 1,
          )
        ] >>
          4);
      generateTypedArrayFromBase64[currentByteIndex++] =
        _base64DecodedByte & 255;
    }
    if (base64DecodedByteLength === 1) {
      _base64DecodedByte =
        (base64CharacterValueMap[
          ________validateAndRetrieveIntrinsicProperty.charCodeAt(
            _currentBase64CharacterIndex,
          )
        ] <<
          10) |
        (base64CharacterValueMap[
          ________validateAndRetrieveIntrinsicProperty.charCodeAt(
            _currentBase64CharacterIndex + 1,
          )
        ] <<
          4) |
        (base64CharacterValueMap[
          ________validateAndRetrieveIntrinsicProperty.charCodeAt(
            _currentBase64CharacterIndex + 2,
          )
        ] >>
          2);
      generateTypedArrayFromBase64[currentByteIndex++] =
        (_base64DecodedByte >> 8) & 255;
      generateTypedArrayFromBase64[currentByteIndex++] =
        _base64DecodedByte & 255;
    }
    return generateTypedArrayFromBase64;
  }
  function convertToBase64String(_decodeBase64ToTypedArray) {
    return (
      base64CharSet[(_decodeBase64ToTypedArray >> 18) & 63] +
      base64CharSet[(_decodeBase64ToTypedArray >> 12) & 63] +
      base64CharSet[(_decodeBase64ToTypedArray >> 6) & 63] +
      base64CharSet[_decodeBase64ToTypedArray & 63]
    );
  }
  function extractAndTransformColorValues(
    __decodeBase64ToTypedArray,
    decodeBase64Chunk,
    decodeBase64String,
  ) {
    var combinedRGBColorValue;
    var hexColorEncodedResults = [];
    for (
      var base64ColorChannelPosition = decodeBase64Chunk;
      base64ColorChannelPosition < decodeBase64String;
      base64ColorChannelPosition += 3
    ) {
      combinedRGBColorValue =
        ((__decodeBase64ToTypedArray[base64ColorChannelPosition] << 16) &
          16711680) +
        ((__decodeBase64ToTypedArray[base64ColorChannelPosition + 1] << 8) &
          65280) +
        (__decodeBase64ToTypedArray[base64ColorChannelPosition + 2] & 255);
      hexColorEncodedResults.push(convertToBase64String(combinedRGBColorValue));
    }
    return hexColorEncodedResults.join("");
  }
  function encodeBase64InChunks(getDecodedByteFromBase64) {
    var remainingByteValueForBase64Encoding;
    var decodedInputDataLength = getDecodedByteFromBase64.length;
    var remainingBytesInDecodedInput = decodedInputDataLength % 3;
    var encodedColorChunks = [];
    for (
      var maxChunkSize = 16383,
        currentChunkStartOffset = 0,
        maxDecodableByteOffset =
          decodedInputDataLength - remainingBytesInDecodedInput;
      currentChunkStartOffset < maxDecodableByteOffset;
      currentChunkStartOffset += maxChunkSize
    ) {
      encodedColorChunks.push(
        extractAndTransformColorValues(
          getDecodedByteFromBase64,
          currentChunkStartOffset,
          currentChunkStartOffset + maxChunkSize > maxDecodableByteOffset
            ? maxDecodableByteOffset
            : currentChunkStartOffset + maxChunkSize,
        ),
      );
    }
    if (remainingBytesInDecodedInput === 1) {
      remainingByteValueForBase64Encoding =
        getDecodedByteFromBase64[decodedInputDataLength - 1];
      encodedColorChunks.push(
        base64CharSet[remainingByteValueForBase64Encoding >> 2] +
          base64CharSet[(remainingByteValueForBase64Encoding << 4) & 63] +
          "==",
      );
    } else if (remainingBytesInDecodedInput === 2) {
      remainingByteValueForBase64Encoding =
        (getDecodedByteFromBase64[decodedInputDataLength - 2] << 8) +
        getDecodedByteFromBase64[decodedInputDataLength - 1];
      encodedColorChunks.push(
        base64CharSet[remainingByteValueForBase64Encoding >> 10] +
          base64CharSet[(remainingByteValueForBase64Encoding >> 4) & 63] +
          base64CharSet[(remainingByteValueForBase64Encoding << 2) & 63] +
          "=",
      );
    }
    return encodedColorChunks.join("");
  }
});
var extractColorValuesFromBase64 = lazyModuleInitializer(
  (extractAndTransformIntrinsicProperty) => {
    extractAndTransformIntrinsicProperty.read = function (
      extractAndTransformColorValues,
      _extractColorValuesFromBase64,
      processAndEncodeBase64Chunks,
      base64DecodedByte,
      getPropertyValueDescriptor,
    ) {
      var extractedColorValue;
      var lastByteOfDecodedIntrinsicPropertyValue;
      var bitOffsetForColorValueExtraction =
        getPropertyValueDescriptor * 8 - base64DecodedByte - 1;
      var maxBitMaskForColorValueExtraction =
        (1 << bitOffsetForColorValueExtraction) - 1;
      var maxBitMaskForColorValueExtractionShifted =
        maxBitMaskForColorValueExtraction >> 1;
      var colorValueBitShiftOffset = -7;
      var currentPropertyDescriptorIndex = processAndEncodeBase64Chunks
        ? getPropertyValueDescriptor - 1
        : 0;
      var colorValueAdjustmentIndex = processAndEncodeBase64Chunks ? -1 : 1;
      var extractedIntrinsicColorValue =
        extractAndTransformColorValues[
          _extractColorValuesFromBase64 + currentPropertyDescriptorIndex
        ];
      currentPropertyDescriptorIndex += colorValueAdjustmentIndex;
      extractedColorValue =
        extractedIntrinsicColorValue & ((1 << -colorValueBitShiftOffset) - 1);
      extractedIntrinsicColorValue >>= -colorValueBitShiftOffset;
      colorValueBitShiftOffset += bitOffsetForColorValueExtraction;
      for (; colorValueBitShiftOffset > 0; colorValueBitShiftOffset -= 8) {
        extractedColorValue =
          extractedColorValue * 256 +
          extractAndTransformColorValues[
            _extractColorValuesFromBase64 + currentPropertyDescriptorIndex
          ];
        currentPropertyDescriptorIndex += colorValueAdjustmentIndex;
      }
      lastByteOfDecodedIntrinsicPropertyValue =
        extractedColorValue & ((1 << -colorValueBitShiftOffset) - 1);
      extractedColorValue >>= -colorValueBitShiftOffset;
      colorValueBitShiftOffset += base64DecodedByte;
      for (; colorValueBitShiftOffset > 0; colorValueBitShiftOffset -= 8) {
        lastByteOfDecodedIntrinsicPropertyValue =
          lastByteOfDecodedIntrinsicPropertyValue * 256 +
          extractAndTransformColorValues[
            _extractColorValuesFromBase64 + currentPropertyDescriptorIndex
          ];
        currentPropertyDescriptorIndex += colorValueAdjustmentIndex;
      }
      if (extractedColorValue === 0) {
        extractedColorValue = 1 - maxBitMaskForColorValueExtractionShifted;
      } else {
        if (extractedColorValue === maxBitMaskForColorValueExtraction) {
          if (lastByteOfDecodedIntrinsicPropertyValue) {
            return NaN;
          } else {
            return (extractedIntrinsicColorValue ? -1 : 1) * Infinity;
          }
        }
        lastByteOfDecodedIntrinsicPropertyValue =
          lastByteOfDecodedIntrinsicPropertyValue +
          Math.pow(2, base64DecodedByte);
        extractedColorValue =
          extractedColorValue - maxBitMaskForColorValueExtractionShifted;
      }
      return (
        (extractedIntrinsicColorValue ? -1 : 1) *
        lastByteOfDecodedIntrinsicPropertyValue *
        Math.pow(2, extractedColorValue - base64DecodedByte)
      );
    };
    extractAndTransformIntrinsicProperty.write = function (
      validateAndExtractColorValue,
      validateAndRetrieveColorProperties,
      extractAndComputeColorPropertyValues,
      validateIntrinsicPropertyForDecoding,
      processAndValidateColorIntrinsicValues,
      decodeAndRetrieveColorValue,
    ) {
      var computedIntrinsicColorValue;
      var baseColorIntrinsicValue;
      var colorAdjustmentFactor;
      var computedColorAdjustmentBasedOnDecodeValue =
        decodeAndRetrieveColorValue * 8 -
        processAndValidateColorIntrinsicValues -
        1;
      var calculateMaxColorValue =
        (1 << computedColorAdjustmentBasedOnDecodeValue) - 1;
      var maxColorValueHalf = calculateMaxColorValue >> 1;
      var colorAdjustmentCalculation =
        processAndValidateColorIntrinsicValues === 23
          ? Math.pow(2, -24) - Math.pow(2, -77)
          : 0;
      var initialIntrinsicColorValue = validateIntrinsicPropertyForDecoding
        ? 0
        : decodeAndRetrieveColorValue - 1;
      var validateAndRetrieveIntrinsicPropertyValues =
        validateIntrinsicPropertyForDecoding ? 1 : -1;
      var calculateColorProperties =
        validateAndRetrieveColorProperties < 0 ||
        (validateAndRetrieveColorProperties === 0 &&
          1 / validateAndRetrieveColorProperties < 0)
          ? 1
          : 0;
      validateAndRetrieveColorProperties = Math.abs(
        validateAndRetrieveColorProperties,
      );
      if (
        isNaN(validateAndRetrieveColorProperties) ||
        validateAndRetrieveColorProperties === Infinity
      ) {
        if (isNaN(validateAndRetrieveColorProperties)) {
          baseColorIntrinsicValue = 1;
        } else {
          baseColorIntrinsicValue = 0;
        }
        computedIntrinsicColorValue = calculateMaxColorValue;
      } else {
        computedIntrinsicColorValue = Math.floor(
          Math.log(validateAndRetrieveColorProperties) / Math.LN2,
        );
        if (
          validateAndRetrieveColorProperties *
            (colorAdjustmentFactor = Math.pow(
              2,
              -computedIntrinsicColorValue,
            )) <
          1
        ) {
          computedIntrinsicColorValue--;
          colorAdjustmentFactor *= 2;
        }
        if (computedIntrinsicColorValue + maxColorValueHalf >= 1) {
          validateAndRetrieveColorProperties +=
            colorAdjustmentCalculation / colorAdjustmentFactor;
        } else {
          validateAndRetrieveColorProperties +=
            colorAdjustmentCalculation * Math.pow(2, 1 - maxColorValueHalf);
        }
        if (validateAndRetrieveColorProperties * colorAdjustmentFactor >= 2) {
          computedIntrinsicColorValue++;
          colorAdjustmentFactor /= 2;
        }
        if (
          computedIntrinsicColorValue + maxColorValueHalf >=
          calculateMaxColorValue
        ) {
          baseColorIntrinsicValue = 0;
          computedIntrinsicColorValue = calculateMaxColorValue;
        } else if (computedIntrinsicColorValue + maxColorValueHalf >= 1) {
          baseColorIntrinsicValue =
            (validateAndRetrieveColorProperties * colorAdjustmentFactor - 1) *
            Math.pow(2, processAndValidateColorIntrinsicValues);
          computedIntrinsicColorValue =
            computedIntrinsicColorValue + maxColorValueHalf;
        } else {
          baseColorIntrinsicValue =
            validateAndRetrieveColorProperties *
            Math.pow(2, maxColorValueHalf - 1) *
            Math.pow(2, processAndValidateColorIntrinsicValues);
          computedIntrinsicColorValue = 0;
        }
      }
      for (
        ;
        processAndValidateColorIntrinsicValues >= 8;
        processAndValidateColorIntrinsicValues -= 8
      ) {
        validateAndExtractColorValue[
          extractAndComputeColorPropertyValues + initialIntrinsicColorValue
        ] = baseColorIntrinsicValue & 255;
        initialIntrinsicColorValue +=
          validateAndRetrieveIntrinsicPropertyValues;
        baseColorIntrinsicValue /= 256;
      }
      computedIntrinsicColorValue =
        (computedIntrinsicColorValue <<
          processAndValidateColorIntrinsicValues) |
        baseColorIntrinsicValue;
      computedColorAdjustmentBasedOnDecodeValue +=
        processAndValidateColorIntrinsicValues;
      for (
        ;
        computedColorAdjustmentBasedOnDecodeValue > 0;
        computedColorAdjustmentBasedOnDecodeValue -= 8
      ) {
        validateAndExtractColorValue[
          extractAndComputeColorPropertyValues + initialIntrinsicColorValue
        ] = computedIntrinsicColorValue & 255;
        initialIntrinsicColorValue +=
          validateAndRetrieveIntrinsicPropertyValues;
        computedIntrinsicColorValue /= 256;
      }
      validateAndExtractColorValue[
        extractAndComputeColorPropertyValues +
          initialIntrinsicColorValue -
          validateAndRetrieveIntrinsicPropertyValues
      ] |= calculateColorProperties * 128;
    };
  },
);
var generateColorValidationMessage = lazyModuleInitializer((BufferHandler) => {
  var createRandomDataView = createRandomNumberGenerator();
  var extractIntrinsicPropertyDescriptor = extractColorValuesFromBase64();
  var nodejsInspectCustomSymbol =
    typeof Symbol == "function" && typeof Symbol.for == "function"
      ? Symbol.for("nodejs.util.inspect.custom")
      : null;
  BufferHandler.Buffer = processInputDataForPromiseValidation;
  BufferHandler.SlowBuffer = createDebugLogInstanceWithBufferValidation;
  BufferHandler.INSPECT_MAX_BYTES = 50;
  var MAXIMUM_BUFFER_SIZE = 2147483647;
  BufferHandler.kMaxLength = MAXIMUM_BUFFER_SIZE;
  processInputDataForPromiseValidation.TYPED_ARRAY_SUPPORT =
    isFooMethodAvailableOnTypedArray();
  if (
    !processInputDataForPromiseValidation.TYPED_ARRAY_SUPPORT &&
    typeof console !== "undefined" &&
    typeof console.error == "function"
  ) {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.",
    );
  }
  function isFooMethodAvailableOnTypedArray() {
    try {
      let uint8ArrayWithFooPrototype = new Uint8Array(1);
      let uint8ArrayWithCustomFooPrototype = {
        foo() {
          return 42;
        },
      };
      Object.setPrototypeOf(
        uint8ArrayWithCustomFooPrototype,
        Uint8Array.prototype,
      );
      Object.setPrototypeOf(
        uint8ArrayWithFooPrototype,
        uint8ArrayWithCustomFooPrototype,
      );
      return uint8ArrayWithFooPrototype.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(
    processInputDataForPromiseValidation.prototype,
    "parent",
    {
      enumerable: true,
      get() {
        if (processInputDataForPromiseValidation.isBuffer(this)) {
          return this.buffer;
        }
      },
    },
  );
  Object.defineProperty(
    processInputDataForPromiseValidation.prototype,
    "offset",
    {
      enumerable: true,
      get() {
        if (processInputDataForPromiseValidation.isBuffer(this)) {
          return this.byteOffset;
        }
      },
    },
  );
  function initializeValidatedUint8Array(_bufferSize) {
    if (_bufferSize > MAXIMUM_BUFFER_SIZE) {
      throw new RangeError(
        'The value "' + _bufferSize + '" is invalid for option "size"',
      );
    }
    let createValidatedUint8Array = new Uint8Array(_bufferSize);
    Object.setPrototypeOf(
      createValidatedUint8Array,
      processInputDataForPromiseValidation.prototype,
    );
    return createValidatedUint8Array;
  }
  function processInputDataForPromiseValidation(
    isInputBufferValid,
    isPromiseValidationUndefined,
    isValidationPromiseNull,
  ) {
    if (typeof isInputBufferValid == "number") {
      if (typeof isPromiseValidationUndefined == "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number',
        );
      }
      return validateAndInitializeBufferArray(isInputBufferValid);
    }
    return handleInputData(
      isInputBufferValid,
      isPromiseValidationUndefined,
      isValidationPromiseNull,
    );
  }
  processInputDataForPromiseValidation.poolSize = 8192;
  function handleInputData(inputType, shouldValidateAsError, isInputTypeValid) {
    if (typeof inputType == "string") {
      return createAndValidateByteBuffer(inputType, shouldValidateAsError);
    }
    if (ArrayBuffer.isView(inputType)) {
      return convertToByteArrayOrUint8Array(inputType);
    }
    if (inputType == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof inputType,
      );
    }
    if (
      isInstanceOrSameConstructorName(inputType, ArrayBuffer) ||
      (inputType &&
        isInstanceOrSameConstructorName(inputType.buffer, ArrayBuffer)) ||
      (typeof SharedArrayBuffer !== "undefined" &&
        (isInstanceOrSameConstructorName(inputType, SharedArrayBuffer) ||
          (inputType &&
            isInstanceOrSameConstructorName(
              inputType.buffer,
              SharedArrayBuffer,
            ))))
    ) {
      return createUint8ArrayFromBufferWithOffsetAndLength(
        inputType,
        shouldValidateAsError,
        isInputTypeValid,
      );
    }
    if (typeof inputType == "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number',
      );
    }
    let inputValueParameter = inputType.valueOf && inputType.valueOf();
    if (inputValueParameter != null && inputValueParameter !== inputType) {
      return processInputDataForPromiseValidation.from(
        inputValueParameter,
        shouldValidateAsError,
        isInputTypeValid,
      );
    }
    let _handleInputData = handleAndValidateBufferInput(inputType);
    if (_handleInputData) {
      return _handleInputData;
    }
    if (
      typeof Symbol !== "undefined" &&
      Symbol.toPrimitive != null &&
      typeof inputType[Symbol.toPrimitive] == "function"
    ) {
      return processInputDataForPromiseValidation.from(
        inputType[Symbol.toPrimitive]("string"),
        shouldValidateAsError,
        isInputTypeValid,
      );
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
        typeof inputType,
    );
  }
  processInputDataForPromiseValidation.from = function (
    processAndValidateInput,
    processAndValidateInputWithLogging,
    processAndLogCurrentDateTime,
  ) {
    return handleInputData(
      processAndValidateInput,
      processAndValidateInputWithLogging,
      processAndLogCurrentDateTime,
    );
  };
  Object.setPrototypeOf(
    processInputDataForPromiseValidation.prototype,
    Uint8Array.prototype,
  );
  Object.setPrototypeOf(processInputDataForPromiseValidation, Uint8Array);
  function validateSizeParameter(isSizeArgumentValid) {
    if (typeof isSizeArgumentValid != "number") {
      throw new TypeError('"size" argument must be of type number');
    }
    if (isSizeArgumentValid < 0) {
      throw new RangeError(
        'The value "' + isSizeArgumentValid + '" is invalid for option "size"',
      );
    }
  }
  function validateAndFormatTimeArray(
    processTimeArrayWithLeadingZeroValidation,
    validateArrayTypeForProcess,
    validateAndProcessTimeArray,
  ) {
    validateSizeParameter(processTimeArrayWithLeadingZeroValidation);
    if (processTimeArrayWithLeadingZeroValidation <= 0) {
      return initializeValidatedUint8Array(
        processTimeArrayWithLeadingZeroValidation,
      );
    } else if (validateArrayTypeForProcess !== undefined) {
      if (typeof validateAndProcessTimeArray == "string") {
        return initializeValidatedUint8Array(
          processTimeArrayWithLeadingZeroValidation,
        ).fill(validateArrayTypeForProcess, validateAndProcessTimeArray);
      } else {
        return initializeValidatedUint8Array(
          processTimeArrayWithLeadingZeroValidation,
        ).fill(validateArrayTypeForProcess);
      }
    } else {
      return initializeValidatedUint8Array(
        processTimeArrayWithLeadingZeroValidation,
      );
    }
  }
  processInputDataForPromiseValidation.alloc = function (
    logCurrentTimestamp,
    logMessageWithFormattedOutput,
    logDebugInformation,
  ) {
    return validateAndFormatTimeArray(
      logCurrentTimestamp,
      logMessageWithFormattedOutput,
      logDebugInformation,
    );
  };
  function validateAndInitializeBufferArray(_processAndCreateUint8Array) {
    validateSizeParameter(_processAndCreateUint8Array);
    return initializeValidatedUint8Array(
      _processAndCreateUint8Array < 0
        ? 0
        : checkLogBufferSize(_processAndCreateUint8Array) | 0,
    );
  }
  processInputDataForPromiseValidation.allocUnsafe = function (
    _logDebugInformation,
  ) {
    return validateAndInitializeBufferArray(_logDebugInformation);
  };
  processInputDataForPromiseValidation.allocUnsafeSlow = function (
    processAndLogDebugInformation,
  ) {
    return validateAndInitializeBufferArray(processAndLogDebugInformation);
  };
  function createAndValidateByteBuffer(
    convertToPromiseWithCustomSymbol,
    processArrayAndExtendValidation,
  ) {
    if (
      typeof processArrayAndExtendValidation != "string" ||
      processArrayAndExtendValidation === ""
    ) {
      processArrayAndExtendValidation = "utf8";
    }
    if (
      !processInputDataForPromiseValidation.isEncoding(
        processArrayAndExtendValidation,
      )
    ) {
      throw new TypeError(
        "Unknown encoding: " + processArrayAndExtendValidation,
      );
    }
    let bufferByteLength =
      getLengthOfBufferOrArrayBuffer(
        convertToPromiseWithCustomSymbol,
        processArrayAndExtendValidation,
      ) | 0;
    let byteBuffer = initializeValidatedUint8Array(bufferByteLength);
    let writtenBytesCount = byteBuffer.write(
      convertToPromiseWithCustomSymbol,
      processArrayAndExtendValidation,
    );
    if (writtenBytesCount !== bufferByteLength) {
      byteBuffer = byteBuffer.slice(0, writtenBytesCount);
    }
    return byteBuffer;
  }
  function convertPromiseFunctionToByteArray(convertToPromise) {
    let getFunctionByteSize =
      convertToPromise.length < 0
        ? 0
        : checkLogBufferSize(convertToPromise.length) | 0;
    let _convertPromiseFunctionToByteArray =
      initializeValidatedUint8Array(getFunctionByteSize);
    for (
      let byteArrayIndex = 0;
      byteArrayIndex < getFunctionByteSize;
      byteArrayIndex += 1
    ) {
      _convertPromiseFunctionToByteArray[byteArrayIndex] =
        convertToPromise[byteArrayIndex] & 255;
    }
    return _convertPromiseFunctionToByteArray;
  }
  function convertToByteArrayOrUint8Array(convertFunctionToPromise) {
    if (isInstanceOrSameConstructorName(convertFunctionToPromise, Uint8Array)) {
      let bufferPromiseUint8Array = new Uint8Array(convertFunctionToPromise);
      return createUint8ArrayFromBufferWithOffsetAndLength(
        bufferPromiseUint8Array.buffer,
        bufferPromiseUint8Array.byteOffset,
        bufferPromiseUint8Array.byteLength,
      );
    }
    return convertPromiseFunctionToByteArray(convertFunctionToPromise);
  }
  function createUint8ArrayFromBufferWithOffsetAndLength(
    convertFunctionToUint8Array,
    logPromiseAndExecuteCallback,
    validateAndLogInstance,
  ) {
    if (
      logPromiseAndExecuteCallback < 0 ||
      convertFunctionToUint8Array.byteLength < logPromiseAndExecuteCallback
    ) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (
      convertFunctionToUint8Array.byteLength <
      logPromiseAndExecuteCallback + (validateAndLogInstance || 0)
    ) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let dataByteArray;
    if (
      logPromiseAndExecuteCallback === undefined &&
      validateAndLogInstance === undefined
    ) {
      dataByteArray = new Uint8Array(convertFunctionToUint8Array);
    } else if (validateAndLogInstance === undefined) {
      dataByteArray = new Uint8Array(
        convertFunctionToUint8Array,
        logPromiseAndExecuteCallback,
      );
    } else {
      dataByteArray = new Uint8Array(
        convertFunctionToUint8Array,
        logPromiseAndExecuteCallback,
        validateAndLogInstance,
      );
    }
    Object.setPrototypeOf(
      dataByteArray,
      processInputDataForPromiseValidation.prototype,
    );
    return dataByteArray;
  }
  function handleAndValidateBufferInput(createUint8ArrayFromBuffer) {
    if (
      processInputDataForPromiseValidation.isBuffer(createUint8ArrayFromBuffer)
    ) {
      let bufferLengthForLogging =
        checkLogBufferSize(createUint8ArrayFromBuffer.length) | 0;
      let initializedLoggingBuffer = initializeValidatedUint8Array(
        bufferLengthForLogging,
      );
      if (initializedLoggingBuffer.length !== 0) {
        createUint8ArrayFromBuffer.copy(
          initializedLoggingBuffer,
          0,
          0,
          bufferLengthForLogging,
        );
      }
      return initializedLoggingBuffer;
    }
    if (createUint8ArrayFromBuffer.length !== undefined) {
      if (
        typeof createUint8ArrayFromBuffer.length != "number" ||
        isIntrinsicPropertyValid(createUint8ArrayFromBuffer.length)
      ) {
        return initializeValidatedUint8Array(0);
      } else {
        return convertPromiseFunctionToByteArray(createUint8ArrayFromBuffer);
      }
    }
    if (
      createUint8ArrayFromBuffer.type === "Buffer" &&
      Array.isArray(createUint8ArrayFromBuffer.data)
    ) {
      return convertPromiseFunctionToByteArray(createUint8ArrayFromBuffer.data);
    }
  }
  function checkLogBufferSize(logBufferProcessingResult) {
    if (logBufferProcessingResult >= MAXIMUM_BUFFER_SIZE) {
      throw new RangeError(
        "Attempt to allocate Buffer larger than maximum size: 0x" +
          MAXIMUM_BUFFER_SIZE.toString(16) +
          " bytes",
      );
    }
    return logBufferProcessingResult | 0;
  }
  function createDebugLogInstanceWithBufferValidation(validateLogBufferSize) {
    if (+validateLogBufferSize != validateLogBufferSize) {
      validateLogBufferSize = 0;
    }
    return processInputDataForPromiseValidation.alloc(+validateLogBufferSize);
  }
  processInputDataForPromiseValidation.isBuffer = function (
    convertCallbackToPromise,
  ) {
    return (
      convertCallbackToPromise != null &&
      convertCallbackToPromise._isBuffer === true &&
      convertCallbackToPromise !==
        processInputDataForPromiseValidation.prototype
    );
  };
  processInputDataForPromiseValidation.compare = function (
    processPromiseRejection,
    validateStyledOutputPromise,
  ) {
    if (isInstanceOrSameConstructorName(processPromiseRejection, Uint8Array)) {
      processPromiseRejection = processInputDataForPromiseValidation.from(
        processPromiseRejection,
        processPromiseRejection.offset,
        processPromiseRejection.byteLength,
      );
    }
    if (
      isInstanceOrSameConstructorName(validateStyledOutputPromise, Uint8Array)
    ) {
      validateStyledOutputPromise = processInputDataForPromiseValidation.from(
        validateStyledOutputPromise,
        validateStyledOutputPromise.offset,
        validateStyledOutputPromise.byteLength,
      );
    }
    if (
      !processInputDataForPromiseValidation.isBuffer(processPromiseRejection) ||
      !processInputDataForPromiseValidation.isBuffer(
        validateStyledOutputPromise,
      )
    ) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array',
      );
    }
    if (processPromiseRejection === validateStyledOutputPromise) {
      return 0;
    }
    let getPromiseRejectionLength = processPromiseRejection.length;
    let validateStyledOutputLength = validateStyledOutputPromise.length;
    for (
      let comparisonIndex = 0,
        minLengthForComparison = Math.min(
          getPromiseRejectionLength,
          validateStyledOutputLength,
        );
      comparisonIndex < minLengthForComparison;
      ++comparisonIndex
    ) {
      if (
        processPromiseRejection[comparisonIndex] !==
        validateStyledOutputPromise[comparisonIndex]
      ) {
        getPromiseRejectionLength = processPromiseRejection[comparisonIndex];
        validateStyledOutputLength =
          validateStyledOutputPromise[comparisonIndex];
        break;
      }
    }
    if (getPromiseRejectionLength < validateStyledOutputLength) {
      return -1;
    } else if (validateStyledOutputLength < getPromiseRejectionLength) {
      return 1;
    } else {
      return 0;
    }
  };
  processInputDataForPromiseValidation.isEncoding = function (
    compareBufferContents,
  ) {
    switch (String(compareBufferContents).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  processInputDataForPromiseValidation.concat = function (
    comparePromiseRejectionsAndOutputs,
    comparePromiseRejectionToStyledOutput,
  ) {
    if (!Array.isArray(comparePromiseRejectionsAndOutputs)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (comparePromiseRejectionsAndOutputs.length === 0) {
      return processInputDataForPromiseValidation.alloc(0);
    }
    let currentRejectionIndex;
    if (comparePromiseRejectionToStyledOutput === undefined) {
      comparePromiseRejectionToStyledOutput = 0;
      currentRejectionIndex = 0;
      for (
        ;
        currentRejectionIndex < comparePromiseRejectionsAndOutputs.length;
        ++currentRejectionIndex
      ) {
        comparePromiseRejectionToStyledOutput +=
          comparePromiseRejectionsAndOutputs[currentRejectionIndex].length;
      }
    }
    let combinedBufferView = processInputDataForPromiseValidation.allocUnsafe(
      comparePromiseRejectionToStyledOutput,
    );
    let totalBytesWritten = 0;
    for (
      currentRejectionIndex = 0;
      currentRejectionIndex < comparePromiseRejectionsAndOutputs.length;
      ++currentRejectionIndex
    ) {
      let currentDataBuffer =
        comparePromiseRejectionsAndOutputs[currentRejectionIndex];
      if (isInstanceOrSameConstructorName(currentDataBuffer, Uint8Array)) {
        if (
          totalBytesWritten + currentDataBuffer.length >
          combinedBufferView.length
        ) {
          if (
            !processInputDataForPromiseValidation.isBuffer(currentDataBuffer)
          ) {
            currentDataBuffer =
              processInputDataForPromiseValidation.from(currentDataBuffer);
          }
          currentDataBuffer.copy(combinedBufferView, totalBytesWritten);
        } else {
          Uint8Array.prototype.set.call(
            combinedBufferView,
            currentDataBuffer,
            totalBytesWritten,
          );
        }
      } else if (
        processInputDataForPromiseValidation.isBuffer(currentDataBuffer)
      ) {
        currentDataBuffer.copy(combinedBufferView, totalBytesWritten);
      } else {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      totalBytesWritten += currentDataBuffer.length;
    }
    return combinedBufferView;
  };
  function getLengthOfBufferOrArrayBuffer(
    calculateStyledOutputFromPromiseRejections,
    calculateTotalBufferSize,
  ) {
    if (
      processInputDataForPromiseValidation.isBuffer(
        calculateStyledOutputFromPromiseRejections,
      )
    ) {
      return calculateStyledOutputFromPromiseRejections.length;
    }
    if (
      ArrayBuffer.isView(calculateStyledOutputFromPromiseRejections) ||
      isInstanceOrSameConstructorName(
        calculateStyledOutputFromPromiseRejections,
        ArrayBuffer,
      )
    ) {
      return calculateStyledOutputFromPromiseRejections.byteLength;
    }
    if (typeof calculateStyledOutputFromPromiseRejections != "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
          typeof calculateStyledOutputFromPromiseRejections,
      );
    }
    let getStringLength = calculateStyledOutputFromPromiseRejections.length;
    let isAdditionalProcessingRequired =
      arguments.length > 2 && arguments[2] === true;
    if (!isAdditionalProcessingRequired && getStringLength === 0) {
      return 0;
    }
    let isStringLengthValid = false;
    while (true) {
      switch (calculateTotalBufferSize) {
        case "ascii":
        case "latin1":
        case "binary":
          return getStringLength;
        case "utf8":
        case "utf-8":
          return validateUnicodeAndFetchProperties(
            calculateStyledOutputFromPromiseRejections,
          ).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return getStringLength * 2;
        case "hex":
          return getStringLength >>> 1;
        case "base64":
          return generateAndStoreByteArrayFromBase64(
            calculateStyledOutputFromPromiseRejections,
          ).length;
        default:
          if (isStringLengthValid) {
            if (isAdditionalProcessingRequired) {
              return -1;
            } else {
              return validateUnicodeAndFetchProperties(
                calculateStyledOutputFromPromiseRejections,
              ).length;
            }
          }
          calculateTotalBufferSize = (
            "" + calculateTotalBufferSize
          ).toLowerCase();
          isStringLengthValid = true;
      }
    }
  }
  processInputDataForPromiseValidation.byteLength =
    getLengthOfBufferOrArrayBuffer;
  function createStringSlice(
    calculateStringLength,
    calculateOutputStringLength,
    calculateFormattedOutputSize,
  ) {
    let isValidSliceParameters = false;
    if (
      calculateOutputStringLength === undefined ||
      calculateOutputStringLength < 0
    ) {
      calculateOutputStringLength = 0;
    }
    if (
      calculateOutputStringLength > this.length ||
      ((calculateFormattedOutputSize === undefined ||
        calculateFormattedOutputSize > this.length) &&
        (calculateFormattedOutputSize = this.length),
      calculateFormattedOutputSize <= 0) ||
      ((calculateFormattedOutputSize >>>= 0),
      (calculateOutputStringLength >>>= 0),
      calculateFormattedOutputSize <= calculateOutputStringLength)
    ) {
      return "";
    }
    for (calculateStringLength ||= "utf8"; ; ) {
      switch (calculateStringLength) {
        case "hex":
          return convertTypedArrayToConcatenatedString(
            this,
            calculateOutputStringLength,
            calculateFormattedOutputSize,
          );
        case "utf8":
        case "utf-8":
          return validateAndDecodeUnicodeTypedArray(
            this,
            calculateOutputStringLength,
            calculateFormattedOutputSize,
          );
        case "ascii":
          return getValidPromiseTypeCharacters(
            this,
            calculateOutputStringLength,
            calculateFormattedOutputSize,
          );
        case "latin1":
        case "binary":
          return getCharactersFromProcessedInput(
            this,
            calculateOutputStringLength,
            calculateFormattedOutputSize,
          );
        case "base64":
          return generateDataViewFromByteArraySlice(
            this,
            calculateOutputStringLength,
            calculateFormattedOutputSize,
          );
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return decodeAndExtractBufferValues(
            this,
            calculateOutputStringLength,
            calculateFormattedOutputSize,
          );
        default:
          if (isValidSliceParameters) {
            throw new TypeError("Unknown encoding: " + calculateStringLength);
          }
          calculateStringLength = (calculateStringLength + "").toLowerCase();
          isValidSliceParameters = true;
      }
    }
  }
  processInputDataForPromiseValidation.prototype._isBuffer = true;
  function exchangeCharacterAttributes(
    processCharacterDataAndConvert,
    getFormattedOutputSize,
    validateAndFormatOutput,
  ) {
    let swappedCharacterAttributes =
      processCharacterDataAndConvert[getFormattedOutputSize];
    processCharacterDataAndConvert[getFormattedOutputSize] =
      processCharacterDataAndConvert[validateAndFormatOutput];
    processCharacterDataAndConvert[validateAndFormatOutput] =
      swappedCharacterAttributes;
  }
  processInputDataForPromiseValidation.prototype.swap16 = function () {
    let __bufferLengthInBytes = this.length;
    if (__bufferLengthInBytes % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (
      let _characterAttributeIndex = 0;
      _characterAttributeIndex < __bufferLengthInBytes;
      _characterAttributeIndex += 2
    ) {
      exchangeCharacterAttributes(
        this,
        _characterAttributeIndex,
        _characterAttributeIndex + 1,
      );
    }
    return this;
  };
  processInputDataForPromiseValidation.prototype.swap32 = function () {
    let _bufferLengthInBytes = this.length;
    if (_bufferLengthInBytes % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (
      let characterAttributeIndex = 0;
      characterAttributeIndex < _bufferLengthInBytes;
      characterAttributeIndex += 4
    ) {
      exchangeCharacterAttributes(
        this,
        characterAttributeIndex,
        characterAttributeIndex + 3,
      );
      exchangeCharacterAttributes(
        this,
        characterAttributeIndex + 1,
        characterAttributeIndex + 2,
      );
    }
    return this;
  };
  processInputDataForPromiseValidation.prototype.swap64 = function () {
    let bufferLengthInBytes = this.length;
    if (bufferLengthInBytes % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (
      let characterAttributeBufferIndex = 0;
      characterAttributeBufferIndex < bufferLengthInBytes;
      characterAttributeBufferIndex += 8
    ) {
      exchangeCharacterAttributes(
        this,
        characterAttributeBufferIndex,
        characterAttributeBufferIndex + 7,
      );
      exchangeCharacterAttributes(
        this,
        characterAttributeBufferIndex + 1,
        characterAttributeBufferIndex + 6,
      );
      exchangeCharacterAttributes(
        this,
        characterAttributeBufferIndex + 2,
        characterAttributeBufferIndex + 5,
      );
      exchangeCharacterAttributes(
        this,
        characterAttributeBufferIndex + 3,
        characterAttributeBufferIndex + 4,
      );
    }
    return this;
  };
  processInputDataForPromiseValidation.prototype.toString = function () {
    let inputArrayLength = this.length;
    if (inputArrayLength === 0) {
      return "";
    } else if (arguments.length === 0) {
      return validateAndDecodeUnicodeTypedArray(this, 0, inputArrayLength);
    } else {
      return createStringSlice.apply(this, arguments);
    }
  };
  processInputDataForPromiseValidation.prototype.toLocaleString =
    processInputDataForPromiseValidation.prototype.toString;
  processInputDataForPromiseValidation.prototype.equals = function (
    decodeBase64String,
  ) {
    if (!processInputDataForPromiseValidation.isBuffer(decodeBase64String)) {
      throw new TypeError("Argument must be a Buffer");
    }
    if (this === decodeBase64String) {
      return true;
    } else {
      return (
        processInputDataForPromiseValidation.compare(
          this,
          decodeBase64String,
        ) === 0
      );
    }
  };
  processInputDataForPromiseValidation.prototype.inspect = function () {
    let formattedHexBufferString = "";
    let maxBytesForHexBufferDisplay = BufferHandler.INSPECT_MAX_BYTES;
    formattedHexBufferString = this.toString(
      "hex",
      0,
      maxBytesForHexBufferDisplay,
    )
      .replace(/(.{2})/g, "$1 ")
      .trim();
    if (this.length > maxBytesForHexBufferDisplay) {
      formattedHexBufferString += " ... ";
    }
    return "<Buffer " + formattedHexBufferString + ">";
  };
  if (nodejsInspectCustomSymbol) {
    processInputDataForPromiseValidation.prototype[nodejsInspectCustomSymbol] =
      processInputDataForPromiseValidation.prototype.inspect;
  }
  processInputDataForPromiseValidation.prototype.compare = function (
    validateBufferProcessing,
    validateAndRetrieveBufferData,
    bufferDataValidator,
    processAndReturnEncodedData,
    bufferCharacterCode,
  ) {
    if (isInstanceOrSameConstructorName(validateBufferProcessing, Uint8Array)) {
      validateBufferProcessing = processInputDataForPromiseValidation.from(
        validateBufferProcessing,
        validateBufferProcessing.offset,
        validateBufferProcessing.byteLength,
      );
    }
    if (
      !processInputDataForPromiseValidation.isBuffer(validateBufferProcessing)
    ) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
          typeof validateBufferProcessing,
      );
    }
    if (validateAndRetrieveBufferData === undefined) {
      validateAndRetrieveBufferData = 0;
    }
    if (bufferDataValidator === undefined) {
      if (validateBufferProcessing) {
        bufferDataValidator = validateBufferProcessing.length;
      } else {
        bufferDataValidator = 0;
      }
    }
    if (processAndReturnEncodedData === undefined) {
      processAndReturnEncodedData = 0;
    }
    if (bufferCharacterCode === undefined) {
      bufferCharacterCode = this.length;
    }
    if (
      validateAndRetrieveBufferData < 0 ||
      bufferDataValidator > validateBufferProcessing.length ||
      processAndReturnEncodedData < 0 ||
      bufferCharacterCode > this.length
    ) {
      throw new RangeError("out of range index");
    }
    if (
      processAndReturnEncodedData >= bufferCharacterCode &&
      validateAndRetrieveBufferData >= bufferDataValidator
    ) {
      return 0;
    }
    if (processAndReturnEncodedData >= bufferCharacterCode) {
      return -1;
    }
    if (validateAndRetrieveBufferData >= bufferDataValidator) {
      return 1;
    }
    validateAndRetrieveBufferData >>>= 0;
    bufferDataValidator >>>= 0;
    processAndReturnEncodedData >>>= 0;
    bufferCharacterCode >>>= 0;
    if (this === validateBufferProcessing) {
      return 0;
    }
    let validateBufferAndParameters =
      bufferCharacterCode - processAndReturnEncodedData;
    let validateBufferAndProcessData =
      bufferDataValidator - validateAndRetrieveBufferData;
    let initializeBufferParameters = Math.min(
      validateBufferAndParameters,
      validateBufferAndProcessData,
    );
    let validateAndProcessBufferData = this.slice(
      processAndReturnEncodedData,
      bufferCharacterCode,
    );
    let validateBufferInputParameters = validateBufferProcessing.slice(
      validateAndRetrieveBufferData,
      bufferDataValidator,
    );
    for (
      let bufferParameterIndex = 0;
      bufferParameterIndex < initializeBufferParameters;
      ++bufferParameterIndex
    ) {
      if (
        validateAndProcessBufferData[bufferParameterIndex] !==
        validateBufferInputParameters[bufferParameterIndex]
      ) {
        validateBufferAndParameters =
          validateAndProcessBufferData[bufferParameterIndex];
        validateBufferAndProcessData =
          validateBufferInputParameters[bufferParameterIndex];
        break;
      }
    }
    if (validateBufferAndParameters < validateBufferAndProcessData) {
      return -1;
    } else if (validateBufferAndProcessData < validateBufferAndParameters) {
      return 1;
    } else {
      return 0;
    }
  };
  function getBufferSegmentOrDefault(
    validateAndRetrieveBufferBounds,
    validateBufferRangeAndIntegrity,
    validateAndProcessBuffer,
    validateBufferDataAndReturnEncodedData,
    compareAndValidateBufferData,
  ) {
    if (validateAndRetrieveBufferBounds.length === 0) {
      return -1;
    }
    if (typeof validateAndProcessBuffer == "string") {
      validateBufferDataAndReturnEncodedData = validateAndProcessBuffer;
      validateAndProcessBuffer = 0;
    } else if (validateAndProcessBuffer > 2147483647) {
      validateAndProcessBuffer = 2147483647;
    } else if (validateAndProcessBuffer < -2147483648) {
      validateAndProcessBuffer = -2147483648;
    }
    validateAndProcessBuffer = +validateAndProcessBuffer;
    if (isIntrinsicPropertyValid(validateAndProcessBuffer)) {
      if (compareAndValidateBufferData) {
        validateAndProcessBuffer = 0;
      } else {
        validateAndProcessBuffer = validateAndRetrieveBufferBounds.length - 1;
      }
    }
    if (validateAndProcessBuffer < 0) {
      validateAndProcessBuffer =
        validateAndRetrieveBufferBounds.length + validateAndProcessBuffer;
    }
    if (validateAndProcessBuffer >= validateAndRetrieveBufferBounds.length) {
      if (compareAndValidateBufferData) {
        return -1;
      }
      validateAndProcessBuffer = validateAndRetrieveBufferBounds.length - 1;
    } else if (validateAndProcessBuffer < 0) {
      if (compareAndValidateBufferData) {
        validateAndProcessBuffer = 0;
      } else {
        return -1;
      }
    }
    if (typeof validateBufferRangeAndIntegrity == "string") {
      validateBufferRangeAndIntegrity =
        processInputDataForPromiseValidation.from(
          validateBufferRangeAndIntegrity,
          validateBufferDataAndReturnEncodedData,
        );
    }
    if (
      processInputDataForPromiseValidation.isBuffer(
        validateBufferRangeAndIntegrity,
      )
    ) {
      if (validateBufferRangeAndIntegrity.length === 0) {
        return -1;
      } else {
        return validateAndCalculateBufferProperties(
          validateAndRetrieveBufferBounds,
          validateBufferRangeAndIntegrity,
          validateAndProcessBuffer,
          validateBufferDataAndReturnEncodedData,
          compareAndValidateBufferData,
        );
      }
    }
    if (typeof validateBufferRangeAndIntegrity == "number") {
      validateBufferRangeAndIntegrity = validateBufferRangeAndIntegrity & 255;
      if (typeof Uint8Array.prototype.indexOf == "function") {
        if (compareAndValidateBufferData) {
          return Uint8Array.prototype.indexOf.call(
            validateAndRetrieveBufferBounds,
            validateBufferRangeAndIntegrity,
            validateAndProcessBuffer,
          );
        } else {
          return Uint8Array.prototype.lastIndexOf.call(
            validateAndRetrieveBufferBounds,
            validateBufferRangeAndIntegrity,
            validateAndProcessBuffer,
          );
        }
      } else {
        return validateAndCalculateBufferProperties(
          validateAndRetrieveBufferBounds,
          [validateBufferRangeAndIntegrity],
          validateAndProcessBuffer,
          validateBufferDataAndReturnEncodedData,
          compareAndValidateBufferData,
        );
      }
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function validateAndCalculateBufferProperties(
    validateAndCalculateIntrinsicBufferProperties,
    calculateAndValidateBufferProperties,
    _calculateAndValidateBufferProperties,
    computeBufferProperties,
    calculateAndValidateBufferPropertyValue,
  ) {
    let requiredPropertyCount = 1;
    let intrinsicBufferPropertiesCount =
      validateAndCalculateIntrinsicBufferProperties.length;
    let calculatedBufferPropertyCount =
      calculateAndValidateBufferProperties.length;
    if (
      computeBufferProperties !== undefined &&
      ((computeBufferProperties = String(
        computeBufferProperties,
      ).toLowerCase()),
      computeBufferProperties === "ucs2" ||
        computeBufferProperties === "ucs-2" ||
        computeBufferProperties === "utf16le" ||
        computeBufferProperties === "utf-16le")
    ) {
      if (
        validateAndCalculateIntrinsicBufferProperties.length < 2 ||
        calculateAndValidateBufferProperties.length < 2
      ) {
        return -1;
      }
      requiredPropertyCount = 2;
      intrinsicBufferPropertiesCount /= 2;
      calculatedBufferPropertyCount /= 2;
      _calculateAndValidateBufferProperties /= 2;
    }
    function retrieveBufferPropertyValue(
      __calculateAndValidateBufferProperties,
      calculateAndValidateIntrinsicBufferProperties,
    ) {
      if (requiredPropertyCount === 1) {
        return __calculateAndValidateBufferProperties[
          calculateAndValidateIntrinsicBufferProperties
        ];
      } else {
        return __calculateAndValidateBufferProperties.readUInt16BE(
          calculateAndValidateIntrinsicBufferProperties * requiredPropertyCount,
        );
      }
    }
    let computeAndValidateBufferProperties;
    if (calculateAndValidateBufferPropertyValue) {
      let firstBufferPropertyMatchIndex = -1;
      for (
        computeAndValidateBufferProperties =
          _calculateAndValidateBufferProperties;
        computeAndValidateBufferProperties < intrinsicBufferPropertiesCount;
        computeAndValidateBufferProperties++
      ) {
        if (
          retrieveBufferPropertyValue(
            validateAndCalculateIntrinsicBufferProperties,
            computeAndValidateBufferProperties,
          ) ===
          retrieveBufferPropertyValue(
            calculateAndValidateBufferProperties,
            firstBufferPropertyMatchIndex === -1
              ? 0
              : computeAndValidateBufferProperties -
                  firstBufferPropertyMatchIndex,
          )
        ) {
          if (firstBufferPropertyMatchIndex === -1) {
            firstBufferPropertyMatchIndex = computeAndValidateBufferProperties;
          }
          if (
            computeAndValidateBufferProperties -
              firstBufferPropertyMatchIndex +
              1 ===
            calculatedBufferPropertyCount
          ) {
            return firstBufferPropertyMatchIndex * requiredPropertyCount;
          }
        } else {
          if (firstBufferPropertyMatchIndex !== -1) {
            computeAndValidateBufferProperties -=
              computeAndValidateBufferProperties -
              firstBufferPropertyMatchIndex;
          }
          firstBufferPropertyMatchIndex = -1;
        }
      }
    } else {
      if (
        _calculateAndValidateBufferProperties + calculatedBufferPropertyCount >
        intrinsicBufferPropertiesCount
      ) {
        _calculateAndValidateBufferProperties =
          intrinsicBufferPropertiesCount - calculatedBufferPropertyCount;
      }
      computeAndValidateBufferProperties =
        _calculateAndValidateBufferProperties;
      for (
        ;
        computeAndValidateBufferProperties >= 0;
        computeAndValidateBufferProperties--
      ) {
        let areAllBufferPropertiesValid = true;
        for (
          let bufferPropertyIndex = 0;
          bufferPropertyIndex < calculatedBufferPropertyCount;
          bufferPropertyIndex++
        ) {
          if (
            retrieveBufferPropertyValue(
              validateAndCalculateIntrinsicBufferProperties,
              computeAndValidateBufferProperties + bufferPropertyIndex,
            ) !==
            retrieveBufferPropertyValue(
              calculateAndValidateBufferProperties,
              bufferPropertyIndex,
            )
          ) {
            areAllBufferPropertiesValid = false;
            break;
          }
        }
        if (areAllBufferPropertiesValid) {
          return computeAndValidateBufferProperties;
        }
      }
    }
    return -1;
  }
  processInputDataForPromiseValidation.prototype.includes = function (
    findMatchingIntrinsicPropertyIndex,
    validateIntrinsicPropertyValues,
    validateAndRetrieveIntrinsicPropertyValues,
  ) {
    return (
      this.indexOf(
        findMatchingIntrinsicPropertyIndex,
        validateIntrinsicPropertyValues,
        validateAndRetrieveIntrinsicPropertyValues,
      ) !== -1
    );
  };
  processInputDataForPromiseValidation.prototype.indexOf = function (
    validatePropertyValueIndex,
    validateAndRetrievePropertyIndex,
    _________validateAndRetrieveIntrinsicProperty,
  ) {
    return getBufferSegmentOrDefault(
      this,
      validatePropertyValueIndex,
      validateAndRetrievePropertyIndex,
      _________validateAndRetrieveIntrinsicProperty,
      true,
    );
  };
  processInputDataForPromiseValidation.prototype.lastIndexOf = function (
    intrinsicPropertyValue,
    getIntrinsicPropertyValue,
    _getIntrinsicPropertyValue,
  ) {
    return getBufferSegmentOrDefault(
      this,
      intrinsicPropertyValue,
      getIntrinsicPropertyValue,
      _getIntrinsicPropertyValue,
      false,
    );
  };
  function adjustIntrinsicsBasedOnAvailableProperties(
    retrieveValidatedProperty,
    __retrieveAndValidateIntrinsicProperty,
    _intrinsicPropertyValue,
    calculateAdjustedIntrinsicValue,
  ) {
    _intrinsicPropertyValue = Number(_intrinsicPropertyValue) || 0;
    let availablePropertyCapacity =
      retrieveValidatedProperty.length - _intrinsicPropertyValue;
    if (calculateAdjustedIntrinsicValue) {
      calculateAdjustedIntrinsicValue = Number(calculateAdjustedIntrinsicValue);
      if (calculateAdjustedIntrinsicValue > availablePropertyCapacity) {
        calculateAdjustedIntrinsicValue = availablePropertyCapacity;
      }
    } else {
      calculateAdjustedIntrinsicValue = availablePropertyCapacity;
    }
    let countOfBuildingIntrinsicProperties =
      __retrieveAndValidateIntrinsicProperty.length;
    if (
      calculateAdjustedIntrinsicValue >
      countOfBuildingIntrinsicProperties / 2
    ) {
      calculateAdjustedIntrinsicValue = countOfBuildingIntrinsicProperties / 2;
    }
    let adjustedIntrinsicPropertyIndex;
    for (
      adjustedIntrinsicPropertyIndex = 0;
      adjustedIntrinsicPropertyIndex < calculateAdjustedIntrinsicValue;
      ++adjustedIntrinsicPropertyIndex
    ) {
      let convertHexStringToInteger = parseInt(
        __retrieveAndValidateIntrinsicProperty.substr(
          adjustedIntrinsicPropertyIndex * 2,
          2,
        ),
        16,
      );
      if (isIntrinsicPropertyValid(convertHexStringToInteger)) {
        return adjustedIntrinsicPropertyIndex;
      }
      retrieveValidatedProperty[
        _intrinsicPropertyValue + adjustedIntrinsicPropertyIndex
      ] = convertHexStringToInteger;
    }
    return adjustedIntrinsicPropertyIndex;
  }
  function handleIntrinsicValuesValidationAndCopying(
    validateAndCopyIntrinsicProperties,
    validateAndCollectIntrinsicValues,
    _validateAndRetrieveIntrinsicProperties,
    retrieveAndValidatePropertyValueForIntrinsics,
  ) {
    return transferAndValidateIntrinsicValues(
      validateUnicodeAndFetchProperties(
        validateAndCollectIntrinsicValues,
        validateAndCopyIntrinsicProperties.length -
          _validateAndRetrieveIntrinsicProperties,
      ),
      validateAndCopyIntrinsicProperties,
      _validateAndRetrieveIntrinsicProperties,
      retrieveAndValidatePropertyValueForIntrinsics,
    );
  }
  function transferAndValidateIntrinsicValuesWithCharCode(
    intrinsicPropertyValues,
    getValidatedIntrinsicValue,
    _getValidatedIntrinsicValue,
    _validateAndRetrieveIntrinsicPropertyValues,
  ) {
    return transferAndValidateIntrinsicValues(
      stringToCharCodeByteArray(getValidatedIntrinsicValue),
      intrinsicPropertyValues,
      _getValidatedIntrinsicValue,
      _validateAndRetrieveIntrinsicPropertyValues,
    );
  }
  function _transferAndValidateIntrinsicValues(
    validateAndCopyIntrinsicProperty,
    validateAndRetrieveIntrinsicValue,
    retrieveValidatedIntrinsicNumber,
    _validateAndRetrieveIntrinsicValue,
  ) {
    return transferAndValidateIntrinsicValues(
      generateAndStoreByteArrayFromBase64(validateAndRetrieveIntrinsicValue),
      validateAndCopyIntrinsicProperty,
      retrieveValidatedIntrinsicNumber,
      _validateAndRetrieveIntrinsicValue,
    );
  }
  function validateAndCopyIntrinsicValueProperties(
    intrinsicValueProperties,
    extractAndValidateIntrinsicProperty,
    __validateAndRetrieveIntrinsicValue,
    __validateAndRetrieveIntrinsicPropertyValue,
  ) {
    return transferAndValidateIntrinsicValues(
      calculateIntrinsicCharacterValues(
        extractAndValidateIntrinsicProperty,
        intrinsicValueProperties.length - __validateAndRetrieveIntrinsicValue,
      ),
      intrinsicValueProperties,
      __validateAndRetrieveIntrinsicValue,
      __validateAndRetrieveIntrinsicPropertyValue,
    );
  }
  processInputDataForPromiseValidation.prototype.write = function (
    __________validateAndRetrieveIntrinsicProperty,
    ___________validateAndRetrieveIntrinsicProperty,
    ____________validateAndRetrieveIntrinsicProperty,
    validateAndRetrieveBoneProperty,
  ) {
    if (___________validateAndRetrieveIntrinsicProperty === undefined) {
      validateAndRetrieveBoneProperty = "utf8";
      ____________validateAndRetrieveIntrinsicProperty = this.length;
      ___________validateAndRetrieveIntrinsicProperty = 0;
    } else if (
      ____________validateAndRetrieveIntrinsicProperty === undefined &&
      typeof ___________validateAndRetrieveIntrinsicProperty == "string"
    ) {
      validateAndRetrieveBoneProperty =
        ___________validateAndRetrieveIntrinsicProperty;
      ____________validateAndRetrieveIntrinsicProperty = this.length;
      ___________validateAndRetrieveIntrinsicProperty = 0;
    } else if (isFinite(___________validateAndRetrieveIntrinsicProperty)) {
      ___________validateAndRetrieveIntrinsicProperty =
        ___________validateAndRetrieveIntrinsicProperty >>> 0;
      if (isFinite(____________validateAndRetrieveIntrinsicProperty)) {
        ____________validateAndRetrieveIntrinsicProperty =
          ____________validateAndRetrieveIntrinsicProperty >>> 0;
        if (validateAndRetrieveBoneProperty === undefined) {
          validateAndRetrieveBoneProperty = "utf8";
        }
      } else {
        validateAndRetrieveBoneProperty =
          ____________validateAndRetrieveIntrinsicProperty;
        ____________validateAndRetrieveIntrinsicProperty = undefined;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported",
      );
    }
    let validateAndRetrieveIntrinsicPropertySettings =
      this.length - ___________validateAndRetrieveIntrinsicProperty;
    if (
      ____________validateAndRetrieveIntrinsicProperty === undefined ||
      ____________validateAndRetrieveIntrinsicProperty >
        validateAndRetrieveIntrinsicPropertySettings
    ) {
      ____________validateAndRetrieveIntrinsicProperty =
        validateAndRetrieveIntrinsicPropertySettings;
    }
    if (
      (__________validateAndRetrieveIntrinsicProperty.length > 0 &&
        (____________validateAndRetrieveIntrinsicProperty < 0 ||
          ___________validateAndRetrieveIntrinsicProperty < 0)) ||
      ___________validateAndRetrieveIntrinsicProperty > this.length
    ) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    validateAndRetrieveBoneProperty ||= "utf8";
    let setDefaultsAndValidateProperty = false;
    while (true) {
      switch (validateAndRetrieveBoneProperty) {
        case "hex":
          return adjustIntrinsicsBasedOnAvailableProperties(
            this,
            __________validateAndRetrieveIntrinsicProperty,
            ___________validateAndRetrieveIntrinsicProperty,
            ____________validateAndRetrieveIntrinsicProperty,
          );
        case "utf8":
        case "utf-8":
          return handleIntrinsicValuesValidationAndCopying(
            this,
            __________validateAndRetrieveIntrinsicProperty,
            ___________validateAndRetrieveIntrinsicProperty,
            ____________validateAndRetrieveIntrinsicProperty,
          );
        case "ascii":
        case "latin1":
        case "binary":
          return transferAndValidateIntrinsicValuesWithCharCode(
            this,
            __________validateAndRetrieveIntrinsicProperty,
            ___________validateAndRetrieveIntrinsicProperty,
            ____________validateAndRetrieveIntrinsicProperty,
          );
        case "base64":
          return _transferAndValidateIntrinsicValues(
            this,
            __________validateAndRetrieveIntrinsicProperty,
            ___________validateAndRetrieveIntrinsicProperty,
            ____________validateAndRetrieveIntrinsicProperty,
          );
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return validateAndCopyIntrinsicValueProperties(
            this,
            __________validateAndRetrieveIntrinsicProperty,
            ___________validateAndRetrieveIntrinsicProperty,
            ____________validateAndRetrieveIntrinsicProperty,
          );
        default:
          if (setDefaultsAndValidateProperty) {
            throw new TypeError(
              "Unknown encoding: " + validateAndRetrieveBoneProperty,
            );
          }
          validateAndRetrieveBoneProperty = (
            "" + validateAndRetrieveBoneProperty
          ).toLowerCase();
          setDefaultsAndValidateProperty = true;
      }
    }
  };
  processInputDataForPromiseValidation.prototype.toJSON = function () {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0),
    };
  };
  function generateDataViewFromByteArraySlice(
    retrieveByteValuesWithValidation,
    getNextByteValues,
    getUnicodeValueFromBytes,
  ) {
    if (
      getNextByteValues === 0 &&
      getUnicodeValueFromBytes === retrieveByteValuesWithValidation.length
    ) {
      return createRandomDataView.fromByteArray(
        retrieveByteValuesWithValidation,
      );
    } else {
      return createRandomDataView.fromByteArray(
        retrieveByteValuesWithValidation.slice(
          getNextByteValues,
          getUnicodeValueFromBytes,
        ),
      );
    }
  }
  function validateAndDecodeUnicodeTypedArray(
    retrieveUnicodeByteValues,
    validateAndDecodeUnicodeByteSequence,
    decodeUTF8BytesToUnicode,
  ) {
    decodeUTF8BytesToUnicode = Math.min(
      retrieveUnicodeByteValues.length,
      decodeUTF8BytesToUnicode,
    );
    let unicodeByteBuffer = [];
    let currentByteIndex = validateAndDecodeUnicodeByteSequence;
    while (currentByteIndex < decodeUTF8BytesToUnicode) {
      let leadingByteValue = retrieveUnicodeByteValues[currentByteIndex];
      let unpackingUnicodeValue = null;
      let unicodeByteLength =
        leadingByteValue > 239
          ? 4
          : leadingByteValue > 223
            ? 3
            : leadingByteValue > 191
              ? 2
              : 1;
      if (currentByteIndex + unicodeByteLength <= decodeUTF8BytesToUnicode) {
        let retrieveNextUnicodeByte;
        let thirdByteUnicodeValue;
        let extractUnicodeValueFromByteSequence;
        let decodedUnicodeCharacter;
        switch (unicodeByteLength) {
          case 1:
            if (leadingByteValue < 128) {
              unpackingUnicodeValue = leadingByteValue;
            }
            break;
          case 2:
            retrieveNextUnicodeByte =
              retrieveUnicodeByteValues[currentByteIndex + 1];
            if ((retrieveNextUnicodeByte & 192) === 128) {
              decodedUnicodeCharacter =
                ((leadingByteValue & 31) << 6) | (retrieveNextUnicodeByte & 63);
              if (decodedUnicodeCharacter > 127) {
                unpackingUnicodeValue = decodedUnicodeCharacter;
              }
            }
            break;
          case 3:
            retrieveNextUnicodeByte =
              retrieveUnicodeByteValues[currentByteIndex + 1];
            thirdByteUnicodeValue =
              retrieveUnicodeByteValues[currentByteIndex + 2];
            if (
              (retrieveNextUnicodeByte & 192) === 128 &&
              (thirdByteUnicodeValue & 192) === 128
            ) {
              decodedUnicodeCharacter =
                ((leadingByteValue & 15) << 12) |
                ((retrieveNextUnicodeByte & 63) << 6) |
                (thirdByteUnicodeValue & 63);
              if (
                decodedUnicodeCharacter > 2047 &&
                (decodedUnicodeCharacter < 55296 ||
                  decodedUnicodeCharacter > 57343)
              ) {
                unpackingUnicodeValue = decodedUnicodeCharacter;
              }
            }
            break;
          case 4:
            retrieveNextUnicodeByte =
              retrieveUnicodeByteValues[currentByteIndex + 1];
            thirdByteUnicodeValue =
              retrieveUnicodeByteValues[currentByteIndex + 2];
            extractUnicodeValueFromByteSequence =
              retrieveUnicodeByteValues[currentByteIndex + 3];
            if (
              (retrieveNextUnicodeByte & 192) === 128 &&
              (thirdByteUnicodeValue & 192) === 128 &&
              (extractUnicodeValueFromByteSequence & 192) === 128
            ) {
              decodedUnicodeCharacter =
                ((leadingByteValue & 15) << 18) |
                ((retrieveNextUnicodeByte & 63) << 12) |
                ((thirdByteUnicodeValue & 63) << 6) |
                (extractUnicodeValueFromByteSequence & 63);
              if (
                decodedUnicodeCharacter > 65535 &&
                decodedUnicodeCharacter < 1114112
              ) {
                unpackingUnicodeValue = decodedUnicodeCharacter;
              }
            }
        }
      }
      if (unpackingUnicodeValue === null) {
        unpackingUnicodeValue = 65533;
        unicodeByteLength = 1;
      } else if (unpackingUnicodeValue > 65535) {
        unpackingUnicodeValue -= 65536;
        unicodeByteBuffer.push(((unpackingUnicodeValue >>> 10) & 1023) | 55296);
        unpackingUnicodeValue = (unpackingUnicodeValue & 1023) | 56320;
      }
      unicodeByteBuffer.push(unpackingUnicodeValue);
      currentByteIndex += unicodeByteLength;
    }
    return convertTypedArrayToString(unicodeByteBuffer);
  }
  var _checkTypedArraySupport = 4096;
  function convertTypedArrayToString(validatePromiseInputFormat) {
    let inputFormatLength = validatePromiseInputFormat.length;
    if (inputFormatLength <= _checkTypedArraySupport) {
      return String.fromCharCode.apply(String, validatePromiseInputFormat);
    }
    let resultingStringFromTypedArray = "";
    let currentTypedArraySegmentStartIndex = 0;
    while (currentTypedArraySegmentStartIndex < inputFormatLength) {
      resultingStringFromTypedArray += String.fromCharCode.apply(
        String,
        validatePromiseInputFormat.slice(
          currentTypedArraySegmentStartIndex,
          (currentTypedArraySegmentStartIndex += _checkTypedArraySupport),
        ),
      );
    }
    return resultingStringFromTypedArray;
  }
  function getValidPromiseTypeCharacters(
    sliceArrayWithBounds,
    slicePromiseArray,
    _validatePromiseInputFormat,
  ) {
    let extractValidPromiseCharacterTypes = "";
    _validatePromiseInputFormat = Math.min(
      sliceArrayWithBounds.length,
      _validatePromiseInputFormat,
    );
    for (
      let currentPromiseTypeIndexWithinBounds = slicePromiseArray;
      currentPromiseTypeIndexWithinBounds < _validatePromiseInputFormat;
      ++currentPromiseTypeIndexWithinBounds
    ) {
      extractValidPromiseCharacterTypes += String.fromCharCode(
        sliceArrayWithBounds[currentPromiseTypeIndexWithinBounds] & 127,
      );
    }
    return extractValidPromiseCharacterTypes;
  }
  function getCharactersFromProcessedInput(
    validateProcessInput,
    validatePromiseInputSize,
    _validatePromiseInputSize,
  ) {
    let charactersFromInput = "";
    _validatePromiseInputSize = Math.min(
      validateProcessInput.length,
      _validatePromiseInputSize,
    );
    for (
      let currentInputCharacterIndex = validatePromiseInputSize;
      currentInputCharacterIndex < _validatePromiseInputSize;
      ++currentInputCharacterIndex
    ) {
      charactersFromInput += String.fromCharCode(
        validateProcessInput[currentInputCharacterIndex],
      );
    }
    return charactersFromInput;
  }
  function convertTypedArrayToConcatenatedString(
    validateAndReadUIntLE,
    validateBufferRangeAndSize,
    __validateBufferSize,
  ) {
    let typedArrayTotalLength = validateAndReadUIntLE.length;
    if (!validateBufferRangeAndSize || validateBufferRangeAndSize < 0) {
      validateBufferRangeAndSize = 0;
    }
    if (
      !__validateBufferSize ||
      __validateBufferSize < 0 ||
      __validateBufferSize > typedArrayTotalLength
    ) {
      __validateBufferSize = typedArrayTotalLength;
    }
    let concatenatedTypedArrayString = "";
    for (
      let bufferValidationIndex = validateBufferRangeAndSize;
      bufferValidationIndex < __validateBufferSize;
      ++bufferValidationIndex
    ) {
      concatenatedTypedArrayString +=
        isTypedArraySupported[validateAndReadUIntLE[bufferValidationIndex]];
    }
    return concatenatedTypedArrayString;
  }
  function decodeAndExtractBufferValues(
    calculateBufferValueFromInput,
    validateBufferSizeWithTypeCheck,
    validateAndConvertBufferSize,
  ) {
    let bufferValueCharCodes = calculateBufferValueFromInput.slice(
      validateBufferSizeWithTypeCheck,
      validateAndConvertBufferSize,
    );
    let decodedBufferValues = "";
    for (
      let charCodePairIndex = 0;
      charCodePairIndex < bufferValueCharCodes.length - 1;
      charCodePairIndex += 2
    ) {
      decodedBufferValues += String.fromCharCode(
        bufferValueCharCodes[charCodePairIndex] +
          bufferValueCharCodes[charCodePairIndex + 1] * 256,
      );
    }
    return decodedBufferValues;
  }
  processInputDataForPromiseValidation.prototype.slice = function (
    allocateUInt8FromBuffer,
    getAllocatedValueFromBuffer,
  ) {
    let bufferLength = this.length;
    allocateUInt8FromBuffer = ~~allocateUInt8FromBuffer;
    if (getAllocatedValueFromBuffer === undefined) {
      getAllocatedValueFromBuffer = bufferLength;
    } else {
      getAllocatedValueFromBuffer = ~~getAllocatedValueFromBuffer;
    }
    if (allocateUInt8FromBuffer < 0) {
      allocateUInt8FromBuffer += bufferLength;
      if (allocateUInt8FromBuffer < 0) {
        allocateUInt8FromBuffer = 0;
      }
    } else if (allocateUInt8FromBuffer > bufferLength) {
      allocateUInt8FromBuffer = bufferLength;
    }
    if (getAllocatedValueFromBuffer < 0) {
      getAllocatedValueFromBuffer += bufferLength;
      if (getAllocatedValueFromBuffer < 0) {
        getAllocatedValueFromBuffer = 0;
      }
    } else if (getAllocatedValueFromBuffer > bufferLength) {
      getAllocatedValueFromBuffer = bufferLength;
    }
    if (getAllocatedValueFromBuffer < allocateUInt8FromBuffer) {
      getAllocatedValueFromBuffer = allocateUInt8FromBuffer;
    }
    let sliceBufferSubArray = this.subarray(
      allocateUInt8FromBuffer,
      getAllocatedValueFromBuffer,
    );
    Object.setPrototypeOf(
      sliceBufferSubArray,
      processInputDataForPromiseValidation.prototype,
    );
    return sliceBufferSubArray;
  };
  function checkAndValidateBufferIndex(
    checkArrayIndexBounds,
    validateAndEnsureArrayIndex,
    validateBufferAndThrowErrorIfOutOfBounds,
  ) {
    if (checkArrayIndexBounds % 1 !== 0 || checkArrayIndexBounds < 0) {
      throw new RangeError("offset is not uint");
    }
    if (
      checkArrayIndexBounds + validateAndEnsureArrayIndex >
      validateBufferAndThrowErrorIfOutOfBounds
    ) {
      throw new RangeError("Trying to access beyond buffer length");
    }
  }
  processInputDataForPromiseValidation.prototype.readUintLE =
    processInputDataForPromiseValidation.prototype.readUIntLE = function (
      checkBufferSizeValidity,
      prepareBufferForLogging,
      allocateDebugBuffer,
    ) {
      checkBufferSizeValidity = checkBufferSizeValidity >>> 0;
      prepareBufferForLogging = prepareBufferForLogging >>> 0;
      if (!allocateDebugBuffer) {
        checkAndValidateBufferIndex(
          checkBufferSizeValidity,
          prepareBufferForLogging,
          this.length,
        );
      }
      let accumulatedBufferValue = this[checkBufferSizeValidity];
      let bufferMultiplier = 1;
      let bufferValueAccumulator = 0;
      while (
        ++bufferValueAccumulator < prepareBufferForLogging &&
        (bufferMultiplier *= 256)
      ) {
        accumulatedBufferValue +=
          this[checkBufferSizeValidity + bufferValueAccumulator] *
          bufferMultiplier;
      }
      return accumulatedBufferValue;
    };
  processInputDataForPromiseValidation.prototype.readUintBE =
    processInputDataForPromiseValidation.prototype.readUIntBE = function (
      allocateBufferWithLeadingZero,
      allocateBufferWithValidation,
      validateBufferAllocationForDebugLogger,
    ) {
      allocateBufferWithLeadingZero = allocateBufferWithLeadingZero >>> 0;
      allocateBufferWithValidation = allocateBufferWithValidation >>> 0;
      if (!validateBufferAllocationForDebugLogger) {
        checkAndValidateBufferIndex(
          allocateBufferWithLeadingZero,
          allocateBufferWithValidation,
          this.length,
        );
      }
      let finalAllocatedBufferValue =
        this[allocateBufferWithLeadingZero + --allocateBufferWithValidation];
      let allocationMultiplier = 1;
      while (
        allocateBufferWithValidation > 0 &&
        (allocationMultiplier *= 256)
      ) {
        finalAllocatedBufferValue +=
          this[allocateBufferWithLeadingZero + --allocateBufferWithValidation] *
          allocationMultiplier;
      }
      return finalAllocatedBufferValue;
    };
  processInputDataForPromiseValidation.prototype.readUint8 =
    processInputDataForPromiseValidation.prototype.readUInt8 = function (
      validateAndFillBufferArray,
      validateAndExtendBufferArraySize,
    ) {
      validateAndFillBufferArray = validateAndFillBufferArray >>> 0;
      if (!validateAndExtendBufferArraySize) {
        checkAndValidateBufferIndex(validateAndFillBufferArray, 1, this.length);
      }
      return this[validateAndFillBufferArray];
    };
  processInputDataForPromiseValidation.prototype.readUint16LE =
    processInputDataForPromiseValidation.prototype.readUInt16LE = function (
      validateAndLogPromiseWithOffset,
      setupDebugLogger,
    ) {
      validateAndLogPromiseWithOffset = validateAndLogPromiseWithOffset >>> 0;
      if (!setupDebugLogger) {
        checkAndValidateBufferIndex(
          validateAndLogPromiseWithOffset,
          2,
          this.length,
        );
      }
      return (
        this[validateAndLogPromiseWithOffset] |
        (this[validateAndLogPromiseWithOffset + 1] << 8)
      );
    };
  processInputDataForPromiseValidation.prototype.readUint16BE =
    processInputDataForPromiseValidation.prototype.readUInt16BE = function (
      validateAndProcessBuffer,
      validateAndTransformBufferEncoding,
    ) {
      validateAndProcessBuffer = validateAndProcessBuffer >>> 0;
      if (!validateAndTransformBufferEncoding) {
        checkAndValidateBufferIndex(validateAndProcessBuffer, 2, this.length);
      }
      return (
        (this[validateAndProcessBuffer] << 8) |
        this[validateAndProcessBuffer + 1]
      );
    };
  processInputDataForPromiseValidation.prototype.readUint32LE =
    processInputDataForPromiseValidation.prototype.readUInt32LE = function (
      validateAndLogBufferData,
      _allocateDebugBuffer,
    ) {
      validateAndLogBufferData = validateAndLogBufferData >>> 0;
      if (!_allocateDebugBuffer) {
        checkAndValidateBufferIndex(validateAndLogBufferData, 4, this.length);
      }
      return (
        (this[validateAndLogBufferData] |
          (this[validateAndLogBufferData + 1] << 8) |
          (this[validateAndLogBufferData + 2] << 16)) +
        this[validateAndLogBufferData + 3] * 16777216
      );
    };
  processInputDataForPromiseValidation.prototype.readUint32BE =
    processInputDataForPromiseValidation.prototype.readUInt32BE = function (
      validateAndPrepareBufferOffsets,
      validateAndExpandEncodedData,
    ) {
      validateAndPrepareBufferOffsets = validateAndPrepareBufferOffsets >>> 0;
      if (!validateAndExpandEncodedData) {
        checkAndValidateBufferIndex(
          validateAndPrepareBufferOffsets,
          4,
          this.length,
        );
      }
      return (
        this[validateAndPrepareBufferOffsets] * 16777216 +
        ((this[validateAndPrepareBufferOffsets + 1] << 16) |
          (this[validateAndPrepareBufferOffsets + 2] << 8) |
          this[validateAndPrepareBufferOffsets + 3])
      );
    };
  processInputDataForPromiseValidation.prototype.readBigUInt64LE =
    retrieveIntrinsicValueWithFallback(
      function (validateAndLogPromiseFunction) {
        validateAndLogPromiseFunction = validateAndLogPromiseFunction >>> 0;
        validateAndThrowIfNotNumber(validateAndLogPromiseFunction, "offset");
        let currentBufferValue = this[validateAndLogPromiseFunction];
        let bufferOffsetValue = this[validateAndLogPromiseFunction + 7];
        if (
          currentBufferValue === undefined ||
          bufferOffsetValue === undefined
        ) {
          checkBufferOffsetAndBounds(
            validateAndLogPromiseFunction,
            this.length - 8,
          );
        }
        let combinedBufferValue =
          currentBufferValue +
          this[++validateAndLogPromiseFunction] * 256 +
          this[++validateAndLogPromiseFunction] * 65536 +
          this[++validateAndLogPromiseFunction] * 16777216;
        let combinedValueFromBuffer =
          this[++validateAndLogPromiseFunction] +
          this[++validateAndLogPromiseFunction] * 256 +
          this[++validateAndLogPromiseFunction] * 65536 +
          bufferOffsetValue * 16777216;
        return (
          BigInt(combinedBufferValue) +
          (BigInt(combinedValueFromBuffer) << BigInt(32))
        );
      },
    );
  processInputDataForPromiseValidation.prototype.readBigUInt64BE =
    retrieveIntrinsicValueWithFallback(
      function (validateBufferSizeAndLogError) {
        validateBufferSizeAndLogError = validateBufferSizeAndLogError >>> 0;
        validateAndThrowIfNotNumber(validateBufferSizeAndLogError, "offset");
        let getBufferValueAtOffset = this[validateBufferSizeAndLogError];
        let bufferValueAtOffsetPlusSeven =
          this[validateBufferSizeAndLogError + 7];
        if (
          getBufferValueAtOffset === undefined ||
          bufferValueAtOffsetPlusSeven === undefined
        ) {
          checkBufferOffsetAndBounds(
            validateBufferSizeAndLogError,
            this.length - 8,
          );
        }
        let combinedBufferValue =
          getBufferValueAtOffset * 16777216 +
          this[++validateBufferSizeAndLogError] * 65536 +
          this[++validateBufferSizeAndLogError] * 256 +
          this[++validateBufferSizeAndLogError];
        let nextBufferValue =
          this[++validateBufferSizeAndLogError] * 16777216 +
          this[++validateBufferSizeAndLogError] * 65536 +
          this[++validateBufferSizeAndLogError] * 256 +
          bufferValueAtOffsetPlusSeven;
        return (
          (BigInt(combinedBufferValue) << BigInt(32)) + BigInt(nextBufferValue)
        );
      },
    );
  processInputDataForPromiseValidation.prototype.readIntLE = function (
    extractByteArrayFromBuffer,
    createUint8ArrayFromBuffer,
    generateTypedArrayFromBuffer,
  ) {
    extractByteArrayFromBuffer = extractByteArrayFromBuffer >>> 0;
    createUint8ArrayFromBuffer = createUint8ArrayFromBuffer >>> 0;
    if (!generateTypedArrayFromBuffer) {
      checkAndValidateBufferIndex(
        extractByteArrayFromBuffer,
        createUint8ArrayFromBuffer,
        this.length,
      );
    }
    let decodedBufferValue = this[extractByteArrayFromBuffer];
    let byteMultiplier = 1;
    let _currentByteIndex = 0;
    while (
      ++_currentByteIndex < createUint8ArrayFromBuffer &&
      (byteMultiplier *= 256)
    ) {
      decodedBufferValue +=
        this[extractByteArrayFromBuffer + _currentByteIndex] * byteMultiplier;
    }
    byteMultiplier *= 128;
    if (decodedBufferValue >= byteMultiplier) {
      decodedBufferValue -= Math.pow(2, createUint8ArrayFromBuffer * 8);
    }
    return decodedBufferValue;
  };
  processInputDataForPromiseValidation.prototype.readIntBE = function (
    extractInt16FromLoggingBuffer,
    generateBufferFromLogData,
    initializeLoggingProcessData,
  ) {
    extractInt16FromLoggingBuffer = extractInt16FromLoggingBuffer >>> 0;
    generateBufferFromLogData = generateBufferFromLogData >>> 0;
    if (!initializeLoggingProcessData) {
      checkAndValidateBufferIndex(
        extractInt16FromLoggingBuffer,
        generateBufferFromLogData,
        this.length,
      );
    }
    let bytesLeftToDecode = generateBufferFromLogData;
    let encodingMultiplier = 1;
    let decodedLogValue =
      this[extractInt16FromLoggingBuffer + --bytesLeftToDecode];
    while (bytesLeftToDecode > 0 && (encodingMultiplier *= 256)) {
      decodedLogValue +=
        this[extractInt16FromLoggingBuffer + --bytesLeftToDecode] *
        encodingMultiplier;
    }
    encodingMultiplier *= 128;
    if (decodedLogValue >= encodingMultiplier) {
      decodedLogValue -= Math.pow(2, generateBufferFromLogData * 8);
    }
    return decodedLogValue;
  };
  processInputDataForPromiseValidation.prototype.readInt8 = function (
    debugLogBufferHandler,
    validateAndReadLoggingData,
  ) {
    debugLogBufferHandler = debugLogBufferHandler >>> 0;
    if (!validateAndReadLoggingData) {
      checkAndValidateBufferIndex(debugLogBufferHandler, 1, this.length);
    }
    if (this[debugLogBufferHandler] & 128) {
      return (255 - this[debugLogBufferHandler] + 1) * -1;
    } else {
      return this[debugLogBufferHandler];
    }
  };
  processInputDataForPromiseValidation.prototype.readInt16LE = function (
    processLoggingData,
    validateAndReadBigInt64,
  ) {
    processLoggingData = processLoggingData >>> 0;
    if (!validateAndReadBigInt64) {
      checkAndValidateBufferIndex(processLoggingData, 2, this.length);
    }
    let getCombinedLoggingValue =
      this[processLoggingData] | (this[processLoggingData + 1] << 8);
    if (getCombinedLoggingValue & 32768) {
      return getCombinedLoggingValue | 4294901760;
    } else {
      return getCombinedLoggingValue;
    }
  };
  processInputDataForPromiseValidation.prototype.readInt16BE = function (
    combineBufferValuesAndReturnBigInt,
    validateDebugLogSizeAndBounds,
  ) {
    combineBufferValuesAndReturnBigInt =
      combineBufferValuesAndReturnBigInt >>> 0;
    if (!validateDebugLogSizeAndBounds) {
      checkAndValidateBufferIndex(
        combineBufferValuesAndReturnBigInt,
        2,
        this.length,
      );
    }
    let getCombinedLogEntry =
      this[combineBufferValuesAndReturnBigInt + 1] |
      (this[combineBufferValuesAndReturnBigInt] << 8);
    if (getCombinedLogEntry & 32768) {
      return getCombinedLogEntry | 4294901760;
    } else {
      return getCombinedLogEntry;
    }
  };
  processInputDataForPromiseValidation.prototype.readInt32LE = function (
    logDebugForInstance,
    _logDebugInfoForInstance,
  ) {
    logDebugForInstance = logDebugForInstance >>> 0;
    if (!_logDebugInfoForInstance) {
      checkAndValidateBufferIndex(logDebugForInstance, 4, this.length);
    }
    return (
      this[logDebugForInstance] |
      (this[logDebugForInstance + 1] << 8) |
      (this[logDebugForInstance + 2] << 16) |
      (this[logDebugForInstance + 3] << 24)
    );
  };
  processInputDataForPromiseValidation.prototype.readInt32BE = function (
    validateAndCompareBuffers,
    compareAndCombineBufferValues,
  ) {
    validateAndCompareBuffers = validateAndCompareBuffers >>> 0;
    if (!compareAndCombineBufferValues) {
      checkAndValidateBufferIndex(validateAndCompareBuffers, 4, this.length);
    }
    return (
      (this[validateAndCompareBuffers] << 24) |
      (this[validateAndCompareBuffers + 1] << 16) |
      (this[validateAndCompareBuffers + 2] << 8) |
      this[validateAndCompareBuffers + 3]
    );
  };
  processInputDataForPromiseValidation.prototype.readBigInt64LE =
    retrieveIntrinsicValueWithFallback(function (compareBufferValues) {
      compareBufferValues = compareBufferValues >>> 0;
      validateAndThrowIfNotNumber(compareBufferValues, "offset");
      let currentBufferValue = this[compareBufferValues];
      let __nextBufferValue = this[compareBufferValues + 7];
      if (currentBufferValue === undefined || __nextBufferValue === undefined) {
        checkBufferOffsetAndBounds(compareBufferValues, this.length - 8);
      }
      let computedBufferValue =
        this[compareBufferValues + 4] +
        this[compareBufferValues + 5] * 256 +
        this[compareBufferValues + 6] * 65536 +
        (__nextBufferValue << 24);
      return (
        (BigInt(computedBufferValue) << BigInt(32)) +
        BigInt(
          currentBufferValue +
            this[++compareBufferValues] * 256 +
            this[++compareBufferValues] * 65536 +
            this[++compareBufferValues] * 16777216,
        )
      );
    });
  processInputDataForPromiseValidation.prototype.readBigInt64BE =
    retrieveIntrinsicValueWithFallback(
      function (validateAndCompareBufferOrder) {
        validateAndCompareBufferOrder = validateAndCompareBufferOrder >>> 0;
        validateAndThrowIfNotNumber(validateAndCompareBufferOrder, "offset");
        let __currentBufferValue = this[validateAndCompareBufferOrder];
        let nextBufferValue = this[validateAndCompareBufferOrder + 7];
        if (
          __currentBufferValue === undefined ||
          nextBufferValue === undefined
        ) {
          checkBufferOffsetAndBounds(
            validateAndCompareBufferOrder,
            this.length - 8,
          );
        }
        let combinedBufferValue32Bit =
          (__currentBufferValue << 24) +
          this[++validateAndCompareBufferOrder] * 65536 +
          this[++validateAndCompareBufferOrder] * 256 +
          this[++validateAndCompareBufferOrder];
        return (
          (BigInt(combinedBufferValue32Bit) << BigInt(32)) +
          BigInt(
            this[++validateAndCompareBufferOrder] * 16777216 +
              this[++validateAndCompareBufferOrder] * 65536 +
              this[++validateAndCompareBufferOrder] * 256 +
              nextBufferValue,
          )
        );
      },
    );
  processInputDataForPromiseValidation.prototype.readFloatLE = function (
    _validateAndProcessBufferArguments,
    validateAndProcessBufferParameters,
  ) {
    _validateAndProcessBufferArguments =
      _validateAndProcessBufferArguments >>> 0;
    if (!validateAndProcessBufferParameters) {
      checkAndValidateBufferIndex(
        _validateAndProcessBufferArguments,
        4,
        this.length,
      );
    }
    return extractIntrinsicPropertyDescriptor.read(
      this,
      _validateAndProcessBufferArguments,
      true,
      23,
      4,
    );
  };
  processInputDataForPromiseValidation.prototype.readFloatBE = function (
    mergeBuffers,
    validateAndMergeBufferLists,
  ) {
    mergeBuffers = mergeBuffers >>> 0;
    if (!validateAndMergeBufferLists) {
      checkAndValidateBufferIndex(mergeBuffers, 4, this.length);
    }
    return extractIntrinsicPropertyDescriptor.read(
      this,
      mergeBuffers,
      false,
      23,
      4,
    );
  };
  processInputDataForPromiseValidation.prototype.readDoubleLE = function (
    validateAndMergeArrayBuffers,
    validateAndConcatenateBuffersWithBounds,
  ) {
    validateAndMergeArrayBuffers = validateAndMergeArrayBuffers >>> 0;
    if (!validateAndConcatenateBuffersWithBounds) {
      checkAndValidateBufferIndex(validateAndMergeArrayBuffers, 8, this.length);
    }
    return extractIntrinsicPropertyDescriptor.read(
      this,
      validateAndMergeArrayBuffers,
      true,
      52,
      8,
    );
  };
  processInputDataForPromiseValidation.prototype.readDoubleBE = function (
    validateAndMergeBufferData,
    combineArrayBuffers,
  ) {
    validateAndMergeBufferData = validateAndMergeBufferData >>> 0;
    if (!combineArrayBuffers) {
      checkAndValidateBufferIndex(validateAndMergeBufferData, 8, this.length);
    }
    return extractIntrinsicPropertyDescriptor.read(
      this,
      validateAndMergeBufferData,
      false,
      52,
      8,
    );
  };
  function checkAndMergeBufferArguments(
    _validateAndMergeBufferData,
    validateAndMergeArrayBuffers,
    validateAndMergeBufferValues,
    validateAndMergeBufferArrays,
    validateAndProcessBufferInput,
    validateAndConcatBufferInput,
  ) {
    if (
      !processInputDataForPromiseValidation.isBuffer(
        _validateAndMergeBufferData,
      )
    ) {
      throw new TypeError('"buffer" argument must be a Buffer instance');
    }
    if (
      validateAndMergeArrayBuffers > validateAndProcessBufferInput ||
      validateAndMergeArrayBuffers < validateAndConcatBufferInput
    ) {
      throw new RangeError('"value" argument is out of bounds');
    }
    if (
      validateAndMergeBufferValues + validateAndMergeBufferArrays >
      _validateAndMergeBufferData.length
    ) {
      throw new RangeError("Index out of range");
    }
  }
  processInputDataForPromiseValidation.prototype.writeUintLE =
    processInputDataForPromiseValidation.prototype.writeUIntLE = function (
      exportedRandomValueByteCount,
      copyAndValidateBufferContent,
      __bufferSize,
      bufferIndex,
    ) {
      exportedRandomValueByteCount = +exportedRandomValueByteCount;
      copyAndValidateBufferContent = copyAndValidateBufferContent >>> 0;
      __bufferSize = __bufferSize >>> 0;
      if (!bufferIndex) {
        let bufferCapacityLimit = Math.pow(2, __bufferSize * 8) - 1;
        checkAndMergeBufferArguments(
          this,
          exportedRandomValueByteCount,
          copyAndValidateBufferContent,
          __bufferSize,
          bufferCapacityLimit,
          0,
        );
      }
      let scalingFactorForBufferData = 1;
      let bufferOffset = 0;
      for (
        this[copyAndValidateBufferContent] = exportedRandomValueByteCount & 255;
        ++bufferOffset < __bufferSize && (scalingFactorForBufferData *= 256);

      ) {
        this[copyAndValidateBufferContent + bufferOffset] =
          (exportedRandomValueByteCount / scalingFactorForBufferData) & 255;
      }
      return copyAndValidateBufferContent + __bufferSize;
    };
  processInputDataForPromiseValidation.prototype.writeUintBE =
    processInputDataForPromiseValidation.prototype.writeUIntBE = function (
      copyArraysAndAdjustOffset,
      concatenateBuffers,
      isDataBufferOrArrayBuffer,
      validateBufferLength,
    ) {
      copyArraysAndAdjustOffset = +copyArraysAndAdjustOffset;
      concatenateBuffers = concatenateBuffers >>> 0;
      isDataBufferOrArrayBuffer = isDataBufferOrArrayBuffer >>> 0;
      if (!validateBufferLength) {
        let maxBufferSize = Math.pow(2, isDataBufferOrArrayBuffer * 8) - 1;
        checkAndMergeBufferArguments(
          this,
          copyArraysAndAdjustOffset,
          concatenateBuffers,
          isDataBufferOrArrayBuffer,
          maxBufferSize,
          0,
        );
      }
      let initialBufferIndex = isDataBufferOrArrayBuffer - 1;
      let bufferScalingFactor = 1;
      for (
        this[concatenateBuffers + initialBufferIndex] =
          copyArraysAndAdjustOffset & 255;
        --initialBufferIndex >= 0 && (bufferScalingFactor *= 256);

      ) {
        this[concatenateBuffers + initialBufferIndex] =
          (copyArraysAndAdjustOffset / bufferScalingFactor) & 255;
      }
      return concatenateBuffers + isDataBufferOrArrayBuffer;
    };
  processInputDataForPromiseValidation.prototype.writeUint8 =
    processInputDataForPromiseValidation.prototype.writeUInt8 = function (
      byteLengthForRandomValue,
      byteLengthOfRandomValue,
      calculateEncodedValueByteLength,
    ) {
      byteLengthForRandomValue = +byteLengthForRandomValue;
      byteLengthOfRandomValue = byteLengthOfRandomValue >>> 0;
      if (!calculateEncodedValueByteLength) {
        checkAndMergeBufferArguments(
          this,
          byteLengthForRandomValue,
          byteLengthOfRandomValue,
          1,
          255,
          0,
        );
      }
      this[byteLengthOfRandomValue] = byteLengthForRandomValue & 255;
      return byteLengthOfRandomValue + 1;
    };
  processInputDataForPromiseValidation.prototype.writeUint16LE =
    processInputDataForPromiseValidation.prototype.writeUInt16LE = function (
      validateRandomValueType,
      calculateEncodedValueLength,
      getRandomValueLengthInBytes,
    ) {
      validateRandomValueType = +validateRandomValueType;
      calculateEncodedValueLength = calculateEncodedValueLength >>> 0;
      if (!getRandomValueLengthInBytes) {
        checkAndMergeBufferArguments(
          this,
          validateRandomValueType,
          calculateEncodedValueLength,
          2,
          65535,
          0,
        );
      }
      this[calculateEncodedValueLength] = validateRandomValueType & 255;
      this[calculateEncodedValueLength + 1] = validateRandomValueType >>> 8;
      return calculateEncodedValueLength + 2;
    };
  processInputDataForPromiseValidation.prototype.writeUint16BE =
    processInputDataForPromiseValidation.prototype.writeUInt16BE = function (
      calculateEncodedByteLength,
      calculateByteLengthForEncoding,
      returnZeroWhenConditionsAreNotMet,
    ) {
      calculateEncodedByteLength = +calculateEncodedByteLength;
      calculateByteLengthForEncoding = calculateByteLengthForEncoding >>> 0;
      if (!returnZeroWhenConditionsAreNotMet) {
        checkAndMergeBufferArguments(
          this,
          calculateEncodedByteLength,
          calculateByteLengthForEncoding,
          2,
          65535,
          0,
        );
      }
      this[calculateByteLengthForEncoding] = calculateEncodedByteLength >>> 8;
      this[calculateByteLengthForEncoding + 1] =
        calculateEncodedByteLength & 255;
      return calculateByteLengthForEncoding + 2;
    };
  processInputDataForPromiseValidation.prototype.writeUint32LE =
    processInputDataForPromiseValidation.prototype.writeUInt32LE = function (
      extractRandomValueParts,
      _calculateEncodedByteLength,
      calculateRandomValueLength,
    ) {
      extractRandomValueParts = +extractRandomValueParts;
      _calculateEncodedByteLength = _calculateEncodedByteLength >>> 0;
      if (!calculateRandomValueLength) {
        checkAndMergeBufferArguments(
          this,
          extractRandomValueParts,
          _calculateEncodedByteLength,
          4,
          4294967295,
          0,
        );
      }
      this[_calculateEncodedByteLength + 3] = extractRandomValueParts >>> 24;
      this[_calculateEncodedByteLength + 2] = extractRandomValueParts >>> 16;
      this[_calculateEncodedByteLength + 1] = extractRandomValueParts >>> 8;
      this[_calculateEncodedByteLength] = extractRandomValueParts & 255;
      return _calculateEncodedByteLength + 4;
    };
  processInputDataForPromiseValidation.prototype.writeUint32BE =
    processInputDataForPromiseValidation.prototype.writeUInt32BE = function (
      addDecodedValuesToLengthCheckStart,
      appendDecodedValuesToLengthCheckArray,
      extractValueWithBitManipulation,
    ) {
      addDecodedValuesToLengthCheckStart = +addDecodedValuesToLengthCheckStart;
      appendDecodedValuesToLengthCheckArray =
        appendDecodedValuesToLengthCheckArray >>> 0;
      if (!extractValueWithBitManipulation) {
        checkAndMergeBufferArguments(
          this,
          addDecodedValuesToLengthCheckStart,
          appendDecodedValuesToLengthCheckArray,
          4,
          4294967295,
          0,
        );
      }
      this[appendDecodedValuesToLengthCheckArray] =
        addDecodedValuesToLengthCheckStart >>> 24;
      this[appendDecodedValuesToLengthCheckArray + 1] =
        addDecodedValuesToLengthCheckStart >>> 16;
      this[appendDecodedValuesToLengthCheckArray + 2] =
        addDecodedValuesToLengthCheckStart >>> 8;
      this[appendDecodedValuesToLengthCheckArray + 3] =
        addDecodedValuesToLengthCheckStart & 255;
      return appendDecodedValuesToLengthCheckArray + 4;
    };
  function extractAndStoreDecodedBytes(
    decodedValueBuffer,
    decodeAndStoreHighOrderBytes,
    currentBufferIndex,
    encodeDataFromIdentifier,
    processAndEncodeCharacterBuffer,
  ) {
    checkAndDescribePropertyValueRange(
      decodeAndStoreHighOrderBytes,
      encodeDataFromIdentifier,
      processAndEncodeCharacterBuffer,
      decodedValueBuffer,
      currentBufferIndex,
      7,
    );
    let decodedByteValue = Number(
      decodeAndStoreHighOrderBytes & BigInt(4294967295),
    );
    decodedValueBuffer[currentBufferIndex++] = decodedByteValue;
    decodedByteValue = decodedByteValue >> 8;
    decodedValueBuffer[currentBufferIndex++] = decodedByteValue;
    decodedByteValue = decodedByteValue >> 8;
    decodedValueBuffer[currentBufferIndex++] = decodedByteValue;
    decodedByteValue = decodedByteValue >> 8;
    decodedValueBuffer[currentBufferIndex++] = decodedByteValue;
    let highOrderDecodedByteValue = Number(
      (decodeAndStoreHighOrderBytes >> BigInt(32)) & BigInt(4294967295),
    );
    decodedValueBuffer[currentBufferIndex++] = highOrderDecodedByteValue;
    highOrderDecodedByteValue = highOrderDecodedByteValue >> 8;
    decodedValueBuffer[currentBufferIndex++] = highOrderDecodedByteValue;
    highOrderDecodedByteValue = highOrderDecodedByteValue >> 8;
    decodedValueBuffer[currentBufferIndex++] = highOrderDecodedByteValue;
    highOrderDecodedByteValue = highOrderDecodedByteValue >> 8;
    decodedValueBuffer[currentBufferIndex++] = highOrderDecodedByteValue;
    return currentBufferIndex;
  }
  function encodeCharacterDataBuffer(
    storeAndEncodeCharacterData,
    processAndStoreEncodedCharacterData,
    mapAndStoreCharacterData,
    storeAndTransformCharacterData,
    processAndStoreCharacterEncodingData,
  ) {
    checkAndDescribePropertyValueRange(
      processAndStoreEncodedCharacterData,
      storeAndTransformCharacterData,
      processAndStoreCharacterEncodingData,
      storeAndEncodeCharacterData,
      mapAndStoreCharacterData,
      7,
    );
    let encodedCharacterDataLower32Bits = Number(
      processAndStoreEncodedCharacterData & BigInt(4294967295),
    );
    storeAndEncodeCharacterData[mapAndStoreCharacterData + 7] =
      encodedCharacterDataLower32Bits;
    encodedCharacterDataLower32Bits = encodedCharacterDataLower32Bits >> 8;
    storeAndEncodeCharacterData[mapAndStoreCharacterData + 6] =
      encodedCharacterDataLower32Bits;
    encodedCharacterDataLower32Bits = encodedCharacterDataLower32Bits >> 8;
    storeAndEncodeCharacterData[mapAndStoreCharacterData + 5] =
      encodedCharacterDataLower32Bits;
    encodedCharacterDataLower32Bits = encodedCharacterDataLower32Bits >> 8;
    storeAndEncodeCharacterData[mapAndStoreCharacterData + 4] =
      encodedCharacterDataLower32Bits;
    let encodeCharacterDataLower32Bits = Number(
      (processAndStoreEncodedCharacterData >> BigInt(32)) & BigInt(4294967295),
    );
    storeAndEncodeCharacterData[mapAndStoreCharacterData + 3] =
      encodeCharacterDataLower32Bits;
    encodeCharacterDataLower32Bits = encodeCharacterDataLower32Bits >> 8;
    storeAndEncodeCharacterData[mapAndStoreCharacterData + 2] =
      encodeCharacterDataLower32Bits;
    encodeCharacterDataLower32Bits = encodeCharacterDataLower32Bits >> 8;
    storeAndEncodeCharacterData[mapAndStoreCharacterData + 1] =
      encodeCharacterDataLower32Bits;
    encodeCharacterDataLower32Bits = encodeCharacterDataLower32Bits >> 8;
    storeAndEncodeCharacterData[mapAndStoreCharacterData] =
      encodeCharacterDataLower32Bits;
    return mapAndStoreCharacterData + 8;
  }
  processInputDataForPromiseValidation.prototype.writeBigUInt64LE =
    retrieveIntrinsicValueWithFallback(function (
      convertBufferEndianess,
      initialCounterValue = 0,
    ) {
      return extractAndStoreDecodedBytes(
        this,
        convertBufferEndianess,
        initialCounterValue,
        BigInt(0),
        BigInt("0xffffffffffffffff"),
      );
    });
  processInputDataForPromiseValidation.prototype.writeBigUInt64BE =
    retrieveIntrinsicValueWithFallback(function (
      getSwappedBufferEndianness,
      _defaultCounterValue = 0,
    ) {
      return encodeCharacterDataBuffer(
        this,
        getSwappedBufferEndianness,
        _defaultCounterValue,
        BigInt(0),
        BigInt("0xffffffffffffffff"),
      );
    });
  processInputDataForPromiseValidation.prototype.writeIntLE = function (
    _convertBufferEndianess,
    convertBytesToBufferEndianess,
    writeIntegerToBufferWithEndianSwap,
    writeIntegerToBufferWithEndianAdjustment,
  ) {
    _convertBufferEndianess = +_convertBufferEndianess;
    convertBytesToBufferEndianess = convertBytesToBufferEndianess >>> 0;
    if (!writeIntegerToBufferWithEndianAdjustment) {
      let maxWritableBufferSize = Math.pow(
        2,
        writeIntegerToBufferWithEndianSwap * 8 - 1,
      );
      checkAndMergeBufferArguments(
        this,
        _convertBufferEndianess,
        convertBytesToBufferEndianess,
        writeIntegerToBufferWithEndianSwap,
        maxWritableBufferSize - 1,
        -maxWritableBufferSize,
      );
    }
    let currentBufferByteIndex = 0;
    let bytePositionMultiplier = 1;
    let isValueNegative = 0;
    for (
      this[convertBytesToBufferEndianess] = _convertBufferEndianess & 255;
      ++currentBufferByteIndex < writeIntegerToBufferWithEndianSwap &&
      (bytePositionMultiplier *= 256);

    ) {
      if (
        _convertBufferEndianess < 0 &&
        isValueNegative === 0 &&
        this[convertBytesToBufferEndianess + currentBufferByteIndex - 1] !== 0
      ) {
        isValueNegative = 1;
      }
      this[convertBytesToBufferEndianess + currentBufferByteIndex] =
        (((_convertBufferEndianess / bytePositionMultiplier) >> 0) -
          isValueNegative) &
        255;
    }
    return convertBytesToBufferEndianess + writeIntegerToBufferWithEndianSwap;
  };
  processInputDataForPromiseValidation.prototype.writeIntBE = function (
    convertEndiannessOfBytes,
    setBufferValueBasedOnEndianness,
    convertByteOrderAndAdjustBasedOnEndianness,
    validateAndWriteBufferValue,
  ) {
    convertEndiannessOfBytes = +convertEndiannessOfBytes;
    setBufferValueBasedOnEndianness = setBufferValueBasedOnEndianness >>> 0;
    if (!validateAndWriteBufferValue) {
      let maxBitValueForBuffer = Math.pow(
        2,
        convertByteOrderAndAdjustBasedOnEndianness * 8 - 1,
      );
      checkAndMergeBufferArguments(
        this,
        convertEndiannessOfBytes,
        setBufferValueBasedOnEndianness,
        convertByteOrderAndAdjustBasedOnEndianness,
        maxBitValueForBuffer - 1,
        -maxBitValueForBuffer,
      );
    }
    let lastByteIndex = convertByteOrderAndAdjustBasedOnEndianness - 1;
    let byteValueMultiplier = 1;
    let isNegativeByteAdjustmentNeeded = 0;
    for (
      this[setBufferValueBasedOnEndianness + lastByteIndex] =
        convertEndiannessOfBytes & 255;
      --lastByteIndex >= 0 && (byteValueMultiplier *= 256);

    ) {
      if (
        convertEndiannessOfBytes < 0 &&
        isNegativeByteAdjustmentNeeded === 0 &&
        this[setBufferValueBasedOnEndianness + lastByteIndex + 1] !== 0
      ) {
        isNegativeByteAdjustmentNeeded = 1;
      }
      this[setBufferValueBasedOnEndianness + lastByteIndex] =
        (((convertEndiannessOfBytes / byteValueMultiplier) >> 0) -
          isNegativeByteAdjustmentNeeded) &
        255;
    }
    return (
      setBufferValueBasedOnEndianness +
      convertByteOrderAndAdjustBasedOnEndianness
    );
  };
  processInputDataForPromiseValidation.prototype.writeInt8 = function (
    extractAndStoreBufferData,
    storeDataInBuffer,
    storeHexadecimalBufferData,
  ) {
    extractAndStoreBufferData = +extractAndStoreBufferData;
    storeDataInBuffer = storeDataInBuffer >>> 0;
    if (!storeHexadecimalBufferData) {
      checkAndMergeBufferArguments(
        this,
        extractAndStoreBufferData,
        storeDataInBuffer,
        1,
        127,
        -128,
      );
    }
    if (extractAndStoreBufferData < 0) {
      extractAndStoreBufferData = 255 + extractAndStoreBufferData + 1;
    }
    this[storeDataInBuffer] = extractAndStoreBufferData & 255;
    return storeDataInBuffer + 1;
  };
  processInputDataForPromiseValidation.prototype.writeInt16LE = function (
    writeBufferToByteArray,
    _writeBufferToByteArray,
    writeBufferToInt16BE,
  ) {
    writeBufferToByteArray = +writeBufferToByteArray;
    _writeBufferToByteArray = _writeBufferToByteArray >>> 0;
    if (!writeBufferToInt16BE) {
      checkAndMergeBufferArguments(
        this,
        writeBufferToByteArray,
        _writeBufferToByteArray,
        2,
        32767,
        -32768,
      );
    }
    this[_writeBufferToByteArray] = writeBufferToByteArray & 255;
    this[_writeBufferToByteArray + 1] = writeBufferToByteArray >>> 8;
    return _writeBufferToByteArray + 2;
  };
  processInputDataForPromiseValidation.prototype.writeInt16BE = function (
    compareAndStoreBuffer,
    writeBufferComparison,
    writeBufferToArray,
  ) {
    compareAndStoreBuffer = +compareAndStoreBuffer;
    writeBufferComparison = writeBufferComparison >>> 0;
    if (!writeBufferToArray) {
      checkAndMergeBufferArguments(
        this,
        compareAndStoreBuffer,
        writeBufferComparison,
        2,
        32767,
        -32768,
      );
    }
    this[writeBufferComparison] = compareAndStoreBuffer >>> 8;
    this[writeBufferComparison + 1] = compareAndStoreBuffer & 255;
    return writeBufferComparison + 2;
  };
  processInputDataForPromiseValidation.prototype.writeInt32LE = function (
    _extractAndStoreBufferData,
    MAX_DATA_BUFFER_SIZE,
    storeBufferData,
  ) {
    _extractAndStoreBufferData = +_extractAndStoreBufferData;
    MAX_DATA_BUFFER_SIZE = MAX_DATA_BUFFER_SIZE >>> 0;
    if (!storeBufferData) {
      checkAndMergeBufferArguments(
        this,
        _extractAndStoreBufferData,
        MAX_DATA_BUFFER_SIZE,
        4,
        2147483647,
        -2147483648,
      );
    }
    this[MAX_DATA_BUFFER_SIZE] = _extractAndStoreBufferData & 255;
    this[MAX_DATA_BUFFER_SIZE + 1] = _extractAndStoreBufferData >>> 8;
    this[MAX_DATA_BUFFER_SIZE + 2] = _extractAndStoreBufferData >>> 16;
    this[MAX_DATA_BUFFER_SIZE + 3] = _extractAndStoreBufferData >>> 24;
    return MAX_DATA_BUFFER_SIZE + 4;
  };
  processInputDataForPromiseValidation.prototype.writeInt32BE = function (
    handleDataBufferProcessing,
    processDataBufferWithEncoding,
    validateAndStoreBufferData,
  ) {
    handleDataBufferProcessing = +handleDataBufferProcessing;
    processDataBufferWithEncoding = processDataBufferWithEncoding >>> 0;
    if (!validateAndStoreBufferData) {
      checkAndMergeBufferArguments(
        this,
        handleDataBufferProcessing,
        processDataBufferWithEncoding,
        4,
        2147483647,
        -2147483648,
      );
    }
    if (handleDataBufferProcessing < 0) {
      handleDataBufferProcessing = 4294967295 + handleDataBufferProcessing + 1;
    }
    this[processDataBufferWithEncoding] = handleDataBufferProcessing >>> 24;
    this[processDataBufferWithEncoding + 1] = handleDataBufferProcessing >>> 16;
    this[processDataBufferWithEncoding + 2] = handleDataBufferProcessing >>> 8;
    this[processDataBufferWithEncoding + 3] = handleDataBufferProcessing & 255;
    return processDataBufferWithEncoding + 4;
  };
  processInputDataForPromiseValidation.prototype.writeBigInt64LE =
    retrieveIntrinsicValueWithFallback(function (
      processEncodingData,
      defaultCounterValue = 0,
    ) {
      return extractAndStoreDecodedBytes(
        this,
        processEncodingData,
        defaultCounterValue,
        -BigInt("0x8000000000000000"),
        BigInt("0x7fffffffffffffff"),
      );
    });
  processInputDataForPromiseValidation.prototype.writeBigInt64BE =
    retrieveIntrinsicValueWithFallback(function (
      validateAndReturnEncodedData,
      baseCost = 0,
    ) {
      return encodeCharacterDataBuffer(
        this,
        validateAndReturnEncodedData,
        baseCost,
        -BigInt("0x8000000000000000"),
        BigInt("0x7fffffffffffffff"),
      );
    });
  function checkDataIndexBounds(
    retrieveDataAtIndex,
    retrieveAndValidateIndexComparison,
    computeComparisonIndex,
    validateAndProcessEncodedData,
    compareCharCodeWithData,
    charCodeComparisonIndex,
  ) {
    if (
      computeComparisonIndex + validateAndProcessEncodedData >
      retrieveDataAtIndex.length
    ) {
      throw new RangeError("Index out of range");
    }
    if (computeComparisonIndex < 0) {
      throw new RangeError("Index out of range");
    }
  }
  function validateAndTransformDataBounds(
    validateAndModifyDataBoundaries,
    checkAndRetrieveDataIndices,
    sliceAndValidateDataIndices,
    retrieveAndValidateDataIndices,
    compareAndValidateEncodedDataIndices,
  ) {
    checkAndRetrieveDataIndices = +checkAndRetrieveDataIndices;
    sliceAndValidateDataIndices = sliceAndValidateDataIndices >>> 0;
    if (!compareAndValidateEncodedDataIndices) {
      checkDataIndexBounds(
        validateAndModifyDataBoundaries,
        checkAndRetrieveDataIndices,
        sliceAndValidateDataIndices,
        4,
        3.4028234663852886e38,
        -3.4028234663852886e38,
      );
    }
    extractIntrinsicPropertyDescriptor.write(
      validateAndModifyDataBoundaries,
      checkAndRetrieveDataIndices,
      sliceAndValidateDataIndices,
      retrieveAndValidateDataIndices,
      23,
      4,
    );
    return sliceAndValidateDataIndices + 4;
  }
  processInputDataForPromiseValidation.prototype.writeFloatLE = function (
    validateAndExtractInputData,
    validateEncodedDataRanges,
    validateAndCompareEncodedDataSegments,
  ) {
    return validateAndTransformDataBounds(
      this,
      validateAndExtractInputData,
      validateEncodedDataRanges,
      true,
      validateAndCompareEncodedDataSegments,
    );
  };
  processInputDataForPromiseValidation.prototype.writeFloatBE = function (
    compareAndValidateEncodedDataSegments,
    compareAndValidateEncodedSegments,
    validateAndCompareEncodedData,
  ) {
    return validateAndTransformDataBounds(
      this,
      compareAndValidateEncodedDataSegments,
      compareAndValidateEncodedSegments,
      false,
      validateAndCompareEncodedData,
    );
  };
  function _processAndCompareEncodedDataSegments(
    validateAndExtractEncodedDataSegments,
    _validateAndCompareEncodedDataSegments,
    validateAndProcessEncodedDataSegments,
    compareAndProcessEncodedData,
    validateAndCompareEncodedData,
  ) {
    _validateAndCompareEncodedDataSegments =
      +_validateAndCompareEncodedDataSegments;
    validateAndProcessEncodedDataSegments =
      validateAndProcessEncodedDataSegments >>> 0;
    if (!validateAndCompareEncodedData) {
      checkDataIndexBounds(
        validateAndExtractEncodedDataSegments,
        _validateAndCompareEncodedDataSegments,
        validateAndProcessEncodedDataSegments,
        8,
        1.7976931348623157e308,
        -1.7976931348623157e308,
      );
    }
    extractIntrinsicPropertyDescriptor.write(
      validateAndExtractEncodedDataSegments,
      _validateAndCompareEncodedDataSegments,
      validateAndProcessEncodedDataSegments,
      compareAndProcessEncodedData,
      52,
      8,
    );
    return validateAndProcessEncodedDataSegments + 8;
  }
  processInputDataForPromiseValidation.prototype.writeDoubleLE = function (
    validateAndCompareEncodedSegments,
    compareEncodedDataSegments,
    _compareEncodedDataSegments,
  ) {
    return _processAndCompareEncodedDataSegments(
      this,
      validateAndCompareEncodedSegments,
      compareEncodedDataSegments,
      true,
      _compareEncodedDataSegments,
    );
  };
  processInputDataForPromiseValidation.prototype.writeDoubleBE = function (
    _validateAndCompareEncodedSegments,
    processAndCompareEncodedDataSegments,
    compareEncodedDataSegmentsForEquality,
  ) {
    return _processAndCompareEncodedDataSegments(
      this,
      _validateAndCompareEncodedSegments,
      processAndCompareEncodedDataSegments,
      false,
      compareEncodedDataSegmentsForEquality,
    );
  };
  processInputDataForPromiseValidation.prototype.copy = function (
    compareEncodedDataSegmentsForCopy,
    __compareEncodedDataSegments,
    compareProcessedDataSegments,
    _compareEncodedDataSegmentsForEquality,
  ) {
    if (
      !processInputDataForPromiseValidation.isBuffer(
        compareEncodedDataSegmentsForCopy,
      )
    ) {
      throw new TypeError("argument should be a Buffer");
    }
    compareProcessedDataSegments ||= 0;
    if (
      !_compareEncodedDataSegmentsForEquality &&
      _compareEncodedDataSegmentsForEquality !== 0
    ) {
      _compareEncodedDataSegmentsForEquality = this.length;
    }
    if (
      __compareEncodedDataSegments >= compareEncodedDataSegmentsForCopy.length
    ) {
      __compareEncodedDataSegments = compareEncodedDataSegmentsForCopy.length;
    }
    __compareEncodedDataSegments ||= 0;
    if (
      _compareEncodedDataSegmentsForEquality > 0 &&
      _compareEncodedDataSegmentsForEquality < compareProcessedDataSegments
    ) {
      _compareEncodedDataSegmentsForEquality = compareProcessedDataSegments;
    }
    if (
      _compareEncodedDataSegmentsForEquality === compareProcessedDataSegments ||
      compareEncodedDataSegmentsForCopy.length === 0 ||
      this.length === 0
    ) {
      return 0;
    }
    if (__compareEncodedDataSegments < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (
      compareProcessedDataSegments < 0 ||
      compareProcessedDataSegments >= this.length
    ) {
      throw new RangeError("Index out of range");
    }
    if (_compareEncodedDataSegmentsForEquality < 0) {
      throw new RangeError("sourceEnd out of bounds");
    }
    if (_compareEncodedDataSegmentsForEquality > this.length) {
      _compareEncodedDataSegmentsForEquality = this.length;
    }
    if (
      compareEncodedDataSegmentsForCopy.length - __compareEncodedDataSegments <
      _compareEncodedDataSegmentsForEquality - compareProcessedDataSegments
    ) {
      _compareEncodedDataSegmentsForEquality =
        compareEncodedDataSegmentsForCopy.length -
        __compareEncodedDataSegments +
        compareProcessedDataSegments;
    }
    let normalizeEncodedDataSegmentIndex =
      _compareEncodedDataSegmentsForEquality - compareProcessedDataSegments;
    if (
      this === compareEncodedDataSegmentsForCopy &&
      typeof Uint8Array.prototype.copyWithin == "function"
    ) {
      this.copyWithin(
        __compareEncodedDataSegments,
        compareProcessedDataSegments,
        _compareEncodedDataSegmentsForEquality,
      );
    } else {
      Uint8Array.prototype.set.call(
        compareEncodedDataSegmentsForCopy,
        this.subarray(
          compareProcessedDataSegments,
          _compareEncodedDataSegmentsForEquality,
        ),
        __compareEncodedDataSegments,
      );
    }
    return normalizeEncodedDataSegmentIndex;
  };
  processInputDataForPromiseValidation.prototype.fill = function (
    getAdjustedSegmentIndex,
    validSegmentIndex,
    adjustEncodedDataSegmentIndex,
    getValidEncodedSegmentIndex,
  ) {
    if (typeof getAdjustedSegmentIndex == "string") {
      if (typeof validSegmentIndex == "string") {
        getValidEncodedSegmentIndex = validSegmentIndex;
        validSegmentIndex = 0;
        adjustEncodedDataSegmentIndex = this.length;
      } else if (typeof adjustEncodedDataSegmentIndex == "string") {
        getValidEncodedSegmentIndex = adjustEncodedDataSegmentIndex;
        adjustEncodedDataSegmentIndex = this.length;
      }
      if (
        getValidEncodedSegmentIndex !== undefined &&
        typeof getValidEncodedSegmentIndex != "string"
      ) {
        throw new TypeError("encoding must be a string");
      }
      if (
        typeof getValidEncodedSegmentIndex == "string" &&
        !processInputDataForPromiseValidation.isEncoding(
          getValidEncodedSegmentIndex,
        )
      ) {
        throw new TypeError("Unknown encoding: " + getValidEncodedSegmentIndex);
      }
      if (getAdjustedSegmentIndex.length === 1) {
        let adjustedSegmentCharCode = getAdjustedSegmentIndex.charCodeAt(0);
        if (
          (getValidEncodedSegmentIndex === "utf8" &&
            adjustedSegmentCharCode < 128) ||
          getValidEncodedSegmentIndex === "latin1"
        ) {
          getAdjustedSegmentIndex = adjustedSegmentCharCode;
        }
      }
    } else if (typeof getAdjustedSegmentIndex == "number") {
      getAdjustedSegmentIndex = getAdjustedSegmentIndex & 255;
    } else if (typeof getAdjustedSegmentIndex == "boolean") {
      getAdjustedSegmentIndex = Number(getAdjustedSegmentIndex);
    }
    if (
      validSegmentIndex < 0 ||
      this.length < validSegmentIndex ||
      this.length < adjustEncodedDataSegmentIndex
    ) {
      throw new RangeError("Out of range index");
    }
    if (adjustEncodedDataSegmentIndex <= validSegmentIndex) {
      return this;
    }
    validSegmentIndex = validSegmentIndex >>> 0;
    if (adjustEncodedDataSegmentIndex === undefined) {
      adjustEncodedDataSegmentIndex = this.length;
    } else {
      adjustEncodedDataSegmentIndex = adjustEncodedDataSegmentIndex >>> 0;
    }
    getAdjustedSegmentIndex ||= 0;
    let getValidEncodingIndex;
    if (typeof getAdjustedSegmentIndex == "number") {
      for (
        getValidEncodingIndex = validSegmentIndex;
        getValidEncodingIndex < adjustEncodedDataSegmentIndex;
        ++getValidEncodingIndex
      ) {
        this[getValidEncodingIndex] = getAdjustedSegmentIndex;
      }
    } else {
      let adjustedDataBuffer = processInputDataForPromiseValidation.isBuffer(
        getAdjustedSegmentIndex,
      )
        ? getAdjustedSegmentIndex
        : processInputDataForPromiseValidation.from(
            getAdjustedSegmentIndex,
            getValidEncodedSegmentIndex,
          );
      let adjustedDataBufferLength = adjustedDataBuffer.length;
      if (adjustedDataBufferLength === 0) {
        throw new TypeError(
          'The value "' +
            getAdjustedSegmentIndex +
            '" is invalid for argument "value"',
        );
      }
      for (
        getValidEncodingIndex = 0;
        getValidEncodingIndex <
        adjustEncodedDataSegmentIndex - validSegmentIndex;
        ++getValidEncodingIndex
      ) {
        this[getValidEncodingIndex + validSegmentIndex] =
          adjustedDataBuffer[getValidEncodingIndex % adjustedDataBufferLength];
      }
    }
    return this;
  };
  var __checkTypedArraySupport = {};
  function generateIntrinsicPropertyError(
    validateAndRetrieveEncodedDataSegment,
    _____________validateAndRetrieveIntrinsicProperty,
    validateAndRetrieveSegmentData,
  ) {
    __checkTypedArraySupport[validateAndRetrieveEncodedDataSegment] =
      class extends validateAndRetrieveSegmentData {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: _____________validateAndRetrieveIntrinsicProperty.apply(
              this,
              arguments,
            ),
            writable: true,
            configurable: true,
          });
          this.name =
            this.name + " [" + validateAndRetrieveEncodedDataSegment + "]";
          this.stack;
          delete this.name;
        }
        get code() {
          return validateAndRetrieveEncodedDataSegment;
        }
        set code(defineCodeProperty) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value: defineCodeProperty,
            writable: true,
          });
        }
        toString() {
          return (
            this.name +
            " [" +
            validateAndRetrieveEncodedDataSegment +
            "]: " +
            this.message
          );
        }
      };
  }
  generateIntrinsicPropertyError(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function (validateBufferBounds) {
      if (validateBufferBounds) {
        return validateBufferBounds + " is outside of buffer bounds";
      } else {
        return "Attempt to access memory outside buffer bounds";
      }
    },
    RangeError,
  );
  generateIntrinsicPropertyError(
    "ERR_INVALID_ARG_TYPE",
    function (
      validateArgumentTypeAndRetrieveValue,
      _validateArgumentTypeAndRetrieveValue,
    ) {
      return (
        'The "' +
        validateArgumentTypeAndRetrieveValue +
        '" argument must be of type number. Received type ' +
        typeof _validateArgumentTypeAndRetrieveValue
      );
    },
    TypeError,
  );
  generateIntrinsicPropertyError(
    "ERR_OUT_OF_RANGE",
    function (
      generateOutOfRangeErrorMessage,
      generateRangeErrorMessage,
      generateIntrinsicPropertyRangeError,
    ) {
      let formattedOutOfRangeErrorMessage =
        'The value of "' +
        generateOutOfRangeErrorMessage +
        '" is out of range.';
      let intrinsicPropertyFormattedValue = generateIntrinsicPropertyRangeError;
      if (
        Number.isInteger(generateIntrinsicPropertyRangeError) &&
        Math.abs(generateIntrinsicPropertyRangeError) > 4294967296
      ) {
        intrinsicPropertyFormattedValue = convertAndFormatPropertyString(
          String(generateIntrinsicPropertyRangeError),
        );
      } else if (typeof generateIntrinsicPropertyRangeError == "bigint") {
        intrinsicPropertyFormattedValue = String(
          generateIntrinsicPropertyRangeError,
        );
        if (
          generateIntrinsicPropertyRangeError > BigInt(2) ** BigInt(32) ||
          generateIntrinsicPropertyRangeError < -(BigInt(2) ** BigInt(32))
        ) {
          intrinsicPropertyFormattedValue = convertAndFormatPropertyString(
            intrinsicPropertyFormattedValue,
          );
        }
        intrinsicPropertyFormattedValue += "n";
      }
      formattedOutOfRangeErrorMessage +=
        " It must be " +
        generateRangeErrorMessage +
        ". Received " +
        intrinsicPropertyFormattedValue;
      return formattedOutOfRangeErrorMessage;
    },
    RangeError,
  );
  function convertAndFormatPropertyString(formatAndValidatePropertyString) {
    let formattedPropertyOutput = "";
    let remainingPropertyStringLength = formatAndValidatePropertyString.length;
    let isNegativePrefix = formatAndValidatePropertyString[0] === "-" ? 1 : 0;
    for (
      ;
      remainingPropertyStringLength >= isNegativePrefix + 4;
      remainingPropertyStringLength -= 3
    ) {
      formattedPropertyOutput =
        "_" +
        formatAndValidatePropertyString.slice(
          remainingPropertyStringLength - 3,
          remainingPropertyStringLength,
        ) +
        formattedPropertyOutput;
    }
    return (
      "" +
      formatAndValidatePropertyString.slice(0, remainingPropertyStringLength) +
      formattedPropertyOutput
    );
  }
  function checkAndValidatePropertyRangeWithDescriptor(
    validateAndFormatPropertyRange,
    validatePropertyRangeUsingDescriptor,
    validateAndFormatPropertyRangeDescriptors,
  ) {
    validateAndThrowIfNotNumber(validatePropertyRangeUsingDescriptor, "offset");
    if (
      validateAndFormatPropertyRange[validatePropertyRangeUsingDescriptor] ===
        undefined ||
      validateAndFormatPropertyRange[
        validatePropertyRangeUsingDescriptor +
          validateAndFormatPropertyRangeDescriptors
      ] === undefined
    ) {
      checkBufferOffsetAndBounds(
        validatePropertyRangeUsingDescriptor,
        validateAndFormatPropertyRange.length -
          (validateAndFormatPropertyRangeDescriptors + 1),
      );
    }
  }
  function checkAndDescribePropertyValueRange(
    validateAndDescribeMatchingPropertyRange,
    validateAndDescribeIntrinsicPropertyValue,
    validateAndDescribePropertyDescriptor,
    calculatePropertyDescriptorValues,
    computeAndVerifyPropertyValue,
    _validatePropertyRangeAndDescriptor,
  ) {
    if (
      validateAndDescribeMatchingPropertyRange >
        validateAndDescribePropertyDescriptor ||
      validateAndDescribeMatchingPropertyRange <
        validateAndDescribeIntrinsicPropertyValue
    ) {
      let propertyTypeSuffixBasedOnValue =
        typeof validateAndDescribeIntrinsicPropertyValue == "bigint" ? "n" : "";
      let propertyValueRangeDescription;
      if (_validatePropertyRangeAndDescriptor > 3) {
        if (
          validateAndDescribeIntrinsicPropertyValue === 0 ||
          validateAndDescribeIntrinsicPropertyValue === BigInt(0)
        ) {
          propertyValueRangeDescription =
            ">= 0" +
            propertyTypeSuffixBasedOnValue +
            " and < 2" +
            propertyTypeSuffixBasedOnValue +
            " ** " +
            (_validatePropertyRangeAndDescriptor + 1) * 8 +
            propertyTypeSuffixBasedOnValue;
        } else {
          propertyValueRangeDescription =
            ">= -(2" +
            propertyTypeSuffixBasedOnValue +
            " ** " +
            ((_validatePropertyRangeAndDescriptor + 1) * 8 - 1) +
            propertyTypeSuffixBasedOnValue +
            ") and < 2 ** " +
            ((_validatePropertyRangeAndDescriptor + 1) * 8 - 1) +
            propertyTypeSuffixBasedOnValue;
        }
      } else {
        propertyValueRangeDescription =
          ">= " +
          validateAndDescribeIntrinsicPropertyValue +
          propertyTypeSuffixBasedOnValue +
          " and <= " +
          validateAndDescribePropertyDescriptor +
          propertyTypeSuffixBasedOnValue;
      }
      throw new __checkTypedArraySupport.ERR_OUT_OF_RANGE(
        "value",
        propertyValueRangeDescription,
        validateAndDescribeMatchingPropertyRange,
      );
    }
    checkAndValidatePropertyRangeWithDescriptor(
      calculatePropertyDescriptorValues,
      computeAndVerifyPropertyValue,
      _validatePropertyRangeAndDescriptor,
    );
  }
  function validateAndThrowIfNotNumber(
    validateAndVerifyLastMatchingIndex,
    validateAndRetrievePropertyValue,
  ) {
    if (typeof validateAndVerifyLastMatchingIndex != "number") {
      throw new __checkTypedArraySupport.ERR_INVALID_ARG_TYPE(
        validateAndRetrievePropertyValue,
        "number",
        validateAndVerifyLastMatchingIndex,
      );
    }
  }
  function checkBufferOffsetAndBounds(
    validateBufferOffsetBasedOnPropertyIndex,
    getIntrinsicPropertyIndex,
    getLastMatchingIndexInArray,
  ) {
    throw Math.floor(validateBufferOffsetBasedOnPropertyIndex) !==
      validateBufferOffsetBasedOnPropertyIndex
      ? (validateAndThrowIfNotNumber(
          validateBufferOffsetBasedOnPropertyIndex,
          getLastMatchingIndexInArray,
        ),
        new __checkTypedArraySupport.ERR_OUT_OF_RANGE(
          getLastMatchingIndexInArray || "offset",
          "an integer",
          validateBufferOffsetBasedOnPropertyIndex,
        ))
      : getIntrinsicPropertyIndex < 0
        ? new __checkTypedArraySupport.ERR_BUFFER_OUT_OF_BOUNDS()
        : new __checkTypedArraySupport.ERR_OUT_OF_RANGE(
            getLastMatchingIndexInArray || "offset",
            ">= " +
              (getLastMatchingIndexInArray ? 1 : 0) +
              " and <= " +
              getIntrinsicPropertyIndex,
            validateBufferOffsetBasedOnPropertyIndex,
          );
  }
  var ___checkTypedArraySupport = /[^+/0-9A-Za-z-_]/g;
  function sanitizeAndPadBase64Input(findMatchingIntrinsicPropertyIndex) {
    findMatchingIntrinsicPropertyIndex =
      findMatchingIntrinsicPropertyIndex.split("=")[0];
    findMatchingIntrinsicPropertyIndex = findMatchingIntrinsicPropertyIndex
      .trim()
      .replace(___checkTypedArraySupport, "");
    if (findMatchingIntrinsicPropertyIndex.length < 2) {
      return "";
    }
    while (findMatchingIntrinsicPropertyIndex.length % 4 !== 0) {
      findMatchingIntrinsicPropertyIndex =
        findMatchingIntrinsicPropertyIndex + "=";
    }
    return findMatchingIntrinsicPropertyIndex;
  }
  function validateUnicodeAndFetchProperties(
    validateAndGetUnicodeProperty,
    ______________validateAndRetrieveIntrinsicProperty,
  ) {
    ______________validateAndRetrieveIntrinsicProperty =
      ______________validateAndRetrieveIntrinsicProperty || Infinity;
    let getUnicodeCharacterCode;
    let inputStringLength = validateAndGetUnicodeProperty.length;
    let isCharacterValidForEncoding = null;
    let unicodeByteOrderMarkBuffer = [];
    for (
      let currentCharacterIndex = 0;
      currentCharacterIndex < inputStringLength;
      ++currentCharacterIndex
    ) {
      getUnicodeCharacterCode = validateAndGetUnicodeProperty.charCodeAt(
        currentCharacterIndex,
      );
      if (getUnicodeCharacterCode > 55295 && getUnicodeCharacterCode < 57344) {
        if (!isCharacterValidForEncoding) {
          if (getUnicodeCharacterCode > 56319) {
            if (
              (______________validateAndRetrieveIntrinsicProperty -= 3) > -1
            ) {
              unicodeByteOrderMarkBuffer.push(239, 191, 189);
            }
            continue;
          } else if (currentCharacterIndex + 1 === inputStringLength) {
            if (
              (______________validateAndRetrieveIntrinsicProperty -= 3) > -1
            ) {
              unicodeByteOrderMarkBuffer.push(239, 191, 189);
            }
            continue;
          }
          isCharacterValidForEncoding = getUnicodeCharacterCode;
          continue;
        }
        if (getUnicodeCharacterCode < 56320) {
          if ((______________validateAndRetrieveIntrinsicProperty -= 3) > -1) {
            unicodeByteOrderMarkBuffer.push(239, 191, 189);
          }
          isCharacterValidForEncoding = getUnicodeCharacterCode;
          continue;
        }
        getUnicodeCharacterCode =
          (((isCharacterValidForEncoding - 55296) << 10) |
            (getUnicodeCharacterCode - 56320)) +
          65536;
      } else if (
        isCharacterValidForEncoding &&
        (______________validateAndRetrieveIntrinsicProperty -= 3) > -1
      ) {
        unicodeByteOrderMarkBuffer.push(239, 191, 189);
      }
      isCharacterValidForEncoding = null;
      if (getUnicodeCharacterCode < 128) {
        if ((______________validateAndRetrieveIntrinsicProperty -= 1) < 0) {
          break;
        }
        unicodeByteOrderMarkBuffer.push(getUnicodeCharacterCode);
      } else if (getUnicodeCharacterCode < 2048) {
        if ((______________validateAndRetrieveIntrinsicProperty -= 2) < 0) {
          break;
        }
        unicodeByteOrderMarkBuffer.push(
          (getUnicodeCharacterCode >> 6) | 192,
          (getUnicodeCharacterCode & 63) | 128,
        );
      } else if (getUnicodeCharacterCode < 65536) {
        if ((______________validateAndRetrieveIntrinsicProperty -= 3) < 0) {
          break;
        }
        unicodeByteOrderMarkBuffer.push(
          (getUnicodeCharacterCode >> 12) | 224,
          ((getUnicodeCharacterCode >> 6) & 63) | 128,
          (getUnicodeCharacterCode & 63) | 128,
        );
      } else if (getUnicodeCharacterCode < 1114112) {
        if ((______________validateAndRetrieveIntrinsicProperty -= 4) < 0) {
          break;
        }
        unicodeByteOrderMarkBuffer.push(
          (getUnicodeCharacterCode >> 18) | 240,
          ((getUnicodeCharacterCode >> 12) & 63) | 128,
          ((getUnicodeCharacterCode >> 6) & 63) | 128,
          (getUnicodeCharacterCode & 63) | 128,
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return unicodeByteOrderMarkBuffer;
  }
  function stringToCharCodeByteArray(_convertStringToCharCodeArray) {
    let charCodeByteArray = [];
    for (
      let charCodeIndex = 0;
      charCodeIndex < _convertStringToCharCodeArray.length;
      ++charCodeIndex
    ) {
      charCodeByteArray.push(
        _convertStringToCharCodeArray.charCodeAt(charCodeIndex) & 255,
      );
    }
    return charCodeByteArray;
  }
  function calculateIntrinsicCharacterValues(
    maxIntrinsicPropertyLength,
    decreaseHalfIntrinsicCount,
  ) {
    let intrinsicCharacterValue;
    let highOrderCharacterValue;
    let lowOrderCharacterValue;
    let intrinsicCharacterValues = [];
    for (
      let charIndex = 0;
      charIndex < maxIntrinsicPropertyLength.length &&
      !((decreaseHalfIntrinsicCount -= 2) < 0);
      ++charIndex
    ) {
      intrinsicCharacterValue =
        maxIntrinsicPropertyLength.charCodeAt(charIndex);
      highOrderCharacterValue = intrinsicCharacterValue >> 8;
      lowOrderCharacterValue = intrinsicCharacterValue % 256;
      intrinsicCharacterValues.push(lowOrderCharacterValue);
      intrinsicCharacterValues.push(highOrderCharacterValue);
    }
    return intrinsicCharacterValues;
  }
  function generateAndStoreByteArrayFromBase64(
    convertAndStoreNormalizedIntrinsicValue,
  ) {
    return createRandomDataView.toByteArray(
      sanitizeAndPadBase64Input(convertAndStoreNormalizedIntrinsicValue),
    );
  }
  function transferAndValidateIntrinsicValues(
    extractAndStoreIntrinsicValues,
    _copyAndValidateIntrinsicValues,
    copyIntrinsicsToValues,
    getAndCopyIntrinsicValuesCount,
  ) {
    let _currentIndex;
    for (
      _currentIndex = 0;
      _currentIndex < getAndCopyIntrinsicValuesCount &&
      !(
        _currentIndex + copyIntrinsicsToValues >=
        _copyAndValidateIntrinsicValues.length
      ) &&
      !(_currentIndex >= extractAndStoreIntrinsicValues.length);
      ++_currentIndex
    ) {
      _copyAndValidateIntrinsicValues[_currentIndex + copyIntrinsicsToValues] =
        extractAndStoreIntrinsicValues[_currentIndex];
    }
    return _currentIndex;
  }
  function isInstanceOrSameConstructorName(
    validateAndObtainIntrinsicProperties,
    isInstanceOfOrHasSameConstructor,
  ) {
    return (
      validateAndObtainIntrinsicProperties instanceof
        isInstanceOfOrHasSameConstructor ||
      (validateAndObtainIntrinsicProperties != null &&
        validateAndObtainIntrinsicProperties.constructor != null &&
        validateAndObtainIntrinsicProperties.constructor.name != null &&
        validateAndObtainIntrinsicProperties.constructor.name ===
          isInstanceOfOrHasSameConstructor.name)
    );
  }
  function isIntrinsicPropertyValid(retrieveAndValidateIntrinsicProperty) {
    return (
      retrieveAndValidateIntrinsicProperty !==
      retrieveAndValidateIntrinsicProperty
    );
  }
  var isTypedArraySupported = (function () {
    let hexDigitString = "0123456789abcdef";
    let generateHexColorCodes = new Array(256);
    for (
      let outerColorPairIndex = 0;
      outerColorPairIndex < 16;
      ++outerColorPairIndex
    ) {
      let baseColorCodeIndex = outerColorPairIndex * 16;
      for (
        let hexColorCodeIndexer = 0;
        hexColorCodeIndexer < 16;
        ++hexColorCodeIndexer
      ) {
        generateHexColorCodes[baseColorCodeIndex + hexColorCodeIndexer] =
          hexDigitString[outerColorPairIndex] +
          hexDigitString[hexColorCodeIndexer];
      }
    }
    return generateHexColorCodes;
  })();
  function retrieveIntrinsicValueWithFallback(getIntrinsicValue) {
    if (typeof BigInt === "undefined") {
      return raiseErrorForUnsupportedBigInt;
    } else {
      return getIntrinsicValue;
    }
  }
  function raiseErrorForUnsupportedBigInt() {
    throw new Error("BigInt not supported");
  }
});
var intrinsicPropertiesManager = {};
defineGettersForProperties(intrinsicPropertiesManager, {
  Buffer: () => fetchIntrinsicPropertiesWithValidation,
  constants: () => fetchAndValidateIntrinsicProperty,
  default: () => validateAndFetchIntrinsicPropertiesWithDefaults,
});
var validateAndRetrieveIntrinsicPropertyBasedOnDefaults;
var fetchIntrinsicPropertiesWithValidation;
var fetchAndValidateIntrinsicProperty;
var validateAndFetchIntrinsicPropertiesWithDefaults;
var retrieveAndValidateIntrinsicPropertyValue = resettableValueUpdater(() => {
  validateAndRetrieveIntrinsicPropertyBasedOnDefaults =
    initializeObjectWithProperties(generateColorValidationMessage());
  mergePropertiesWithDefaults(
    intrinsicPropertiesManager,
    initializeObjectWithProperties(generateColorValidationMessage()),
  );
  fetchIntrinsicPropertiesWithValidation =
    validateAndRetrieveIntrinsicPropertyBasedOnDefaults.Buffer;
  fetchIntrinsicPropertiesWithValidation.prototype.copy = function (
    validateAndExtractBufferProperties,
    extractAndValidateIntrinsicValue,
    getValidIntrinsicValue,
    ___validateAndRetrieveIntrinsicValue,
  ) {
    if (!(validateAndExtractBufferProperties instanceof Uint8Array)) {
      throw new TypeError("argument should be a Buffer");
    }
    getValidIntrinsicValue ||= 0;
    if (
      !___validateAndRetrieveIntrinsicValue &&
      ___validateAndRetrieveIntrinsicValue !== 0
    ) {
      ___validateAndRetrieveIntrinsicValue = this.length;
    }
    if (
      extractAndValidateIntrinsicValue >=
      validateAndExtractBufferProperties.length
    ) {
      extractAndValidateIntrinsicValue =
        validateAndExtractBufferProperties.length;
    }
    extractAndValidateIntrinsicValue ||= 0;
    if (
      ___validateAndRetrieveIntrinsicValue > 0 &&
      ___validateAndRetrieveIntrinsicValue < getValidIntrinsicValue
    ) {
      ___validateAndRetrieveIntrinsicValue = getValidIntrinsicValue;
    }
    if (
      ___validateAndRetrieveIntrinsicValue === getValidIntrinsicValue ||
      validateAndExtractBufferProperties.length === 0 ||
      this.length === 0
    ) {
      return 0;
    }
    if (extractAndValidateIntrinsicValue < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (getValidIntrinsicValue < 0 || getValidIntrinsicValue >= this.length) {
      throw new RangeError("Index out of range");
    }
    if (___validateAndRetrieveIntrinsicValue < 0) {
      throw new RangeError("sourceEnd out of bounds");
    }
    if (___validateAndRetrieveIntrinsicValue > this.length) {
      ___validateAndRetrieveIntrinsicValue = this.length;
    }
    if (
      validateAndExtractBufferProperties.length -
        extractAndValidateIntrinsicValue <
      ___validateAndRetrieveIntrinsicValue - getValidIntrinsicValue
    ) {
      ___validateAndRetrieveIntrinsicValue =
        validateAndExtractBufferProperties.length -
        extractAndValidateIntrinsicValue +
        getValidIntrinsicValue;
    }
    let validateAndManageBufferInput =
      ___validateAndRetrieveIntrinsicValue - getValidIntrinsicValue;
    if (
      this === validateAndExtractBufferProperties &&
      typeof Uint8Array.prototype.copyWithin == "function"
    ) {
      this.copyWithin(
        extractAndValidateIntrinsicValue,
        getValidIntrinsicValue,
        ___validateAndRetrieveIntrinsicValue,
      );
    } else {
      Uint8Array.prototype.set.call(
        validateAndExtractBufferProperties,
        this.subarray(
          getValidIntrinsicValue,
          ___validateAndRetrieveIntrinsicValue,
        ),
        extractAndValidateIntrinsicValue,
      );
    }
    return validateAndManageBufferInput;
  };
  Object.defineProperties(fetchIntrinsicPropertiesWithValidation, {
    TextEncoder: {
      value: self.TextEncoder,
    },
    TextDecoder: {
      value: self.TextDecoder,
    },
  });
  fetchAndValidateIntrinsicProperty = {
    MAX_LENGTH: 4294967296,
    MAX_STRING_LENGTH: 536870888,
  };
  Object.defineProperties(validateAndRetrieveIntrinsicPropertyBasedOnDefaults, {
    constants: {
      value: fetchAndValidateIntrinsicProperty,
    },
  });
  validateAndFetchIntrinsicPropertiesWithDefaults =
    validateAndRetrieveIntrinsicPropertyBasedOnDefaults;
});
var handlePendingPromiseResolution = lazyModuleInitializer(
  (PromiseExecutorModule) => {
    Object.defineProperty(PromiseExecutorModule, "__esModule", {
      value: true,
    });
    PromiseExecutorModule.createDeferredExecutor = undefined;
    function initializePromiseHandler() {
      let initializeCustomPromiseHandler = (
        createCustomPromiseHandler,
        _handlePromiseRejection,
      ) => {
        initializeCustomPromiseHandler.state = "pending";
        initializeCustomPromiseHandler.resolve = (processPendingPromise) => {
          if (initializeCustomPromiseHandler.state !== "pending") {
            return;
          }
          initializeCustomPromiseHandler.result = processPendingPromise;
          let handlePromiseFulfillment = (markPromiseAsFulfilled) => {
            initializeCustomPromiseHandler.state = "fulfilled";
            return markPromiseAsFulfilled;
          };
          return createCustomPromiseHandler(
            processPendingPromise instanceof Promise
              ? processPendingPromise
              : Promise.resolve(processPendingPromise).then(
                  handlePromiseFulfillment,
                ),
          );
        };
        initializeCustomPromiseHandler.reject = (
          processPendingPromiseState,
        ) => {
          if (initializeCustomPromiseHandler.state === "pending") {
            queueMicrotask(() => {
              initializeCustomPromiseHandler.state = "rejected";
            });
            return _handlePromiseRejection(
              (initializeCustomPromiseHandler.rejectionReason =
                processPendingPromiseState),
            );
          }
        };
      };
      return initializeCustomPromiseHandler;
    }
    PromiseExecutorModule.createDeferredExecutor = initializePromiseHandler;
  },
);
var validateAndRetrieveDeferredExecutor = lazyModuleInitializer(
  (AsyncDeferredPromise) => {
    Object.defineProperty(AsyncDeferredPromise, "__esModule", {
      value: true,
    });
    AsyncDeferredPromise.DeferredPromise = undefined;
    var promiseResolutionHandler = handlePendingPromiseResolution();
    var DeferredExecutionPromise = class extends Promise {
      #e;
      resolve;
      reject;
      constructor(initialValue = null) {
        let _deferredPromiseExecutor = (0,
        promiseResolutionHandler.createDeferredExecutor)();
        super((executeDeferredPromise, deferredPromiseHandler) => {
          _deferredPromiseExecutor(
            executeDeferredPromise,
            deferredPromiseHandler,
          );
          initialValue?.(
            _deferredPromiseExecutor.resolve,
            _deferredPromiseExecutor.reject,
          );
        });
        this.#e = _deferredPromiseExecutor;
        this.resolve = this.#e.resolve;
        this.reject = this.#e.reject;
      }
      get state() {
        return this.#e.state;
      }
      get rejectionReason() {
        return this.#e.rejectionReason;
      }
      then(handleApiResponse, transformApiResponseData) {
        return this.#t(super.then(handleApiResponse, transformApiResponseData));
      }
      catch(_handleCatchError) {
        return this.#t(super.catch(_handleCatchError));
      }
      finally(finalizePromiseAndHandleResult) {
        return this.#t(super.finally(finalizePromiseAndHandleResult));
      }
      #t(createPromiseHandlerProperties) {
        return Object.defineProperties(createPromiseHandlerProperties, {
          resolve: {
            configurable: true,
            value: this.resolve,
          },
          reject: {
            configurable: true,
            value: this.reject,
          },
        });
      }
    };
    AsyncDeferredPromise.DeferredPromise = DeferredExecutionPromise;
  },
);
var validateBufferCapacityAndRetrieveLimits = lazyModuleInitializer(
  (createGetterBinding) => {
    var definePropertyWithGetter =
      (createGetterBinding && createGetterBinding.__createBinding) ||
      (Object.create
        ? function (
            _definePropertyWithDescriptor,
            getIntrinsicPropertyLimit,
            getPropertyLength,
            _getPropertyLength = getPropertyLength,
          ) {
            var propertyDescriptorForIntrinsicLimit =
              Object.getOwnPropertyDescriptor(
                getIntrinsicPropertyLimit,
                getPropertyLength,
              );
            if (
              !propertyDescriptorForIntrinsicLimit ||
              ("get" in propertyDescriptorForIntrinsicLimit
                ? !getIntrinsicPropertyLimit.__esModule
                : propertyDescriptorForIntrinsicLimit.writable ||
                  propertyDescriptorForIntrinsicLimit.configurable)
            ) {
              propertyDescriptorForIntrinsicLimit = {
                enumerable: true,
                get() {
                  return getIntrinsicPropertyLimit[getPropertyLength];
                },
              };
            }
            Object.defineProperty(
              _definePropertyWithDescriptor,
              _getPropertyLength,
              propertyDescriptorForIntrinsicLimit,
            );
          }
        : function (
            validateAndFetchBufferEncoding,
            _______________validateAndRetrieveIntrinsicProperty,
            _validateAndProcessEncoding,
            __validateAndProcessEncoding = _validateAndProcessEncoding,
          ) {
            validateAndFetchBufferEncoding[__validateAndProcessEncoding] =
              _______________validateAndRetrieveIntrinsicProperty[
                _validateAndProcessEncoding
              ];
          });
    var definePropertyWithGetterDescriptor =
      (createGetterBinding && createGetterBinding.__exportStar) ||
      function (
        retrieveAndValidateEncodingProperties,
        retrieveAndValidateBufferProperties,
      ) {
        for (var encodingPropertyName in retrieveAndValidateEncodingProperties) {
          if (
            encodingPropertyName !== "default" &&
            !Object.prototype.hasOwnProperty.call(
              retrieveAndValidateBufferProperties,
              encodingPropertyName,
            )
          ) {
            definePropertyWithGetter(
              retrieveAndValidateBufferProperties,
              retrieveAndValidateEncodingProperties,
              encodingPropertyName,
            );
          }
        }
      };
    Object.defineProperty(createGetterBinding, "__esModule", {
      value: true,
    });
    definePropertyWithGetterDescriptor(
      handlePendingPromiseResolution(),
      createGetterBinding,
    );
    definePropertyWithGetterDescriptor(
      validateAndRetrieveDeferredExecutor(),
      createGetterBinding,
    );
  },
);
var initializeEncodingValidationAndRegistration = lazyModuleInitializer(
  (initializeSemverConstants, exportSemverConstants) => {
    var SEMVER_VERSION_SPECIFICATION = "2.0.0";
    var MAX_VERSION_STRING_LENGTH = 256;
    var MAX_SAFE_JS_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_VERSION_COMPONENT_LENGTH = 16;
    exportSemverConstants.exports = {
      SEMVER_SPEC_VERSION: SEMVER_VERSION_SPECIFICATION,
      MAX_LENGTH: MAX_VERSION_STRING_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_JS_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_VERSION_COMPONENT_LENGTH,
    };
  },
);
var validateAndAddEncodingPattern = lazyModuleInitializer(
  (handleSemverLogging, _handleSemverLogging) => {
    var logSemverErrorsToConsole =
      typeof process == "object" &&
      process.env &&
      "false" &&
      /\bsemver\b/i.test("false")
        ? (...logSemanticVersioningErrors) =>
            console.error("SEMVER", ...logSemanticVersioningErrors)
        : () => {};
    _handleSemverLogging.exports = logSemverErrorsToConsole;
  },
);
var validateAndStoreEncodingPattern = lazyModuleInitializer(
  (encodingPatternManager, encodingPatternManagerExporter) => {
    var { MAX_SAFE_COMPONENT_LENGTH: MAX_VALID_ENCODING_LENGTH } =
      initializeEncodingValidationAndRegistration();
    var _validateAndProcessEncoding = validateAndAddEncodingPattern();
    encodingPatternManager = encodingPatternManagerExporter.exports = {};
    var registeredEncodingPatterns = (encodingPatternManager.re = []);
    var registeredEncodingPatternRegexArray = (encodingPatternManager.src = []);
    var encodingPatternRegistry = (encodingPatternManager.t = {});
    var currentEncodingPatternCount = 0;
    var registerEncodingPattern = (
      _registerEncodingPattern,
      encodingPattern,
      isGlobalRegexFlag,
    ) => {
      let encodingPatternId = currentEncodingPatternCount++;
      _validateAndProcessEncoding(
        _registerEncodingPattern,
        encodingPatternId,
        encodingPattern,
      );
      encodingPatternRegistry[_registerEncodingPattern] = encodingPatternId;
      registeredEncodingPatternRegexArray[encodingPatternId] = encodingPattern;
      registeredEncodingPatterns[encodingPatternId] = new RegExp(
        encodingPattern,
        isGlobalRegexFlag ? "g" : undefined,
      );
    };
    registerEncodingPattern("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    registerEncodingPattern("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    registerEncodingPattern(
      "NONNUMERICIDENTIFIER",
      "\\d*[a-zA-Z-][a-zA-Z0-9-]*",
    );
    registerEncodingPattern(
      "MAINVERSION",
      "(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.NUMERICIDENTIFIER
        ] +
        ")\\.(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.NUMERICIDENTIFIER
        ] +
        ")\\.(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.NUMERICIDENTIFIER
        ] +
        ")",
    );
    registerEncodingPattern(
      "MAINVERSIONLOOSE",
      "(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.NUMERICIDENTIFIERLOOSE
        ] +
        ")\\.(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.NUMERICIDENTIFIERLOOSE
        ] +
        ")\\.(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.NUMERICIDENTIFIERLOOSE
        ] +
        ")",
    );
    registerEncodingPattern(
      "PRERELEASEIDENTIFIER",
      "(?:" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.NUMERICIDENTIFIER
        ] +
        "|" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.NONNUMERICIDENTIFIER
        ] +
        ")",
    );
    registerEncodingPattern(
      "PRERELEASEIDENTIFIERLOOSE",
      "(?:" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.NUMERICIDENTIFIERLOOSE
        ] +
        "|" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.NONNUMERICIDENTIFIER
        ] +
        ")",
    );
    registerEncodingPattern(
      "PRERELEASE",
      "(?:-(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.PRERELEASEIDENTIFIER
        ] +
        "(?:\\." +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.PRERELEASEIDENTIFIER
        ] +
        ")*))",
    );
    registerEncodingPattern(
      "PRERELEASELOOSE",
      "(?:-?(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.PRERELEASEIDENTIFIERLOOSE
        ] +
        "(?:\\." +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.PRERELEASEIDENTIFIERLOOSE
        ] +
        ")*))",
    );
    registerEncodingPattern("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    registerEncodingPattern(
      "BUILD",
      "(?:\\+(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.BUILDIDENTIFIER
        ] +
        "(?:\\." +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.BUILDIDENTIFIER
        ] +
        ")*))",
    );
    registerEncodingPattern(
      "FULLPLAIN",
      "v?" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.MAINVERSION
        ] +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.PRERELEASE
        ] +
        "?" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.BUILD] +
        "?",
    );
    registerEncodingPattern(
      "FULL",
      "^" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.FULLPLAIN] +
        "$",
    );
    registerEncodingPattern(
      "LOOSEPLAIN",
      "[v=\\s]*" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.MAINVERSIONLOOSE
        ] +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.PRERELEASELOOSE
        ] +
        "?" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.BUILD] +
        "?",
    );
    registerEncodingPattern(
      "LOOSE",
      "^" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.LOOSEPLAIN
        ] +
        "$",
    );
    registerEncodingPattern("GTLT", "((?:<|>)?=?)");
    registerEncodingPattern(
      "XRANGEIDENTIFIERLOOSE",
      registeredEncodingPatternRegexArray[
        encodingPatternRegistry.NUMERICIDENTIFIERLOOSE
      ] + "|x|X|\\*",
    );
    registerEncodingPattern(
      "XRANGEIDENTIFIER",
      registeredEncodingPatternRegexArray[
        encodingPatternRegistry.NUMERICIDENTIFIER
      ] + "|x|X|\\*",
    );
    registerEncodingPattern(
      "XRANGEPLAIN",
      "[v=\\s]*(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEIDENTIFIER
        ] +
        ")(?:\\.(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEIDENTIFIER
        ] +
        ")(?:\\.(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEIDENTIFIER
        ] +
        ")(?:" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.PRERELEASE
        ] +
        ")?" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.BUILD] +
        "?)?)?",
    );
    registerEncodingPattern(
      "XRANGEPLAINLOOSE",
      "[v=\\s]*(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEIDENTIFIERLOOSE
        ] +
        ")(?:\\.(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEIDENTIFIERLOOSE
        ] +
        ")(?:\\.(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEIDENTIFIERLOOSE
        ] +
        ")(?:" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.PRERELEASELOOSE
        ] +
        ")?" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.BUILD] +
        "?)?)?",
    );
    registerEncodingPattern(
      "XRANGE",
      "^" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.GTLT] +
        "\\s*" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEPLAIN
        ] +
        "$",
    );
    registerEncodingPattern(
      "XRANGELOOSE",
      "^" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.GTLT] +
        "\\s*" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEPLAINLOOSE
        ] +
        "$",
    );
    registerEncodingPattern(
      "COERCE",
      "(^|[^\\d])(\\d{1," +
        MAX_VALID_ENCODING_LENGTH +
        "})(?:\\.(\\d{1," +
        MAX_VALID_ENCODING_LENGTH +
        "}))?(?:\\.(\\d{1," +
        MAX_VALID_ENCODING_LENGTH +
        "}))?(?:$|[^\\d])",
    );
    registerEncodingPattern(
      "COERCERTL",
      registeredEncodingPatternRegexArray[encodingPatternRegistry.COERCE],
      true,
    );
    registerEncodingPattern("LONETILDE", "(?:~>?)");
    registerEncodingPattern(
      "TILDETRIM",
      "(\\s*)" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.LONETILDE] +
        "\\s+",
      true,
    );
    encodingPatternManager.tildeTrimReplace = "$1~";
    registerEncodingPattern(
      "TILDE",
      "^" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.LONETILDE] +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEPLAIN
        ] +
        "$",
    );
    registerEncodingPattern(
      "TILDELOOSE",
      "^" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.LONETILDE] +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEPLAINLOOSE
        ] +
        "$",
    );
    registerEncodingPattern("LONECARET", "(?:\\^)");
    registerEncodingPattern(
      "CARETTRIM",
      "(\\s*)" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.LONECARET] +
        "\\s+",
      true,
    );
    encodingPatternManager.caretTrimReplace = "$1^";
    registerEncodingPattern(
      "CARET",
      "^" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.LONECARET] +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEPLAIN
        ] +
        "$",
    );
    registerEncodingPattern(
      "CARETLOOSE",
      "^" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.LONECARET] +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEPLAINLOOSE
        ] +
        "$",
    );
    registerEncodingPattern(
      "COMPARATORLOOSE",
      "^" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.GTLT] +
        "\\s*(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.LOOSEPLAIN
        ] +
        ")$|^$",
    );
    registerEncodingPattern(
      "COMPARATOR",
      "^" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.GTLT] +
        "\\s*(" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.FULLPLAIN] +
        ")$|^$",
    );
    registerEncodingPattern(
      "COMPARATORTRIM",
      "(\\s*)" +
        registeredEncodingPatternRegexArray[encodingPatternRegistry.GTLT] +
        "\\s*(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.LOOSEPLAIN
        ] +
        "|" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEPLAIN
        ] +
        ")",
      true,
    );
    encodingPatternManager.comparatorTrimReplace = "$1$2$3";
    registerEncodingPattern(
      "HYPHENRANGE",
      "^\\s*(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEPLAIN
        ] +
        ")\\s+-\\s+(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEPLAIN
        ] +
        ")\\s*$",
    );
    registerEncodingPattern(
      "HYPHENRANGELOOSE",
      "^\\s*(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEPLAINLOOSE
        ] +
        ")\\s+-\\s+(" +
        registeredEncodingPatternRegexArray[
          encodingPatternRegistry.XRANGEPLAINLOOSE
        ] +
        ")\\s*$",
    );
    registerEncodingPattern("STAR", "(<|>)?=?\\s*\\*");
    registerEncodingPattern("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    registerEncodingPattern("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  },
);
var compareNumericStrings = lazyModuleInitializer(
  (applyLooseAndFilteredOptions, generateOptionsFilter) => {
    var configurableOptionsKeys = ["includePrerelease", "loose", "rtl"];
    var createConfigurableOptionsFilter = (getLooseConfigOptions) =>
      getLooseConfigOptions
        ? typeof getLooseConfigOptions != "object"
          ? {
              loose: true,
            }
          : configurableOptionsKeys
              .filter(
                (_getLooseConfigOptions) =>
                  getLooseConfigOptions[_getLooseConfigOptions],
              )
              .reduce(
                (assignBooleanTrueToProperty, assignTrueToPropertyByKey) => {
                  assignBooleanTrueToProperty[assignTrueToPropertyByKey] = true;
                  return assignBooleanTrueToProperty;
                },
                {},
              )
        : {};
    generateOptionsFilter.exports = createConfigurableOptionsFilter;
  },
);
var versionComparisonFunctions = lazyModuleInitializer(
  (compareAndSortByNumericValue, _compareAndSortByNumericValue) => {
    var numericStringRegex = /^[0-9]+$/;
    var _compareNumericStrings = (
      __compareNumericStrings,
      compareTwoNumericStrings,
    ) => {
      let isFirstStringNumeric = numericStringRegex.test(
        __compareNumericStrings,
      );
      let isSecondStringNumeric = numericStringRegex.test(
        compareTwoNumericStrings,
      );
      if (isFirstStringNumeric && isSecondStringNumeric) {
        __compareNumericStrings = +__compareNumericStrings;
        compareTwoNumericStrings = +compareTwoNumericStrings;
      }
      if (__compareNumericStrings === compareTwoNumericStrings) {
        return 0;
      } else if (isFirstStringNumeric && !isSecondStringNumeric) {
        return -1;
      } else if (isSecondStringNumeric && !isFirstStringNumeric) {
        return 1;
      } else if (__compareNumericStrings < compareTwoNumericStrings) {
        return -1;
      } else {
        return 1;
      }
    };
    var compareAndSortNumericStringsDescending = (
      __compareAndSortByNumericValue,
      compareAndSortStringsByNumericValue,
    ) =>
      _compareNumericStrings(
        compareAndSortStringsByNumericValue,
        __compareAndSortByNumericValue,
      );
    _compareAndSortByNumericValue.exports = {
      compareIdentifiers: _compareNumericStrings,
      rcompareIdentifiers: compareAndSortNumericStringsDescending,
    };
  },
);
var validateAndProcessVersionEncoding = lazyModuleInitializer(
  (buildVersionInfo, validateAndParseVersion) => {
    var validateAndProcessVersionEncoding = validateAndAddEncodingPattern();
    var {
      MAX_LENGTH: MAX_VERSION_LENGTH,
      MAX_SAFE_INTEGER: maxAllowedVersion,
    } = initializeEncodingValidationAndRegistration();
    var { re: versionValidationRegex, t: parsedVersionInfo } =
      validateAndStoreEncodingPattern();
    var compareAndDecodeOptions = compareNumericStrings();
    var { compareIdentifiers: compareVersionIdentifiersForSorting } =
      versionComparisonFunctions();
    var VersionInfoParser = class {
      constructor(inputVersionOrParser, parsedOptions) {
        parsedOptions = compareAndDecodeOptions(parsedOptions);
        if (inputVersionOrParser instanceof VersionInfoParser) {
          if (
            inputVersionOrParser.loose === !!parsedOptions.loose &&
            inputVersionOrParser.includePrerelease ===
              !!parsedOptions.includePrerelease
          ) {
            return inputVersionOrParser;
          }
          inputVersionOrParser = inputVersionOrParser.version;
        } else if (typeof inputVersionOrParser != "string") {
          throw new TypeError("Invalid Version: " + inputVersionOrParser);
        }
        if (inputVersionOrParser.length > MAX_VERSION_LENGTH) {
          throw new TypeError(
            "version is longer than " + MAX_VERSION_LENGTH + " characters",
          );
        }
        validateAndProcessVersionEncoding(
          "SemVer",
          inputVersionOrParser,
          parsedOptions,
        );
        this.options = parsedOptions;
        this.loose = !!parsedOptions.loose;
        this.includePrerelease = !!parsedOptions.includePrerelease;
        let extractedVersionComponents = inputVersionOrParser
          .trim()
          .match(
            parsedOptions.loose
              ? versionValidationRegex[parsedVersionInfo.LOOSE]
              : versionValidationRegex[parsedVersionInfo.FULL],
          );
        if (!extractedVersionComponents) {
          throw new TypeError("Invalid Version: " + inputVersionOrParser);
        }
        this.raw = inputVersionOrParser;
        this.major = +extractedVersionComponents[1];
        this.minor = +extractedVersionComponents[2];
        this.patch = +extractedVersionComponents[3];
        if (this.major > maxAllowedVersion || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > maxAllowedVersion || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > maxAllowedVersion || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (extractedVersionComponents[4]) {
          this.prerelease = extractedVersionComponents[4]
            .split(".")
            .map((parseAndValidateNonNegativeInteger) => {
              if (/^[0-9]+$/.test(parseAndValidateNonNegativeInteger)) {
                let nonNegativeIntegerWithinVersionLimit =
                  +parseAndValidateNonNegativeInteger;
                if (
                  nonNegativeIntegerWithinVersionLimit >= 0 &&
                  nonNegativeIntegerWithinVersionLimit < maxAllowedVersion
                ) {
                  return nonNegativeIntegerWithinVersionLimit;
                }
              }
              return parseAndValidateNonNegativeInteger;
            });
        } else {
          this.prerelease = [];
        }
        if (extractedVersionComponents[5]) {
          this.build = extractedVersionComponents[5].split(".");
        } else {
          this.build = [];
        }
        this.format();
      }
      format() {
        this.version = this.major + "." + this.minor + "." + this.patch;
        if (this.prerelease.length) {
          this.version += "-" + this.prerelease.join(".");
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(versionToCompare) {
        validateAndProcessVersionEncoding(
          "SemVer.compare",
          this.version,
          this.options,
          versionToCompare,
        );
        if (!(versionToCompare instanceof VersionInfoParser)) {
          if (
            typeof versionToCompare == "string" &&
            versionToCompare === this.version
          ) {
            return 0;
          }
          versionToCompare = new VersionInfoParser(
            versionToCompare,
            this.options,
          );
        }
        if (versionToCompare.version === this.version) {
          return 0;
        } else {
          return (
            this.compareMain(versionToCompare) ||
            this.comparePre(versionToCompare)
          );
        }
      }
      compareMain(__versionToCompare) {
        if (!(__versionToCompare instanceof VersionInfoParser)) {
          __versionToCompare = new VersionInfoParser(
            __versionToCompare,
            this.options,
          );
        }
        return (
          compareVersionIdentifiersForSorting(
            this.major,
            __versionToCompare.major,
          ) ||
          compareVersionIdentifiersForSorting(
            this.minor,
            __versionToCompare.minor,
          ) ||
          compareVersionIdentifiersForSorting(
            this.patch,
            __versionToCompare.patch,
          )
        );
      }
      comparePre(comparePreReleaseVersionInfo) {
        if (!(comparePreReleaseVersionInfo instanceof VersionInfoParser)) {
          comparePreReleaseVersionInfo = new VersionInfoParser(
            comparePreReleaseVersionInfo,
            this.options,
          );
        }
        if (
          this.prerelease.length &&
          !comparePreReleaseVersionInfo.prerelease.length
        ) {
          return -1;
        }
        if (
          !this.prerelease.length &&
          comparePreReleaseVersionInfo.prerelease.length
        ) {
          return 1;
        }
        if (
          !this.prerelease.length &&
          !comparePreReleaseVersionInfo.prerelease.length
        ) {
          return 0;
        }
        let currentPrereleaseIndex = 0;
        do {
          let activePrereleaseVersion = this.prerelease[currentPrereleaseIndex];
          let targetPrereleaseVersion =
            comparePreReleaseVersionInfo.prerelease[currentPrereleaseIndex];
          validateAndProcessVersionEncoding(
            "prerelease compare",
            currentPrereleaseIndex,
            activePrereleaseVersion,
            targetPrereleaseVersion,
          );
          if (
            activePrereleaseVersion === undefined &&
            targetPrereleaseVersion === undefined
          ) {
            return 0;
          }
          if (targetPrereleaseVersion === undefined) {
            return 1;
          }
          if (activePrereleaseVersion === undefined) {
            return -1;
          }
          if (activePrereleaseVersion === targetPrereleaseVersion) {
            continue;
          }
          return compareVersionIdentifiersForSorting(
            activePrereleaseVersion,
            targetPrereleaseVersion,
          );
        } while (++currentPrereleaseIndex);
      }
      compareBuild(compareCurrentBuildWithReferenceVersion) {
        if (
          !(
            compareCurrentBuildWithReferenceVersion instanceof VersionInfoParser
          )
        ) {
          compareCurrentBuildWithReferenceVersion = new VersionInfoParser(
            compareCurrentBuildWithReferenceVersion,
            this.options,
          );
        }
        let currentBuildPosition = 0;
        do {
          let currentBuildVersion = this.build[currentBuildPosition];
          let referenceBuildVersion =
            compareCurrentBuildWithReferenceVersion.build[currentBuildPosition];
          validateAndProcessVersionEncoding(
            "prerelease compare",
            currentBuildPosition,
            currentBuildVersion,
            referenceBuildVersion,
          );
          if (
            currentBuildVersion === undefined &&
            referenceBuildVersion === undefined
          ) {
            return 0;
          }
          if (referenceBuildVersion === undefined) {
            return 1;
          }
          if (currentBuildVersion === undefined) {
            return -1;
          }
          if (currentBuildVersion === referenceBuildVersion) {
            continue;
          }
          return compareVersionIdentifiersForSorting(
            currentBuildVersion,
            referenceBuildVersion,
          );
        } while (++currentBuildPosition);
      }
      inc(versionIncrementStrategy, applyVersionIncrement) {
        switch (versionIncrementStrategy) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", applyVersionIncrement);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", applyVersionIncrement);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", applyVersionIncrement);
            this.inc("pre", applyVersionIncrement);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", applyVersionIncrement);
            }
            this.inc("pre", applyVersionIncrement);
            break;
          case "major":
            if (
              this.minor !== 0 ||
              this.patch !== 0 ||
              this.prerelease.length === 0
            ) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let updatedPrereleaseVersionCount = this.prerelease.length;
              while (--updatedPrereleaseVersionCount >= 0) {
                if (
                  typeof this.prerelease[updatedPrereleaseVersionCount] ==
                  "number"
                ) {
                  this.prerelease[updatedPrereleaseVersionCount]++;
                  updatedPrereleaseVersionCount = -2;
                }
              }
              if (updatedPrereleaseVersionCount === -1) {
                this.prerelease.push(0);
              }
            }
            if (applyVersionIncrement) {
              if (
                compareVersionIdentifiersForSorting(
                  this.prerelease[0],
                  applyVersionIncrement,
                ) === 0
              ) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [applyVersionIncrement, 0];
                }
              } else {
                this.prerelease = [applyVersionIncrement, 0];
              }
            }
            break;
          default:
            throw new Error(
              "invalid increment argument: " + versionIncrementStrategy,
            );
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    validateAndParseVersion.exports = VersionInfoParser;
  },
);
var extractBigUInt64FromBuffer = lazyModuleInitializer(
  (
    _validateCharacterEncodingInput,
    validateAndExportCharacterEncodingToFile,
  ) => {
    var { MAX_LENGTH: MAX_CHARACTER_ENCODING_INPUT_LENGTH } =
      initializeEncodingValidationAndRegistration();
    var { re: encodingValidationRegex, t: encodingValidationSettings } =
      validateAndStoreEncodingPattern();
    var characterEncodingValidator = validateAndProcessVersionEncoding();
    var decodeCharacterEncoding = compareNumericStrings();
    var processAndValidateCharacterEncodingInput = (
      validateAndCreateCharacterEncoding,
      validatedDecodedInput,
    ) => {
      validatedDecodedInput = decodeCharacterEncoding(validatedDecodedInput);
      if (
        validateAndCreateCharacterEncoding instanceof characterEncodingValidator
      ) {
        return validateAndCreateCharacterEncoding;
      }
      if (
        typeof validateAndCreateCharacterEncoding != "string" ||
        validateAndCreateCharacterEncoding.length >
          MAX_CHARACTER_ENCODING_INPUT_LENGTH ||
        !(
          validatedDecodedInput.loose
            ? encodingValidationRegex[encodingValidationSettings.LOOSE]
            : encodingValidationRegex[encodingValidationSettings.FULL]
        ).test(validateAndCreateCharacterEncoding)
      ) {
        return null;
      }
      try {
        return new characterEncodingValidator(
          validateAndCreateCharacterEncoding,
          validatedDecodedInput,
        );
      } catch {
        return null;
      }
    };
    validateAndExportCharacterEncodingToFile.exports =
      processAndValidateCharacterEncodingInput;
  },
);
var calculateBigIntegerFromByteBuffer = lazyModuleInitializer(
  (extractVersionFromBufferAndExport, _extractVersionFromBufferAndExport) => {
    var currentBufferVersion = extractBigUInt64FromBuffer();
    var extractVersionFromBuffer = (
      fetchCurrentBufferVersion,
      currentBufferVersionData,
    ) => {
      let currentBufferVersionResult = currentBufferVersion(
        fetchCurrentBufferVersion,
        currentBufferVersionData,
      );
      if (currentBufferVersionResult) {
        return currentBufferVersionResult.version;
      } else {
        return null;
      }
    };
    _extractVersionFromBufferAndExport.exports = extractVersionFromBuffer;
  },
);
var readBigUInt64FromByteBuffer = lazyModuleInitializer(
  (
    handleVersionExtractionAndMapping,
    handleVersionExtractionFromTrimmedInput,
  ) => {
    var extractVersionFromBuffer = extractBigUInt64FromBuffer();
    var extractAndNormalizeVersionFromInput = (
      retrieveCleanVersionFromInput,
      extractedVersionFromInput,
    ) => {
      let cleanedAndExtractedVersionData = extractVersionFromBuffer(
        retrieveCleanVersionFromInput.trim().replace(/^[=v]+/, ""),
        extractedVersionFromInput,
      );
      if (cleanedAndExtractedVersionData) {
        return cleanedAndExtractedVersionData.version;
      } else {
        return null;
      }
    };
    handleVersionExtractionFromTrimmedInput.exports =
      extractAndNormalizeVersionFromInput;
  },
);
var parseBufferToBigInt = lazyModuleInitializer(
  (
    initializeCharacterEncodingVersionIncrementer,
    characterEncodingVersionIncrementer,
  ) => {
    var CharacterEncodingVersionIncrementer =
      validateAndProcessVersionEncoding();
    var createAndIncrementCharacterEncodingVersion = (
      createCharacterEncodingIncrementer,
      inputString,
      characterEncoding,
      specifiedCharacterEncoding,
    ) => {
      if (typeof characterEncoding == "string") {
        specifiedCharacterEncoding = characterEncoding;
        characterEncoding = undefined;
      }
      try {
        return new CharacterEncodingVersionIncrementer(
          createCharacterEncodingIncrementer instanceof
          CharacterEncodingVersionIncrementer
            ? createCharacterEncodingIncrementer.version
            : createCharacterEncodingIncrementer,
          characterEncoding,
        ).inc(inputString, specifiedCharacterEncoding).version;
      } catch {
        return null;
      }
    };
    characterEncodingVersionIncrementer.exports =
      createAndIncrementCharacterEncodingVersion;
  },
);
var extractAndCompareBigInt = lazyModuleInitializer(
  (compareCharacterEncodingsForType, _compareCharacterEncodings) => {
    var initializeAndEvaluateEncodingComparison =
      validateAndProcessVersionEncoding();
    var ___compareCharacterEncodings = (
      initializeAndCompareCharacterEncodings,
      encodingComparisonEvaluator,
      encodingComparisonEvaluatorInstance,
    ) =>
      new initializeAndEvaluateEncodingComparison(
        initializeAndCompareCharacterEncodings,
        encodingComparisonEvaluatorInstance,
      ).compare(
        new initializeAndEvaluateEncodingComparison(
          encodingComparisonEvaluator,
          encodingComparisonEvaluatorInstance,
        ),
      );
    _compareCharacterEncodings.exports = ___compareCharacterEncodings;
  },
);
var extractIntegerFromBuffer = lazyModuleInitializer(
  (areInputValuesIdenticalToZero, _areInputValuesIdenticalToZero) => {
    var areCalculatedValuesIdenticalToZero = extractAndCompareBigInt();
    var checkIfCalculatedValuesAreZero = (
      firstInputValue,
      computeValueDifference,
      areValuesIdenticalToZero,
    ) =>
      areCalculatedValuesIdenticalToZero(
        firstInputValue,
        computeValueDifference,
        areValuesIdenticalToZero,
      ) === 0;
    _areInputValuesIdenticalToZero.exports = checkIfCalculatedValuesAreZero;
  },
);
var versionBuffer = lazyModuleInitializer(
  (isPrereleaseVersionComparable, comparePrereleaseVersions) => {
    var extractBigUInt64ValueFromBuffer = extractBigUInt64FromBuffer();
    var extractIntegerFromBufferForVersionComparison =
      extractIntegerFromBuffer();
    var comparePrereleaseVersionsBasedOnBuffer = (
      compareSoftwarePackageVersions,
      compareSoftwarePackageVersionsWithCurrent,
    ) => {
      if (
        extractIntegerFromBufferForVersionComparison(
          compareSoftwarePackageVersions,
          compareSoftwarePackageVersionsWithCurrent,
        )
      ) {
        return null;
      }
      {
        let _compareSoftwarePackageVersions = extractBigUInt64ValueFromBuffer(
          compareSoftwarePackageVersions,
        );
        let extractCurrentPackageVersion = extractBigUInt64ValueFromBuffer(
          compareSoftwarePackageVersionsWithCurrent,
        );
        let isAnyPackageVersionPrerelease =
          _compareSoftwarePackageVersions.prerelease.length ||
          extractCurrentPackageVersion.prerelease.length;
        let versionReleasePrefix = isAnyPackageVersionPrerelease ? "pre" : "";
        let prereleaseStatusIndicator = isAnyPackageVersionPrerelease
          ? "prerelease"
          : "";
        for (let softwareVersionCategory in _compareSoftwarePackageVersions) {
          if (
            (softwareVersionCategory === "major" ||
              softwareVersionCategory === "minor" ||
              softwareVersionCategory === "patch") &&
            _compareSoftwarePackageVersions[softwareVersionCategory] !==
              extractCurrentPackageVersion[softwareVersionCategory]
          ) {
            return versionReleasePrefix + softwareVersionCategory;
          }
        }
        return prereleaseStatusIndicator;
      }
    };
    comparePrereleaseVersions.exports = comparePrereleaseVersionsBasedOnBuffer;
  },
);
var prereleaseBufferLength = lazyModuleInitializer(
  (generateMajorFromCharacterEncoding, exportCharacterEncodingMajorInfo) => {
    var _generateMajorFromCharacterEncoding =
      validateAndProcessVersionEncoding();
    var __generateMajorFromCharacterEncoding = (
      ___generateMajorFromCharacterEncoding,
      ____generateMajorFromCharacterEncoding,
    ) =>
      new _generateMajorFromCharacterEncoding(
        ___generateMajorFromCharacterEncoding,
        ____generateMajorFromCharacterEncoding,
      ).major;
    exportCharacterEncodingMajorInfo.exports =
      __generateMajorFromCharacterEncoding;
  },
);
var bufferCapacity = lazyModuleInitializer(
  (generateMinorFromEncoding, registerMinorCreationFunction) => {
    var createMinorCharacterEncoding = validateAndProcessVersionEncoding();
    var generateMinorCharacterFromEncoding = (
      initializeCharacterEncoding,
      _processCharacterEncoding,
    ) =>
      new createMinorCharacterEncoding(
        initializeCharacterEncoding,
        _processCharacterEncoding,
      ).minor;
    registerMinorCreationFunction.exports = generateMinorCharacterFromEncoding;
  },
);
var readSignedInt16LittleEndianFromBuffer = lazyModuleInitializer(
  (initializeAndExportCharacterPatch, _initializeAndExportCharacterPatch) => {
    var validateAndExportCharacterPatch = validateAndProcessVersionEncoding();
    var generateAndExposeCharacterPatch = (
      generateCharacterValidationPatch,
      _validateAndExportCharacterPatch,
    ) =>
      new validateAndExportCharacterPatch(
        generateCharacterValidationPatch,
        _validateAndExportCharacterPatch,
      ).patch;
    _initializeAndExportCharacterPatch.exports =
      generateAndExposeCharacterPatch;
  },
);
var calculateSigned16BitInteger = lazyModuleInitializer(
  (
    extractPrereleaseVersionsFromBuffer,
    exportExtractPrereleaseVersionsFromBuffer,
  ) => {
    var _extractPrereleaseVersionsFromBuffer = extractBigUInt64FromBuffer();
    var extractPrereleaseInfoFromBuffer = (
      __extractPrereleaseVersionsFromBuffer,
      prereleaseVersionBuffer,
    ) => {
      let extractedPrereleaseVersions = _extractPrereleaseVersionsFromBuffer(
        __extractPrereleaseVersionsFromBuffer,
        prereleaseVersionBuffer,
      );
      if (
        extractedPrereleaseVersions &&
        extractedPrereleaseVersions.prerelease.length
      ) {
        return extractedPrereleaseVersions.prerelease;
      } else {
        return null;
      }
    };
    exportExtractPrereleaseVersionsFromBuffer.exports =
      extractPrereleaseInfoFromBuffer;
  },
);
var readInt16ValueFromBuffer = lazyModuleInitializer(
  (executeBigIntCalculationAndExport, exportCalculatedBigIntWithOptions) => {
    var performBigIntCalculationAndExportWithParameters =
      extractAndCompareBigInt();
    var performAndExportBigIntCalculation = (
      performBigIntCalculationAndExport,
      bigIntCalculationParameters,
      performAndExportBigIntCalculationWithParams,
    ) =>
      performBigIntCalculationAndExportWithParameters(
        bigIntCalculationParameters,
        performBigIntCalculationAndExport,
        performAndExportBigIntCalculationWithParams,
      );
    exportCalculatedBigIntWithOptions.exports =
      performAndExportBigIntCalculation;
  },
);
var compareCharacterEncodingsByEncoding = lazyModuleInitializer(
  (
    calculateBigIntWithExportAndPrecision,
    exportBigIntWithPrecisionCalculation,
  ) => {
    var _calculateAndExportBigIntWithPrecision = extractAndCompareBigInt();
    var calculateAndExportBigIntWithPrecisionHandling = (
      initialBigIntForExport,
      shouldExportBigInt,
    ) =>
      _calculateAndExportBigIntWithPrecision(
        initialBigIntForExport,
        shouldExportBigInt,
        true,
      );
    exportBigIntWithPrecisionCalculation.exports =
      calculateAndExportBigIntWithPrecisionHandling;
  },
);
var getLogProcessSorterByIndex = lazyModuleInitializer(
  (characterEncodingComparerFunction, compareCharacterEncodings) => {
    var initializeCharacterEncodingComparer =
      validateAndProcessVersionEncoding();
    var compareCharacterEncodingsByEncoding = (
      compareCharacterEncodingsUsingComparer,
      referenceEncodingComparator,
      encodingComparator,
    ) => {
      let encodingComparer = new initializeCharacterEncodingComparer(
        compareCharacterEncodingsUsingComparer,
        encodingComparator,
      );
      let referenceEncodingComparer = new initializeCharacterEncodingComparer(
        referenceEncodingComparator,
        encodingComparator,
      );
      return (
        encodingComparer.compare(referenceEncodingComparer) ||
        encodingComparer.compareBuild(referenceEncodingComparer)
      );
    };
    compareCharacterEncodings.exports = compareCharacterEncodingsByEncoding;
  },
);
var isBigIntGreaterThanZero = lazyModuleInitializer(
  (sortLogProcessesBySortingIndex, _sortLogProcessesBySortingIndex) => {
    var __sortLogProcessesBySortingIndex = getLogProcessSorterByIndex();
    var sortProcessesBySortingIndex = (
      ___sortLogProcessesBySortingIndex,
      sortLogProcessesByPriority,
    ) =>
      ___sortLogProcessesBySortingIndex.sort(
        (
          ____sortLogProcessesBySortingIndex,
          _____sortLogProcessesBySortingIndex,
        ) =>
          __sortLogProcessesBySortingIndex(
            ____sortLogProcessesBySortingIndex,
            _____sortLogProcessesBySortingIndex,
            sortLogProcessesByPriority,
          ),
      );
    _sortLogProcessesBySortingIndex.exports = sortProcessesBySortingIndex;
  },
);
var validateLoggingData = lazyModuleInitializer(
  (applyProcessLogSortingByIndex, sortProcessLogsByIndex) => {
    var _sortProcessLogsByIndex = getLogProcessSorterByIndex();
    var sortProcessLogsByIndexAndSort = (
      sortProcessLogsByIndexBasedOnLogEntries,
      currentLogProcessSortIndex,
    ) =>
      sortProcessLogsByIndexBasedOnLogEntries.sort(
        (sortAndIndexLogEntriesByProcess, processLogEntries) =>
          _sortProcessLogsByIndex(
            processLogEntries,
            sortAndIndexLogEntriesByProcess,
            currentLogProcessSortIndex,
          ),
      );
    sortProcessLogsByIndex.exports = sortProcessLogsByIndexAndSort;
  },
);
var readSignedInt16WithSignExtension = lazyModuleInitializer(
  (isBigIntGreaterThanZero, isBigIntPositive) => {
    var checkIfBigIntIsPositive = extractAndCompareBigInt();
    var _isBigIntGreaterThanZero = (
      _isBigIntPositive,
      valueToCheck,
      isValuePositive,
    ) =>
      checkIfBigIntIsPositive(
        _isBigIntPositive,
        valueToCheck,
        isValuePositive,
      ) > 0;
    isBigIntPositive.exports = _isBigIntGreaterThanZero;
  },
);
var checkIfBigIntIsNonPositive = lazyModuleInitializer(
  (isBigIntLessThanZero, isBigIntLessThan) => {
    var isBigIntNegative = extractAndCompareBigInt();
    var isBigIntLessThanNegative = (
      initialBigIntComparisonValue,
      compareInitialAndFirstBigIntValues,
      comparisonOutcome,
    ) =>
      isBigIntNegative(
        initialBigIntComparisonValue,
        compareInitialAndFirstBigIntValues,
        comparisonOutcome,
      ) < 0;
    isBigIntLessThan.exports = isBigIntLessThanNegative;
  },
);
var logBigIntProcessingInstance = lazyModuleInitializer(
  (checkIfBigIntIsNonZero, validateNonZeroBigInt) => {
    var _checkIfBigIntIsNonZero = extractAndCompareBigInt();
    var isValidNonZeroBigInt = (
      _validateNonZeroBigInt,
      validateNonZeroBigInteger,
      isValidNonZeroBigInt,
    ) =>
      _checkIfBigIntIsNonZero(
        _validateNonZeroBigInt,
        validateNonZeroBigInteger,
        isValidNonZeroBigInt,
      ) !== 0;
    validateNonZeroBigInt.exports = isValidNonZeroBigInt;
  },
);
var readBigInt64FromBuffer = lazyModuleInitializer(
  (isBigIntPositive, checkIfBigIntIsNonNegative) => {
    var validateAndVerifyBigIntNonNegativity = extractAndCompareBigInt();
    var isBigIntNonNegative = (
      validateBigIntegerArrayForNonNegativity,
      _validateAndVerifyBigIntNonNegativity,
      isBigIntArrayNonNegativeResult,
    ) =>
      validateAndVerifyBigIntNonNegativity(
        validateBigIntegerArrayForNonNegativity,
        _validateAndVerifyBigIntNonNegativity,
        isBigIntArrayNonNegativeResult,
      ) >= 0;
    checkIfBigIntIsNonNegative.exports = isBigIntNonNegative;
  },
);
var readBigInt64LEFromBuffer = lazyModuleInitializer(
  (_checkIfBigIntIsNonPositive, _isBigIntNonPositive) => {
    var evaluateBigIntAgainstThreshold = extractAndCompareBigInt();
    var evaluateIfBigIntIsNonPositive = (
      isBigIntLessThanOrEqualToThreshold,
      valueToCompareAgainstThreshold,
      thresholdLimit,
    ) =>
      evaluateBigIntAgainstThreshold(
        isBigIntLessThanOrEqualToThreshold,
        valueToCompareAgainstThreshold,
        thresholdLimit,
      ) <= 0;
    _isBigIntNonPositive.exports = evaluateIfBigIntIsNonPositive;
  },
);
var evaluateBufferComparison = lazyModuleInitializer(
  (compareValuesForStrictEquality, _compareValuesForStrictEquality) => {
    var extractIntegerFromBufferInstance = extractIntegerFromBuffer();
    var _logBigIntProcessingInstance = logBigIntProcessingInstance();
    var ___readSignedInt16WithSignExtension =
      readSignedInt16WithSignExtension();
    var __readBigInt64FromBuffer = readBigInt64FromBuffer();
    var checkAndApplyBitwiseOrMask = checkIfBigIntIsNonPositive();
    var lastReadBigIntValueFromBuffer = readBigInt64LEFromBuffer();
    var __compareValuesForStrictEquality = (
      evaluateComparisonAgainstOperator,
      _comparisonOperator,
      expectedValue,
      dataBufferPosition,
    ) => {
      switch (_comparisonOperator) {
        case "===":
          if (typeof evaluateComparisonAgainstOperator == "object") {
            evaluateComparisonAgainstOperator =
              evaluateComparisonAgainstOperator.version;
          }
          if (typeof expectedValue == "object") {
            expectedValue = expectedValue.version;
          }
          return evaluateComparisonAgainstOperator === expectedValue;
        case "!==":
          if (typeof evaluateComparisonAgainstOperator == "object") {
            evaluateComparisonAgainstOperator =
              evaluateComparisonAgainstOperator.version;
          }
          if (typeof expectedValue == "object") {
            expectedValue = expectedValue.version;
          }
          return evaluateComparisonAgainstOperator !== expectedValue;
        case "":
        case "=":
        case "==":
          return extractIntegerFromBufferInstance(
            evaluateComparisonAgainstOperator,
            expectedValue,
            dataBufferPosition,
          );
        case "!=":
          return _logBigIntProcessingInstance(
            evaluateComparisonAgainstOperator,
            expectedValue,
            dataBufferPosition,
          );
        case ">":
          return ___readSignedInt16WithSignExtension(
            evaluateComparisonAgainstOperator,
            expectedValue,
            dataBufferPosition,
          );
        case ">=":
          return __readBigInt64FromBuffer(
            evaluateComparisonAgainstOperator,
            expectedValue,
            dataBufferPosition,
          );
        case "<":
          return checkAndApplyBitwiseOrMask(
            evaluateComparisonAgainstOperator,
            expectedValue,
            dataBufferPosition,
          );
        case "<=":
          return lastReadBigIntValueFromBuffer(
            evaluateComparisonAgainstOperator,
            expectedValue,
            dataBufferPosition,
          );
        default:
          throw new TypeError("Invalid operator: " + _comparisonOperator);
      }
    };
    _compareValuesForStrictEquality.exports = __compareValuesForStrictEquality;
  },
);
var getMatchedCharacterEncodingFromInput = lazyModuleInitializer(
  (validateAndCoerceInputValue, extractAndCoerceValueFromInput) => {
    var validatedCharacterEncoding = validateAndProcessVersionEncoding();
    var extractedBigUInt64 = extractBigUInt64FromBuffer();
    var { re: encodingValidationRegex, t: intrinsicEncodingProperty } =
      validateAndStoreEncodingPattern();
    var validateAndCoerceCharacterEncoding = (
      _________validateAndProcessCharacterEncoding,
      encodingOptions,
    ) => {
      if (
        _________validateAndProcessCharacterEncoding instanceof
        validatedCharacterEncoding
      ) {
        return _________validateAndProcessCharacterEncoding;
      }
      if (typeof _________validateAndProcessCharacterEncoding == "number") {
        _________validateAndProcessCharacterEncoding = String(
          _________validateAndProcessCharacterEncoding,
        );
      }
      if (typeof _________validateAndProcessCharacterEncoding != "string") {
        return null;
      }
      encodingOptions = encodingOptions || {};
      let validatedEncodingResult = null;
      if (!encodingOptions.rtl) {
        validatedEncodingResult =
          _________validateAndProcessCharacterEncoding.match(
            encodingValidationRegex[intrinsicEncodingProperty.COERCE],
          );
      } else {
        let matchedEncodingSegment;
        while (
          (matchedEncodingSegment = encodingValidationRegex[
            intrinsicEncodingProperty.COERCERTL
          ].exec(_________validateAndProcessCharacterEncoding)) &&
          (!validatedEncodingResult ||
            validatedEncodingResult.index +
              validatedEncodingResult[0].length !==
              _________validateAndProcessCharacterEncoding.length)
        ) {
          if (
            !validatedEncodingResult ||
            matchedEncodingSegment.index + matchedEncodingSegment[0].length !==
              validatedEncodingResult.index + validatedEncodingResult[0].length
          ) {
            validatedEncodingResult = matchedEncodingSegment;
          }
          encodingValidationRegex[
            intrinsicEncodingProperty.COERCERTL
          ].lastIndex =
            matchedEncodingSegment.index +
            matchedEncodingSegment[1].length +
            matchedEncodingSegment[2].length;
        }
        encodingValidationRegex[intrinsicEncodingProperty.COERCERTL].lastIndex =
          -1;
      }
      if (validatedEncodingResult === null) {
        return null;
      } else {
        return extractedBigUInt64(
          validatedEncodingResult[2] +
            "." +
            (validatedEncodingResult[3] || "0") +
            "." +
            (validatedEncodingResult[4] || "0"),
          encodingOptions,
        );
      }
    };
    extractAndCoerceValueFromInput.exports = validateAndCoerceCharacterEncoding;
  },
);
var validateAndConcatenateBuffer = lazyModuleInitializer(
  (createBufferIterator, bufferConcatenatorIterator) => {
    bufferConcatenatorIterator.exports = function (
      initializeBufferConcatenator,
    ) {
      initializeBufferConcatenator.prototype[Symbol.iterator] = function* () {
        for (
          let currentIteratorNode = this.head;
          currentIteratorNode;
          currentIteratorNode = currentIteratorNode.next
        ) {
          yield currentIteratorNode.value;
        }
      };
    };
  },
);
var processAndValidateBuffer = lazyModuleInitializer(
  (setupBufferConcatenationContext, setupBufferConcatenationExports) => {
    setupBufferConcatenationExports.exports = BufferAggregator;
    BufferAggregator.Node = BigUInt64NodeList;
    BufferAggregator.create = BufferAggregator;
    function BufferAggregator(validateAndConcatenateBuffer) {
      var bufferAggregatorContext = this;
      if (!(bufferAggregatorContext instanceof BufferAggregator)) {
        bufferAggregatorContext = new BufferAggregator();
      }
      bufferAggregatorContext.tail = null;
      bufferAggregatorContext.head = null;
      bufferAggregatorContext.length = 0;
      if (
        validateAndConcatenateBuffer &&
        typeof validateAndConcatenateBuffer.forEach == "function"
      ) {
        validateAndConcatenateBuffer.forEach(
          function (removeAndCleanupBufferNode) {
            bufferAggregatorContext.push(removeAndCleanupBufferNode);
          },
        );
      } else if (arguments.length > 0) {
        for (
          var argumentIndex = 0, totalArguments = arguments.length;
          argumentIndex < totalArguments;
          argumentIndex++
        ) {
          bufferAggregatorContext.push(arguments[argumentIndex]);
        }
      }
      return bufferAggregatorContext;
    }
    BufferAggregator.prototype.removeNode = function (
      validateAndCleanupBufferNode,
    ) {
      if (validateAndCleanupBufferNode.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var nextBufferNode = validateAndCleanupBufferNode.next;
      var previousBufferNode = validateAndCleanupBufferNode.prev;
      if (nextBufferNode) {
        nextBufferNode.prev = previousBufferNode;
      }
      if (previousBufferNode) {
        previousBufferNode.next = nextBufferNode;
      }
      if (validateAndCleanupBufferNode === this.head) {
        this.head = nextBufferNode;
      }
      if (validateAndCleanupBufferNode === this.tail) {
        this.tail = previousBufferNode;
      }
      validateAndCleanupBufferNode.list.length--;
      validateAndCleanupBufferNode.next = null;
      validateAndCleanupBufferNode.prev = null;
      validateAndCleanupBufferNode.list = null;
      return nextBufferNode;
    };
    BufferAggregator.prototype.unshiftNode = function (addToBufferAndValidate) {
      if (addToBufferAndValidate !== this.head) {
        if (addToBufferAndValidate.list) {
          addToBufferAndValidate.list.removeNode(addToBufferAndValidate);
        }
        var currentHeadNode = this.head;
        addToBufferAndValidate.list = this;
        addToBufferAndValidate.next = currentHeadNode;
        if (currentHeadNode) {
          currentHeadNode.prev = addToBufferAndValidate;
        }
        this.head = addToBufferAndValidate;
        this.tail ||= addToBufferAndValidate;
        this.length++;
      }
    };
    BufferAggregator.prototype.pushNode = function (processAndStoreBufferData) {
      if (processAndStoreBufferData !== this.tail) {
        if (processAndStoreBufferData.list) {
          processAndStoreBufferData.list.removeNode(processAndStoreBufferData);
        }
        var lastTailNode = this.tail;
        processAndStoreBufferData.list = this;
        processAndStoreBufferData.prev = lastTailNode;
        if (lastTailNode) {
          lastTailNode.next = processAndStoreBufferData;
        }
        this.tail = processAndStoreBufferData;
        this.head ||= processAndStoreBufferData;
        this.length++;
      }
    };
    BufferAggregator.prototype.push = function () {
      for (
        var _currentArgumentIndex = 0, argumentsCount = arguments.length;
        _currentArgumentIndex < argumentsCount;
        _currentArgumentIndex++
      ) {
        appendAndLinkCharacterNode(this, arguments[_currentArgumentIndex]);
      }
      return this.length;
    };
    BufferAggregator.prototype.unshift = function () {
      for (
        var argumentIndex = 0, argumentsLength = arguments.length;
        argumentIndex < argumentsLength;
        argumentIndex++
      ) {
        initializeCharacterNodeAndLink(this, arguments[argumentIndex]);
      }
      return this.length;
    };
    BufferAggregator.prototype.pop = function () {
      if (this.tail) {
        var removedElementValue = this.tail.value;
        this.tail = this.tail.prev;
        if (this.tail) {
          this.tail.next = null;
        } else {
          this.head = null;
        }
        this.length--;
        return removedElementValue;
      }
    };
    BufferAggregator.prototype.shift = function () {
      if (this.head) {
        var extractedHeadValue = this.head.value;
        this.head = this.head.next;
        if (this.head) {
          this.head.prev = null;
        } else {
          this.tail = null;
        }
        this.length--;
        return extractedHeadValue;
      }
    };
    BufferAggregator.prototype.forEach = function (
      writeUnsignedInt16BigEndianForBufferConcatenation,
      writeUint16LittleEndianAndCheckBounds,
    ) {
      writeUint16LittleEndianAndCheckBounds =
        writeUint16LittleEndianAndCheckBounds || this;
      for (
        var __currentNode = this.head, _currentNodeIndex = 0;
        __currentNode !== null;
        _currentNodeIndex++
      ) {
        writeUnsignedInt16BigEndianForBufferConcatenation.call(
          writeUint16LittleEndianAndCheckBounds,
          __currentNode.value,
          _currentNodeIndex,
          this,
        );
        __currentNode = __currentNode.next;
      }
    };
    BufferAggregator.prototype.forEachReverse = function (
      __exportedRandomValueLength,
      writeUint16ToBufferLittleEndian,
    ) {
      writeUint16ToBufferLittleEndian = writeUint16ToBufferLittleEndian || this;
      for (
        var traverseTailNode = this.tail, currentNodeIndex = this.length - 1;
        traverseTailNode !== null;
        currentNodeIndex--
      ) {
        __exportedRandomValueLength.call(
          writeUint16ToBufferLittleEndian,
          traverseTailNode.value,
          currentNodeIndex,
          this,
        );
        traverseTailNode = traverseTailNode.prev;
      }
    };
    BufferAggregator.prototype.get = function (writeUnsignedInt16LE) {
      for (
        var maxIterations = 0, _currentLinkedListNode = this.head;
        _currentLinkedListNode !== null && maxIterations < writeUnsignedInt16LE;
        maxIterations++
      ) {
        _currentLinkedListNode = _currentLinkedListNode.next;
      }
      if (
        maxIterations === writeUnsignedInt16LE &&
        _currentLinkedListNode !== null
      ) {
        return _currentLinkedListNode.value;
      }
    };
    BufferAggregator.prototype.getReverse = function (
      writeUnsignedInt16AsBigEndian,
    ) {
      for (
        var traverseFromTailToHead = 0,
          currentNodeTraversingFromTail = this.tail;
        currentNodeTraversingFromTail !== null &&
        traverseFromTailToHead < writeUnsignedInt16AsBigEndian;
        traverseFromTailToHead++
      ) {
        currentNodeTraversingFromTail = currentNodeTraversingFromTail.prev;
      }
      if (
        traverseFromTailToHead === writeUnsignedInt16AsBigEndian &&
        currentNodeTraversingFromTail !== null
      ) {
        return currentNodeTraversingFromTail.value;
      }
    };
    BufferAggregator.prototype.map = function (
      writeUint32LE_optimized,
      calculateByteLengthForEncodedValue,
    ) {
      calculateByteLengthForEncodedValue =
        calculateByteLengthForEncodedValue || this;
      var valueBufferAggregator = new BufferAggregator();
      for (var ___currentNode = this.head; ___currentNode !== null; ) {
        valueBufferAggregator.push(
          writeUint32LE_optimized.call(
            calculateByteLengthForEncodedValue,
            ___currentNode.value,
            this,
          ),
        );
        ___currentNode = ___currentNode.next;
      }
      return valueBufferAggregator;
    };
    BufferAggregator.prototype.mapReverse = function (
      calculateTotalByteLength,
      __calculateEncodedByteLength,
    ) {
      __calculateEncodedByteLength = __calculateEncodedByteLength || this;
      var bufferLengthAggregator = new BufferAggregator();
      for (
        var currentNodeFromTail = this.tail;
        currentNodeFromTail !== null;

      ) {
        bufferLengthAggregator.push(
          calculateTotalByteLength.call(
            __calculateEncodedByteLength,
            currentNodeFromTail.value,
            this,
          ),
        );
        currentNodeFromTail = currentNodeFromTail.prev;
      }
      return bufferLengthAggregator;
    };
    BufferAggregator.prototype.reduce = function (
      applyFunctionToRandomValuesWithInitial,
      calculateByteLengthFromEncoding,
    ) {
      var initialValue;
      var currentNode = this.head;
      if (arguments.length > 1) {
        initialValue = calculateByteLengthFromEncoding;
      } else if (this.head) {
        currentNode = this.head.next;
        initialValue = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var randomValueIndex = 0; currentNode !== null; randomValueIndex++) {
        initialValue = applyFunctionToRandomValuesWithInitial(
          initialValue,
          currentNode.value,
          randomValueIndex,
        );
        currentNode = currentNode.next;
      }
      return initialValue;
    };
    BufferAggregator.prototype.reduceReverse = function (
      calculateRandomValueBasedOnCurrentNode,
      generateRandomValueBasedOnLength,
    ) {
      var accumulatorValue;
      var previousNode = this.tail;
      if (arguments.length > 1) {
        accumulatorValue = generateRandomValueBasedOnLength;
      } else if (this.tail) {
        previousNode = this.tail.prev;
        accumulatorValue = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (
        var currentNodeIndex = this.length - 1;
        previousNode !== null;
        currentNodeIndex--
      ) {
        accumulatorValue = calculateRandomValueBasedOnCurrentNode(
          accumulatorValue,
          previousNode.value,
          currentNodeIndex,
        );
        previousNode = previousNode.prev;
      }
      return accumulatorValue;
    };
    BufferAggregator.prototype.toArray = function () {
      var nodeValuesArray = new Array(this.length);
      for (
        var nodeIndex = 0, currentLinkedListNode = this.head;
        currentLinkedListNode !== null;
        nodeIndex++
      ) {
        nodeValuesArray[nodeIndex] = currentLinkedListNode.value;
        currentLinkedListNode = currentLinkedListNode.next;
      }
      return nodeValuesArray;
    };
    BufferAggregator.prototype.toArrayReverse = function () {
      var collectTailNodeValues = new Array(this.length);
      for (
        var countOfCollectedTailNodeValues = 0, currentTailNode = this.tail;
        currentTailNode !== null;
        countOfCollectedTailNodeValues++
      ) {
        collectTailNodeValues[countOfCollectedTailNodeValues] =
          currentTailNode.value;
        currentTailNode = currentTailNode.prev;
      }
      return collectTailNodeValues;
    };
    BufferAggregator.prototype.slice = function (
      maxIdentifierLength,
      getIdentifierSegmentsCount,
    ) {
      getIdentifierSegmentsCount = getIdentifierSegmentsCount || this.length;
      if (getIdentifierSegmentsCount < 0) {
        getIdentifierSegmentsCount += this.length;
      }
      maxIdentifierLength = maxIdentifierLength || 0;
      if (maxIdentifierLength < 0) {
        maxIdentifierLength += this.length;
      }
      var identifierBuffer = new BufferAggregator();
      if (
        getIdentifierSegmentsCount < maxIdentifierLength ||
        getIdentifierSegmentsCount < 0
      ) {
        return identifierBuffer;
      }
      if (maxIdentifierLength < 0) {
        maxIdentifierLength = 0;
      }
      if (getIdentifierSegmentsCount > this.length) {
        getIdentifierSegmentsCount = this.length;
      }
      for (
        var _currentSegmentIndex = 0, _currentNodeTraversal = this.head;
        _currentNodeTraversal !== null &&
        _currentSegmentIndex < maxIdentifierLength;
        _currentSegmentIndex++
      ) {
        _currentNodeTraversal = _currentNodeTraversal.next;
      }
      _currentSegmentIndex++;
      for (
        ;
        _currentNodeTraversal !== null &&
        _currentSegmentIndex < getIdentifierSegmentsCount;
        _currentNodeTraversal = _currentNodeTraversal.next
      ) {
        identifierBuffer.push(_currentNodeTraversal.value);
      }
      return identifierBuffer;
    };
    BufferAggregator.prototype.sliceReverse = function (
      getAndAccumulateEncodedValues,
      calculateAndStoreEncodedValues,
    ) {
      calculateAndStoreEncodedValues =
        calculateAndStoreEncodedValues || this.length;
      if (calculateAndStoreEncodedValues < 0) {
        calculateAndStoreEncodedValues += this.length;
      }
      getAndAccumulateEncodedValues = getAndAccumulateEncodedValues || 0;
      if (getAndAccumulateEncodedValues < 0) {
        getAndAccumulateEncodedValues += this.length;
      }
      var bufferConcatenatorAccumulator = new BufferAggregator();
      if (
        calculateAndStoreEncodedValues < getAndAccumulateEncodedValues ||
        calculateAndStoreEncodedValues < 0
      ) {
        return bufferConcatenatorAccumulator;
      }
      if (getAndAccumulateEncodedValues < 0) {
        getAndAccumulateEncodedValues = 0;
      }
      if (calculateAndStoreEncodedValues > this.length) {
        calculateAndStoreEncodedValues = this.length;
      }
      for (
        var _currentBufferIndex = this.length, _currentTailNode = this.tail;
        _currentTailNode !== null &&
        _currentBufferIndex > calculateAndStoreEncodedValues;
        _currentBufferIndex--
      ) {
        _currentTailNode = _currentTailNode.prev;
      }
      _currentBufferIndex--;
      for (
        ;
        _currentTailNode !== null &&
        _currentBufferIndex > getAndAccumulateEncodedValues;
        _currentTailNode = _currentTailNode.prev
      ) {
        bufferConcatenatorAccumulator.push(_currentTailNode.value);
      }
      return bufferConcatenatorAccumulator;
    };
    BufferAggregator.prototype.splice = function (
      retrieveAndLinkUniqueEncodedValues,
      getNextUniqueIdAndEncode,
      ...additionalValuesToEncode
    ) {
      if (retrieveAndLinkUniqueEncodedValues > this.length) {
        retrieveAndLinkUniqueEncodedValues = this.length - 1;
      }
      if (retrieveAndLinkUniqueEncodedValues < 0) {
        retrieveAndLinkUniqueEncodedValues =
          this.length + retrieveAndLinkUniqueEncodedValues;
      }
      for (
        var currentNodeId = 0, traversalNode = this.head;
        traversalNode !== null &&
        currentNodeId < retrieveAndLinkUniqueEncodedValues;
        currentNodeId++
      ) {
        traversalNode = traversalNode.next;
      }
      var extractedNodeValues = [];
      for (
        var currentNodeId = 0;
        traversalNode && currentNodeId < getNextUniqueIdAndEncode;
        currentNodeId++
      ) {
        extractedNodeValues.push(traversalNode.value);
        traversalNode = this.removeNode(traversalNode);
      }
      if (traversalNode === null) {
        traversalNode = this.tail;
      }
      if (traversalNode !== this.head && traversalNode !== this.tail) {
        traversalNode = traversalNode.prev;
      }
      for (
        var currentNodeId = 0;
        currentNodeId < additionalValuesToEncode.length;
        currentNodeId++
      ) {
        traversalNode = linkAndUpdateCharacterData(
          this,
          traversalNode,
          additionalValuesToEncode[currentNodeId],
        );
      }
      return extractedNodeValues;
    };
    BufferAggregator.prototype.reverse = function () {
      var _currentNode = this.head;
      var initialTail = this.tail;
      for (
        var currentNodeTraversal = _currentNode;
        currentNodeTraversal !== null;
        currentNodeTraversal = currentNodeTraversal.prev
      ) {
        var previousTraversalNode = currentNodeTraversal.prev;
        currentNodeTraversal.prev = currentNodeTraversal.next;
        currentNodeTraversal.next = previousTraversalNode;
      }
      this.head = initialTail;
      this.tail = _currentNode;
      return this;
    };
    function linkAndUpdateCharacterData(
      processAndMapCharacterData,
      storeAndUpdateEncodedCharacterData,
      updateAndStoreCharacterData,
    ) {
      var newCharacterDataNode =
        storeAndUpdateEncodedCharacterData === processAndMapCharacterData.head
          ? new BigUInt64NodeList(
              updateAndStoreCharacterData,
              null,
              storeAndUpdateEncodedCharacterData,
              processAndMapCharacterData,
            )
          : new BigUInt64NodeList(
              updateAndStoreCharacterData,
              storeAndUpdateEncodedCharacterData,
              storeAndUpdateEncodedCharacterData.next,
              processAndMapCharacterData,
            );
      if (newCharacterDataNode.next === null) {
        processAndMapCharacterData.tail = newCharacterDataNode;
      }
      if (newCharacterDataNode.prev === null) {
        processAndMapCharacterData.head = newCharacterDataNode;
      }
      processAndMapCharacterData.length++;
      return newCharacterDataNode;
    }
    function appendAndLinkCharacterNode(
      createAndLinkCharacterData,
      createBigUInt64LinkedList,
    ) {
      createAndLinkCharacterData.tail = new BigUInt64NodeList(
        createBigUInt64LinkedList,
        createAndLinkCharacterData.tail,
        null,
        createAndLinkCharacterData,
      );
      createAndLinkCharacterData.head ||= createAndLinkCharacterData.tail;
      createAndLinkCharacterData.length++;
    }
    function initializeCharacterNodeAndLink(
      createAndLinkBigUInt64Node,
      handleCharacterDataProcessing,
    ) {
      createAndLinkBigUInt64Node.head = new BigUInt64NodeList(
        handleCharacterDataProcessing,
        null,
        createAndLinkBigUInt64Node.head,
        createAndLinkBigUInt64Node,
      );
      createAndLinkBigUInt64Node.tail ||= createAndLinkBigUInt64Node.head;
      createAndLinkBigUInt64Node.length++;
    }
    function BigUInt64NodeList(
      storeBigUInt64InLittleEndianFormat,
      setNextBigUInt64,
      linkBigUInt64Nodes,
      writeIntAsLittleEndian,
    ) {
      if (!(this instanceof BigUInt64NodeList)) {
        return new BigUInt64NodeList(
          storeBigUInt64InLittleEndianFormat,
          setNextBigUInt64,
          linkBigUInt64Nodes,
          writeIntAsLittleEndian,
        );
      }
      this.list = writeIntAsLittleEndian;
      this.value = storeBigUInt64InLittleEndianFormat;
      if (setNextBigUInt64) {
        setNextBigUInt64.next = this;
        this.prev = setNextBigUInt64;
      } else {
        this.prev = null;
      }
      if (linkBigUInt64Nodes) {
        linkBigUInt64Nodes.prev = this;
        this.next = linkBigUInt64Nodes;
      } else {
        this.next = null;
      }
    }
    try {
      validateAndConcatenateBuffer()(BufferAggregator);
    } catch {}
  },
);
var updateCircularBufferForCache = lazyModuleInitializer(
  (createLRUCacheWithMaxSize, createLRUCacheWithMaxLimit) => {
    var _maxCacheSize = processAndValidateBuffer();
    var maxCacheSizeSymbol = Symbol("max");
    var cacheLengthSymbol = Symbol("length");
    var lengthCalculationAlgorithm = Symbol("lengthCalculator");
    var isStaleAllowed = Symbol("allowStale");
    var maxItemAgeSymbol = Symbol("maxAge");
    var disposeCacheItem = Symbol("dispose");
    var skipDisposeOnSet = Symbol("noDisposeOnSet");
    var lruCacheNodeList = Symbol("lruList");
    var cacheStorageSymbol = Symbol("cache");
    var updateCacheItemAgeOnGet = Symbol("updateAgeOnGet");
    var defaultCacheItemSizeCalculator = () => 1;
    var LRUCacheWithMaxSize = class {
      constructor(cacheOptions) {
        if (typeof cacheOptions == "number") {
          cacheOptions = {
            max: cacheOptions,
          };
        }
        cacheOptions ||= {};
        if (
          cacheOptions.max &&
          (typeof cacheOptions.max != "number" || cacheOptions.max < 0)
        ) {
          throw new TypeError("max must be a non-negative number");
        }
        let maximumCacheSize = (this[maxCacheSizeSymbol] =
          cacheOptions.max || Infinity);
        let _lengthCalculationAlgorithm =
          cacheOptions.length || defaultCacheItemSizeCalculator;
        if (typeof _lengthCalculationAlgorithm != "function") {
          this[lengthCalculationAlgorithm] = defaultCacheItemSizeCalculator;
        } else {
          this[lengthCalculationAlgorithm] = _lengthCalculationAlgorithm;
        }
        this[isStaleAllowed] = cacheOptions.stale || false;
        if (cacheOptions.maxAge && typeof cacheOptions.maxAge != "number") {
          throw new TypeError("maxAge must be a number");
        }
        this[maxItemAgeSymbol] = cacheOptions.maxAge || 0;
        this[disposeCacheItem] = cacheOptions.dispose;
        this[skipDisposeOnSet] = cacheOptions.noDisposeOnSet || false;
        this[updateCacheItemAgeOnGet] = cacheOptions.updateAgeOnGet || false;
        this.reset();
      }
      set max(setMaximumCacheSize) {
        if (typeof setMaximumCacheSize != "number" || setMaximumCacheSize < 0) {
          throw new TypeError("max must be a non-negative number");
        }
        this[maxCacheSizeSymbol] = setMaximumCacheSize || Infinity;
        maxCacheCapacity(this);
      }
      get max() {
        return this[maxCacheSizeSymbol];
      }
      set allowStale(setAllowStaleStatus) {
        this[isStaleAllowed] = !!setAllowStaleStatus;
      }
      get allowStale() {
        return this[isStaleAllowed];
      }
      set maxAge(setMaximumItemAge) {
        if (typeof setMaximumItemAge != "number") {
          throw new TypeError("maxAge must be a non-negative number");
        }
        this[maxItemAgeSymbol] = setMaximumItemAge;
        maxCacheCapacity(this);
      }
      get maxAge() {
        return this[maxItemAgeSymbol];
      }
      set lengthCalculator(setCacheItemSizeCalculator) {
        if (typeof setCacheItemSizeCalculator != "function") {
          setCacheItemSizeCalculator = defaultCacheItemSizeCalculator;
        }
        if (setCacheItemSizeCalculator !== this[lengthCalculationAlgorithm]) {
          this[lengthCalculationAlgorithm] = setCacheItemSizeCalculator;
          this[cacheLengthSymbol] = 0;
          this[lruCacheNodeList].forEach((calculatedLengthResult) => {
            calculatedLengthResult.length = this[lengthCalculationAlgorithm](
              calculatedLengthResult.value,
              calculatedLengthResult.key,
            );
            this[cacheLengthSymbol] += calculatedLengthResult.length;
          });
        }
        maxCacheCapacity(this);
      }
      get lengthCalculator() {
        return this[lengthCalculationAlgorithm];
      }
      get length() {
        return this[cacheLengthSymbol];
      }
      get itemCount() {
        return this[lruCacheNodeList].length;
      }
      rforEach(performCacheEviction, defaultCacheEvictionContext) {
        defaultCacheEvictionContext = defaultCacheEvictionContext || this;
        for (
          let traversingLruCacheNode = this[lruCacheNodeList].tail;
          traversingLruCacheNode !== null;

        ) {
          let evictedCacheNode = traversingLruCacheNode.prev;
          ___maxCacheSize(
            this,
            performCacheEviction,
            traversingLruCacheNode,
            defaultCacheEvictionContext,
          );
          traversingLruCacheNode = evictedCacheNode;
        }
      }
      forEach(iterateOverCacheEntries, cacheEntryHandler) {
        cacheEntryHandler = cacheEntryHandler || this;
        for (
          let currentCacheNode = this[lruCacheNodeList].head;
          currentCacheNode !== null;

        ) {
          let getNextCacheNode = currentCacheNode.next;
          ___maxCacheSize(
            this,
            iterateOverCacheEntries,
            currentCacheNode,
            cacheEntryHandler,
          );
          currentCacheNode = getNextCacheNode;
        }
      }
      keys() {
        return this[lruCacheNodeList]
          .toArray()
          .map((p801ConfigurationKey) => p801ConfigurationKey.key);
      }
      values() {
        return this[lruCacheNodeList]
          .toArray()
          .map((getP802Value) => getP802Value.value);
      }
      reset() {
        if (
          this[disposeCacheItem] &&
          this[lruCacheNodeList] &&
          this[lruCacheNodeList].length
        ) {
          this[lruCacheNodeList].forEach((clearCacheEntry) =>
            this[disposeCacheItem](clearCacheEntry.key, clearCacheEntry.value),
          );
        }
        this[cacheStorageSymbol] = new Map();
        this[lruCacheNodeList] = new _maxCacheSize();
        this[cacheLengthSymbol] = 0;
      }
      dump() {
        return this[lruCacheNodeList]
          .map((___cacheEntry) =>
            __maxCacheSize(this, ___cacheEntry)
              ? false
              : {
                  k: ___cacheEntry.key,
                  v: ___cacheEntry.value,
                  e: ___cacheEntry.now + (___cacheEntry.maxAge || 0),
                },
          )
          .toArray()
          .filter((handlePaymentProcessing) => handlePaymentProcessing);
      }
      dumpLru() {
        return this[lruCacheNodeList];
      }
      set(updateCacheItemWithExpiry, cachedValue, maxCacheItemAge) {
        maxCacheItemAge = maxCacheItemAge || this[maxItemAgeSymbol];
        if (maxCacheItemAge && typeof maxCacheItemAge != "number") {
          throw new TypeError("maxAge must be a number");
        }
        let cacheItemTimestamp = maxCacheItemAge ? Date.now() : 0;
        let computedCachedValueSize = this[lengthCalculationAlgorithm](
          cachedValue,
          updateCacheItemWithExpiry,
        );
        if (this[cacheStorageSymbol].has(updateCacheItemWithExpiry)) {
          if (computedCachedValueSize > this[maxCacheSizeSymbol]) {
            _maxCacheCapacity(
              this,
              this[cacheStorageSymbol].get(updateCacheItemWithExpiry),
            );
            return false;
          }
          let cachedItemForUpdate = this[cacheStorageSymbol].get(
            updateCacheItemWithExpiry,
          ).value;
          if (this[disposeCacheItem]) {
            if (!this[skipDisposeOnSet]) {
              this[disposeCacheItem](
                updateCacheItemWithExpiry,
                cachedItemForUpdate.value,
              );
            }
          }
          cachedItemForUpdate.now = cacheItemTimestamp;
          cachedItemForUpdate.maxAge = maxCacheItemAge;
          cachedItemForUpdate.value = cachedValue;
          this[cacheLengthSymbol] +=
            computedCachedValueSize - cachedItemForUpdate.length;
          cachedItemForUpdate.length = computedCachedValueSize;
          this.get(updateCacheItemWithExpiry);
          maxCacheCapacity(this);
          return true;
        }
        let _cacheEntry = new maxCacheSize(
          updateCacheItemWithExpiry,
          cachedValue,
          computedCachedValueSize,
          cacheItemTimestamp,
          maxCacheItemAge,
        );
        if (_cacheEntry.length > this[maxCacheSizeSymbol]) {
          if (this[disposeCacheItem]) {
            this[disposeCacheItem](updateCacheItemWithExpiry, cachedValue);
          }
          return false;
        } else {
          this[cacheLengthSymbol] += _cacheEntry.length;
          this[lruCacheNodeList].unshift(_cacheEntry);
          this[cacheStorageSymbol].set(
            updateCacheItemWithExpiry,
            this[lruCacheNodeList].head,
          );
          maxCacheCapacity(this);
          return true;
        }
      }
      has(isCachedValueUnderLimit) {
        if (!this[cacheStorageSymbol].has(isCachedValueUnderLimit)) {
          return false;
        }
        let cachedValueForLimitCheck = this[cacheStorageSymbol].get(
          isCachedValueUnderLimit,
        ).value;
        return !__maxCacheSize(this, cachedValueForLimitCheck);
      }
      get(__maxCacheCapacity) {
        return maximumCacheCapacity(this, __maxCacheCapacity, true);
      }
      peek(maximumCachedItems) {
        return maximumCacheCapacity(this, maximumCachedItems, false);
      }
      pop() {
        let lastNodeInCache = this[lruCacheNodeList].tail;
        if (lastNodeInCache) {
          _maxCacheCapacity(this, lastNodeInCache);
          return lastNodeInCache.value;
        } else {
          return null;
        }
      }
      del(cacheEntryToDelete) {
        _maxCacheCapacity(
          this,
          this[cacheStorageSymbol].get(cacheEntryToDelete),
        );
      }
      load(loadItemsThatHaveNotExpired) {
        this.reset();
        let currentSystemTimestamp = Date.now();
        for (
          let itemArrayIndex = loadItemsThatHaveNotExpired.length - 1;
          itemArrayIndex >= 0;
          itemArrayIndex--
        ) {
          let currentItemForProcessing =
            loadItemsThatHaveNotExpired[itemArrayIndex];
          let itemExpirationTimestamp = currentItemForProcessing.e || 0;
          if (itemExpirationTimestamp === 0) {
            this.set(currentItemForProcessing.k, currentItemForProcessing.v);
          } else {
            let remainingTimeBeforeExpiration =
              itemExpirationTimestamp - currentSystemTimestamp;
            if (remainingTimeBeforeExpiration > 0) {
              this.set(
                currentItemForProcessing.k,
                currentItemForProcessing.v,
                remainingTimeBeforeExpiration,
              );
            }
          }
        }
      }
      prune() {
        this[cacheStorageSymbol].forEach(
          (computeOptimalCacheCapacity, isUsingDefaultCache) =>
            maximumCacheCapacity(this, isUsingDefaultCache, false),
        );
      }
    };
    var maximumCacheCapacity = (
      retrieveCachedValue,
      cacheIdentifier,
      isCacheExpired,
    ) => {
      let cachedValue =
        retrieveCachedValue[cacheStorageSymbol].get(cacheIdentifier);
      if (cachedValue) {
        let currentCachedValue = cachedValue.value;
        if (__maxCacheSize(retrieveCachedValue, currentCachedValue)) {
          _maxCacheCapacity(retrieveCachedValue, cachedValue);
          if (!retrieveCachedValue[isStaleAllowed]) {
            return;
          }
        } else if (isCacheExpired) {
          if (retrieveCachedValue[updateCacheItemAgeOnGet]) {
            cachedValue.value.now = Date.now();
          }
          retrieveCachedValue[lruCacheNodeList].unshiftNode(cachedValue);
        }
        return currentCachedValue.value;
      }
    };
    var __maxCacheSize = (hasItemExpired, itemExpirationInfo) => {
      if (
        !itemExpirationInfo ||
        (!itemExpirationInfo.maxAge && !hasItemExpired[maxItemAgeSymbol])
      ) {
        return false;
      }
      let getElapsedTimeSinceCreation = Date.now() - itemExpirationInfo.now;
      if (itemExpirationInfo.maxAge) {
        return getElapsedTimeSinceCreation > itemExpirationInfo.maxAge;
      } else {
        return (
          hasItemExpired[maxItemAgeSymbol] &&
          getElapsedTimeSinceCreation > hasItemExpired[maxItemAgeSymbol]
        );
      }
    };
    var maxCacheCapacity = (adjustCacheSizeToLimit) => {
      if (
        adjustCacheSizeToLimit[cacheLengthSymbol] >
        adjustCacheSizeToLimit[maxCacheSizeSymbol]
      ) {
        for (
          let lruCacheNodeToEvict =
            adjustCacheSizeToLimit[lruCacheNodeList].tail;
          adjustCacheSizeToLimit[cacheLengthSymbol] >
            adjustCacheSizeToLimit[maxCacheSizeSymbol] &&
          lruCacheNodeToEvict !== null;

        ) {
          let lastEvictedCacheNode = lruCacheNodeToEvict.prev;
          _maxCacheCapacity(adjustCacheSizeToLimit, lruCacheNodeToEvict);
          lruCacheNodeToEvict = lastEvictedCacheNode;
        }
      }
    };
    var _maxCacheCapacity = (manageCacheItemLifecycle, processCacheItem) => {
      if (processCacheItem) {
        let cachedProcessItem = processCacheItem.value;
        if (manageCacheItemLifecycle[disposeCacheItem]) {
          manageCacheItemLifecycle[disposeCacheItem](
            cachedProcessItem.key,
            cachedProcessItem.value,
          );
        }
        manageCacheItemLifecycle[cacheLengthSymbol] -= cachedProcessItem.length;
        manageCacheItemLifecycle[cacheStorageSymbol].delete(
          cachedProcessItem.key,
        );
        manageCacheItemLifecycle[lruCacheNodeList].removeNode(processCacheItem);
      }
    };
    var maxCacheSize = class {
      constructor(
        keyValue,
        data,
        durationInSeconds,
        currentTimeInMilliseconds,
        maxAllowedAge,
      ) {
        this.key = keyValue;
        this.value = data;
        this.length = durationInSeconds;
        this.now = currentTimeInMilliseconds;
        this.maxAge = maxAllowedAge || 0;
      }
    };
    var ___maxCacheSize = (
      cacheEntryProcessor,
      _processCacheEntry,
      __cacheEntry,
      processingContext,
    ) => {
      let currentCacheEntryValue = __cacheEntry.value;
      if (__maxCacheSize(cacheEntryProcessor, currentCacheEntryValue)) {
        _maxCacheCapacity(cacheEntryProcessor, __cacheEntry);
        if (!cacheEntryProcessor[isStaleAllowed]) {
          currentCacheEntryValue = undefined;
        }
      }
      if (currentCacheEntryValue) {
        _processCacheEntry.call(
          processingContext,
          currentCacheEntryValue.value,
          currentCacheEntryValue.key,
          cacheEntryProcessor,
        );
      }
    };
    createLRUCacheWithMaxLimit.exports = LRUCacheWithMaxSize;
  },
);
var createSemanticVersionRangeFromInput = lazyModuleInitializer(
  (initializeSemanticVersionRange, _initializeSemanticVersionRange) => {
    var VersionRangeParser = class {
      constructor(versionInput, normalizedVersionOptions) {
        normalizedVersionOptions = normalizeVersionOptions(
          normalizedVersionOptions,
        );
        if (versionInput instanceof VersionRangeParser) {
          if (
            versionInput.loose === !!normalizedVersionOptions.loose &&
            versionInput.includePrerelease ===
              !!normalizedVersionOptions.includePrerelease
          ) {
            return versionInput;
          } else {
            return new VersionRangeParser(
              versionInput.raw,
              normalizedVersionOptions,
            );
          }
        }
        if (versionInput instanceof SemanticVersionRange) {
          this.raw = versionInput.value;
          this.set = [[versionInput]];
          this.format();
          return this;
        }
        this.options = normalizedVersionOptions;
        this.loose = !!normalizedVersionOptions.loose;
        this.includePrerelease = !!normalizedVersionOptions.includePrerelease;
        this.raw = versionInput;
        this.set = versionInput
          .split("||")
          .map((extractAndTrimRange) =>
            this.parseRange(extractAndTrimRange.trim()),
          )
          .filter((getArrayLength) => getArrayLength.length);
        if (!this.set.length) {
          throw new TypeError("Invalid SemVer Range: " + versionInput);
        }
        if (this.set.length > 1) {
          let _initialVersionRange = this.set[0];
          this.set = this.set.filter(
            (isVersionRangeInvalid) =>
              !initializeSemanticVersioningRange(isVersionRangeInvalid[0]),
          );
          if (this.set.length === 0) {
            this.set = [_initialVersionRange];
          } else if (this.set.length > 1) {
            for (let versionRangeSet of this.set) {
              if (
                versionRangeSet.length === 1 &&
                _VersionRangeParser(versionRangeSet[0])
              ) {
                this.set = [versionRangeSet];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set
          .map((joinAndTrimAndCleanStringArray) =>
            joinAndTrimAndCleanStringArray.join(" ").trim(),
          )
          .join("||")
          .trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(parsedVersionRange) {
        parsedVersionRange = parsedVersionRange.trim();
        let logParsedVersionRangeDetails =
          "parseRange:" +
          Object.keys(this.options).join(",") +
          ":" +
          parsedVersionRange;
        let cachedVersionRangeParsingResult =
          __initializeSemanticVersionRange.get(logParsedVersionRangeDetails);
        if (cachedVersionRangeParsingResult) {
          return cachedVersionRangeParsingResult;
        }
        let isLooseParsingEnabled = this.options.loose;
        let versionRangeHyphenPattern = isLooseParsingEnabled
          ? __SemanticVersionRangeParser[
              ___SemanticVersionRangeParser.HYPHENRANGELOOSE
            ]
          : __SemanticVersionRangeParser[
              ___SemanticVersionRangeParser.HYPHENRANGE
            ];
        parsedVersionRange = parsedVersionRange.replace(
          versionRangeHyphenPattern,
          ___VersionRangeParser(this.options.includePrerelease),
        );
        SemanticVersionRangeParser("hyphen replace", parsedVersionRange);
        parsedVersionRange = parsedVersionRange.replace(
          __SemanticVersionRangeParser[
            ___SemanticVersionRangeParser.COMPARATORTRIM
          ],
          VersionRange,
        );
        SemanticVersionRangeParser("comparator trim", parsedVersionRange);
        parsedVersionRange = parsedVersionRange.replace(
          __SemanticVersionRangeParser[___SemanticVersionRangeParser.TILDETRIM],
          _VersionRange,
        );
        parsedVersionRange = parsedVersionRange.replace(
          __SemanticVersionRangeParser[___SemanticVersionRangeParser.CARETTRIM],
          ____SemanticVersionRangeParser,
        );
        parsedVersionRange = parsedVersionRange.split(/\s+/).join(" ");
        let parseSemanticVersionRange = parsedVersionRange
          .split(" ")
          .map((_________SemanticVersionRangeParser) =>
            _____SemanticVersionRangeParser(
              _________SemanticVersionRangeParser,
              this.options,
            ),
          )
          .join(" ")
          .split(/\s+/)
          .map((parseSemanticVersionRange) =>
            __VersionRange(parseSemanticVersionRange, this.options),
          );
        if (isLooseParsingEnabled) {
          parseSemanticVersionRange = parseSemanticVersionRange.filter(
            (validateLooseInvalidFilter) => {
              SemanticVersionRangeParser(
                "loose invalid filter",
                validateLooseInvalidFilter,
                this.options,
              );
              return !!validateLooseInvalidFilter.match(
                __SemanticVersionRangeParser[
                  ___SemanticVersionRangeParser.COMPARATORLOOSE
                ],
              );
            },
          );
        }
        SemanticVersionRangeParser("range list", parseSemanticVersionRange);
        let _parseSemanticVersionRange = new Map();
        let parseVersionRange = parseSemanticVersionRange.map(
          (___currentSemanticVersion) =>
            new SemanticVersionRange(___currentSemanticVersion, this.options),
        );
        for (let _semanticVersionRange of parseVersionRange) {
          if (initializeSemanticVersioningRange(_semanticVersionRange)) {
            return [_semanticVersionRange];
          }
          _parseSemanticVersionRange.set(
            _semanticVersionRange.value,
            _semanticVersionRange,
          );
        }
        if (
          _parseSemanticVersionRange.size > 1 &&
          _parseSemanticVersionRange.has("")
        ) {
          _parseSemanticVersionRange.delete("");
        }
        let _parseVersionRange = [..._parseSemanticVersionRange.values()];
        __initializeSemanticVersionRange.set(
          logParsedVersionRangeDetails,
          _parseVersionRange,
        );
        return _parseVersionRange;
      }
      intersects(isSemanticVersionRangeIntersecting, _currentSemanticVersion) {
        if (
          !(isSemanticVersionRangeIntersecting instanceof VersionRangeParser)
        ) {
          throw new TypeError("a Range is required");
        }
        return this.set.some(
          (__checkVersionRangeCompatibility) =>
            initializeAndParseSemanticVersionRange(
              __checkVersionRangeCompatibility,
              _currentSemanticVersion,
            ) &&
            isSemanticVersionRangeIntersecting.set.some(
              (checkSemanticVersionCompatibility) =>
                initializeAndParseSemanticVersionRange(
                  checkSemanticVersionCompatibility,
                  _currentSemanticVersion,
                ) &&
                __checkVersionRangeCompatibility.every(
                  (checkAllVersionsCompatibility) =>
                    checkSemanticVersionCompatibility.every(
                      (targetVersionForCompatibilityCheck) =>
                        checkAllVersionsCompatibility.intersects(
                          targetVersionForCompatibilityCheck,
                          _currentSemanticVersion,
                        ),
                    ),
                ),
            ),
        );
      }
      test(versionRange) {
        if (!versionRange) {
          return false;
        }
        if (typeof versionRange == "string") {
          try {
            versionRange = new _SemanticVersionRangeParser(
              versionRange,
              this.options,
            );
          } catch {
            return false;
          }
        }
        for (
          let currentSetVersionIndex = 0;
          currentSetVersionIndex < this.set.length;
          currentSetVersionIndex++
        ) {
          if (
            ________SemanticVersionRangeParser(
              this.set[currentSetVersionIndex],
              versionRange,
              this.options,
            )
          ) {
            return true;
          }
        }
        return false;
      }
    };
    _initializeSemanticVersionRange.exports = VersionRangeParser;
    var initializeVersionRangeParser = updateCircularBufferForCache();
    var __initializeSemanticVersionRange = new initializeVersionRangeParser({
      max: 1000,
    });
    var normalizeVersionOptions = compareNumericStrings();
    var SemanticVersionRange = parseSemVerComparator();
    var SemanticVersionRangeParser = validateAndAddEncodingPattern();
    var _SemanticVersionRangeParser = validateAndProcessVersionEncoding();
    var {
      re: __SemanticVersionRangeParser,
      t: ___SemanticVersionRangeParser,
      comparatorTrimReplace: VersionRange,
      tildeTrimReplace: _VersionRange,
      caretTrimReplace: ____SemanticVersionRangeParser,
    } = validateAndStoreEncodingPattern();
    var initializeSemanticVersioningRange = (isVersionBelowMinimumThreshold) =>
      isVersionBelowMinimumThreshold.value === "<0.0.0-0";
    var _VersionRangeParser = (hasEmptyInputValue) =>
      hasEmptyInputValue.value === "";
    var initializeAndParseSemanticVersionRange = (
      areAllShapesOverlapping,
      checkShapeIntersections,
    ) => {
      let areAllShapesIntersecting = true;
      let remainingShapes = areAllShapesOverlapping.slice();
      let shapeToCheckAgainst = remainingShapes.pop();
      while (areAllShapesIntersecting && remainingShapes.length) {
        areAllShapesIntersecting = remainingShapes.every(
          (targetShapeForIntersectionCheck) =>
            shapeToCheckAgainst.intersects(
              targetShapeForIntersectionCheck,
              checkShapeIntersections,
            ),
        );
        shapeToCheckAgainst = remainingShapes.pop();
      }
      return areAllShapesIntersecting;
    };
    var _____SemanticVersionRangeParser = (
      initialVersionRange,
      versionComparisonFunction,
    ) => {
      SemanticVersionRangeParser(
        "comp",
        initialVersionRange,
        versionComparisonFunction,
      );
      initialVersionRange = __VersionRangeHandler(
        initialVersionRange,
        versionComparisonFunction,
      );
      SemanticVersionRangeParser("caret", initialVersionRange);
      initialVersionRange = _VersionRangeHandler(
        initialVersionRange,
        versionComparisonFunction,
      );
      SemanticVersionRangeParser("tildes", initialVersionRange);
      initialVersionRange = VersionRangeConstructor(
        initialVersionRange,
        versionComparisonFunction,
      );
      SemanticVersionRangeParser("xrange", initialVersionRange);
      initialVersionRange = ___initializeSemanticVersionRange(
        initialVersionRange,
        versionComparisonFunction,
      );
      SemanticVersionRangeParser("stars", initialVersionRange);
      return initialVersionRange;
    };
    var VersionRangeHandler = (isInputEmptyOrSpecial) =>
      !isInputEmptyOrSpecial ||
      isInputEmptyOrSpecial.toLowerCase() === "x" ||
      isInputEmptyOrSpecial === "*";
    var _VersionRangeHandler = (
      processAndParseSemanticVersionRanges,
      semanticVersionRangeParser,
    ) =>
      processAndParseSemanticVersionRanges
        .trim()
        .split(/\s+/)
        .map((__validateSemanticVersionRange) =>
          ______SemanticVersionRangeParser(
            __validateSemanticVersionRange,
            semanticVersionRangeParser,
          ),
        )
        .join(" ");
    var ______SemanticVersionRangeParser = (
      transformTildeInSemanticVersionRange,
      tildeSemanticVersionRange,
    ) => {
      let mergedTildeSemanticVersionParser = tildeSemanticVersionRange.loose
        ? __SemanticVersionRangeParser[___SemanticVersionRangeParser.TILDELOOSE]
        : __SemanticVersionRangeParser[___SemanticVersionRangeParser.TILDE];
      return transformTildeInSemanticVersionRange.replace(
        mergedTildeSemanticVersionParser,
        (
          createSemanticVersionRange,
          majorVersion,
          _minorVersion,
          patchVersion,
          preReleaseTag,
        ) => {
          SemanticVersionRangeParser(
            "tilde",
            transformTildeInSemanticVersionRange,
            createSemanticVersionRange,
            majorVersion,
            _minorVersion,
            patchVersion,
            preReleaseTag,
          );
          let semanticVersionRange;
          if (VersionRangeHandler(majorVersion)) {
            semanticVersionRange = "";
          } else if (VersionRangeHandler(_minorVersion)) {
            semanticVersionRange =
              ">=" + majorVersion + ".0.0 <" + (+majorVersion + 1) + ".0.0-0";
          } else if (VersionRangeHandler(patchVersion)) {
            semanticVersionRange =
              ">=" +
              majorVersion +
              "." +
              _minorVersion +
              ".0 <" +
              majorVersion +
              "." +
              (+_minorVersion + 1) +
              ".0-0";
          } else if (preReleaseTag) {
            SemanticVersionRangeParser("replaceTilde pr", preReleaseTag);
            semanticVersionRange =
              ">=" +
              majorVersion +
              "." +
              _minorVersion +
              "." +
              patchVersion +
              "-" +
              preReleaseTag +
              " <" +
              majorVersion +
              "." +
              (+_minorVersion + 1) +
              ".0-0";
          } else {
            semanticVersionRange =
              ">=" +
              majorVersion +
              "." +
              _minorVersion +
              "." +
              patchVersion +
              " <" +
              majorVersion +
              "." +
              (+_minorVersion + 1) +
              ".0-0";
          }
          SemanticVersionRangeParser("tilde return", semanticVersionRange);
          return semanticVersionRange;
        },
      );
    };
    var __VersionRangeHandler = (
      processVersionRangeWithComparisonOperator,
      ___comparisonOperator,
    ) =>
      processVersionRangeWithComparisonOperator
        .trim()
        .split(/\s+/)
        .map((compareVersionToRange) =>
          __VersionRangeParser(compareVersionToRange, ___comparisonOperator),
        )
        .join(" ");
    var __VersionRangeParser = (
      currentSemanticVersion,
      semanticVersionOptions,
    ) => {
      SemanticVersionRangeParser(
        "caret",
        currentSemanticVersion,
        semanticVersionOptions,
      );
      let selectedVersionRangePattern = semanticVersionOptions.loose
        ? __SemanticVersionRangeParser[___SemanticVersionRangeParser.CARETLOOSE]
        : __SemanticVersionRangeParser[___SemanticVersionRangeParser.CARET];
      let prereleaseVersionSuffix = semanticVersionOptions.includePrerelease
        ? "-0"
        : "";
      return currentSemanticVersion.replace(
        selectedVersionRangePattern,
        (
          baseVersion,
          minorVersion,
          prereleaseIdentifier,
          preReleaseVersionInfo,
          isPrereleaseVersionEnabled,
        ) => {
          SemanticVersionRangeParser(
            "caret",
            currentSemanticVersion,
            baseVersion,
            minorVersion,
            prereleaseIdentifier,
            preReleaseVersionInfo,
            isPrereleaseVersionEnabled,
          );
          let versionRangeConditionBasedOnPrerelease;
          if (VersionRangeHandler(minorVersion)) {
            versionRangeConditionBasedOnPrerelease = "";
          } else if (VersionRangeHandler(prereleaseIdentifier)) {
            versionRangeConditionBasedOnPrerelease =
              ">=" +
              minorVersion +
              ".0.0" +
              prereleaseVersionSuffix +
              " <" +
              (+minorVersion + 1) +
              ".0.0-0";
          } else if (VersionRangeHandler(preReleaseVersionInfo)) {
            if (minorVersion === "0") {
              versionRangeConditionBasedOnPrerelease =
                ">=" +
                minorVersion +
                "." +
                prereleaseIdentifier +
                ".0" +
                prereleaseVersionSuffix +
                " <" +
                minorVersion +
                "." +
                (+prereleaseIdentifier + 1) +
                ".0-0";
            } else {
              versionRangeConditionBasedOnPrerelease =
                ">=" +
                minorVersion +
                "." +
                prereleaseIdentifier +
                ".0" +
                prereleaseVersionSuffix +
                " <" +
                (+minorVersion + 1) +
                ".0.0-0";
            }
          } else if (isPrereleaseVersionEnabled) {
            SemanticVersionRangeParser(
              "replaceCaret pr",
              isPrereleaseVersionEnabled,
            );
            if (minorVersion === "0") {
              if (prereleaseIdentifier === "0") {
                versionRangeConditionBasedOnPrerelease =
                  ">=" +
                  minorVersion +
                  "." +
                  prereleaseIdentifier +
                  "." +
                  preReleaseVersionInfo +
                  "-" +
                  isPrereleaseVersionEnabled +
                  " <" +
                  minorVersion +
                  "." +
                  prereleaseIdentifier +
                  "." +
                  (+preReleaseVersionInfo + 1) +
                  "-0";
              } else {
                versionRangeConditionBasedOnPrerelease =
                  ">=" +
                  minorVersion +
                  "." +
                  prereleaseIdentifier +
                  "." +
                  preReleaseVersionInfo +
                  "-" +
                  isPrereleaseVersionEnabled +
                  " <" +
                  minorVersion +
                  "." +
                  (+prereleaseIdentifier + 1) +
                  ".0-0";
              }
            } else {
              versionRangeConditionBasedOnPrerelease =
                ">=" +
                minorVersion +
                "." +
                prereleaseIdentifier +
                "." +
                preReleaseVersionInfo +
                "-" +
                isPrereleaseVersionEnabled +
                " <" +
                (+minorVersion + 1) +
                ".0.0-0";
            }
          } else {
            SemanticVersionRangeParser("no pr");
            if (minorVersion === "0") {
              if (prereleaseIdentifier === "0") {
                versionRangeConditionBasedOnPrerelease =
                  ">=" +
                  minorVersion +
                  "." +
                  prereleaseIdentifier +
                  "." +
                  preReleaseVersionInfo +
                  prereleaseVersionSuffix +
                  " <" +
                  minorVersion +
                  "." +
                  prereleaseIdentifier +
                  "." +
                  (+preReleaseVersionInfo + 1) +
                  "-0";
              } else {
                versionRangeConditionBasedOnPrerelease =
                  ">=" +
                  minorVersion +
                  "." +
                  prereleaseIdentifier +
                  "." +
                  preReleaseVersionInfo +
                  prereleaseVersionSuffix +
                  " <" +
                  minorVersion +
                  "." +
                  (+prereleaseIdentifier + 1) +
                  ".0-0";
              }
            } else {
              versionRangeConditionBasedOnPrerelease =
                ">=" +
                minorVersion +
                "." +
                prereleaseIdentifier +
                "." +
                preReleaseVersionInfo +
                " <" +
                (+minorVersion + 1) +
                ".0.0-0";
            }
          }
          SemanticVersionRangeParser(
            "caret return",
            versionRangeConditionBasedOnPrerelease,
          );
          return versionRangeConditionBasedOnPrerelease;
        },
      );
    };
    var VersionRangeConstructor = (inputVersionRange, updatedVersionRange) => {
      SemanticVersionRangeParser(
        "replaceXRanges",
        inputVersionRange,
        updatedVersionRange,
      );
      return inputVersionRange
        .split(/\s+/)
        .map((parseSemanticVersionRangeUpdatedVersionRangeVersionRange) =>
          _______SemanticVersionRangeParser(
            parseSemanticVersionRangeUpdatedVersionRangeVersionRange,
            updatedVersionRange,
          ),
        )
        .join(" ");
    };
    var _______SemanticVersionRangeParser = (
      versionString,
      semanticVersionOptions,
    ) => {
      versionString = versionString.trim();
      let versionRangePattern = semanticVersionOptions.loose
        ? __SemanticVersionRangeParser[
            ___SemanticVersionRangeParser.XRANGELOOSE
          ]
        : __SemanticVersionRangeParser[___SemanticVersionRangeParser.XRANGE];
      return versionString.replace(
        versionRangePattern,
        (
          majorVersion,
          __comparisonOperator,
          previousVersionConstraint,
          currentVersionConstraint,
          referenceVersion,
          prereleaseSuffix,
        ) => {
          SemanticVersionRangeParser(
            "xRange",
            versionString,
            majorVersion,
            __comparisonOperator,
            previousVersionConstraint,
            currentVersionConstraint,
            referenceVersion,
            prereleaseSuffix,
          );
          let previousVersionRangeHandler = VersionRangeHandler(
            previousVersionConstraint,
          );
          let activeVersionRange =
            previousVersionRangeHandler ||
            VersionRangeHandler(currentVersionConstraint);
          let _activeVersionRange =
            activeVersionRange || VersionRangeHandler(referenceVersion);
          let activeVersion = _activeVersionRange;
          if (__comparisonOperator === "=" && activeVersion) {
            __comparisonOperator = "";
          }
          if (semanticVersionOptions.includePrerelease) {
            prereleaseSuffix = "-0";
          } else {
            prereleaseSuffix = "";
          }
          if (previousVersionRangeHandler) {
            if (__comparisonOperator === ">" || __comparisonOperator === "<") {
              majorVersion = "<0.0.0-0";
            } else {
              majorVersion = "*";
            }
          } else if (__comparisonOperator && activeVersion) {
            if (activeVersionRange) {
              currentVersionConstraint = 0;
            }
            referenceVersion = 0;
            if (__comparisonOperator === ">") {
              __comparisonOperator = ">=";
              if (activeVersionRange) {
                previousVersionConstraint = +previousVersionConstraint + 1;
                currentVersionConstraint = 0;
                referenceVersion = 0;
              } else {
                currentVersionConstraint = +currentVersionConstraint + 1;
                referenceVersion = 0;
              }
            } else if (__comparisonOperator === "<=") {
              __comparisonOperator = "<";
              if (activeVersionRange) {
                previousVersionConstraint = +previousVersionConstraint + 1;
              } else {
                currentVersionConstraint = +currentVersionConstraint + 1;
              }
            }
            if (__comparisonOperator === "<") {
              prereleaseSuffix = "-0";
            }
            majorVersion =
              __comparisonOperator +
              previousVersionConstraint +
              "." +
              currentVersionConstraint +
              "." +
              referenceVersion +
              prereleaseSuffix;
          } else if (activeVersionRange) {
            majorVersion =
              ">=" +
              previousVersionConstraint +
              ".0.0" +
              prereleaseSuffix +
              " <" +
              (+previousVersionConstraint + 1) +
              ".0.0-0";
          } else if (_activeVersionRange) {
            majorVersion =
              ">=" +
              previousVersionConstraint +
              "." +
              currentVersionConstraint +
              ".0" +
              prereleaseSuffix +
              " <" +
              previousVersionConstraint +
              "." +
              (+currentVersionConstraint + 1) +
              ".0-0";
          }
          SemanticVersionRangeParser("xRange return", majorVersion);
          return majorVersion;
        },
      );
    };
    var ___initializeSemanticVersionRange = (
      userInputVersionRange,
      removePlaceholderVersionsFromRange,
    ) => {
      SemanticVersionRangeParser(
        "replaceStars",
        userInputVersionRange,
        removePlaceholderVersionsFromRange,
      );
      return userInputVersionRange
        .trim()
        .replace(
          __SemanticVersionRangeParser[___SemanticVersionRangeParser.STAR],
          "",
        );
    };
    var __VersionRange = (
      parseAndCleanSemanticVersionRange,
      shouldIncludePrereleaseVersions,
    ) => {
      SemanticVersionRangeParser(
        "replaceGTE0",
        parseAndCleanSemanticVersionRange,
        shouldIncludePrereleaseVersions,
      );
      return parseAndCleanSemanticVersionRange
        .trim()
        .replace(
          __SemanticVersionRangeParser[
            shouldIncludePrereleaseVersions.includePrerelease
              ? ___SemanticVersionRangeParser.GTE0PRE
              : ___SemanticVersionRangeParser.GTE0
          ],
          "",
        );
    };
    var ___VersionRangeParser =
      (generateSemanticVersionRange) =>
      (
        generateSemanticVersionRange,
        calculatedSemanticVersionRange,
        baseVersion,
        minimumSupportedPatchVersionRange,
        minimumSupportedPatchVersion,
        isBaseVersionPresent,
        _currentSemanticVersionRange,
        minimumCompatibleSemanticVersionRange,
        minimumCompatibleVersionThreshold,
        computeCompatibleSemanticVersionRange,
        getCurrentSemanticVersionRange,
        currentCompatiblePatchVersionRange,
        minimumSupportedVersionRangeForCompatibility,
      ) => {
        if (VersionRangeHandler(baseVersion)) {
          calculatedSemanticVersionRange = "";
        } else if (VersionRangeHandler(minimumSupportedPatchVersionRange)) {
          calculatedSemanticVersionRange =
            ">=" +
            baseVersion +
            ".0.0" +
            (generateSemanticVersionRange ? "-0" : "");
        } else if (VersionRangeHandler(minimumSupportedPatchVersion)) {
          calculatedSemanticVersionRange =
            ">=" +
            baseVersion +
            "." +
            minimumSupportedPatchVersionRange +
            ".0" +
            (generateSemanticVersionRange ? "-0" : "");
        } else if (isBaseVersionPresent) {
          calculatedSemanticVersionRange =
            ">=" + calculatedSemanticVersionRange;
        } else {
          calculatedSemanticVersionRange =
            ">=" +
            calculatedSemanticVersionRange +
            (generateSemanticVersionRange ? "-0" : "");
        }
        if (VersionRangeHandler(minimumCompatibleVersionThreshold)) {
          minimumCompatibleSemanticVersionRange = "";
        } else if (VersionRangeHandler(computeCompatibleSemanticVersionRange)) {
          minimumCompatibleSemanticVersionRange =
            "<" + (+minimumCompatibleVersionThreshold + 1) + ".0.0-0";
        } else if (VersionRangeHandler(getCurrentSemanticVersionRange)) {
          minimumCompatibleSemanticVersionRange =
            "<" +
            minimumCompatibleVersionThreshold +
            "." +
            (+computeCompatibleSemanticVersionRange + 1) +
            ".0-0";
        } else if (currentCompatiblePatchVersionRange) {
          minimumCompatibleSemanticVersionRange =
            "<=" +
            minimumCompatibleVersionThreshold +
            "." +
            computeCompatibleSemanticVersionRange +
            "." +
            getCurrentSemanticVersionRange +
            "-" +
            currentCompatiblePatchVersionRange;
        } else if (generateSemanticVersionRange) {
          minimumCompatibleSemanticVersionRange =
            "<" +
            minimumCompatibleVersionThreshold +
            "." +
            computeCompatibleSemanticVersionRange +
            "." +
            (+getCurrentSemanticVersionRange + 1) +
            "-0";
        } else {
          minimumCompatibleSemanticVersionRange =
            "<=" + minimumCompatibleSemanticVersionRange;
        }
        return (
          calculatedSemanticVersionRange +
          " " +
          minimumCompatibleSemanticVersionRange
        ).trim();
      };
    var ________SemanticVersionRangeParser = (
      checkSemverCompatibilityWithPrerelease,
      _currentVersion,
      isPrereleaseAllowed,
    ) => {
      for (
        let prereleaseVersionIndex = 0;
        prereleaseVersionIndex < checkSemverCompatibilityWithPrerelease.length;
        prereleaseVersionIndex++
      ) {
        if (
          !checkSemverCompatibilityWithPrerelease[prereleaseVersionIndex].test(
            _currentVersion,
          )
        ) {
          return false;
        }
      }
      if (
        _currentVersion.prerelease.length &&
        !isPrereleaseAllowed.includePrerelease
      ) {
        for (
          let currentIndex = 0;
          currentIndex < checkSemverCompatibilityWithPrerelease.length;
          currentIndex++
        ) {
          SemanticVersionRangeParser(
            checkSemverCompatibilityWithPrerelease[currentIndex].semver,
          );
          if (
            checkSemverCompatibilityWithPrerelease[currentIndex].semver !==
              SemanticVersionRange.ANY &&
            checkSemverCompatibilityWithPrerelease[currentIndex].semver
              .prerelease.length > 0
          ) {
            let currentReleaseVersion =
              checkSemverCompatibilityWithPrerelease[currentIndex].semver;
            if (
              currentReleaseVersion.major === _currentVersion.major &&
              currentReleaseVersion.minor === _currentVersion.minor &&
              currentReleaseVersion.patch === _currentVersion.patch
            ) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  },
);
var parseSemVerComparator = lazyModuleInitializer(
  (_createSemVerComparator, initializeSemVerComparator) => {
    var SemVerWildcardSymbol = Symbol("SemVer ANY");
    var SemanticVersionComparator = class {
      static get ANY() {
        return SemVerWildcardSymbol;
      }
      constructor(comparatorExpression, sanitizedComparatorOptions) {
        sanitizedComparatorOptions = sanitizeComparatorOptions(
          sanitizedComparatorOptions,
        );
        if (comparatorExpression instanceof SemanticVersionComparator) {
          if (
            comparatorExpression.loose === !!sanitizedComparatorOptions.loose
          ) {
            return comparatorExpression;
          }
          comparatorExpression = comparatorExpression.value;
        }
        logComparatorInstanceCreation(
          "comparator",
          comparatorExpression,
          sanitizedComparatorOptions,
        );
        this.options = sanitizedComparatorOptions;
        this.loose = !!sanitizedComparatorOptions.loose;
        this.parse(comparatorExpression);
        if (this.semver === SemVerWildcardSymbol) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        logComparatorInstanceCreation("comp", this);
      }
      parse(parseComparatorString) {
        let comparatorStringPatternRegex = this.options.loose
          ? semVerComparator[semanticVersionComparatorPattern.COMPARATORLOOSE]
          : semVerComparator[semanticVersionComparatorPattern.COMPARATOR];
        let parsedComparatorMatch = parseComparatorString.match(
          comparatorStringPatternRegex,
        );
        if (!parsedComparatorMatch) {
          throw new TypeError("Invalid comparator: " + parseComparatorString);
        }
        if (parsedComparatorMatch[1] !== undefined) {
          this.operator = parsedComparatorMatch[1];
        } else {
          this.operator = "";
        }
        if (this.operator === "=") {
          this.operator = "";
        }
        if (parsedComparatorMatch[2]) {
          this.semver = new _SemanticVersionComparator(
            parsedComparatorMatch[2],
            this.options.loose,
          );
        } else {
          this.semver = SemVerWildcardSymbol;
        }
      }
      toString() {
        return this.value;
      }
      test(_semanticVersionComparator) {
        logComparatorInstanceCreation(
          "Comparator.test",
          _semanticVersionComparator,
          this.options.loose,
        );
        if (
          this.semver === SemVerWildcardSymbol ||
          _semanticVersionComparator === SemVerWildcardSymbol
        ) {
          return true;
        }
        if (typeof _semanticVersionComparator == "string") {
          try {
            _semanticVersionComparator = new _SemanticVersionComparator(
              _semanticVersionComparator,
              this.options,
            );
          } catch {
            return false;
          }
        }
        return logSemanticVersionComparatorCreation(
          _semanticVersionComparator,
          this.operator,
          this.semver,
          this.options,
        );
      }
      intersects(semanticVersionComparator, intersectOptions) {
        if (!(semanticVersionComparator instanceof SemanticVersionComparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!intersectOptions || typeof intersectOptions != "object") {
          intersectOptions = {
            loose: !!intersectOptions,
            includePrerelease: false,
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          } else {
            return new initializeSemanticVersionComparator(
              semanticVersionComparator.value,
              intersectOptions,
            ).test(this.value);
          }
        }
        if (semanticVersionComparator.operator === "") {
          if (semanticVersionComparator.value === "") {
            return true;
          } else {
            return new initializeSemanticVersionComparator(
              this.value,
              intersectOptions,
            ).test(semanticVersionComparator.semver);
          }
        }
        let areVersionRangesCompatible =
          (this.operator === ">=" || this.operator === ">") &&
          (semanticVersionComparator.operator === ">=" ||
            semanticVersionComparator.operator === ">");
        let areSemanticVersionsCompatible =
          (this.operator === "<=" || this.operator === "<") &&
          (semanticVersionComparator.operator === "<=" ||
            semanticVersionComparator.operator === "<");
        let areVersionRangesEquivalent =
          this.semver.version === semanticVersionComparator.semver.version;
        let areVersionRangesCompatibleWithComparator =
          (this.operator === ">=" || this.operator === "<=") &&
          (semanticVersionComparator.operator === ">=" ||
            semanticVersionComparator.operator === "<=");
        let _checkVersionRangeCompatibility =
          logSemanticVersionComparatorCreation(
            this.semver,
            "<",
            semanticVersionComparator.semver,
            intersectOptions,
          ) &&
          (this.operator === ">=" || this.operator === ">") &&
          (semanticVersionComparator.operator === "<=" ||
            semanticVersionComparator.operator === "<");
        let _areSemanticVersionsCompatible =
          logSemanticVersionComparatorCreation(
            this.semver,
            ">",
            semanticVersionComparator.semver,
            intersectOptions,
          ) &&
          (this.operator === "<=" || this.operator === "<") &&
          (semanticVersionComparator.operator === ">=" ||
            semanticVersionComparator.operator === ">");
        return (
          areVersionRangesCompatible ||
          areSemanticVersionsCompatible ||
          (areVersionRangesEquivalent &&
            areVersionRangesCompatibleWithComparator) ||
          _checkVersionRangeCompatibility ||
          _areSemanticVersionsCompatible
        );
      }
    };
    initializeSemVerComparator.exports = SemanticVersionComparator;
    var sanitizeComparatorOptions = compareNumericStrings();
    var { re: semVerComparator, t: semanticVersionComparatorPattern } =
      validateAndStoreEncodingPattern();
    var logSemanticVersionComparatorCreation = evaluateBufferComparison();
    var logComparatorInstanceCreation = validateAndAddEncodingPattern();
    var _SemanticVersionComparator = validateAndProcessVersionEncoding();
    var initializeSemanticVersionComparator =
      createSemanticVersionRangeFromInput();
  },
);
var hexCharacterPairsGenerator = lazyModuleInitializer(
  (compareAndTestSegmentBounds, testSegmentBoundsWithComparisonTester) => {
    var createAndTestSegmentBounds = createSemanticVersionRangeFromInput();
    var validateAndCompareSegmentBoundaries = (
      testSegmentBoundsComparison,
      createAndTestSegmentBoundsComparison,
      segmentBoundsTester,
    ) => {
      try {
        createAndTestSegmentBoundsComparison = new createAndTestSegmentBounds(
          createAndTestSegmentBoundsComparison,
          segmentBoundsTester,
        );
      } catch {
        return false;
      }
      return createAndTestSegmentBoundsComparison.test(
        testSegmentBoundsComparison,
      );
    };
    testSegmentBoundsWithComparisonTester.exports =
      validateAndCompareSegmentBoundaries;
  },
);
var createHexColorPairs = lazyModuleInitializer(
  (generateBoundSegmentValues, exportSegmentBoundValues) => {
    var generateAndExportSegmentBoundValues =
      createSemanticVersionRangeFromInput();
    var createSegmentBoundValueStrings = (
      compareSegmentBoundsAndExtractValues,
      compareAndExtractSegmentBoundValues,
    ) =>
      new generateAndExportSegmentBoundValues(
        compareSegmentBoundsAndExtractValues,
        compareAndExtractSegmentBoundValues,
      ).set.map((mapAndFormatInputFieldValues) =>
        mapAndFormatInputFieldValues
          .map((inputFieldValueElement) => inputFieldValueElement.value)
          .join(" ")
          .trim()
          .split(" "),
      );
    exportSegmentBoundValues.exports = createSegmentBoundValueStrings;
  },
);
var retrieveBestMatchingCharacterProperties = lazyModuleInitializer(
  (
    validateAndGetMostRecentCharacter,
    validateAndRetrieveMostRecentValidCharacter,
  ) => {
    var characterInputValidator = validateAndProcessVersionEncoding();
    var createCharacterValidationRange = createSemanticVersionRangeFromInput();
    var findAndValidateMostRecentCharacter = (
      getLatestValidCharacterInput,
      _createCharacterValidationRange,
      validationRangeBoundary,
    ) => {
      let latestValidCharacterInput = null;
      let _characterInputValidator = null;
      let createCharacterValidatorInstance = null;
      try {
        createCharacterValidatorInstance = new createCharacterValidationRange(
          _createCharacterValidationRange,
          validationRangeBoundary,
        );
      } catch {
        return null;
      }
      getLatestValidCharacterInput.forEach((validatedCharacterInput) => {
        if (
          createCharacterValidatorInstance.test(validatedCharacterInput) &&
          (!latestValidCharacterInput ||
            _characterInputValidator.compare(validatedCharacterInput) === -1)
        ) {
          latestValidCharacterInput = validatedCharacterInput;
          _characterInputValidator = new characterInputValidator(
            latestValidCharacterInput,
            validationRangeBoundary,
          );
        }
      });
      return latestValidCharacterInput;
    };
    validateAndRetrieveMostRecentValidCharacter.exports =
      findAndValidateMostRecentCharacter;
  },
);
var validateAndRetrieveSemanticVersioningProperties = lazyModuleInitializer(
  (getOptimalCharacterEncodingMatch, findMostCompatibleEncodingSegment) => {
    var _characterEncodingValidator = validateAndProcessVersionEncoding();
    var findOptimalEncodingSegmentForMatch =
      createSemanticVersionRangeFromInput();
    var _findMostCompatibleEncodingSegment = (
      getOptimalEncodingMatch,
      optimalEncodingSegment,
      candidateEncodingToTest,
    ) => {
      let selectedOptimalEncoding = null;
      let __characterEncodingValidator = null;
      let optimalSegmentMatch = null;
      try {
        optimalSegmentMatch = new findOptimalEncodingSegmentForMatch(
          optimalEncodingSegment,
          candidateEncodingToTest,
        );
      } catch {
        return null;
      }
      getOptimalEncodingMatch.forEach((validCharacterEncoding) => {
        if (
          optimalSegmentMatch.test(validCharacterEncoding) &&
          (!selectedOptimalEncoding ||
            __characterEncodingValidator.compare(validCharacterEncoding) === 1)
        ) {
          selectedOptimalEncoding = validCharacterEncoding;
          __characterEncodingValidator = new _characterEncodingValidator(
            selectedOptimalEncoding,
            candidateEncodingToTest,
          );
        }
      });
      return selectedOptimalEncoding;
    };
    findMostCompatibleEncodingSegment.exports =
      _findMostCompatibleEncodingSegment;
  },
);
var validateAndRetrieveSemverBounds = lazyModuleInitializer(
  (
    validateSemanticVersionAgainstRange,
    _validateSemanticVersionAgainstRange,
  ) => {
    var SemanticVersionValidator = validateAndProcessVersionEncoding();
    var createSemanticVersionBounds = createSemanticVersionRangeFromInput();
    var __readSignedInt16WithSignExtension = readSignedInt16WithSignExtension();
    var validateSemanticVersionWithinBounds = (
      createAndValidateSemanticVersion,
      semanticVersioningBounds,
    ) => {
      createAndValidateSemanticVersion = new createSemanticVersionBounds(
        createAndValidateSemanticVersion,
        semanticVersioningBounds,
      );
      let defaultSemanticVersion = new SemanticVersionValidator("0.0.0");
      if (
        createAndValidateSemanticVersion.test(defaultSemanticVersion) ||
        ((defaultSemanticVersion = new SemanticVersionValidator("0.0.0-0")),
        createAndValidateSemanticVersion.test(defaultSemanticVersion))
      ) {
        return defaultSemanticVersion;
      }
      defaultSemanticVersion = null;
      for (
        let semverSetIndex = 0;
        semverSetIndex < createAndValidateSemanticVersion.set.length;
        ++semverSetIndex
      ) {
        let validatedSemanticVersionSet =
          createAndValidateSemanticVersion.set[semverSetIndex];
        let bestValidatedSemanticVersion = null;
        validatedSemanticVersionSet.forEach(
          (validateAndProcessSemanticVersion) => {
            let semanticVersionHandler = new SemanticVersionValidator(
              validateAndProcessSemanticVersion.semver.version,
            );
            switch (validateAndProcessSemanticVersion.operator) {
              case ">":
                if (semanticVersionHandler.prerelease.length === 0) {
                  semanticVersionHandler.patch++;
                } else {
                  semanticVersionHandler.prerelease.push(0);
                }
                semanticVersionHandler.raw = semanticVersionHandler.format();
              case "":
              case ">=":
                if (
                  !bestValidatedSemanticVersion ||
                  __readSignedInt16WithSignExtension(
                    semanticVersionHandler,
                    bestValidatedSemanticVersion,
                  )
                ) {
                  bestValidatedSemanticVersion = semanticVersionHandler;
                }
                break;
              case "<":
              case "<=":
                break;
              default:
                throw new Error(
                  "Unexpected operation: " +
                    validateAndProcessSemanticVersion.operator,
                );
            }
          },
        );
        if (
          bestValidatedSemanticVersion &&
          (!defaultSemanticVersion ||
            __readSignedInt16WithSignExtension(
              defaultSemanticVersion,
              bestValidatedSemanticVersion,
            ))
        ) {
          defaultSemanticVersion = bestValidatedSemanticVersion;
        }
      }
      if (
        defaultSemanticVersion &&
        createAndValidateSemanticVersion.test(defaultSemanticVersion)
      ) {
        return defaultSemanticVersion;
      } else {
        return null;
      }
    };
    _validateSemanticVersionAgainstRange.exports =
      validateSemanticVersionWithinBounds;
  },
);
var validateAndRetrieveIntrinsicValueFromEncoding = lazyModuleInitializer(
  (generateAndExportSegmentRange, generateAndExportSegmentRangeFromPoints) => {
    var _createSegmentRangeFromInput = createSemanticVersionRangeFromInput();
    var createSegmentRangeFromStartEndValues = (
      inputRangeToSegment,
      createSegmentFromInputRange,
    ) => {
      try {
        return (
          new _createSegmentRangeFromInput(
            inputRangeToSegment,
            createSegmentFromInputRange,
          ).range || "*"
        );
      } catch {
        return null;
      }
    };
    generateAndExportSegmentRangeFromPoints.exports =
      createSegmentRangeFromStartEndValues;
  },
);
var segmentComparisonIndex = lazyModuleInitializer(
  (compareSegmentValues, segmentComparisonOperator) => {
    var VersionEncodingProcessor = validateAndProcessVersionEncoding();
    var parsedSemanticVersionComparator = parseSemVerComparator();
    var { ANY: parsedAnyValue } = parsedSemanticVersionComparator;
    var createSegmentRangeFromInput = createSemanticVersionRangeFromInput();
    var generateHexCharacterPairs = hexCharacterPairsGenerator();
    var _readSignedInt16WithSignExtension = readSignedInt16WithSignExtension();
    var checkForZeroOrNegativeBigInt = checkIfBigIntIsNonPositive();
    var signedBigInt64Value = readBigInt64LEFromBuffer();
    var _readBigInt64FromBuffer = readBigInt64FromBuffer();
    var compareEncodedVersionSegments = (
      characterEncodingProcessor,
      encodingSegmentBounds,
      _comparisonOperatorSymbol,
      segmentLengthForEncoding,
    ) => {
      characterEncodingProcessor = new VersionEncodingProcessor(
        characterEncodingProcessor,
        segmentLengthForEncoding,
      );
      encodingSegmentBounds = new createSegmentRangeFromInput(
        encodingSegmentBounds,
        segmentLengthForEncoding,
      );
      let valueForComparisonOperation;
      let bigIntComparisonValue;
      let maskedValueForComparison;
      let comparisonOperator;
      let comparisonOperatorBound;
      switch (_comparisonOperatorSymbol) {
        case ">":
          valueForComparisonOperation = _readSignedInt16WithSignExtension;
          bigIntComparisonValue = signedBigInt64Value;
          maskedValueForComparison = checkForZeroOrNegativeBigInt;
          comparisonOperator = ">";
          comparisonOperatorBound = ">=";
          break;
        case "<":
          valueForComparisonOperation = checkForZeroOrNegativeBigInt;
          bigIntComparisonValue = _readBigInt64FromBuffer;
          maskedValueForComparison = _readSignedInt16WithSignExtension;
          comparisonOperator = "<";
          comparisonOperatorBound = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (
        generateHexCharacterPairs(
          characterEncodingProcessor,
          encodingSegmentBounds,
          segmentLengthForEncoding,
        )
      ) {
        return false;
      }
      for (
        let currentEncodingSegmentIndex = 0;
        currentEncodingSegmentIndex < encodingSegmentBounds.set.length;
        ++currentEncodingSegmentIndex
      ) {
        let currentSegmentBounds =
          encodingSegmentBounds.set[currentEncodingSegmentIndex];
        let mostRecentValidSegment = null;
        let mostRecentProcessedSegment = null;
        currentSegmentBounds.forEach((__currentSemanticVersion) => {
          if (__currentSemanticVersion.semver === parsedAnyValue) {
            __currentSemanticVersion = new parsedSemanticVersionComparator(
              ">=0.0.0",
            );
          }
          mostRecentValidSegment =
            mostRecentValidSegment || __currentSemanticVersion;
          mostRecentProcessedSegment =
            mostRecentProcessedSegment || __currentSemanticVersion;
          if (
            valueForComparisonOperation(
              __currentSemanticVersion.semver,
              mostRecentValidSegment.semver,
              segmentLengthForEncoding,
            )
          ) {
            mostRecentValidSegment = __currentSemanticVersion;
          } else if (
            maskedValueForComparison(
              __currentSemanticVersion.semver,
              mostRecentProcessedSegment.semver,
              segmentLengthForEncoding,
            )
          ) {
            mostRecentProcessedSegment = __currentSemanticVersion;
          }
        });
        if (
          mostRecentValidSegment.operator === comparisonOperator ||
          mostRecentValidSegment.operator === comparisonOperatorBound ||
          ((!mostRecentProcessedSegment.operator ||
            mostRecentProcessedSegment.operator === comparisonOperator) &&
            bigIntComparisonValue(
              characterEncodingProcessor,
              mostRecentProcessedSegment.semver,
            ))
        ) {
          return false;
        }
        if (
          mostRecentProcessedSegment.operator === comparisonOperatorBound &&
          maskedValueForComparison(
            characterEncodingProcessor,
            mostRecentProcessedSegment.semver,
          )
        ) {
          return false;
        }
      }
      return true;
    };
    segmentComparisonOperator.exports = compareEncodedVersionSegments;
  },
);
var validateAndRetrieveIntrinsicValues = lazyModuleInitializer(
  (
    getGreaterIndexComparisonFunction,
    getComparisonFunctionForCurrentIndexGreaterThan,
  ) => {
    var createGreaterIndexComparisonFunction = segmentComparisonIndex();
    var createComparisonFunctionForCurrentIndexHigherThan = (
      isCurrentIndexExceedingThreshold,
      comparisonValueForThresholdCheck,
      thresholdForIndexComparison,
    ) =>
      createGreaterIndexComparisonFunction(
        isCurrentIndexExceedingThreshold,
        comparisonValueForThresholdCheck,
        ">",
        thresholdForIndexComparison,
      );
    getComparisonFunctionForCurrentIndexGreaterThan.exports =
      createComparisonFunctionForCurrentIndexHigherThan;
  },
);
var ____validateAndRetrieveIntrinsicValue = lazyModuleInitializer(
  (
    compareValuesByThresholdAndIndex,
    compareValuesLessThanThresholdBasedOnIndex,
  ) => {
    var compareAndFilterValuesAgainstThreshold = segmentComparisonIndex();
    var filterValuesBelowThresholdBasedOnIndex = (
      compareAndFilterValuesByThreshold,
      comparisonValueThreshold,
      valueBeingCompared,
    ) =>
      compareAndFilterValuesAgainstThreshold(
        compareAndFilterValuesByThreshold,
        comparisonValueThreshold,
        "<",
        valueBeingCompared,
      );
    compareValuesLessThanThresholdBasedOnIndex.exports =
      filterValuesBelowThresholdBasedOnIndex;
  },
);
var validateAndExtractHexCharacterRanges = lazyModuleInitializer(
  (
    validateAndExportSegmentIntersection,
    _validateAndExportSegmentIntersection,
  ) => {
    var initializeSegmentIntersection = createSemanticVersionRangeFromInput();
    var validateSegmentIntersection = (
      initializeAndCheckSegmentIntersections,
      checkSegmentIntersections,
      calculateSegmentIntersections,
    ) => {
      initializeAndCheckSegmentIntersections =
        new initializeSegmentIntersection(
          initializeAndCheckSegmentIntersections,
          calculateSegmentIntersections,
        );
      checkSegmentIntersections = new initializeSegmentIntersection(
        checkSegmentIntersections,
        calculateSegmentIntersections,
      );
      return initializeAndCheckSegmentIntersections.intersects(
        checkSegmentIntersections,
      );
    };
    _validateAndExportSegmentIntersection.exports = validateSegmentIntersection;
  },
);
var validateAndRetrieveValidHexCharacterRanges = lazyModuleInitializer(
  (validateAndSortHexCharacterRanges, processAndValidateHexCharacterRanges) => {
    var isValidHexCharacterRange = hexCharacterPairsGenerator();
    var compareHexCharacterValues = extractAndCompareBigInt();
    processAndValidateHexCharacterRanges.exports = (
      extractValidHexCharacterRanges,
      processHexCharacterRanges,
      traverseAndCollectValidHexRanges,
    ) => {
      let validHexCharacterRanges = [];
      let activeHexCharacter = null;
      let activeHexCharacterRange = null;
      let sortedValidHexCharacterRanges = extractValidHexCharacterRanges.sort(
        (compareCharacterHexSortingCriteria, characterHexSortCriteria) =>
          compareHexCharacterValues(
            compareCharacterHexSortingCriteria,
            characterHexSortCriteria,
            traverseAndCollectValidHexRanges,
          ),
      );
      for (let hexCharacterRange of sortedValidHexCharacterRanges) {
        if (
          isValidHexCharacterRange(
            hexCharacterRange,
            processHexCharacterRanges,
            traverseAndCollectValidHexRanges,
          )
        ) {
          activeHexCharacterRange = hexCharacterRange;
          activeHexCharacter ||= hexCharacterRange;
        } else {
          if (activeHexCharacterRange) {
            validHexCharacterRanges.push([
              activeHexCharacter,
              activeHexCharacterRange,
            ]);
          }
          activeHexCharacterRange = null;
          activeHexCharacter = null;
        }
      }
      if (activeHexCharacter) {
        validHexCharacterRanges.push([activeHexCharacter, null]);
      }
      let collectValidHexCharacterRanges = [];
      for (let [
        hexCharacterRange,
        currentHexCharacter,
      ] of validHexCharacterRanges) {
        if (hexCharacterRange === currentHexCharacter) {
          collectValidHexCharacterRanges.push(hexCharacterRange);
        } else if (
          !currentHexCharacter &&
          hexCharacterRange === sortedValidHexCharacterRanges[0]
        ) {
          collectValidHexCharacterRanges.push("*");
        } else if (currentHexCharacter) {
          if (hexCharacterRange === sortedValidHexCharacterRanges[0]) {
            collectValidHexCharacterRanges.push("<=" + currentHexCharacter);
          } else {
            collectValidHexCharacterRanges.push(
              hexCharacterRange + " - " + currentHexCharacter,
            );
          }
        } else {
          collectValidHexCharacterRanges.push(">=" + hexCharacterRange);
        }
      }
      let _activeHexCharacterRange =
        collectValidHexCharacterRanges.join(" || ");
      let currentHexCharacterRange =
        typeof processHexCharacterRanges.raw == "string"
          ? processHexCharacterRanges.raw
          : String(processHexCharacterRanges);
      if (_activeHexCharacterRange.length < currentHexCharacterRange.length) {
        return _activeHexCharacterRange;
      } else {
        return processHexCharacterRanges;
      }
    };
  },
);
var compareSegmentBoundsAndCheckOverlap = lazyModuleInitializer(
  (areVersionSegmentsComparable, areVersionSegmentsCompatible) => {
    var _SemanticVersionRange = createSemanticVersionRangeFromInput();
    var parsedSemanticVersionData = parseSemVerComparator();
    var { ANY: wildcardCharacter } = parsedSemanticVersionData;
    var hexCharacterPairsForComparison = hexCharacterPairsGenerator();
    var compareBigIntValues = extractAndCompareBigInt();
    var areVersionSegmentsIdentical = (
      areVersionRangesOverlapping,
      areVersionRangesIdentical,
      userPreferences = {},
    ) => {
      if (areVersionRangesOverlapping === areVersionRangesIdentical) {
        return true;
      }
      areVersionRangesOverlapping = new _SemanticVersionRange(
        areVersionRangesOverlapping,
        userPreferences,
      );
      areVersionRangesIdentical = new _SemanticVersionRange(
        areVersionRangesIdentical,
        userPreferences,
      );
      let isAnyVersionSegmentOverlapping = false;
      _0x2c2450: for (let versionSegmentToCheck of areVersionRangesOverlapping.set) {
        for (let comparableVersionSegment of areVersionRangesIdentical.set) {
          let areVersionSegmentsIdenticallyEqual =
            areVersionSegmentsIdenticalStrictly(
              versionSegmentToCheck,
              comparableVersionSegment,
              userPreferences,
            );
          isAnyVersionSegmentOverlapping =
            isAnyVersionSegmentOverlapping ||
            areVersionSegmentsIdenticallyEqual !== null;
          if (areVersionSegmentsIdenticallyEqual) {
            continue _0x2c2450;
          }
        }
        if (isAnyVersionSegmentOverlapping) {
          return false;
        }
      }
      return true;
    };
    var areVersionSegmentsIdenticalStrictly = (
      versionConstraints,
      currentVersion,
      versionConstraintsEvaluationOptions,
    ) => {
      if (versionConstraints === currentVersion) {
        return true;
      }
      if (
        versionConstraints.length === 1 &&
        versionConstraints[0].semver === wildcardCharacter
      ) {
        if (
          currentVersion.length === 1 &&
          currentVersion[0].semver === wildcardCharacter
        ) {
          return true;
        }
        if (versionConstraintsEvaluationOptions.includePrerelease) {
          versionConstraints = [new parsedSemanticVersionData(">=0.0.0-0")];
        } else {
          versionConstraints = [new parsedSemanticVersionData(">=0.0.0")];
        }
      }
      if (
        currentVersion.length === 1 &&
        currentVersion[0].semver === wildcardCharacter
      ) {
        if (versionConstraintsEvaluationOptions.includePrerelease) {
          return true;
        }
        currentVersion = [new parsedSemanticVersionData(">=0.0.0")];
      }
      let usedVersionConstraints = new Set();
      let latestComparisonOutcome;
      let previousComparisonOutcome;
      for (let versionConstraintComparison of versionConstraints) {
        if (
          versionConstraintComparison.operator === ">" ||
          versionConstraintComparison.operator === ">="
        ) {
          latestComparisonOutcome = _areVersionSegmentsIdenticalStrictly(
            latestComparisonOutcome,
            versionConstraintComparison,
            versionConstraintsEvaluationOptions,
          );
        } else if (
          versionConstraintComparison.operator === "<" ||
          versionConstraintComparison.operator === "<="
        ) {
          previousComparisonOutcome = _areVersionSegmentsIdentical(
            previousComparisonOutcome,
            versionConstraintComparison,
            versionConstraintsEvaluationOptions,
          );
        } else {
          usedVersionConstraints.add(versionConstraintComparison.semver);
        }
      }
      if (usedVersionConstraints.size > 1) {
        return null;
      }
      let versionCriteria;
      if (latestComparisonOutcome && previousComparisonOutcome) {
        versionCriteria = compareBigIntValues(
          latestComparisonOutcome.semver,
          previousComparisonOutcome.semver,
          versionConstraintsEvaluationOptions,
        );
        if (versionCriteria > 0) {
          return null;
        }
        if (
          versionCriteria === 0 &&
          (latestComparisonOutcome.operator !== ">=" ||
            previousComparisonOutcome.operator !== "<=")
        ) {
          return null;
        }
      }
      for (let currentUsedVersion of usedVersionConstraints) {
        if (
          (latestComparisonOutcome &&
            !hexCharacterPairsForComparison(
              currentUsedVersion,
              String(latestComparisonOutcome),
              versionConstraintsEvaluationOptions,
            )) ||
          (previousComparisonOutcome &&
            !hexCharacterPairsForComparison(
              currentUsedVersion,
              String(previousComparisonOutcome),
              versionConstraintsEvaluationOptions,
            ))
        ) {
          return null;
        }
        for (let characterInCurrentVersion of currentVersion) {
          if (
            !hexCharacterPairsForComparison(
              currentUsedVersion,
              String(characterInCurrentVersion),
              versionConstraintsEvaluationOptions,
            )
          ) {
            return false;
          }
        }
        return true;
      }
      let versionConstraintList;
      let _evaluateVersionConstraints;
      let evaluateVersionCompatibility;
      let __evaluateVersionConstraints;
      let __validateVersionCompatibility =
        previousComparisonOutcome &&
        !versionConstraintsEvaluationOptions.includePrerelease &&
        previousComparisonOutcome.semver.prerelease.length
          ? previousComparisonOutcome.semver
          : false;
      let userVersionConstraints =
        latestComparisonOutcome &&
        !versionConstraintsEvaluationOptions.includePrerelease &&
        latestComparisonOutcome.semver.prerelease.length
          ? latestComparisonOutcome.semver
          : false;
      if (
        __validateVersionCompatibility &&
        __validateVersionCompatibility.prerelease.length === 1 &&
        previousComparisonOutcome.operator === "<" &&
        __validateVersionCompatibility.prerelease[0] === 0
      ) {
        __validateVersionCompatibility = false;
      }
      for (let versionCriteria of currentVersion) {
        __evaluateVersionConstraints =
          __evaluateVersionConstraints ||
          versionCriteria.operator === ">" ||
          versionCriteria.operator === ">=";
        evaluateVersionCompatibility =
          evaluateVersionCompatibility ||
          versionCriteria.operator === "<" ||
          versionCriteria.operator === "<=";
        if (latestComparisonOutcome) {
          if (
            userVersionConstraints &&
            versionCriteria.semver.prerelease &&
            versionCriteria.semver.prerelease.length &&
            versionCriteria.semver.major === userVersionConstraints.major &&
            versionCriteria.semver.minor === userVersionConstraints.minor &&
            versionCriteria.semver.patch === userVersionConstraints.patch
          ) {
            userVersionConstraints = false;
          }
          if (
            versionCriteria.operator === ">" ||
            versionCriteria.operator === ">="
          ) {
            versionConstraintList = _areVersionSegmentsIdenticalStrictly(
              latestComparisonOutcome,
              versionCriteria,
              versionConstraintsEvaluationOptions,
            );
            if (
              versionConstraintList === versionCriteria &&
              versionConstraintList !== latestComparisonOutcome
            ) {
              return false;
            }
          } else if (
            latestComparisonOutcome.operator === ">=" &&
            !hexCharacterPairsForComparison(
              latestComparisonOutcome.semver,
              String(versionCriteria),
              versionConstraintsEvaluationOptions,
            )
          ) {
            return false;
          }
        }
        if (previousComparisonOutcome) {
          if (
            __validateVersionCompatibility &&
            versionCriteria.semver.prerelease &&
            versionCriteria.semver.prerelease.length &&
            versionCriteria.semver.major ===
              __validateVersionCompatibility.major &&
            versionCriteria.semver.minor ===
              __validateVersionCompatibility.minor &&
            versionCriteria.semver.patch ===
              __validateVersionCompatibility.patch
          ) {
            __validateVersionCompatibility = false;
          }
          if (
            versionCriteria.operator === "<" ||
            versionCriteria.operator === "<="
          ) {
            _evaluateVersionConstraints = _areVersionSegmentsIdentical(
              previousComparisonOutcome,
              versionCriteria,
              versionConstraintsEvaluationOptions,
            );
            if (
              _evaluateVersionConstraints === versionCriteria &&
              _evaluateVersionConstraints !== previousComparisonOutcome
            ) {
              return false;
            }
          } else if (
            previousComparisonOutcome.operator === "<=" &&
            !hexCharacterPairsForComparison(
              previousComparisonOutcome.semver,
              String(versionCriteria),
              versionConstraintsEvaluationOptions,
            )
          ) {
            return false;
          }
        }
        if (
          !versionCriteria.operator &&
          (previousComparisonOutcome || latestComparisonOutcome) &&
          versionCriteria !== 0
        ) {
          return false;
        }
      }
      return (
        (!latestComparisonOutcome ||
          !evaluateVersionCompatibility ||
          !!previousComparisonOutcome ||
          versionCriteria === 0) &&
        (!previousComparisonOutcome ||
          !__evaluateVersionConstraints ||
          !!latestComparisonOutcome ||
          versionCriteria === 0) &&
        !userVersionConstraints &&
        !__validateVersionCompatibility
      );
    };
    var _areVersionSegmentsIdenticalStrictly = (
      ___evaluateVersionConstraints,
      __currentVersion,
      evaluateVersionRelation,
    ) => {
      if (!___evaluateVersionConstraints) {
        return __currentVersion;
      }
      let versionComparisonOutcome = compareBigIntValues(
        ___evaluateVersionConstraints.semver,
        __currentVersion.semver,
        evaluateVersionRelation,
      );
      if (versionComparisonOutcome > 0) {
        return ___evaluateVersionConstraints;
      } else if (
        versionComparisonOutcome < 0 ||
        (__currentVersion.operator === ">" &&
          ___evaluateVersionConstraints.operator === ">=")
      ) {
        return __currentVersion;
      } else {
        return ___evaluateVersionConstraints;
      }
    };
    var _areVersionSegmentsIdentical = (
      determineLatestVersion,
      __currentVersion,
      minimumSupportedVersion,
    ) => {
      if (!determineLatestVersion) {
        return __currentVersion;
      }
      let _versionComparisonOutcome = compareBigIntValues(
        determineLatestVersion.semver,
        __currentVersion.semver,
        minimumSupportedVersion,
      );
      if (_versionComparisonOutcome < 0) {
        return determineLatestVersion;
      } else if (
        _versionComparisonOutcome > 0 ||
        (__currentVersion.operator === "<" &&
          determineLatestVersion.operator === "<=")
      ) {
        return __currentVersion;
      } else {
        return determineLatestVersion;
      }
    };
    areVersionSegmentsCompatible.exports = areVersionSegmentsIdentical;
  },
);
var registerAndValidateEncodingPatterns = lazyModuleInitializer(
  (retrieveAndValidateEncodingPatterns, __retrieveAndProcessData) => {
    var storeValidatedEncodingPattern = validateAndStoreEncodingPattern();
    var initializeAndValidateEncodingPattern =
      initializeEncodingValidationAndRegistration();
    var validatedAndProcessedEncoding = validateAndProcessVersionEncoding();
    var encodingValidationIntrinsicProperties = versionComparisonFunctions();
    var extractBigUInt64FromByteBuffer = extractBigUInt64FromBuffer();
    var calculateBigUInt64FromByteBuffer = calculateBigIntegerFromByteBuffer();
    var getBigUInt64FromByteBuffer = readBigUInt64FromByteBuffer();
    var extractBigIntWithOffsetFromBuffer = parseBufferToBigInt();
    var isEncodingBufferInitialized = versionBuffer();
    var prereleaseBufferLengthInBytes = prereleaseBufferLength();
    var bufferCapacityInBytes = bufferCapacity();
    var _readSignedInt16LittleEndianFromBuffer =
      readSignedInt16LittleEndianFromBuffer();
    var calculateSigned16BitIntegerFromBuffer = calculateSigned16BitInteger();
    var computeBigIntegerFromByteBuffer = extractAndCompareBigInt();
    var extractSignedInt16FromBuffer = readInt16ValueFromBuffer();
    var logProcessedDataForAnalysis = compareCharacterEncodingsByEncoding();
    var retrieveAndValidateProcessedData = getLogProcessSorterByIndex();
    var validateAndRetrieveEncodingProperties = isBigIntGreaterThanZero();
    var retrieveAndValidateEncodingWithCallback = validateLoggingData();
    var ______validateAndRetrieveIntrinsicProperties =
      readSignedInt16WithSignExtension();
    var retrieveAndValidateEncoding = checkIfBigIntIsNonPositive();
    var retrieveAndValidateEncodingData = extractIntegerFromBuffer();
    var handleDataEncodingProcess = logBigIntProcessingInstance();
    var _retrieveAndValidateEncodingData = readBigInt64FromBuffer();
    var __retrieveAndValidateEncodingData = readBigInt64LEFromBuffer();
    var retrieveAndProcessEncodingData = evaluateBufferComparison();
    var _retrieveAndValidateEncodingPatterns =
      getMatchedCharacterEncodingFromInput();
    var _validateAndRetrieveEncodingProperties = parseSemVerComparator();
    var ___retrieveAndValidateEncodingData =
      createSemanticVersionRangeFromInput();
    var retrieveAndProcessData = hexCharacterPairsGenerator();
    var validateAndProcessData = createHexColorPairs();
    var _retrieveAndProcessEncodingData =
      retrieveBestMatchingCharacterProperties();
    var ____retrieveAndValidateEncodingData =
      validateAndRetrieveSemanticVersioningProperties();
    var retrieveAndProcessEncodedData = validateAndRetrieveSemverBounds();
    var __retrieveAndProcessEncodingData =
      validateAndRetrieveIntrinsicValueFromEncoding();
    var __retrieveAndValidateEncodingPatterns = segmentComparisonIndex();
    var retrieveAndValidateDataEncoding = validateAndRetrieveIntrinsicValues();
    var retrieveAndProcessValidationEncodingData =
      ____validateAndRetrieveIntrinsicValue();
    var validateAndExecuteEncodingDataProcessing =
      validateAndExtractHexCharacterRanges();
    var _____retrieveAndValidateEncodingData =
      validateAndRetrieveValidHexCharacterRanges();
    var _retrieveAndProcessData = compareSegmentBoundsAndCheckOverlap();
    __retrieveAndProcessData.exports = {
      parse: extractBigUInt64FromByteBuffer,
      valid: calculateBigUInt64FromByteBuffer,
      clean: getBigUInt64FromByteBuffer,
      inc: extractBigIntWithOffsetFromBuffer,
      diff: isEncodingBufferInitialized,
      major: prereleaseBufferLengthInBytes,
      minor: bufferCapacityInBytes,
      patch: _readSignedInt16LittleEndianFromBuffer,
      prerelease: calculateSigned16BitIntegerFromBuffer,
      compare: computeBigIntegerFromByteBuffer,
      rcompare: extractSignedInt16FromBuffer,
      compareLoose: logProcessedDataForAnalysis,
      compareBuild: retrieveAndValidateProcessedData,
      sort: validateAndRetrieveEncodingProperties,
      rsort: retrieveAndValidateEncodingWithCallback,
      gt: ______validateAndRetrieveIntrinsicProperties,
      lt: retrieveAndValidateEncoding,
      eq: retrieveAndValidateEncodingData,
      neq: handleDataEncodingProcess,
      gte: _retrieveAndValidateEncodingData,
      lte: __retrieveAndValidateEncodingData,
      cmp: retrieveAndProcessEncodingData,
      coerce: _retrieveAndValidateEncodingPatterns,
      Comparator: _validateAndRetrieveEncodingProperties,
      Range: ___retrieveAndValidateEncodingData,
      satisfies: retrieveAndProcessData,
      toComparators: validateAndProcessData,
      maxSatisfying: _retrieveAndProcessEncodingData,
      minSatisfying: ____retrieveAndValidateEncodingData,
      minVersion: retrieveAndProcessEncodedData,
      validRange: __retrieveAndProcessEncodingData,
      outside: __retrieveAndValidateEncodingPatterns,
      gtr: retrieveAndValidateDataEncoding,
      ltr: retrieveAndProcessValidationEncodingData,
      intersects: validateAndExecuteEncodingDataProcessing,
      simplifyRange: _____retrieveAndValidateEncodingData,
      subset: _retrieveAndProcessData,
      SemVer: validatedAndProcessedEncoding,
      re: storeValidatedEncodingPattern.re,
      src: storeValidatedEncodingPattern.src,
      tokens: storeValidatedEncodingPattern.t,
      SEMVER_SPEC_VERSION:
        initializeAndValidateEncodingPattern.SEMVER_SPEC_VERSION,
      compareIdentifiers:
        encodingValidationIntrinsicProperties.compareIdentifiers,
      rcompareIdentifiers:
        encodingValidationIntrinsicProperties.rcompareIdentifiers,
    };
  },
);
var sanitizeAndEscapeStringForRegex = lazyModuleInitializer(
  (escapeSpecialCharactersForRegex, _escapeSpecialCharactersForRegex) => {
    _escapeSpecialCharactersForRegex.exports = (sanitizeInputString) => {
      if (typeof sanitizeInputString != "string") {
        throw new TypeError("Expected a string");
      }
      return sanitizeInputString
        .replace(/[|\\{}()[\]^$+*?.]/g, "\\$&")
        .replace(/-/g, "\\x2d");
    };
  },
);
var initializeVersionComparisonPatterns = lazyModuleInitializer(
  (exportedModule) => {
    var getDefaultExportOrWrapper =
      (exportedModule && exportedModule.__importDefault) ||
      function (importDefaultOrVerifyModule) {
        if (
          importDefaultOrVerifyModule &&
          importDefaultOrVerifyModule.__esModule
        ) {
          return importDefaultOrVerifyModule;
        } else {
          return {
            default: importDefaultOrVerifyModule,
          };
        }
      };
    Object.defineProperty(exportedModule, "__esModule", {
      value: true,
    });
    exportedModule.createMatcherWithIndex = exportedModule.createMatcher =
      undefined;
    var defaultSanitizedPatternRegex = getDefaultExportOrWrapper(
      sanitizeAndEscapeStringForRegex(),
    );
    function generateComparatorCheck(normalizedComparatorPatterns) {
      let generateValueComparisonCheck = createVersionComparator(
        Array.isArray(normalizedComparatorPatterns)
          ? normalizedComparatorPatterns
          : [normalizedComparatorPatterns],
      );
      return (_generateValueComparisonCheck) =>
        generateValueComparisonCheck(_generateValueComparisonCheck) !== -1;
    }
    exportedModule.createMatcher = generateComparatorCheck;
    function createVersionComparator(parseComparatorValues) {
      switch (parseComparatorValues.length) {
        case 0:
          return () => -1;
        case 1:
          return initializeVersionMatcherAndGetIndex(parseComparatorValues[0]);
      }
      let versionComparisonConditions = [];
      let hasNegationConditions = false;
      let containsDirectMatchConditions = false;
      for (let comparatorValue of parseComparatorValues) {
        if (isVersionNegationIndicator(comparatorValue)) {
          hasNegationConditions = true;
          versionComparisonConditions.push({
            ignore: true,
            match: generateCharacterEncodingMatcher(
              comparatorValue.substring(1),
            ),
          });
        } else {
          containsDirectMatchConditions = true;
          versionComparisonConditions.push({
            ignore: false,
            match: generateCharacterEncodingMatcher(comparatorValue),
          });
        }
      }
      if (hasNegationConditions) {
        if (containsDirectMatchConditions) {
          return findFirstMatchingIdentifierIndex.bind(
            null,
            versionComparisonConditions,
          );
        } else {
          return compareMatchingIdentifiersToNumericStrings.bind(
            null,
            versionComparisonConditions,
          );
        }
      } else {
        return findIndexOfMatchingProperty.bind(
          null,
          versionComparisonConditions,
        );
      }
    }
    exportedModule.createMatcherWithIndex = createVersionComparator;
    function findIndexOfMatchingProperty(
      filterMatchingPropertiesByCriteria,
      compareNumericStrings,
    ) {
      for (
        let currentMatchingPropertyIndex = 0;
        currentMatchingPropertyIndex <
        filterMatchingPropertiesByCriteria.length;
        currentMatchingPropertyIndex++
      ) {
        if (
          filterMatchingPropertiesByCriteria[
            currentMatchingPropertyIndex
          ].match(compareNumericStrings)
        ) {
          return currentMatchingPropertyIndex;
        }
      }
      return -1;
    }
    function compareMatchingIdentifiersToNumericStrings(
      validateNumericStringMatch,
      compareNumericStringValues,
    ) {
      if (
        validateNumericStringMatch.some(({ match: criteriaMatcher }) =>
          criteriaMatcher(compareNumericStringValues),
        )
      ) {
        return -1;
      } else {
        return 0;
      }
    }
    function findFirstMatchingIdentifierIndex(
      _findMatchingIdentifierIndex,
      isValueMatchingCriteria,
    ) {
      let firstMatchingIdentifierIndex = -1;
      for (
        let currentIdentifierIndex = 0;
        currentIdentifierIndex < _findMatchingIdentifierIndex.length;
        currentIdentifierIndex++
      ) {
        let {
          ignore: shouldIgnoreIdentifier,
          match: doesIdentifierMatchCriteria,
        } = _findMatchingIdentifierIndex[currentIdentifierIndex];
        if (shouldIgnoreIdentifier) {
          if (doesIdentifierMatchCriteria(isValueMatchingCriteria)) {
            firstMatchingIdentifierIndex = -1;
          }
        } else if (
          firstMatchingIdentifierIndex === -1 &&
          doesIdentifierMatchCriteria(isValueMatchingCriteria)
        ) {
          firstMatchingIdentifierIndex = currentIdentifierIndex;
        }
      }
      return firstMatchingIdentifierIndex;
    }
    function generateCharacterEncodingMatcher(createCharacterEncodingMatcher) {
      if (createCharacterEncodingMatcher === "*") {
        return () => true;
      }
      let sanitizedCharacterEncodingPattern = (0,
      defaultSanitizedPatternRegex.default)(
        createCharacterEncodingMatcher,
      ).replace(/\\\*/g, ".*");
      if (
        sanitizedCharacterEncodingPattern === createCharacterEncodingMatcher
      ) {
        return (_createCharacterEncodingMatcher) =>
          _createCharacterEncodingMatcher === createCharacterEncodingMatcher;
      }
      let characterEncodingPatternMatcher = new RegExp(
        "^" + sanitizedCharacterEncodingPattern + "$",
      );
      return (inputCharacterString) =>
        characterEncodingPatternMatcher.test(inputCharacterString);
    }
    function isVersionNegationIndicator(isMatchingVersionEncoding) {
      return isMatchingVersionEncoding.startsWith("!");
    }
    function initializeVersionMatcherAndGetIndex(createVersionMatcher) {
      let createVersionMatcherAndGetIndex =
        getEncodingMatcherForVersion(createVersionMatcher);
      return (getMatchingVersionIndex) =>
        createVersionMatcherAndGetIndex(getMatchingVersionIndex) ? 0 : -1;
    }
    function getEncodingMatcherForVersion(createEncodingMatcherForVersion) {
      if (!isVersionNegationIndicator(createEncodingMatcherForVersion)) {
        return generateCharacterEncodingMatcher(
          createEncodingMatcherForVersion,
        );
      }
      let extractedVersionSubstring =
        createEncodingMatcherForVersion.substring(1);
      let createEncodingMatcherForNonNegatedVersion =
        generateCharacterEncodingMatcher(extractedVersionSubstring);
      return (isVersionCompatibleWithEncoding) =>
        !createEncodingMatcherForNonNegatedVersion(
          isVersionCompatibleWithEncoding,
        );
    }
  },
);
var initializeVersionValidationModule = lazyModuleInitializer(
  (__initializeVersionValidationModule, versionValidationModuleExporter) => {
    var globalVersionContext =
      typeof globalVersionContext === "undefined"
        ? globalThis
        : globalVersionContext;
    (function (_initializeVersionValidationModule, processVersionString) {
      if (typeof define == "function" && define.amd) {
        define([], processVersionString);
      } else if (typeof __initializeVersionValidationModule == "object") {
        versionValidationModuleExporter.exports = processVersionString();
      } else {
        _initializeVersionValidationModule.untar = processVersionString();
      }
    })(__initializeVersionValidationModule, function () {
      "use strict";

      function handleVersionStringProcessing(_processVersion) {
        function executeVersionCallbacks(
          executeVersionCallbacksForParsedOptions,
        ) {
          for (
            var currentCallbackIndex = 0,
              totalParsedVersionCallbacks = versionParsedCallbacks.length;
            currentCallbackIndex < totalParsedVersionCallbacks;
            ++currentCallbackIndex
          ) {
            versionParsedCallbacks[currentCallbackIndex](
              executeVersionCallbacksForParsedOptions,
            );
          }
          versionProcessingResults.push(
            executeVersionCallbacksForParsedOptions,
          );
        }
        if (typeof Promise != "function") {
          throw new Error(
            "Promise implementation not available in this environment.",
          );
        }
        var versionParsedCallbacks = [];
        var versionProcessingResults = [];
        var versionProcessingPromise = new Promise(function (
          initializeVersionProcessingHooks,
          initializeVersionProcessingHooksAndCallbacks,
        ) {
          _processVersion(
            initializeVersionProcessingHooks,
            initializeVersionProcessingHooksAndCallbacks,
            executeVersionCallbacks,
          );
        });
        versionProcessingPromise.progress = function (onVersionParsedCallback) {
          if (typeof onVersionParsedCallback != "function") {
            throw new Error("cb is not a function.");
          }
          for (
            var versionParseIndex = 0,
              totalVersionProcesses = versionProcessingResults.length;
            versionParseIndex < totalVersionProcesses;
            ++versionParseIndex
          ) {
            onVersionParsedCallback(
              versionProcessingResults[versionParseIndex],
            );
          }
          versionParsedCallbacks.push(onVersionParsedCallback);
          return versionProcessingPromise;
        };
        var registerVersionProcessedCallbacks = versionProcessingPromise.then;
        versionProcessingPromise.then = function (
          registerVersionCallbackAndNotify,
          _onVersionParsedCallback,
          parseVersion,
        ) {
          registerVersionProcessedCallbacks.call(
            versionProcessingPromise,
            registerVersionCallbackAndNotify,
            _onVersionParsedCallback,
          );
          if (parseVersion !== undefined) {
            versionProcessingPromise.progress(parseVersion);
          }
          return versionProcessingPromise;
        };
        return versionProcessingPromise;
      }
      function ___initializeVersionComparisonWorker(
        initializeVersionComparisonWorker,
      ) {
        if (!(initializeVersionComparisonWorker instanceof ArrayBuffer)) {
          throw new TypeError("arrayBuffer is not an instance of ArrayBuffer.");
        }
        if (!processVersionString.Worker) {
          throw new Error(
            "Worker implementation is not available in this environment.",
          );
        }
        return new handleVersionStringProcessing(function (
          handleVersionComparison,
          _handleVersionComparison,
          handleVersionComparisonResult,
        ) {
          var versionComparisonWorker = new Worker(versionProcessingCallbacks);
          var extractedVersionResults = [];
          versionComparisonWorker.onerror = function (
            __initializeVersionComparisonWorker,
          ) {
            _handleVersionComparison(__initializeVersionComparisonWorker);
          };
          versionComparisonWorker.onmessage = function (
            _handleVersionComparisonResult,
          ) {
            _handleVersionComparisonResult =
              _handleVersionComparisonResult.data;
            switch (_handleVersionComparisonResult.type) {
              case "log":
                console[_handleVersionComparisonResult.data.level](
                  "Worker: " + _handleVersionComparisonResult.data.msg,
                );
                break;
              case "extract":
                var processedVersionInfo =
                  initializeVersionProgressWithComparisons(
                    _handleVersionComparisonResult.data,
                  );
                extractedVersionResults.push(processedVersionInfo);
                handleVersionComparisonResult(processedVersionInfo);
                break;
              case "complete":
                versionComparisonWorker.terminate();
                handleVersionComparison(extractedVersionResults);
                break;
              case "error":
                versionComparisonWorker.terminate();
                _handleVersionComparison(
                  new Error(_handleVersionComparisonResult.data.message),
                );
                break;
              default:
                versionComparisonWorker.terminate();
                _handleVersionComparison(
                  new Error(
                    "Unknown message from worker: " +
                      _handleVersionComparisonResult.type,
                  ),
                );
            }
          };
          versionComparisonWorker.postMessage(
            {
              type: "extract",
              buffer: initializeVersionComparisonWorker,
            },
            [initializeVersionComparisonWorker],
          );
        });
      }
      function initializeVersionProgressWithComparisons(
        defineVersionProgressPropertiesWithVersionComparison,
      ) {
        Object.defineProperties(
          defineVersionProgressPropertiesWithVersionComparison,
          processVersionProgress,
        );
        return defineVersionProgressPropertiesWithVersionComparison;
      }
      var versionProcessingCallbacks;
      var processVersionString = globalVersionContext || this;
      var executeVersionCallbacks =
        processVersionString.URL || processVersionString.webkitURL;
      var processVersionProgress = {
        blob: {
          get() {
            return (this._blob ||= new Blob([this.buffer]));
          },
        },
        getBlobUrl: {
          value() {
            return (this._blobUrl ||= executeVersionCallbacks.createObjectURL(
              this.blob,
            ));
          },
        },
        readAsString: {
          value() {
            var rawBuffer = this.buffer;
            for (
              var rawBufferLength = rawBuffer.byteLength,
                _byteMultiplier = 1,
                dataViewForRawBuffer = new DataView(rawBuffer),
                byteValuesArray = [],
                byteIndex = 0;
              byteIndex < rawBufferLength;
              ++byteIndex
            ) {
              var extractedByteValue = dataViewForRawBuffer.getUint8(
                byteIndex * _byteMultiplier,
                true,
              );
              byteValuesArray.push(extractedByteValue);
            }
            return (this._string = String.fromCharCode.apply(
              null,
              byteValuesArray,
            ));
          },
        },
        readAsJSON: {
          value() {
            return JSON.parse(this.readAsString());
          },
        },
      };
      versionProcessingCallbacks = (
        globalVersionContext || this
      ).URL.createObjectURL(
        new Blob([
          '"use strict";function UntarWorker(){}function decodeUTF8(e){for(var r="",t=0;t<e.length;){var a=e[t++];if(a>127){if(a>191&&a<224){if(t>=e.length)throw"UTF-8 decode: incomplete 2-byte sequence";a=(31&a)<<6|63&e[t]}else if(a>223&&a<240){if(t+1>=e.length)throw"UTF-8 decode: incomplete 3-byte sequence";a=(15&a)<<12|(63&e[t])<<6|63&e[++t]}else{if(!(a>239&&a<248))throw"UTF-8 decode: unknown multibyte start 0x"+a.toString(16)+" at index "+(t-1);if(t+2>=e.length)throw"UTF-8 decode: incomplete 4-byte sequence";a=(7&a)<<18|(63&e[t])<<12|(63&e[++t])<<6|63&e[++t]}++t}if(a<=65535)r+=String.fromCharCode(a);else{if(!(a<=1114111))throw"UTF-8 decode: code point 0x"+a.toString(16)+" exceeds UTF-16 reach";a-=65536,r+=String.fromCharCode(a>>10|55296),r+=String.fromCharCode(1023&a|56320)}}return r}function PaxHeader(e){this._fields=e}function TarFile(){}function UntarStream(e){this._bufferView=new DataView(e),this._position=0}function UntarFileStream(e){this._stream=new UntarStream(e),this._globalPaxHeader=null}if(UntarWorker.prototype={onmessage:function(e){try{if("extract"!==e.data.type)throw new Error("Unknown message type: "+e.data.type);this.untarBuffer(e.data.buffer)}catch(r){this.postError(r)}},postError:function(e){this.postMessage({type:"error",data:{message:e.message}})},postLog:function(e,r){this.postMessage({type:"log",data:{level:e,msg:r}})},untarBuffer:function(e){try{for(var r=new UntarFileStream(e);r.hasNext();){var t=r.next();this.postMessage({type:"extract",data:t},[t.buffer])}this.postMessage({type:"complete"})}catch(a){this.postError(a)}},postMessage:function(e,r){self.postMessage(e,r)}},"undefined"!=typeof self){var worker=new UntarWorker;self.onmessage=function(e){worker.onmessage(e)}}PaxHeader.parse=function(e){for(var r=new Uint8Array(e),t=[];r.length>0;){var a=parseInt(decodeUTF8(r.subarray(0,r.indexOf(32)))),n=decodeUTF8(r.subarray(0,a)),i=n.match(/^\\d+ ([^=]+)=(.*)\\n$/);if(null===i)throw new Error("Invalid PAX header data format.");var s=i[1],o=i[2];0===o.length?o=null:null!==o.match(/^\\d+$/)&&(o=parseInt(o));var f={name:s,value:o};t.push(f),r=r.subarray(a)}return new PaxHeader(t)},PaxHeader.prototype={applyHeader:function(e){this._fields.forEach(function(r){var t=r.name,a=r.value;"path"===t?(t="name",void 0!==e.prefix&&delete e.prefix):"linkpath"===t&&(t="linkname"),null===a?delete e[t]:e[t]=a})}},UntarStream.prototype={readString:function(e){for(var r=1,t=e*r,a=[],n=0;n<e;++n){var i=this._bufferView.getUint8(this.position()+n*r,!0);if(0===i)break;a.push(i)}return this.seek(t),String.fromCharCode.apply(null,a)},readBuffer:function(e){var r;if("function"==typeof ArrayBuffer.prototype.slice)r=this._bufferView.buffer.slice(this.position(),this.position()+e);else{r=new ArrayBuffer(e);var t=new Uint8Array(r),a=new Uint8Array(this._bufferView.buffer,this.position(),e);t.set(a)}return this.seek(e),r},seek:function(e){this._position+=e},peekUint32:function(){return this._bufferView.getUint32(this.position(),!0)},position:function(e){return void 0===e?this._position:void(this._position=e)},size:function(){return this._bufferView.byteLength}},UntarFileStream.prototype={hasNext:function(){return this._stream.position()+4<this._stream.size()&&0!==this._stream.peekUint32()},next:function(){return this._readNextFile()},_readNextFile:function(){var e=this._stream,r=new TarFile,t=!1,a=null,n=e.position(),i=n+512;switch(r.name=e.readString(100),r.mode=e.readString(8),r.uid=parseInt(e.readString(8)),r.gid=parseInt(e.readString(8)),r.size=parseInt(e.readString(12),8),r.mtime=parseInt(e.readString(12),8),r.checksum=parseInt(e.readString(8)),r.type=e.readString(1),r.linkname=e.readString(100),r.ustarFormat=e.readString(6),r.ustarFormat.indexOf("ustar")>-1&&(r.version=e.readString(2),r.uname=e.readString(32),r.gname=e.readString(32),r.devmajor=parseInt(e.readString(8)),r.devminor=parseInt(e.readString(8)),r.namePrefix=e.readString(155),r.namePrefix.length>0&&(r.name=r.namePrefix+"/"+r.name)),e.position(i),r.type){case"0":case"":r.buffer=e.readBuffer(r.size);break;case"1":break;case"2":break;case"3":break;case"4":break;case"5":break;case"6":break;case"7":break;case"g":t=!0,this._globalPaxHeader=PaxHeader.parse(e.readBuffer(r.size));break;case"x":t=!0,a=PaxHeader.parse(e.readBuffer(r.size))}void 0===r.buffer&&(r.buffer=new ArrayBuffer(0));var s=i+r.size;return r.size%512!==0&&(s+=512-r.size%512),e.position(s),t&&(r=this._readNextFile()),null!==this._globalPaxHeader&&this._globalPaxHeader.applyHeader(r),null!==a&&a.applyHeader(r),r}};',
        ]),
      );
      return ___initializeVersionComparisonWorker;
    });
  },
);
var compareVersionWithPrereleaseFlag = lazyModuleInitializer(
  (generateFormattedConfiguration, formatConfigurationDataWithSections) => {
    var { hasOwnProperty: hasOwnPropertyCheck } = Object.prototype;
    var newlineCharacterForPlatform =
      typeof process !== "undefined" && process.platform === "win32"
        ? "\r\n"
        : "\n";
    var formatAndStructureConfiguration = (
      formatSectionsWithOptions,
      sectionFormattingOptions,
    ) => {
      let extractedSectionKeys = [];
      let structuredSectionOutput = "";
      if (typeof sectionFormattingOptions == "string") {
        sectionFormattingOptions = {
          section: sectionFormattingOptions,
          whitespace: false,
        };
      } else {
        sectionFormattingOptions =
          sectionFormattingOptions || Object.create(null);
        sectionFormattingOptions.whitespace =
          sectionFormattingOptions.whitespace === true;
      }
      let formattedWhitespaceSeparator = sectionFormattingOptions.whitespace
        ? " = "
        : "=";
      for (let sectionKey of Object.keys(formatSectionsWithOptions)) {
        let formattedSectionItems = formatSectionsWithOptions[sectionKey];
        if (formattedSectionItems && Array.isArray(formattedSectionItems)) {
          for (let formattedSectionItem of formattedSectionItems) {
            structuredSectionOutput +=
              formatAndStructureOutput(sectionKey + "[]") +
              formattedWhitespaceSeparator +
              formatAndStructureOutput(formattedSectionItem) +
              newlineCharacterForPlatform;
          }
        } else if (
          formattedSectionItems &&
          typeof formattedSectionItems == "object"
        ) {
          extractedSectionKeys.push(sectionKey);
        } else {
          structuredSectionOutput +=
            formatAndStructureOutput(sectionKey) +
            formattedWhitespaceSeparator +
            formatAndStructureOutput(formattedSectionItems) +
            newlineCharacterForPlatform;
        }
      }
      if (sectionFormattingOptions.section && structuredSectionOutput.length) {
        structuredSectionOutput =
          "[" +
          formatAndStructureOutput(sectionFormattingOptions.section) +
          "]" +
          newlineCharacterForPlatform +
          structuredSectionOutput;
      }
      for (let sectionKey of extractedSectionKeys) {
        let structuredConfigurationPath =
          formatAndStructureConfigurationObject(sectionKey).join("\\.");
        let detailedSectionPath =
          (sectionFormattingOptions.section
            ? sectionFormattingOptions.section + "."
            : "") + structuredConfigurationPath;
        let { whitespace: indentationStyle } = sectionFormattingOptions;
        let formattedSectionConfigurationOutput =
          formatAndStructureConfiguration(
            formatSectionsWithOptions[sectionKey],
            {
              section: detailedSectionPath,
              whitespace: indentationStyle,
            },
          );
        if (
          structuredSectionOutput.length &&
          formattedSectionConfigurationOutput.length
        ) {
          structuredSectionOutput += newlineCharacterForPlatform;
        }
        structuredSectionOutput += formattedSectionConfigurationOutput;
      }
      return structuredSectionOutput;
    };
    var formatAndStructureConfigurationObject = (replacePlaceholdersInString) =>
      replacePlaceholdersInString
        .replace(/\1/g, "LITERAL\\1LITERAL")
        .replace(/\\\./g, "")
        .split(/\./)
        .map((sanitizeAndReplacePattern) =>
          sanitizeAndReplacePattern
            .replace(/\1/g, "\\.")
            .replace(/\2LITERAL\\1LITERAL\2/g, ""),
        );
    var _formatAndStructureConfiguration = (parseConfigEntriesFromInput) => {
      let configSectionMap = Object.create(null);
      let activeConfigSection = configSectionMap;
      let activeConfigSectionKey = null;
      let configEntryPattern = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
      let configEntries = parseConfigEntriesFromInput.split(/[\r\n]+/g);
      for (let configurationLineItem of configEntries) {
        if (!configurationLineItem || configurationLineItem.match(/^\s*[;#]/)) {
          continue;
        }
        let matchedConfigurationEntry =
          configurationLineItem.match(configEntryPattern);
        if (!matchedConfigurationEntry) {
          continue;
        }
        if (matchedConfigurationEntry[1] !== undefined) {
          activeConfigSectionKey = generateFormattedConfigurationOutput(
            matchedConfigurationEntry[1],
          );
          if (activeConfigSectionKey === "__proto__") {
            activeConfigSection = Object.create(null);
            continue;
          }
          activeConfigSection = configSectionMap[activeConfigSectionKey] =
            configSectionMap[activeConfigSectionKey] || Object.create(null);
          continue;
        }
        let formattedConfigurationValue = generateFormattedConfigurationOutput(
          matchedConfigurationEntry[2],
        );
        let isArrayDelimiter =
          formattedConfigurationValue.length > 2 &&
          formattedConfigurationValue.slice(-2) === "[]";
        let configurationSetting = isArrayDelimiter
          ? formattedConfigurationValue.slice(0, -2)
          : formattedConfigurationValue;
        if (configurationSetting === "__proto__") {
          continue;
        }
        let getConfigurationValueWithFallback = matchedConfigurationEntry[3]
          ? generateFormattedConfigurationOutput(matchedConfigurationEntry[4])
          : true;
        let processConfigurationLineItem =
          getConfigurationValueWithFallback === "true" ||
          getConfigurationValueWithFallback === "false" ||
          getConfigurationValueWithFallback === "null"
            ? JSON.parse(getConfigurationValueWithFallback)
            : getConfigurationValueWithFallback;
        if (isArrayDelimiter) {
          if (
            hasOwnPropertyCheck.call(activeConfigSection, configurationSetting)
          ) {
            if (!Array.isArray(activeConfigSection[configurationSetting])) {
              activeConfigSection[configurationSetting] = [
                activeConfigSection[configurationSetting],
              ];
            }
          } else {
            activeConfigSection[configurationSetting] = [];
          }
        }
        if (Array.isArray(activeConfigSection[configurationSetting])) {
          activeConfigSection[configurationSetting].push(
            processConfigurationLineItem,
          );
        } else {
          activeConfigSection[configurationSetting] =
            processConfigurationLineItem;
        }
      }
      let configEntryLine = [];
      for (let keyNameForConfigSection of Object.keys(configSectionMap)) {
        if (
          !hasOwnPropertyCheck.call(
            configSectionMap,
            keyNameForConfigSection,
          ) ||
          typeof configSectionMap[keyNameForConfigSection] != "object" ||
          Array.isArray(configSectionMap[keyNameForConfigSection])
        ) {
          continue;
        }
        let formattedConfigSectionKeys = formatAndStructureConfigurationObject(
          keyNameForConfigSection,
        );
        activeConfigSection = configSectionMap;
        let lastConfigKeyProcessedForSanitization =
          formattedConfigSectionKeys.pop();
        let sanitizedLastConfigKey =
          lastConfigKeyProcessedForSanitization.replace(/\\\./g, ".");
        for (let configSectionKey of formattedConfigSectionKeys) {
          if (configSectionKey !== "__proto__") {
            if (
              !hasOwnPropertyCheck.call(
                activeConfigSection,
                configSectionKey,
              ) ||
              typeof activeConfigSection[configSectionKey] != "object"
            ) {
              activeConfigSection[configSectionKey] = Object.create(null);
            }
            activeConfigSection = activeConfigSection[configSectionKey];
          }
        }
        if (
          activeConfigSection !== configSectionMap ||
          sanitizedLastConfigKey !== lastConfigKeyProcessedForSanitization
        ) {
          activeConfigSection[sanitizedLastConfigKey] =
            configSectionMap[keyNameForConfigSection];
          configEntryLine.push(keyNameForConfigSection);
        }
      }
      for (let configKeysToRemove of configEntryLine) {
        delete configSectionMap[configKeysToRemove];
      }
      return configSectionMap;
    };
    var __formatAndStructureConfiguration = (isStringWrappedInQuotes) =>
      (isStringWrappedInQuotes.startsWith('"') &&
        isStringWrappedInQuotes.endsWith('"')) ||
      (isStringWrappedInQuotes.startsWith("'") &&
        isStringWrappedInQuotes.endsWith("'"));
    var formatAndStructureOutput = (userInputConfigurationString) =>
      typeof userInputConfigurationString != "string" ||
      userInputConfigurationString.match(/[=\r\n]/) ||
      userInputConfigurationString.match(/^\[/) ||
      (userInputConfigurationString.length > 1 &&
        __formatAndStructureConfiguration(userInputConfigurationString)) ||
      userInputConfigurationString !== userInputConfigurationString.trim()
        ? JSON.stringify(userInputConfigurationString)
        : userInputConfigurationString
            .split(";")
            .join("\\;")
            .split("#")
            .join("\\#");
    var generateFormattedConfigurationOutput = (
      sanitizeAndParseInput,
      sanitizeAndParseJsonInput,
    ) => {
      sanitizeAndParseInput = (sanitizeAndParseInput || "").trim();
      if (__formatAndStructureConfiguration(sanitizeAndParseInput)) {
        if (sanitizeAndParseInput.charAt(0) === "'") {
          sanitizeAndParseInput = sanitizeAndParseInput.slice(1, -1);
        }
        try {
          sanitizeAndParseInput = JSON.parse(sanitizeAndParseInput);
        } catch {}
      } else {
        let isCurrentlyEscapingCharacter = false;
        let extractedContent = "";
        for (
          let inputCharIndex = 0,
            sanitizedInputLength = sanitizeAndParseInput.length;
          inputCharIndex < sanitizedInputLength;
          inputCharIndex++
        ) {
          let currentInputCharacter =
            sanitizeAndParseInput.charAt(inputCharIndex);
          if (isCurrentlyEscapingCharacter) {
            if ("\\;#".indexOf(currentInputCharacter) !== -1) {
              extractedContent += currentInputCharacter;
            } else {
              extractedContent += "\\" + currentInputCharacter;
            }
            isCurrentlyEscapingCharacter = false;
          } else {
            if (";#".indexOf(currentInputCharacter) !== -1) {
              break;
            }
            if (currentInputCharacter === "\\") {
              isCurrentlyEscapingCharacter = true;
            } else {
              extractedContent += currentInputCharacter;
            }
          }
        }
        if (isCurrentlyEscapingCharacter) {
          extractedContent += "\\";
        }
        return extractedContent.trim();
      }
      return sanitizeAndParseInput;
    };
    formatConfigurationDataWithSections.exports = {
      parse: _formatAndStructureConfiguration,
      decode: _formatAndStructureConfiguration,
      stringify: formatAndStructureConfiguration,
      encode: formatAndStructureConfiguration,
      safe: formatAndStructureOutput,
      unsafe: generateFormattedConfigurationOutput,
    };
  },
);
var compareAndConvertToFloat = lazyModuleInitializer(
  (configureWorkerScriptExport, configureWorkerScript) => {
    configureWorkerScript.exports = "worker.js";
  },
);
var performComparisonOperation = lazyModuleInitializer(
  (arrayUtilitiesExport, arrayUtilitiesExports) => {
    arrayUtilitiesExports.exports = {
      ArrayIsArray(isValueArray) {
        return Array.isArray(isValueArray);
      },
      ArrayPrototypeIncludes(doesArrayIncludeElement, doesArrayContainElement) {
        return doesArrayIncludeElement.includes(doesArrayContainElement);
      },
      ArrayPrototypeIndexOf(findElementIndexInArray, searchElementInArray) {
        return findElementIndexInArray.indexOf(searchElementInArray);
      },
      ArrayPrototypeJoin(joinArrayElementsWithSeparator, elementJoiner) {
        return joinArrayElementsWithSeparator.join(elementJoiner);
      },
      ArrayPrototypeMap(mapArrayElements, elementMapper) {
        return mapArrayElements.map(elementMapper);
      },
      ArrayPrototypePop(popLastElementFromArray, _popLastElementFromArray) {
        return popLastElementFromArray.pop(_popLastElementFromArray);
      },
      ArrayPrototypePush(pushElementToArray, appendElementToArray) {
        return pushElementToArray.push(appendElementToArray);
      },
      ArrayPrototypeSlice(
        _extractSubArray,
        subArrayStartIndex,
        subArrayEndIndex,
      ) {
        return _extractSubArray.slice(subArrayStartIndex, subArrayEndIndex);
      },
      Error: Error,
      FunctionPrototypeCall(
        _invokeFunctionWithContext,
        executeFunctionInContext,
        ..._functionArguments
      ) {
        return _invokeFunctionWithContext.call(
          executeFunctionInContext,
          ..._functionArguments,
        );
      },
      FunctionPrototypeSymbolHasInstance(
        validateInstanceAgainstPrototype,
        validateInstanceAgainstPrototypeFunction,
      ) {
        return Function.prototype[Symbol.hasInstance].call(
          validateInstanceAgainstPrototype,
          validateInstanceAgainstPrototypeFunction,
        );
      },
      MathFloor: Math.floor,
      Number: Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(
        defineObjectPropertiesWithDescriptors,
        objectPropertiesDefinitions,
      ) {
        return Object.defineProperties(
          defineObjectPropertiesWithDescriptors,
          objectPropertiesDefinitions,
        );
      },
      ObjectDefineProperty(
        defineObjectProperty,
        __propertyDescriptor,
        propertyValueDescriptor,
      ) {
        return Object.defineProperty(
          defineObjectProperty,
          __propertyDescriptor,
          propertyValueDescriptor,
        );
      },
      ObjectGetOwnPropertyDescriptor(
        getPropertyDescriptorFromObject,
        _propertyKey,
      ) {
        return Object.getOwnPropertyDescriptor(
          getPropertyDescriptorFromObject,
          _propertyKey,
        );
      },
      ObjectKeys(getKeysFromObject) {
        return Object.keys(getKeysFromObject);
      },
      ObjectSetPrototypeOf(setObjectPrototypeTo, setObjectPrototype) {
        return Object.setPrototypeOf(setObjectPrototypeTo, setObjectPrototype);
      },
      Promise: Promise,
      PromisePrototypeCatch(
        __handlePromiseRejection,
        handlePromiseRejectionError,
      ) {
        return __handlePromiseRejection.catch(handlePromiseRejectionError);
      },
      PromisePrototypeThen(
        executePromiseThen,
        _handlePromiseResolution,
        handlePromiseCompletion,
      ) {
        return executePromiseThen.then(
          _handlePromiseResolution,
          handlePromiseCompletion,
        );
      },
      PromiseReject(rejectPromiseWithError) {
        return Promise.reject(rejectPromiseWithError);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(testRegexAgainstInputString, testStringAgainstRegex) {
        return testRegexAgainstInputString.test(testStringAgainstRegex);
      },
      SafeSet: Set,
      String: String,
      StringPrototypeSlice(
        extractSubstring,
        sliceSubstringFromTo,
        substringEndIndex,
      ) {
        return extractSubstring.slice(sliceSubstringFromTo, substringEndIndex);
      },
      StringPrototypeToLowerCase(convertToLowercase) {
        return convertToLowercase.toLowerCase();
      },
      StringPrototypeToUpperCase(convertStringToUpperCase) {
        return convertStringToUpperCase.toUpperCase();
      },
      StringPrototypeTrim(trimWhitespaceFromString) {
        return trimWhitespaceFromString.trim();
      },
      Symbol: Symbol,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      TypedArrayPrototypeSet(
        setTypedArrayValues,
        typedArrayValues,
        startingIndex,
      ) {
        return setTypedArrayValues.set(typedArrayValues, startingIndex);
      },
      Uint8Array: Uint8Array,
    };
  },
);
var validateAndProcessArrayBufferForProcessing = lazyModuleInitializer(
  (validateAndRetrieveBlobProperty, validateAndCreateBlobErrorHandling) => {
    retrieveAndValidateIntrinsicPropertyValue();
    var defineESModuleFromIntrinsicProperties = defineESModuleWithProperties(
      intrinsicPropertiesManager,
    );
    var AsyncFunctionConstructor = Object.getPrototypeOf(
      async function () {},
    ).constructor;
    var BlobTypeChecker =
      globalThis.Blob || defineESModuleFromIntrinsicProperties.Blob;
    var isValidBlobType =
      typeof BlobTypeChecker !== "undefined"
        ? function (isBlobInstanceValidator) {
            return isBlobInstanceValidator instanceof BlobTypeChecker;
          }
        : function (processAndValidateBuffer) {
            return false;
          };
    var AggregateError = class extends Error {
      constructor(errorList) {
        if (!Array.isArray(errorList)) {
          throw new TypeError(
            "Expected input to be an Array, got " + typeof errorList,
          );
        }
        let combinedErrorStack = "";
        for (
          let errorListIndex = 0;
          errorListIndex < errorList.length;
          errorListIndex++
        ) {
          combinedErrorStack += "    " + errorList[errorListIndex].stack + "\n";
        }
        super(combinedErrorStack);
        this.name = "AggregateError";
        this.errors = errorList;
      }
    };
    validateAndCreateBlobErrorHandling.exports = {
      AggregateError: AggregateError,
      kEmptyObject: Object.freeze({}),
      once(executeOnceIfNotExecuted) {
        let hasAlreadyExecuted = false;
        return function (...executeIfNotExecuted) {
          if (!hasAlreadyExecuted) {
            hasAlreadyExecuted = true;
            executeOnceIfNotExecuted.apply(this, executeIfNotExecuted);
          }
        };
      },
      createDeferredPromise() {
        let _createDeferredPromise;
        let rejectPromiseHandler;
        return {
          promise: new Promise(
            (initializePromiseHandlers, rejectPromiseHandler) => {
              _createDeferredPromise = initializePromiseHandlers;
              rejectPromiseHandler = rejectPromiseHandler;
            },
          ),
          resolve: _createDeferredPromise,
          reject: rejectPromiseHandler,
        };
      },
      promisify(promisifyCallbackFunction) {
        return new Promise(
          (processResponseWithCallback, _processApiResponse) => {
            promisifyCallbackFunction(
              (handleApiResponseOrExecuteCallback, ...apiCallbackArgs) =>
                handleApiResponseOrExecuteCallback
                  ? _processApiResponse(handleApiResponseOrExecuteCallback)
                  : processResponseWithCallback(...apiCallbackArgs),
            );
          },
        );
      },
      debuglog() {
        return function () {};
      },
      format(formatStringWithArguments, ...formatValuesArray) {
        return formatStringWithArguments.replace(
          /%([sdifj])/g,
          function (...[formatValueBasedOnType, valueFormatterType]) {
            let _initialValue = formatValuesArray.shift();
            if (valueFormatterType === "f") {
              return _initialValue.toFixed(6);
            } else if (valueFormatterType === "j") {
              return JSON.stringify(_initialValue);
            } else if (
              valueFormatterType === "s" &&
              typeof _initialValue == "object"
            ) {
              return (
                (_initialValue.constructor !== Object
                  ? _initialValue.constructor.name
                  : "") + " {}"
              ).trim();
            } else {
              return _initialValue.toString();
            }
          },
        );
      },
      inspect(inspectVariable) {
        switch (typeof inspectVariable) {
          case "string":
            if (inspectVariable.includes("'")) {
              if (inspectVariable.includes('"')) {
                if (
                  !inspectVariable.includes("`") &&
                  !inspectVariable.includes("${")
                ) {
                  return "`" + inspectVariable + "`";
                }
              } else {
                return '"' + inspectVariable + '"';
              }
            }
            return "'" + inspectVariable + "'";
          case "number":
            if (isNaN(inspectVariable)) {
              return "NaN";
            } else if (Object.is(inspectVariable, -0)) {
              return String(inspectVariable);
            } else {
              return inspectVariable;
            }
          case "bigint":
            return String(inspectVariable) + "n";
          case "boolean":
          case "undefined":
            return String(inspectVariable);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(checkIfAsyncFunction) {
          return checkIfAsyncFunction instanceof AsyncFunctionConstructor;
        },
        isArrayBufferView(isArrayBufferView) {
          return ArrayBuffer.isView(isArrayBufferView);
        },
      },
      isBlob: isValidBlobType,
    };
    validateAndCreateBlobErrorHandling.exports.promisify.custom = Symbol.for(
      "nodejs.util.promisify.custom",
    );
  },
);
var writeUint16LittleEndian = lazyModuleInitializer(
  (setupAbortControllerExports, setupAbortControllerWithExports) => {
    var globalContext =
      typeof globalContext === "undefined" ? globalThis : globalContext;
    var {
      AbortController: NetworkRequestAbortController,
      AbortSignal: NetworkRequestAbortSignal,
    } =
      typeof self !== "undefined"
        ? self
        : typeof globalContext !== "undefined"
          ? globalContext
          : undefined;
    setupAbortControllerWithExports.exports = NetworkRequestAbortController;
    setupAbortControllerWithExports.exports.AbortSignal =
      NetworkRequestAbortSignal;
    setupAbortControllerWithExports.exports.default =
      NetworkRequestAbortController;
  },
);
var fetchNodeValuePostTraversal = lazyModuleInitializer(
  (validateAndProcessData, _validateAndProcessData) => {
    var {
      format: dataFormatter,
      inspect: extractAndAnalyzeData,
      AggregateError: DataProcessingAggregateError,
    } = validateAndProcessArrayBufferForProcessing();
    var DataProcessingErrorAggregateInstance =
      globalThis.AggregateError || DataProcessingAggregateError;
    var NODE_ERROR_SYMBOL_IDENTIFIER = Symbol("kIsNodeError");
    var supportedDataTypes = [
      "string",
      "function",
      "number",
      "object",
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol",
    ];
    var uppercaseCamelCasePattern = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalIdentifier = "__node_internal_";
    var DataProcessingErrorTypes = {};
    function checkAndProcessDataIntegrity(
      validateAndProcessDataInChunks,
      transformDataList,
    ) {
      if (!validateAndProcessDataInChunks) {
        throw new DataProcessingErrorTypes.ERR_INTERNAL_ASSERTION(
          transformDataList,
        );
      }
    }
    function convertAndFormatUint16ToBigEndianString(
      processAndFormatUint16BEData,
    ) {
      let formattedBigEndianHexString = "";
      let remainingDataLength = processAndFormatUint16BEData.length;
      let isFirstDataNegative = processAndFormatUint16BEData[0] === "-" ? 1 : 0;
      for (
        ;
        remainingDataLength >= isFirstDataNegative + 4;
        remainingDataLength -= 3
      ) {
        formattedBigEndianHexString =
          "_" +
          processAndFormatUint16BEData.slice(
            remainingDataLength - 3,
            remainingDataLength,
          ) +
          formattedBigEndianHexString;
      }
      return (
        "" +
        processAndFormatUint16BEData.slice(0, remainingDataLength) +
        formattedBigEndianHexString
      );
    }
    function validateAndFormatEncodedByteLengthsForFunctionInvocation(
      calculateAndValidateEncodedByteLengths,
      computeEncodedByteLengths,
      calculateEncodedByteLength,
    ) {
      if (typeof computeEncodedByteLengths == "function") {
        checkAndProcessDataIntegrity(
          computeEncodedByteLengths.length <= calculateEncodedByteLength.length,
          "Code: " +
            calculateAndValidateEncodedByteLengths +
            "; The provided arguments length (" +
            calculateEncodedByteLength.length +
            ") does not match the required ones (" +
            computeEncodedByteLengths.length +
            ").",
        );
        return computeEncodedByteLengths(...calculateEncodedByteLength);
      }
      let expectedArgumentCountBasedOnFormat = (
        computeEncodedByteLengths.match(/%[dfijoOs]/g) || []
      ).length;
      checkAndProcessDataIntegrity(
        expectedArgumentCountBasedOnFormat ===
          calculateEncodedByteLength.length,
        "Code: " +
          calculateAndValidateEncodedByteLengths +
          "; The provided arguments length (" +
          calculateEncodedByteLength.length +
          ") does not match the required ones (" +
          expectedArgumentCountBasedOnFormat +
          ").",
      );
      if (calculateEncodedByteLength.length === 0) {
        return computeEncodedByteLengths;
      } else {
        return dataFormatter(
          computeEncodedByteLengths,
          ...calculateEncodedByteLength,
        );
      }
    }
    function createCustomErrorTypeWithGenerator(
      generateAndExportRandomData,
      generateRandomDataWithLength,
      aggregateDataValues,
    ) {
      aggregateDataValues ||= Error;
      class RandomDataAggregationHandler extends aggregateDataValues {
        constructor(...constructorArgs) {
          super(
            validateAndFormatEncodedByteLengthsForFunctionInvocation(
              generateAndExportRandomData,
              generateRandomDataWithLength,
              constructorArgs,
            ),
          );
        }
        toString() {
          return (
            this.name +
            " [" +
            generateAndExportRandomData +
            "]: " +
            this.message
          );
        }
      }
      Object.defineProperties(RandomDataAggregationHandler.prototype, {
        name: {
          value: aggregateDataValues.name,
          writable: true,
          enumerable: false,
          configurable: true,
        },
        toString: {
          value() {
            return (
              this.name +
              " [" +
              generateAndExportRandomData +
              "]: " +
              this.message
            );
          },
          writable: true,
          enumerable: false,
          configurable: true,
        },
      });
      RandomDataAggregationHandler.prototype.code = generateAndExportRandomData;
      RandomDataAggregationHandler.prototype[NODE_ERROR_SYMBOL_IDENTIFIER] =
        true;
      DataProcessingErrorTypes[generateAndExportRandomData] =
        RandomDataAggregationHandler;
    }
    function assignFullNodeIdentifierToByteLength(generateRandomByteLength) {
      let assignNodeIdentifierWithByteLength =
        nodeInternalIdentifier + generateRandomByteLength.name;
      Object.defineProperty(generateRandomByteLength, "name", {
        value: assignNodeIdentifierWithByteLength,
      });
      return generateRandomByteLength;
    }
    function combineErrorMessagesForProcessing(
      generateRandomValueSubset,
      extractSubArray,
    ) {
      if (
        generateRandomValueSubset &&
        extractSubArray &&
        generateRandomValueSubset !== extractSubArray
      ) {
        if (Array.isArray(extractSubArray.errors)) {
          extractSubArray.errors.push(generateRandomValueSubset);
          return extractSubArray;
        }
        let dataProcessingErrorAggregate =
          new DataProcessingErrorAggregateInstance(
            [extractSubArray, generateRandomValueSubset],
            extractSubArray.message,
          );
        dataProcessingErrorAggregate.code = extractSubArray.code;
        return dataProcessingErrorAggregate;
      }
      return generateRandomValueSubset || extractSubArray;
    }
    var formatDataForProcessing = class extends Error {
      constructor(
        userCancelledOperationNotification = "The operation was aborted",
        optionsObject = undefined,
      ) {
        if (optionsObject !== undefined && typeof optionsObject != "object") {
          throw new DataProcessingErrorTypes.ERR_INVALID_ARG_TYPE(
            "options",
            "Object",
            optionsObject,
          );
        }
        super(userCancelledOperationNotification, optionsObject);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    createCustomErrorTypeWithGenerator("ERR_ASSERTION", "%s", Error);
    createCustomErrorTypeWithGenerator(
      "ERR_INVALID_ARG_TYPE",
      (argumentName, argumentTypeExpectations, checkExpectedArgumentTypes) => {
        checkAndProcessDataIntegrity(
          typeof argumentName == "string",
          "'name' must be a string",
        );
        if (!Array.isArray(argumentTypeExpectations)) {
          argumentTypeExpectations = [argumentTypeExpectations];
        }
        let formattedArgumentDescription = "The ";
        if (argumentName.endsWith(" argument")) {
          formattedArgumentDescription += argumentName + " ";
        } else {
          formattedArgumentDescription +=
            '"' +
            argumentName +
            '" ' +
            (argumentName.includes(".") ? "property" : "argument") +
            " ";
        }
        formattedArgumentDescription += "must be ";
        let validUppercaseDataTypes = [];
        let expectedUppercaseDataTypes = [];
        let expectedArgumentDataTypes = [];
        for (let expectedArgumentType of argumentTypeExpectations) {
          checkAndProcessDataIntegrity(
            typeof expectedArgumentType == "string",
            "All expected entries have to be of type string",
          );
          if (supportedDataTypes.includes(expectedArgumentType)) {
            validUppercaseDataTypes.push(expectedArgumentType.toLowerCase());
          } else if (uppercaseCamelCasePattern.test(expectedArgumentType)) {
            expectedUppercaseDataTypes.push(expectedArgumentType);
          } else {
            checkAndProcessDataIntegrity(
              expectedArgumentType !== "object",
              'The value "object" should be written as "Object"',
            );
            expectedArgumentDataTypes.push(expectedArgumentType);
          }
        }
        if (expectedUppercaseDataTypes.length > 0) {
          let indexOfObjectTypeInValidDataTypes =
            validUppercaseDataTypes.indexOf("object");
          if (indexOfObjectTypeInValidDataTypes !== -1) {
            validUppercaseDataTypes.splice(
              validUppercaseDataTypes,
              indexOfObjectTypeInValidDataTypes,
              1,
            );
            expectedUppercaseDataTypes.push("Object");
          }
        }
        if (validUppercaseDataTypes.length > 0) {
          switch (validUppercaseDataTypes.length) {
            case 1:
              formattedArgumentDescription +=
                "of type " + validUppercaseDataTypes[0];
              break;
            case 2:
              formattedArgumentDescription +=
                "one of type " +
                validUppercaseDataTypes[0] +
                " or " +
                validUppercaseDataTypes[1];
              break;
            default: {
              let lastValidUppercaseDataType = validUppercaseDataTypes.pop();
              formattedArgumentDescription +=
                "one of type " +
                validUppercaseDataTypes.join(", ") +
                ", or " +
                lastValidUppercaseDataType;
            }
          }
          if (
            expectedUppercaseDataTypes.length > 0 ||
            expectedArgumentDataTypes.length > 0
          ) {
            formattedArgumentDescription += " or ";
          }
        }
        if (expectedUppercaseDataTypes.length > 0) {
          switch (expectedUppercaseDataTypes.length) {
            case 1:
              formattedArgumentDescription +=
                "an instance of " + expectedUppercaseDataTypes[0];
              break;
            case 2:
              formattedArgumentDescription +=
                "an instance of " +
                expectedUppercaseDataTypes[0] +
                " or " +
                expectedUppercaseDataTypes[1];
              break;
            default: {
              let lastExpectedUppercaseDataType =
                expectedUppercaseDataTypes.pop();
              formattedArgumentDescription +=
                "an instance of " +
                expectedUppercaseDataTypes.join(", ") +
                ", or " +
                lastExpectedUppercaseDataType;
            }
          }
          if (expectedArgumentDataTypes.length > 0) {
            formattedArgumentDescription += " or ";
          }
        }
        switch (expectedArgumentDataTypes.length) {
          case 0:
            break;
          case 1:
            if (
              expectedArgumentDataTypes[0].toLowerCase() !==
              expectedArgumentDataTypes[0]
            ) {
              formattedArgumentDescription += "an ";
            }
            formattedArgumentDescription += "" + expectedArgumentDataTypes[0];
            break;
          case 2:
            formattedArgumentDescription +=
              "one of " +
              expectedArgumentDataTypes[0] +
              " or " +
              expectedArgumentDataTypes[1];
            break;
          default: {
            let finalExpectedArgumentType = expectedArgumentDataTypes.pop();
            formattedArgumentDescription +=
              "one of " +
              expectedArgumentDataTypes.join(", ") +
              ", or " +
              finalExpectedArgumentType;
          }
        }
        if (checkExpectedArgumentTypes == null) {
          formattedArgumentDescription +=
            ". Received " + checkExpectedArgumentTypes;
        } else if (
          typeof checkExpectedArgumentTypes == "function" &&
          checkExpectedArgumentTypes.name
        ) {
          formattedArgumentDescription +=
            ". Received function " + checkExpectedArgumentTypes.name;
        } else if (typeof checkExpectedArgumentTypes == "object") {
          var expectedArgumentConstructor;
          if (
            (expectedArgumentConstructor =
              checkExpectedArgumentTypes.constructor) !== null &&
            expectedArgumentConstructor !== undefined &&
            expectedArgumentConstructor.name
          ) {
            formattedArgumentDescription +=
              ". Received an instance of " +
              checkExpectedArgumentTypes.constructor.name;
          } else {
            formattedArgumentDescription +=
              ". Received " +
              extractAndAnalyzeData(checkExpectedArgumentTypes, {
                depth: -1,
              });
          }
        } else {
          let analyzedArgumentTypesSummary = extractAndAnalyzeData(
            checkExpectedArgumentTypes,
            {
              colors: false,
            },
          );
          if (analyzedArgumentTypesSummary.length > 25) {
            analyzedArgumentTypesSummary =
              analyzedArgumentTypesSummary.slice(0, 25) + "...";
          }
          formattedArgumentDescription +=
            ". Received type " +
            typeof checkExpectedArgumentTypes +
            " (" +
            analyzedArgumentTypesSummary +
            ")";
        }
        return formattedArgumentDescription;
      },
      TypeError,
    );
    createCustomErrorTypeWithGenerator(
      "ERR_INVALID_ARG_VALUE",
      (
        generateValidationErrorMessage,
        inputValueForValidation,
        errorMessageInvalid = "is invalid",
      ) => {
        let sanitizedInputValue = extractAndAnalyzeData(
          inputValueForValidation,
        );
        if (sanitizedInputValue.length > 128) {
          sanitizedInputValue = sanitizedInputValue.slice(0, 128) + "...";
        }
        return (
          "The " +
          (generateValidationErrorMessage.includes(".")
            ? "property"
            : "argument") +
          " '" +
          generateValidationErrorMessage +
          "' " +
          errorMessageInvalid +
          ". Received " +
          sanitizedInputValue
        );
      },
      TypeError,
    );
    createCustomErrorTypeWithGenerator(
      "ERR_INVALID_RETURN_VALUE",
      (
        generateErrorMessage,
        generateExpectedReturnErrorMessage,
        formatExpectedReturnTypeErrorMessage,
      ) => {
        var expectedReturnValueTypeDescription;
        let actualReturnValueTypeDescription =
          formatExpectedReturnTypeErrorMessage != null &&
          (expectedReturnValueTypeDescription =
            formatExpectedReturnTypeErrorMessage.constructor) !== null &&
          expectedReturnValueTypeDescription !== undefined &&
          expectedReturnValueTypeDescription.name
            ? "instance of " +
              formatExpectedReturnTypeErrorMessage.constructor.name
            : "type " + typeof formatExpectedReturnTypeErrorMessage;
        return (
          "Expected " +
          generateErrorMessage +
          ' to be returned from the "' +
          generateExpectedReturnErrorMessage +
          '" function but got ' +
          actualReturnValueTypeDescription +
          "."
        );
      },
      TypeError,
    );
    createCustomErrorTypeWithGenerator(
      "ERR_MISSING_ARGS",
      (...inputArgs) => {
        checkAndProcessDataIntegrity(
          inputArgs.length > 0,
          "At least one arg needs to be specified",
        );
        let generateArgumentListDescription;
        let argumentCountTotal = inputArgs.length;
        inputArgs = (Array.isArray(inputArgs) ? inputArgs : [inputArgs])
          .map(
            (formattedStringWithQuotes) =>
              '"' + formattedStringWithQuotes + '"',
          )
          .join(" or ");
        switch (argumentCountTotal) {
          case 1:
            generateArgumentListDescription +=
              "The " + inputArgs[0] + " argument";
            break;
          case 2:
            generateArgumentListDescription +=
              "The " + inputArgs[0] + " and " + inputArgs[1] + " arguments";
            break;
          default:
            {
              let finalInputArgument = inputArgs.pop();
              generateArgumentListDescription +=
                "The " +
                inputArgs.join(", ") +
                ", and " +
                finalInputArgument +
                " arguments";
            }
            break;
        }
        return generateArgumentListDescription + " must be specified";
      },
      TypeError,
    );
    createCustomErrorTypeWithGenerator(
      "ERR_OUT_OF_RANGE",
      (_generateRangeErrorMessage, __generateRangeErrorMessage, inputValue) => {
        checkAndProcessDataIntegrity(
          __generateRangeErrorMessage,
          'Missing "range" argument',
        );
        let processedValue;
        if (Number.isInteger(inputValue) && Math.abs(inputValue) > 4294967296) {
          processedValue = convertAndFormatUint16ToBigEndianString(
            String(inputValue),
          );
        } else if (typeof inputValue == "bigint") {
          processedValue = String(inputValue);
          if (inputValue > 0x2n ** 0x20n || inputValue < -(0x2n ** 0x20n)) {
            processedValue =
              convertAndFormatUint16ToBigEndianString(processedValue);
          }
          processedValue += "n";
        } else {
          processedValue = extractAndAnalyzeData(inputValue);
        }
        return (
          'The value of "' +
          _generateRangeErrorMessage +
          '" is out of range. It must be ' +
          __generateRangeErrorMessage +
          ". Received " +
          processedValue
        );
      },
      RangeError,
    );
    createCustomErrorTypeWithGenerator(
      "ERR_MULTIPLE_CALLBACK",
      "Callback called multiple times",
      Error,
    );
    createCustomErrorTypeWithGenerator(
      "ERR_METHOD_NOT_IMPLEMENTED",
      "The %s method is not implemented",
      Error,
    );
    createCustomErrorTypeWithGenerator(
      "ERR_STREAM_ALREADY_FINISHED",
      "Cannot call %s after a stream was finished",
      Error,
    );
    createCustomErrorTypeWithGenerator(
      "ERR_STREAM_CANNOT_PIPE",
      "Cannot pipe, not readable",
      Error,
    );
    createCustomErrorTypeWithGenerator(
      "ERR_STREAM_DESTROYED",
      "Cannot call %s after a stream was destroyed",
      Error,
    );
    createCustomErrorTypeWithGenerator(
      "ERR_STREAM_NULL_VALUES",
      "May not write null values to stream",
      TypeError,
    );
    createCustomErrorTypeWithGenerator(
      "ERR_STREAM_PREMATURE_CLOSE",
      "Premature close",
      Error,
    );
    createCustomErrorTypeWithGenerator(
      "ERR_STREAM_PUSH_AFTER_EOF",
      "stream.push() after EOF",
      Error,
    );
    createCustomErrorTypeWithGenerator(
      "ERR_STREAM_UNSHIFT_AFTER_END_EVENT",
      "stream.unshift() after end event",
      Error,
    );
    createCustomErrorTypeWithGenerator(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end",
      Error,
    );
    createCustomErrorTypeWithGenerator(
      "ERR_UNKNOWN_ENCODING",
      "Unknown encoding: %s",
      TypeError,
    );
    _validateAndProcessData.exports = {
      AbortError: formatDataForProcessing,
      aggregateTwoErrors: assignFullNodeIdentifierToByteLength(
        combineErrorMessagesForProcessing,
      ),
      hideStackFrames: assignFullNodeIdentifierToByteLength,
      codes: DataProcessingErrorTypes,
    };
  },
);
var handleStreamErrorTypes = lazyModuleInitializer(
  (performNodeOperations, performNodeOperationsOnData) => {
    var {
      ArrayIsArray: isArrayCheck,
      ArrayPrototypeIncludes: ArrayIncludes,
      ArrayPrototypeJoin: arrayJoin,
      ArrayPrototypeMap: ArrayPrototypeMapFunction,
      NumberIsInteger: checkIfInteger,
      NumberIsNaN: checkIfNaN,
      NumberMAX_SAFE_INTEGER: MAX_INTEGER_SAFE_FOR_COMPUTATION,
      NumberMIN_SAFE_INTEGER: MIN_INTEGER_SAFE_FOR_COMPUTATION,
      NumberParseInt: convertStringToInteger,
      ObjectPrototypeHasOwnProperty: ObjectHasOwnPropertyCheck,
      RegExpPrototypeExec: executeRegularExpression,
      String: StringHelpers,
      StringPrototypeToUpperCase: convertStringToUpperCase,
      StringPrototypeTrim: trimStringPrototype,
    } = performComparisonOperation();
    var {
      hideStackFrames: suppressStackTrace,
      codes: {
        ERR_SOCKET_BAD_PORT: ERROR_INVALID_SOCKET_PORT,
        ERR_INVALID_ARG_TYPE: ERROR_TYPE_INVALID_ARGUMENT,
        ERR_INVALID_ARG_VALUE: ERROR_INVALID_ARGUMENT_VALUE,
        ERR_OUT_OF_RANGE: ERROR_INPUT_OUT_OF_BOUNDS,
        ERR_UNKNOWN_SIGNAL: ERROR_SIGNAL_UNRECOGNIZED,
      },
    } = fetchNodeValuePostTraversal();
    var { normalizeEncoding: _performNodeOperationsOnData } =
      validateAndProcessArrayBufferForProcessing();
    var {
      isAsyncFunction: performNodeDataOperations,
      isArrayBufferView: __performNodeOperationsOnData,
    } = validateAndProcessArrayBufferForProcessing().types;
    var performComparisonOperationOnNodes = {};
    function isLengthInteger(calculateItemLength) {
      return calculateItemLength === (calculateItemLength | 0);
    }
    function isValidNonNegativeInteger(configureLengthCalculator) {
      return configureLengthCalculator === configureLengthCalculator >>> 0;
    }
    var executeComparisonLogic = /^[0-7]+$/;
    var _performComparisonOperation =
      "must be a 32-bit unsigned integer or an octal string";
    function calculateLengthsAndTotal(
      recalculateLengthsAndTotal,
      _calculateItemLength,
      getItemLength,
    ) {
      if (typeof recalculateLengthsAndTotal === "undefined") {
        recalculateLengthsAndTotal = getItemLength;
      }
      if (typeof recalculateLengthsAndTotal == "string") {
        if (
          executeRegularExpression(
            executeComparisonLogic,
            recalculateLengthsAndTotal,
          ) === null
        ) {
          throw new ERROR_INVALID_ARGUMENT_VALUE(
            _calculateItemLength,
            recalculateLengthsAndTotal,
            _performComparisonOperation,
          );
        }
        recalculateLengthsAndTotal = convertStringToInteger(
          recalculateLengthsAndTotal,
          8,
        );
      }
      _performNodeOperations(recalculateLengthsAndTotal, _calculateItemLength);
      return recalculateLengthsAndTotal;
    }
    var __performComparisonOperation = suppressStackTrace(
      (
        validateIntegerWithinSafeRange,
        _validateIntegerWithinSafeRange,
        _MIN_INTEGER_SAFE_FOR_COMPUTATION = MIN_INTEGER_SAFE_FOR_COMPUTATION,
        MAX_SAFE_INTEGER_FOR_COMPUTATION = MAX_INTEGER_SAFE_FOR_COMPUTATION,
      ) => {
        if (typeof validateIntegerWithinSafeRange != "number") {
          throw new ERROR_TYPE_INVALID_ARGUMENT(
            _validateIntegerWithinSafeRange,
            "number",
            validateIntegerWithinSafeRange,
          );
        }
        if (!checkIfInteger(validateIntegerWithinSafeRange)) {
          throw new ERROR_INPUT_OUT_OF_BOUNDS(
            _validateIntegerWithinSafeRange,
            "an integer",
            validateIntegerWithinSafeRange,
          );
        }
        if (
          validateIntegerWithinSafeRange < _MIN_INTEGER_SAFE_FOR_COMPUTATION ||
          validateIntegerWithinSafeRange > MAX_SAFE_INTEGER_FOR_COMPUTATION
        ) {
          throw new ERROR_INPUT_OUT_OF_BOUNDS(
            _validateIntegerWithinSafeRange,
            ">= " +
              _MIN_INTEGER_SAFE_FOR_COMPUTATION +
              " && <= " +
              MAX_SAFE_INTEGER_FOR_COMPUTATION,
            validateIntegerWithinSafeRange,
          );
        }
      },
    );
    var ___performComparisonOperation = suppressStackTrace(
      (
        validateIntegerWithinBounds,
        validateIntegerInRange,
        minimumAllowedInteger = -2147483648,
        maximumAllowedInteger = 2147483647,
      ) => {
        if (typeof validateIntegerWithinBounds != "number") {
          throw new ERROR_TYPE_INVALID_ARGUMENT(
            validateIntegerInRange,
            "number",
            validateIntegerWithinBounds,
          );
        }
        if (!checkIfInteger(validateIntegerWithinBounds)) {
          throw new ERROR_INPUT_OUT_OF_BOUNDS(
            validateIntegerInRange,
            "an integer",
            validateIntegerWithinBounds,
          );
        }
        if (
          validateIntegerWithinBounds < minimumAllowedInteger ||
          validateIntegerWithinBounds > maximumAllowedInteger
        ) {
          throw new ERROR_INPUT_OUT_OF_BOUNDS(
            validateIntegerInRange,
            ">= " + minimumAllowedInteger + " && <= " + maximumAllowedInteger,
            validateIntegerWithinBounds,
          );
        }
      },
    );
    var _performNodeOperations = suppressStackTrace(
      (
        validateAndEnsureUnsignedInteger,
        ensureValidUnsignedInteger,
        isUserLoggedIn = false,
      ) => {
        if (typeof validateAndEnsureUnsignedInteger != "number") {
          throw new ERROR_TYPE_INVALID_ARGUMENT(
            ensureValidUnsignedInteger,
            "number",
            validateAndEnsureUnsignedInteger,
          );
        }
        if (!checkIfInteger(validateAndEnsureUnsignedInteger)) {
          throw new ERROR_INPUT_OUT_OF_BOUNDS(
            ensureValidUnsignedInteger,
            "an integer",
            validateAndEnsureUnsignedInteger,
          );
        }
        let minValueForUnsignedInteger = isUserLoggedIn ? 1 : 0;
        let unsignedIntegerUpperLimit = 4294967295;
        if (
          validateAndEnsureUnsignedInteger < minValueForUnsignedInteger ||
          validateAndEnsureUnsignedInteger > unsignedIntegerUpperLimit
        ) {
          throw new ERROR_INPUT_OUT_OF_BOUNDS(
            ensureValidUnsignedInteger,
            ">= " +
              minValueForUnsignedInteger +
              " && <= " +
              unsignedIntegerUpperLimit,
            validateAndEnsureUnsignedInteger,
          );
        }
      },
    );
    function validateCacheEntryString(
      validateAndEnforceUnsignedIntegerRange,
      cacheValueSetter,
    ) {
      if (typeof validateAndEnforceUnsignedIntegerRange != "string") {
        throw new ERROR_TYPE_INVALID_ARGUMENT(
          cacheValueSetter,
          "string",
          validateAndEnforceUnsignedIntegerRange,
        );
      }
    }
    function validateCacheEntryAgainstConstraints(
      validateCacheEntry,
      _validateAndEnforceUnsignedIntegerRange,
      currentUserAuthToken = undefined,
      validateAndEnforceCacheEntryConstraints,
    ) {
      if (typeof validateCacheEntry != "number") {
        throw new ERROR_TYPE_INVALID_ARGUMENT(
          _validateAndEnforceUnsignedIntegerRange,
          "number",
          validateCacheEntry,
        );
      }
      if (
        (currentUserAuthToken != null &&
          validateCacheEntry < currentUserAuthToken) ||
        (validateAndEnforceCacheEntryConstraints != null &&
          validateCacheEntry > validateAndEnforceCacheEntryConstraints) ||
        ((currentUserAuthToken != null ||
          validateAndEnforceCacheEntryConstraints != null) &&
          checkIfNaN(validateCacheEntry))
      ) {
        throw new ERROR_INPUT_OUT_OF_BOUNDS(
          _validateAndEnforceUnsignedIntegerRange,
          "" +
            (currentUserAuthToken != null ? ">= " + currentUserAuthToken : "") +
            (currentUserAuthToken != null &&
            validateAndEnforceCacheEntryConstraints != null
              ? " && "
              : "") +
            (validateAndEnforceCacheEntryConstraints != null
              ? "<= " + validateAndEnforceCacheEntryConstraints
              : ""),
          validateCacheEntry,
        );
      }
    }
    var performOperationsOnNodeData = suppressStackTrace(
      (
        checkArgumentAgainstValidOptions,
        validateArgumentAgainstOptions,
        providedArgumentValues,
      ) => {
        if (
          !ArrayIncludes(
            providedArgumentValues,
            checkArgumentAgainstValidOptions,
          )
        ) {
          let formattedArgumentValuesDisplay = arrayJoin(
            ArrayPrototypeMapFunction(
              providedArgumentValues,
              (formatStringWithQuotesOrUtility) =>
                typeof formatStringWithQuotesOrUtility == "string"
                  ? "'" + formatStringWithQuotesOrUtility + "'"
                  : StringHelpers(formatStringWithQuotesOrUtility),
            ),
            ", ",
          );
          let formattedArgumentErrorMessage =
            "must be one of: " + formattedArgumentValuesDisplay;
          throw new ERROR_INVALID_ARGUMENT_VALUE(
            validateArgumentAgainstOptions,
            checkArgumentAgainstValidOptions,
            formattedArgumentErrorMessage,
          );
        }
      },
    );
    function checkIfBoolean(
      _______executeNodeOperations,
      ________executeNodeOperations,
    ) {
      if (typeof _______executeNodeOperations != "boolean") {
        throw new ERROR_TYPE_INVALID_ARGUMENT(
          ________executeNodeOperations,
          "boolean",
          _______executeNodeOperations,
        );
      }
    }
    function retrieveCachedElementOrFallback(
      validateAndAddElementToCache,
      validateCacheConstraintsAndSessionToken,
      executeNodeOperationWithValidation,
    ) {
      if (
        validateAndAddElementToCache == null ||
        !ObjectHasOwnPropertyCheck(
          validateAndAddElementToCache,
          validateCacheConstraintsAndSessionToken,
        )
      ) {
        return executeNodeOperationWithValidation;
      } else {
        return validateAndAddElementToCache[
          validateCacheConstraintsAndSessionToken
        ];
      }
    }
    var performComparisonOperations = suppressStackTrace(
      (checkInputValidity, _inputValue, __currentUserSession = null) => {
        let isArrayInputAllowed = retrieveCachedElementOrFallback(
          __currentUserSession,
          "allowArray",
          false,
        );
        let isFunctionExecutionPermitted = retrieveCachedElementOrFallback(
          __currentUserSession,
          "allowFunction",
          false,
        );
        if (
          (!retrieveCachedElementOrFallback(
            __currentUserSession,
            "nullable",
            false,
          ) &&
            checkInputValidity === null) ||
          (!isArrayInputAllowed && isArrayCheck(checkInputValidity)) ||
          (typeof checkInputValidity != "object" &&
            (!isFunctionExecutionPermitted ||
              typeof checkInputValidity != "function"))
        ) {
          throw new ERROR_TYPE_INVALID_ARGUMENT(
            _inputValue,
            "Object",
            checkInputValidity,
          );
        }
      },
    );
    var ____performComparisonOperation = suppressStackTrace(
      (
        validateArrayLengthAndCheckMinValue,
        generateErrorMessageForArrayLengthValidation,
        _initialValue = 0,
      ) => {
        if (!isArrayCheck(validateArrayLengthAndCheckMinValue)) {
          throw new ERROR_TYPE_INVALID_ARGUMENT(
            generateErrorMessageForArrayLengthValidation,
            "Array",
            validateArrayLengthAndCheckMinValue,
          );
        }
        if (validateArrayLengthAndCheckMinValue.length < _initialValue) {
          let arrayLengthValidationErrorMessage =
            "must be longer than " + _initialValue;
          throw new ERROR_INVALID_ARGUMENT_VALUE(
            generateErrorMessageForArrayLengthValidation,
            validateArrayLengthAndCheckMinValue,
            arrayLengthValidationErrorMessage,
          );
        }
      },
    );
    function checkSignalValidityAndExecute(
      retrieveElementFromCacheOrDefault,
      communicationSignalType = "signal",
    ) {
      validateCacheEntryString(
        retrieveElementFromCacheOrDefault,
        communicationSignalType,
      );
      if (
        performComparisonOperationOnNodes[retrieveElementFromCacheOrDefault] ===
        undefined
      ) {
        throw performComparisonOperationOnNodes[
          convertStringToUpperCase(retrieveElementFromCacheOrDefault)
        ] !== undefined
          ? new ERROR_SIGNAL_UNRECOGNIZED(
              retrieveElementFromCacheOrDefault +
                " (signals must use all capital letters)",
            )
          : new ERROR_SIGNAL_UNRECOGNIZED(retrieveElementFromCacheOrDefault);
      }
    }
    var _____performComparisonOperation = suppressStackTrace(
      (dataNodeOperationInput, __dataBuffer = "buffer") => {
        if (!__performNodeOperationsOnData(dataNodeOperationInput)) {
          throw new ERROR_TYPE_INVALID_ARGUMENT(
            __dataBuffer,
            ["Buffer", "TypedArray", "DataView"],
            dataNodeOperationInput,
          );
        }
      },
    );
    function assertNodeEncodingValidity(
      validateAndProcessNode,
      validateAndRemoveExpiredSessionNode,
    ) {
      let processedNodeEncoding = _performNodeOperationsOnData(
        validateAndRemoveExpiredSessionNode,
      );
      let validateAndProcessNodeLength = validateAndProcessNode.length;
      if (
        processedNodeEncoding === "hex" &&
        validateAndProcessNodeLength % 2 !== 0
      ) {
        throw new ERROR_INVALID_ARGUMENT_VALUE(
          "encoding",
          validateAndRemoveExpiredSessionNode,
          "is invalid for data of length " + validateAndProcessNodeLength,
        );
      }
    }
    function validateAndNormalizePortNumber(
      validateArrayLengthAndThrowErrors,
      connectionPortName = "Port",
      isPortMandatory = true,
    ) {
      if (
        (typeof validateArrayLengthAndThrowErrors != "number" &&
          typeof validateArrayLengthAndThrowErrors != "string") ||
        (typeof validateArrayLengthAndThrowErrors == "string" &&
          trimStringPrototype(validateArrayLengthAndThrowErrors).length ===
            0) ||
        +validateArrayLengthAndThrowErrors !==
          +validateArrayLengthAndThrowErrors >>> 0 ||
        validateArrayLengthAndThrowErrors > 65535 ||
        (validateArrayLengthAndThrowErrors === 0 && !isPortMandatory)
      ) {
        throw new ERROR_INVALID_SOCKET_PORT(
          connectionPortName,
          validateArrayLengthAndThrowErrors,
          isPortMandatory,
        );
      }
      return validateArrayLengthAndThrowErrors | 0;
    }
    var initializeNodeOperationHelpers = suppressStackTrace(
      (_____abortSignal, abortSignalOptions) => {
        if (
          _____abortSignal !== undefined &&
          (_____abortSignal === null ||
            typeof _____abortSignal != "object" ||
            !("aborted" in _____abortSignal))
        ) {
          throw new ERROR_TYPE_INVALID_ARGUMENT(
            abortSignalOptions,
            "AbortSignal",
            _____abortSignal,
          );
        }
      },
    );
    var ___performNodeOperationsOnData = suppressStackTrace(
      (validateArgumentFunction, validateFunctionArgument) => {
        if (typeof validateArgumentFunction != "function") {
          throw new ERROR_TYPE_INVALID_ARGUMENT(
            validateFunctionArgument,
            "Function",
            validateArgumentFunction,
          );
        }
      },
    );
    var performComparisonOperationBasedOnNode = suppressStackTrace(
      (validateInputFunction, validateInputAndPerformOperations) => {
        if (
          typeof validateInputFunction != "function" ||
          performNodeDataOperations(validateInputFunction)
        ) {
          throw new ERROR_TYPE_INVALID_ARGUMENT(
            validateInputAndPerformOperations,
            "Function",
            validateInputFunction,
          );
        }
      },
    );
    var ______performComparisonOperation = suppressStackTrace(
      (checkForUndefinedAndThrowError, valueToValidate) => {
        if (checkForUndefinedAndThrowError !== undefined) {
          throw new ERROR_TYPE_INVALID_ARGUMENT(
            valueToValidate,
            "undefined",
            checkForUndefinedAndThrowError,
          );
        }
      },
    );
    function checkAndThrowInvalidPortNumber(
      validateAndThrowIfBadPortNumber,
      setValueForNode,
      validatePortNumberAndThrowIfInvalid,
    ) {
      if (
        !ArrayIncludes(
          validatePortNumberAndThrowIfInvalid,
          validateAndThrowIfBadPortNumber,
        )
      ) {
        throw new ERROR_TYPE_INVALID_ARGUMENT(
          setValueForNode,
          "('" + arrayJoin(validatePortNumberAndThrowIfInvalid, "|") + "')",
          validateAndThrowIfBadPortNumber,
        );
      }
    }
    performNodeOperationsOnData.exports = {
      isInt32: isLengthInteger,
      isUint32: isValidNonNegativeInteger,
      parseFileMode: calculateLengthsAndTotal,
      validateArray: ____performComparisonOperation,
      validateBoolean: checkIfBoolean,
      validateBuffer: _____performComparisonOperation,
      validateEncoding: assertNodeEncodingValidity,
      validateFunction: ___performNodeOperationsOnData,
      validateInt32: ___performComparisonOperation,
      validateInteger: __performComparisonOperation,
      validateNumber: validateCacheEntryAgainstConstraints,
      validateObject: performComparisonOperations,
      validateOneOf: performOperationsOnNodeData,
      validatePlainFunction: performComparisonOperationBasedOnNode,
      validatePort: validateAndNormalizePortNumber,
      validateSignalName: checkSignalValidityAndExecute,
      validateString: validateCacheEntryString,
      validateUint32: _performNodeOperations,
      validateUndefined: ______performComparisonOperation,
      validateUnion: checkAndThrowInvalidPortNumber,
      validateAbortSignal: initializeNodeOperationHelpers,
    };
  },
);
var isSemVerRangeValid = lazyModuleInitializer(
  (initializeTimeoutFunctions, initializeAndDefineTimeoutFunctions) => {
    var timeoutFunctionMappings = (initializeAndDefineTimeoutFunctions.exports =
      {});
    var fallbackSetTimeout;
    var retrieveOrThrowClearTimeout;
    function raiseSetTimeoutUndefinedError() {
      throw new Error("setTimeout has not been defined");
    }
    function raiseClearTimeoutUndefinedError() {
      throw new Error("clearTimeout has not been defined");
    }
    (function () {
      try {
        if (typeof setTimeout == "function") {
          fallbackSetTimeout = setTimeout;
        } else {
          fallbackSetTimeout = raiseSetTimeoutUndefinedError;
        }
      } catch {
        fallbackSetTimeout = raiseSetTimeoutUndefinedError;
      }
      try {
        if (typeof clearTimeout == "function") {
          retrieveOrThrowClearTimeout = clearTimeout;
        } else {
          retrieveOrThrowClearTimeout = raiseClearTimeoutUndefinedError;
        }
      } catch {
        retrieveOrThrowClearTimeout = raiseClearTimeoutUndefinedError;
      }
    })();
    function executeHyphenatedRangeProcessing(processHyphenatedRangeInput) {
      if (fallbackSetTimeout === setTimeout) {
        return setTimeout(processHyphenatedRangeInput, 0);
      }
      if (
        (fallbackSetTimeout === raiseSetTimeoutUndefinedError ||
          !fallbackSetTimeout) &&
        setTimeout
      ) {
        fallbackSetTimeout = setTimeout;
        return setTimeout(processHyphenatedRangeInput, 0);
      }
      try {
        return fallbackSetTimeout(processHyphenatedRangeInput, 0);
      } catch {
        try {
          return fallbackSetTimeout.call(null, processHyphenatedRangeInput, 0);
        } catch {
          return fallbackSetTimeout.call(this, processHyphenatedRangeInput, 0);
        }
      }
    }
    function safelyClearTimeout(validateSemanticVersionRange) {
      if (retrieveOrThrowClearTimeout === clearTimeout) {
        return clearTimeout(validateSemanticVersionRange);
      }
      if (
        (retrieveOrThrowClearTimeout === raiseClearTimeoutUndefinedError ||
          !retrieveOrThrowClearTimeout) &&
        clearTimeout
      ) {
        retrieveOrThrowClearTimeout = clearTimeout;
        return clearTimeout(validateSemanticVersionRange);
      }
      try {
        return retrieveOrThrowClearTimeout(validateSemanticVersionRange);
      } catch {
        try {
          return retrieveOrThrowClearTimeout.call(
            null,
            validateSemanticVersionRange,
          );
        } catch {
          return retrieveOrThrowClearTimeout.call(
            this,
            validateSemanticVersionRange,
          );
        }
      }
    }
    var ensureSetTimeoutExists = [];
    var initializeTimeoutFunctionality = false;
    var initializeTimeoutHandlers;
    var _initializeTimeoutHandlers = -1;
    function configureTimeoutHandlers() {
      if (!!initializeTimeoutFunctionality && !!initializeTimeoutHandlers) {
        initializeTimeoutFunctionality = false;
        if (initializeTimeoutHandlers.length) {
          ensureSetTimeoutExists = initializeTimeoutHandlers.concat(
            ensureSetTimeoutExists,
          );
        } else {
          _initializeTimeoutHandlers = -1;
        }
        if (ensureSetTimeoutExists.length) {
          setupTimeoutHandlerExecution();
        }
      }
    }
    function setupTimeoutHandlerExecution() {
      if (!initializeTimeoutFunctionality) {
        var parsedTimeoutSchedule = executeHyphenatedRangeProcessing(
          configureTimeoutHandlers,
        );
        initializeTimeoutFunctionality = true;
        for (
          var activeTimeoutHandlersCount = ensureSetTimeoutExists.length;
          activeTimeoutHandlersCount;

        ) {
          initializeTimeoutHandlers = ensureSetTimeoutExists;
          ensureSetTimeoutExists = [];
          while (++_initializeTimeoutHandlers < activeTimeoutHandlersCount) {
            if (initializeTimeoutHandlers) {
              initializeTimeoutHandlers[_initializeTimeoutHandlers].run();
            }
          }
          _initializeTimeoutHandlers = -1;
          activeTimeoutHandlersCount = ensureSetTimeoutExists.length;
        }
        initializeTimeoutHandlers = null;
        initializeTimeoutFunctionality = false;
        safelyClearTimeout(parsedTimeoutSchedule);
      }
    }
    timeoutFunctionMappings.nextTick = function (
      validateSemanticVersionRangeTimeout,
    ) {
      var timeoutFunctionArguments = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (
          var timeoutFunctionArgsIndex = 1;
          timeoutFunctionArgsIndex < arguments.length;
          timeoutFunctionArgsIndex++
        ) {
          timeoutFunctionArguments[timeoutFunctionArgsIndex - 1] =
            arguments[timeoutFunctionArgsIndex];
        }
      }
      ensureSetTimeoutExists.push(
        new TimeoutIntersectionManager(
          validateSemanticVersionRangeTimeout,
          timeoutFunctionArguments,
        ),
      );
      if (
        ensureSetTimeoutExists.length === 1 &&
        !initializeTimeoutFunctionality
      ) {
        executeHyphenatedRangeProcessing(setupTimeoutHandlerExecution);
      }
    };
    function TimeoutIntersectionManager(
      configureSetTimeout,
      manageTimeoutConfiguration,
    ) {
      this.fun = configureSetTimeout;
      this.array = manageTimeoutConfiguration;
    }
    TimeoutIntersectionManager.prototype.run = function () {
      this.fun.apply(null, this.array);
    };
    timeoutFunctionMappings.title = "browser";
    timeoutFunctionMappings.browser = true;
    timeoutFunctionMappings.env = {};
    timeoutFunctionMappings.argv = [];
    timeoutFunctionMappings.version = "";
    timeoutFunctionMappings.versions = {};
    function setupApp() {}
    timeoutFunctionMappings.on = setupApp;
    timeoutFunctionMappings.addListener = setupApp;
    timeoutFunctionMappings.once = setupApp;
    timeoutFunctionMappings.off = setupApp;
    timeoutFunctionMappings.removeListener = setupApp;
    timeoutFunctionMappings.removeAllListeners = setupApp;
    timeoutFunctionMappings.emit = setupApp;
    timeoutFunctionMappings.prependListener = setupApp;
    timeoutFunctionMappings.prependOnceListener = setupApp;
    timeoutFunctionMappings.listeners = function (scheduleTimeoutHandlers) {
      return [];
    };
    timeoutFunctionMappings.binding = function (
      validateTimeoutFunctionExecution,
    ) {
      throw new Error("process.binding is not supported");
    };
    timeoutFunctionMappings.cwd = function () {
      return "/";
    };
    timeoutFunctionMappings.chdir = function (isTimeoutFunctionScheduled) {
      throw new Error("process.chdir is not supported");
    };
    timeoutFunctionMappings.umask = function () {
      return 0;
    };
  },
);
var scheduleTimeoutWithArguments = lazyModuleInitializer(
  (
    validateStreamConfigAndCheckReadiness,
    validateStreamConfigurationAndReadiness,
  ) => {
    var {
      Symbol: getSymbolByName,
      SymbolAsyncIterator: asyncIteratorSymbol,
      SymbolIterator: streamSymbolIterator,
    } = performComparisonOperation();
    var destroyedSymbol = getSymbolByName("kDestroyed");
    var isStreamErroredSymbol = getSymbolByName("kIsErrored");
    var isStreamReadableSymbol = getSymbolByName("kIsReadable");
    var isStreamDisturbedSymbol = getSymbolByName("kIsDisturbed");
    function __isValidVersionRange(
      validateDateVersionCompatibility,
      isCompatibleVersionRange = false,
    ) {
      return (
        !!validateDateVersionCompatibility &&
        typeof validateDateVersionCompatibility.pipe == "function" &&
        typeof validateDateVersionCompatibility.on == "function" &&
        (!isCompatibleVersionRange ||
          (typeof validateDateVersionCompatibility.pause == "function" &&
            typeof validateDateVersionCompatibility.resume == "function")) &&
        (!validateDateVersionCompatibility._writableState ||
          validateDateVersionCompatibility._readableState?.readable !==
            false) &&
        (!validateDateVersionCompatibility._writableState ||
          !!validateDateVersionCompatibility._readableState)
      );
    }
    function isWritableStreamCompliant(initializeTimeoutFunctionHandlers) {
      return (
        !!initializeTimeoutFunctionHandlers &&
        typeof initializeTimeoutFunctionHandlers.write == "function" &&
        typeof initializeTimeoutFunctionHandlers.on == "function" &&
        (!initializeTimeoutFunctionHandlers._readableState ||
          initializeTimeoutFunctionHandlers._writableState?.writable !== false)
      );
    }
    function ______isStreamReadable(initializeTimeoutHandlerMappings) {
      return (
        !!initializeTimeoutHandlerMappings &&
        typeof initializeTimeoutHandlerMappings.pipe == "function" &&
        !!initializeTimeoutHandlerMappings._readableState &&
        typeof initializeTimeoutHandlerMappings.on == "function" &&
        typeof initializeTimeoutHandlerMappings.write == "function"
      );
    }
    function isReadableWritableStream(getFormattedApplicationVersion) {
      return (
        getFormattedApplicationVersion &&
        (getFormattedApplicationVersion._readableState ||
          getFormattedApplicationVersion._writableState ||
          (typeof getFormattedApplicationVersion.write == "function" &&
            typeof getFormattedApplicationVersion.on == "function") ||
          (typeof getFormattedApplicationVersion.pipe == "function" &&
            typeof getFormattedApplicationVersion.on == "function"))
      );
    }
    function checkIfIterableVersion(
      validateVersionCompatibility,
      createVersionRangeFromTilde,
    ) {
      if (validateVersionCompatibility == null) {
        return false;
      } else if (createVersionRangeFromTilde === true) {
        return (
          typeof validateVersionCompatibility[asyncIteratorSymbol] == "function"
        );
      } else if (createVersionRangeFromTilde === false) {
        return (
          typeof validateVersionCompatibility[streamSymbolIterator] ==
          "function"
        );
      } else {
        return (
          typeof validateVersionCompatibility[asyncIteratorSymbol] ==
            "function" ||
          typeof validateVersionCompatibility[streamSymbolIterator] ==
            "function"
        );
      }
    }
    function checkIfStreamIsDestroyed(_validateVersionCompatibility) {
      if (!isReadableWritableStream(_validateVersionCompatibility)) {
        return null;
      }
      let ___writableState = _validateVersionCompatibility._writableState;
      let ________________readableStreamState =
        _validateVersionCompatibility._readableState;
      let combinedStreamState =
        ___writableState || ________________readableStreamState;
      return (
        !!_validateVersionCompatibility.destroyed ||
        !!_validateVersionCompatibility[destroyedSymbol] ||
        (combinedStreamState != null && !!combinedStreamState.destroyed)
      );
    }
    function isWritableStreamEnded(validateStreamCompatibility) {
      if (!isWritableStreamCompliant(validateStreamCompatibility)) {
        return null;
      }
      if (validateStreamCompatibility.writableEnded === true) {
        return true;
      }
      let ______________writableStreamState =
        validateStreamCompatibility._writableState;
      if (
        ______________writableStreamState != null &&
        ______________writableStreamState.errored
      ) {
        return false;
      } else if (typeof ______________writableStreamState?.ended != "boolean") {
        return null;
      } else {
        return ______________writableStreamState.ended;
      }
    }
    function _validateWritableStreamState(
      validateVersionCompatibilityAndTransformRange,
      validateCaretVersionCompatibility,
    ) {
      if (
        !isWritableStreamCompliant(
          validateVersionCompatibilityAndTransformRange,
        )
      ) {
        return null;
      }
      if (
        validateVersionCompatibilityAndTransformRange.writableFinished === true
      ) {
        return true;
      }
      let ____________writableStreamState =
        validateVersionCompatibilityAndTransformRange._writableState;
      if (
        ____________writableStreamState != null &&
        ____________writableStreamState.errored
      ) {
        return false;
      } else if (
        typeof ____________writableStreamState?.finished != "boolean"
      ) {
        return null;
      } else {
        return (
          !!____________writableStreamState.finished ||
          (validateCaretVersionCompatibility === false &&
            ____________writableStreamState.ended === true &&
            ____________writableStreamState.length === 0)
        );
      }
    }
    function checkIfVersionStreamReadable(isVersionStreamActive) {
      if (!__isValidVersionRange(isVersionStreamActive)) {
        return null;
      }
      if (isVersionStreamActive.readableEnded === true) {
        return true;
      }
      let versionStreamReadableState = isVersionStreamActive._readableState;
      if (!versionStreamReadableState || versionStreamReadableState.errored) {
        return false;
      } else if (typeof versionStreamReadableState?.ended != "boolean") {
        return null;
      } else {
        return versionStreamReadableState.ended;
      }
    }
    function hasPatchVersionBeenEmitted(
      validateStreamPatchVersion,
      checkVersionRangeCompatibility,
    ) {
      if (!__isValidVersionRange(validateStreamPatchVersion)) {
        return null;
      }
      let _______________readableStreamState =
        validateStreamPatchVersion._readableState;
      if (
        _______________readableStreamState != null &&
        _______________readableStreamState.errored
      ) {
        return false;
      } else if (
        typeof _______________readableStreamState?.endEmitted != "boolean"
      ) {
        return null;
      } else {
        return (
          !!_______________readableStreamState.endEmitted ||
          (checkVersionRangeCompatibility === false &&
            _______________readableStreamState.ended === true &&
            _______________readableStreamState.length === 0)
        );
      }
    }
    function isStreamVersionRangeReadable(checkWritableStreamCompatibility) {
      if (
        checkWritableStreamCompatibility &&
        checkWritableStreamCompatibility[isStreamReadableSymbol] != null
      ) {
        return checkWritableStreamCompatibility[isStreamReadableSymbol];
      } else if (
        typeof checkWritableStreamCompatibility?.readable != "boolean"
      ) {
        return null;
      } else if (checkIfStreamIsDestroyed(checkWritableStreamCompatibility)) {
        return false;
      } else {
        return (
          __isValidVersionRange(checkWritableStreamCompatibility) &&
          checkWritableStreamCompatibility.readable &&
          !hasPatchVersionBeenEmitted(checkWritableStreamCompatibility)
        );
      }
    }
    function validateWritableVersionRange(checkWritableStateValidity) {
      if (typeof checkWritableStateValidity?.writable != "boolean") {
        return null;
      } else if (checkIfStreamIsDestroyed(checkWritableStateValidity)) {
        return false;
      } else {
        return (
          isWritableStreamCompliant(checkWritableStateValidity) &&
          checkWritableStateValidity.writable &&
          !isWritableStreamEnded(checkWritableStateValidity)
        );
      }
    }
    function isStreamVersionCompatibilityValid(
      validateWritableStreamState,
      validateAndCheckVersionCompatibility,
    ) {
      if (isReadableWritableStream(validateWritableStreamState)) {
        if (checkIfStreamIsDestroyed(validateWritableStreamState)) {
          return true;
        } else {
          return (
            (validateAndCheckVersionCompatibility?.readable === false ||
              !isStreamVersionRangeReadable(validateWritableStreamState)) &&
            (validateAndCheckVersionCompatibility?.writable === false ||
              !validateWritableVersionRange(validateWritableStreamState))
          );
        }
      } else {
        return null;
      }
    }
    function retrieveWritableErrorState(validateVersionRangeCompatibility) {
      if (isReadableWritableStream(validateVersionRangeCompatibility)) {
        if (validateVersionRangeCompatibility.writableErrored) {
          return validateVersionRangeCompatibility.writableErrored;
        } else {
          return (
            validateVersionRangeCompatibility._writableState?.errored ?? null
          );
        }
      } else {
        return null;
      }
    }
    function extractReadableErrorFromVersionRange(isValidVersionRange) {
      if (isReadableWritableStream(isValidVersionRange)) {
        if (isValidVersionRange.readableErrored) {
          return isValidVersionRange.readableErrored;
        } else {
          return isValidVersionRange._readableState?.errored ?? null;
        }
      } else {
        return null;
      }
    }
    function determineStreamClosureState(validatePatchVersionEmission) {
      if (!isReadableWritableStream(validatePatchVersionEmission)) {
        return null;
      }
      if (typeof validatePatchVersionEmission.closed == "boolean") {
        return validatePatchVersionEmission.closed;
      }
      let __writableState = validatePatchVersionEmission._writableState;
      let ________readableStreamState =
        validatePatchVersionEmission._readableState;
      if (
        typeof __writableState?.closed == "boolean" ||
        typeof ________readableStreamState?.closed == "boolean"
      ) {
        return __writableState?.closed || ________readableStreamState?.closed;
      } else if (
        typeof validatePatchVersionEmission._closed == "boolean" &&
        areMinorVersionFlagsValid(validatePatchVersionEmission)
      ) {
        return validatePatchVersionEmission._closed;
      } else {
        return null;
      }
    }
    function areMinorVersionFlagsValid(versionMinorComponent) {
      return (
        typeof versionMinorComponent._closed == "boolean" &&
        typeof versionMinorComponent._defaultKeepAlive == "boolean" &&
        typeof versionMinorComponent._removedConnection == "boolean" &&
        typeof versionMinorComponent._removedContLen == "boolean"
      );
    }
    function isWritableStreamCompatibilityVersionValid(
      validateAndCheckWritableStreamCompatibility,
    ) {
      return (
        typeof validateAndCheckWritableStreamCompatibility._sent100 ==
          "boolean" &&
        areMinorVersionFlagsValid(validateAndCheckWritableStreamCompatibility)
      );
    }
    function areWritableStreamStateFlagsValid(
      validateWritableStreamCompatibilityAndState,
    ) {
      return (
        typeof validateWritableStreamCompatibilityAndState._consuming ==
          "boolean" &&
        typeof validateWritableStreamCompatibilityAndState._dumped ==
          "boolean" &&
        validateWritableStreamCompatibilityAndState.req?.upgradeOrConnect ===
          undefined
      );
    }
    function isWritableStreamReadyForDestruction(isWritableVersionRangeValid) {
      if (!isReadableWritableStream(isWritableVersionRangeValid)) {
        return null;
      }
      let _____________writableStreamState =
        isWritableVersionRangeValid._writableState;
      let _____________readableStreamState =
        isWritableVersionRangeValid._readableState;
      let streamCombinedState =
        _____________writableStreamState || _____________readableStreamState;
      return (
        (!streamCombinedState &&
          isWritableStreamCompatibilityVersionValid(
            isWritableVersionRangeValid,
          )) ||
        (!!streamCombinedState &&
          !!streamCombinedState.autoDestroy &&
          !!streamCombinedState.emitClose &&
          streamCombinedState.closed === false)
      );
    }
    function isCompatibilityVersionStable(
      generateVersionRangeFromCompatibility,
    ) {
      return (
        !!generateVersionRangeFromCompatibility &&
        !!(
          generateVersionRangeFromCompatibility[isStreamDisturbedSymbol] ??
          (generateVersionRangeFromCompatibility.readableDidRead ||
            generateVersionRangeFromCompatibility.readableAborted)
        )
      );
    }
    function checkIfStreamHasErrors(extractWritableErrorStateFromStream) {
      return (
        !!extractWritableErrorStateFromStream &&
        !!(
          extractWritableErrorStateFromStream[isStreamErroredSymbol] ??
          extractWritableErrorStateFromStream.readableErrored ??
          extractWritableErrorStateFromStream.writableErrored ??
          extractWritableErrorStateFromStream._readableState?.errorEmitted ??
          extractWritableErrorStateFromStream._writableState?.errorEmitted ??
          extractWritableErrorStateFromStream._readableState?.errored ??
          extractWritableErrorStateFromStream._writableState?.errored
        )
      );
    }
    validateStreamConfigurationAndReadiness.exports = {
      kDestroyed: destroyedSymbol,
      isDisturbed: isCompatibilityVersionStable,
      kIsDisturbed: isStreamDisturbedSymbol,
      isErrored: checkIfStreamHasErrors,
      kIsErrored: isStreamErroredSymbol,
      isReadable: isStreamVersionRangeReadable,
      kIsReadable: isStreamReadableSymbol,
      isClosed: determineStreamClosureState,
      isDestroyed: checkIfStreamIsDestroyed,
      isDuplexNodeStream: ______isStreamReadable,
      isFinished: isStreamVersionCompatibilityValid,
      isIterable: checkIfIterableVersion,
      isReadableNodeStream: __isValidVersionRange,
      isReadableEnded: checkIfVersionStreamReadable,
      isReadableFinished: hasPatchVersionBeenEmitted,
      isReadableErrored: extractReadableErrorFromVersionRange,
      isNodeStream: isReadableWritableStream,
      isWritable: validateWritableVersionRange,
      isWritableNodeStream: isWritableStreamCompliant,
      isWritableEnded: isWritableStreamEnded,
      isWritableFinished: _validateWritableStreamState,
      isWritableErrored: retrieveWritableErrorState,
      isServerRequest: areWritableStreamStateFlagsValid,
      isServerResponse: isWritableStreamCompatibilityVersionValid,
      willEmitClose: isWritableStreamReadyForDestruction,
    };
  },
);
var validateStreamVersionState = lazyModuleInitializer(
  (_validateCharacterEncoding, ____validateAndProcessCharacterEncoding) => {
    var isValidSemanticVersionRange = isSemVerRangeValid();
    var { AbortError: FetchAbortError, codes: fetchErrorCodes } =
      fetchNodeValuePostTraversal();
    var {
      ERR_INVALID_ARG_TYPE: _ERR_INVALID_ARGUMENT_TYPE,
      ERR_STREAM_PREMATURE_CLOSE: ERR_STREAM_UNEXPECTED_TERMINATION,
    } = fetchErrorCodes;
    var { kEmptyObject: emptyObject, once: executeOnce } =
      validateAndProcessArrayBufferForProcessing();
    var {
      validateAbortSignal: validateAbortSignalForFetch,
      validateFunction: validateCallbackForProcessing,
      validateObject: validateInputData,
    } = handleStreamErrorTypes();
    var { Promise: AsyncOperationPromise } = performComparisonOperation();
    var {
      isClosed: isStreamTerminated,
      isReadable: ____isStreamReadable,
      isReadableNodeStream: isNodeStreamReadable,
      isReadableFinished: isReadableStreamComplete,
      isReadableErrored: __isStreamInErrorState,
      isWritable: isOutputStreamWritable,
      isWritableNodeStream: isStreamWritable,
      isWritableFinished: _____validateAndProcessCharacterEncoding,
      isWritableErrored: isCharacterEncodingValidationEnabled,
      isNodeStream: validateCharacterEncodingForFetch,
      willEmitClose: ______validateAndProcessCharacterEncoding,
    } = scheduleTimeoutWithArguments();
    function canAbortProcess(_validateVersionRangeCompatibility) {
      return (
        _validateVersionRangeCompatibility.setHeader &&
        typeof _validateVersionRangeCompatibility.abort == "function"
      );
    }
    var _______validateAndProcessCharacterEncoding = () => {};
    function __validateAndProcessStreamData(
      validateWritableVersionRange,
      isStreamInErrorState,
      isVersionRangeComparatorValid,
    ) {
      if (arguments.length === 2) {
        isVersionRangeComparatorValid = isStreamInErrorState;
        isStreamInErrorState = emptyObject;
      } else if (isStreamInErrorState == null) {
        isStreamInErrorState = emptyObject;
      } else {
        validateInputData(isStreamInErrorState, "options");
      }
      validateCallbackForProcessing(isVersionRangeComparatorValid, "callback");
      validateAbortSignalForFetch(
        isStreamInErrorState.signal,
        "options.signal",
      );
      isVersionRangeComparatorValid = executeOnce(
        isVersionRangeComparatorValid,
      );
      let _____isStreamReadable =
        isStreamInErrorState.readable ??
        isNodeStreamReadable(validateWritableVersionRange);
      let _isStreamWritable =
        isStreamInErrorState.writable ??
        isStreamWritable(validateWritableVersionRange);
      if (!validateCharacterEncodingForFetch(validateWritableVersionRange)) {
        throw new _ERR_INVALID_ARGUMENT_TYPE(
          "stream",
          "Stream",
          validateWritableVersionRange,
        );
      }
      let __writableStreamState = validateWritableVersionRange._writableState;
      let isStreamReadableState = validateWritableVersionRange._readableState;
      let _validateAndProcessStreamOptions = () => {
        if (!validateWritableVersionRange.writable) {
          validateAndCheckWritableStream();
        }
      };
      let ___validateAndProcessStreamData =
        ______validateAndProcessCharacterEncoding(
          validateWritableVersionRange,
        ) &&
        isNodeStreamReadable(validateWritableVersionRange) ===
          _____isStreamReadable &&
        isStreamWritable(validateWritableVersionRange) === _isStreamWritable;
      let validateAndPrepareStreamOptions =
        _____validateAndProcessCharacterEncoding(
          validateWritableVersionRange,
          false,
        );
      let validateAndCheckWritableStream = () => {
        validateAndPrepareStreamOptions = true;
        if (validateWritableVersionRange.destroyed) {
          ___validateAndProcessStreamData = false;
        }
        if (
          (!___validateAndProcessStreamData ||
            (!!validateWritableVersionRange.readable &&
              !_____isStreamReadable)) &&
          (!_____isStreamReadable || validateAndPrepareStreamProcess)
        ) {
          isVersionRangeComparatorValid.call(validateWritableVersionRange);
        }
      };
      let validateAndPrepareStreamProcess = isReadableStreamComplete(
        validateWritableVersionRange,
        false,
      );
      let validateAndSetupStreamProcessing = () => {
        validateAndPrepareStreamProcess = true;
        if (validateWritableVersionRange.destroyed) {
          ___validateAndProcessStreamData = false;
        }
        if (
          (!___validateAndProcessStreamData ||
            (!!validateWritableVersionRange.writable && !_isStreamWritable)) &&
          (!_isStreamWritable || validateAndPrepareStreamOptions)
        ) {
          isVersionRangeComparatorValid.call(validateWritableVersionRange);
        }
      };
      let validateAndProcessStreamOptions = (
        _validateVersionRangeComparator,
      ) => {
        isVersionRangeComparatorValid.call(
          validateWritableVersionRange,
          _validateVersionRangeComparator,
        );
      };
      let ____validateAndProcessStreamData = isStreamTerminated(
        validateWritableVersionRange,
      );
      let _validateAbortSignalForFetch = () => {
        ____validateAndProcessStreamData = true;
        let isCharacterEncodingOrStreamErrorValidationRequired =
          isCharacterEncodingValidationEnabled(validateWritableVersionRange) ||
          __isStreamInErrorState(validateWritableVersionRange);
        if (
          isCharacterEncodingOrStreamErrorValidationRequired &&
          typeof isCharacterEncodingOrStreamErrorValidationRequired != "boolean"
        ) {
          return isVersionRangeComparatorValid.call(
            validateWritableVersionRange,
            isCharacterEncodingOrStreamErrorValidationRequired,
          );
        }
        if (
          _____isStreamReadable &&
          !validateAndPrepareStreamProcess &&
          isNodeStreamReadable(validateWritableVersionRange, true) &&
          !isReadableStreamComplete(validateWritableVersionRange, false)
        ) {
          return isVersionRangeComparatorValid.call(
            validateWritableVersionRange,
            new ERR_STREAM_UNEXPECTED_TERMINATION(),
          );
        }
        if (
          _isStreamWritable &&
          !validateAndPrepareStreamOptions &&
          !_____validateAndProcessCharacterEncoding(
            validateWritableVersionRange,
            false,
          )
        ) {
          return isVersionRangeComparatorValid.call(
            validateWritableVersionRange,
            new ERR_STREAM_UNEXPECTED_TERMINATION(),
          );
        }
        isVersionRangeComparatorValid.call(validateWritableVersionRange);
      };
      let validateAndPrepareStreamData = () => {
        validateWritableVersionRange.req.on(
          "finish",
          validateAndCheckWritableStream,
        );
      };
      if (canAbortProcess(validateWritableVersionRange)) {
        validateWritableVersionRange.on(
          "complete",
          validateAndCheckWritableStream,
        );
        if (!___validateAndProcessStreamData) {
          validateWritableVersionRange.on(
            "abort",
            _validateAbortSignalForFetch,
          );
        }
        if (validateWritableVersionRange.req) {
          validateAndPrepareStreamData();
        } else {
          validateWritableVersionRange.on(
            "request",
            validateAndPrepareStreamData,
          );
        }
      } else if (_isStreamWritable && !__writableStreamState) {
        validateWritableVersionRange.on(
          "end",
          _validateAndProcessStreamOptions,
        );
        validateWritableVersionRange.on(
          "close",
          _validateAndProcessStreamOptions,
        );
      }
      if (
        !___validateAndProcessStreamData &&
        typeof validateWritableVersionRange.aborted == "boolean"
      ) {
        validateWritableVersionRange.on(
          "aborted",
          _validateAbortSignalForFetch,
        );
      }
      validateWritableVersionRange.on("end", validateAndSetupStreamProcessing);
      validateWritableVersionRange.on("finish", validateAndCheckWritableStream);
      if (isStreamInErrorState.error !== false) {
        validateWritableVersionRange.on(
          "error",
          validateAndProcessStreamOptions,
        );
      }
      validateWritableVersionRange.on("close", _validateAbortSignalForFetch);
      if (____validateAndProcessStreamData) {
        isValidSemanticVersionRange.nextTick(_validateAbortSignalForFetch);
      } else if (
        (__writableStreamState != null && __writableStreamState.errorEmitted) ||
        (isStreamReadableState != null && isStreamReadableState.errorEmitted)
      ) {
        if (!___validateAndProcessStreamData) {
          isValidSemanticVersionRange.nextTick(_validateAbortSignalForFetch);
        }
      } else if (
        (!_____isStreamReadable &&
          (!___validateAndProcessStreamData ||
            ____isStreamReadable(validateWritableVersionRange)) &&
          (validateAndPrepareStreamOptions ||
            isOutputStreamWritable(validateWritableVersionRange) === false)) ||
        (!_isStreamWritable &&
          (!___validateAndProcessStreamData ||
            isOutputStreamWritable(validateWritableVersionRange)) &&
          (validateAndPrepareStreamProcess ||
            ____isStreamReadable(validateWritableVersionRange) === false)) ||
        (isStreamReadableState &&
          validateWritableVersionRange.req &&
          validateWritableVersionRange.aborted)
      ) {
        isValidSemanticVersionRange.nextTick(_validateAbortSignalForFetch);
      }
      let ______validateAndProcessStreamData = () => {
        isVersionRangeComparatorValid =
          _______validateAndProcessCharacterEncoding;
        validateWritableVersionRange.removeListener(
          "aborted",
          _validateAbortSignalForFetch,
        );
        validateWritableVersionRange.removeListener(
          "complete",
          validateAndCheckWritableStream,
        );
        validateWritableVersionRange.removeListener(
          "abort",
          _validateAbortSignalForFetch,
        );
        validateWritableVersionRange.removeListener(
          "request",
          validateAndPrepareStreamData,
        );
        if (validateWritableVersionRange.req) {
          validateWritableVersionRange.req.removeListener(
            "finish",
            validateAndCheckWritableStream,
          );
        }
        validateWritableVersionRange.removeListener(
          "end",
          _validateAndProcessStreamOptions,
        );
        validateWritableVersionRange.removeListener(
          "close",
          _validateAndProcessStreamOptions,
        );
        validateWritableVersionRange.removeListener(
          "finish",
          validateAndCheckWritableStream,
        );
        validateWritableVersionRange.removeListener(
          "end",
          validateAndSetupStreamProcessing,
        );
        validateWritableVersionRange.removeListener(
          "error",
          validateAndProcessStreamOptions,
        );
        validateWritableVersionRange.removeListener(
          "close",
          _validateAbortSignalForFetch,
        );
      };
      if (isStreamInErrorState.signal && !____validateAndProcessStreamData) {
        let handleStreamAbortAndValidate = () => {
          let validateVersionRangeComparator = isVersionRangeComparatorValid;
          ______validateAndProcessStreamData();
          validateVersionRangeComparator.call(
            validateWritableVersionRange,
            new FetchAbortError(undefined, {
              cause: isStreamInErrorState.signal.reason,
            }),
          );
        };
        if (isStreamInErrorState.signal.aborted) {
          isValidSemanticVersionRange.nextTick(handleStreamAbortAndValidate);
        } else {
          let backupVersionRangeValidator = isVersionRangeComparatorValid;
          isVersionRangeComparatorValid = executeOnce(
            (...validationArguments) => {
              isStreamInErrorState.signal.removeEventListener(
                "abort",
                handleStreamAbortAndValidate,
              );
              backupVersionRangeValidator.apply(
                validateWritableVersionRange,
                validationArguments,
              );
            },
          );
          isStreamInErrorState.signal.addEventListener(
            "abort",
            handleStreamAbortAndValidate,
          );
        }
      }
      return ______validateAndProcessStreamData;
    }
    function _______validateAndProcessStreamData(
      validateAndRetrieveStreamProperties,
      validateAndProcessWritableStreams,
    ) {
      return new AsyncOperationPromise(
        (validateAndHandleStreamData, _____validateAndProcessStreamData) => {
          __validateAndProcessStreamData(
            validateAndRetrieveStreamProperties,
            validateAndProcessWritableStreams,
            (_streamData) => {
              if (_streamData) {
                _____validateAndProcessStreamData(_streamData);
              } else {
                validateAndHandleStreamData();
              }
            },
          );
        },
      );
    }
    ____validateAndProcessCharacterEncoding.exports =
      __validateAndProcessStreamData;
    ____validateAndProcessCharacterEncoding.exports.finished =
      _______validateAndProcessStreamData;
  },
);
var __validateAndRetrieveIntrinsicProperties = lazyModuleInitializer(
  (validateAndHandleAbortSignal, _validateAndHandleAbortSignal) => {
    var AbortControllerFallback =
      globalThis.AbortController || writeUint16LittleEndian().AbortController;
    var {
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARGUMENT_TYPE_FOR_ABORT_SIGNAL,
        ERR_MISSING_ARGS: ERR_REQUIRED_ARGUMENTS,
        ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE_EXCEPTION,
      },
      AbortError: AbortSignalError,
    } = fetchNodeValuePostTraversal();
    var {
      validateAbortSignal: validateAbortSignal,
      validateInteger: validateNumericInput,
      validateObject: validateDataObjectStructure,
    } = handleStreamErrorTypes();
    var abortSignalKey = performComparisonOperation().Symbol("kWeak");
    var { finished: isStreamFinished } = validateStreamVersionState();
    var {
      ArrayPrototypePush: arrayPushToEnd,
      MathFloor: roundDownToNearestInteger,
      Number: GlobalNumberInstance,
      NumberIsNaN: _isValueNaN,
      Promise: nativePromiseImplementation,
      PromiseReject: handlePromiseRejection,
      PromisePrototypeThen: handlePromiseResolution,
      Symbol: validateAndProcessAbortSignal,
    } = performComparisonOperation();
    var __validateAndHandleAbortSignal =
      validateAndProcessAbortSignal("kEmpty");
    var ___validateAndHandleAbortSignal = validateAndProcessAbortSignal("kEof");
    function ________validateAndRetrieveStreamProperties(
      _validateAndRetrieveStreamProperties,
      validateAndProcessStreamOptions,
    ) {
      if (typeof _validateAndRetrieveStreamProperties != "function") {
        throw new ERR_INVALID_ARGUMENT_TYPE_FOR_ABORT_SIGNAL(
          "fn",
          ["Function", "AsyncFunction"],
          _validateAndRetrieveStreamProperties,
        );
      }
      if (validateAndProcessStreamOptions != null) {
        validateDataObjectStructure(validateAndProcessStreamOptions, "options");
      }
      if (validateAndProcessStreamOptions?.signal != null) {
        validateAbortSignal(
          validateAndProcessStreamOptions.signal,
          "options.signal",
        );
      }
      let maxConcurrentStreams = 1;
      if (validateAndProcessStreamOptions?.concurrency != null) {
        maxConcurrentStreams = roundDownToNearestInteger(
          validateAndProcessStreamOptions.concurrency,
        );
      }
      validateNumericInput(maxConcurrentStreams, "concurrency", 1);
      return async function* () {
        var abortSignalFromOptions;
        var _abortSignalFromOptions;
        let abortControllerInstance = new AbortControllerFallback();
        let executionContext = this;
        let failedResponses = [];
        let abortSignal = abortControllerInstance.signal;
        let abortSignalWrapper = {
          signal: abortSignal,
        };
        let onAbortControllerTriggered = () => abortControllerInstance.abort();
        if (
          validateAndProcessStreamOptions != null &&
          (abortSignalFromOptions = validateAndProcessStreamOptions.signal) !==
            null &&
          abortSignalFromOptions !== undefined &&
          abortSignalFromOptions.aborted
        ) {
          onAbortControllerTriggered();
        }
        if (
          validateAndProcessStreamOptions != null &&
          (_abortSignalFromOptions = validateAndProcessStreamOptions.signal) !==
            null &&
          _abortSignalFromOptions !== undefined
        ) {
          _abortSignalFromOptions.addEventListener(
            "abort",
            onAbortControllerTriggered,
          );
        }
        let taskHasBeenAborted;
        let checkIfTaskWasAborted;
        let taskCompletionStatus = false;
        function setTaskCompletionStatusToCompleted() {
          taskCompletionStatus = true;
        }
        async function handleFailedTaskExecution() {
          try {
            for await (let executionTask of executionContext) {
              var currentExecutionTask;
              if (taskCompletionStatus) {
                return;
              }
              if (abortSignal.aborted) {
                throw new AbortSignalError();
              }
              try {
                executionTask = _validateAndRetrieveStreamProperties(
                  executionTask,
                  abortSignalWrapper,
                );
              } catch (promiseRejectionHandler) {
                executionTask = handlePromiseRejection(promiseRejectionHandler);
              }
              if (executionTask !== __validateAndHandleAbortSignal) {
                if (
                  typeof ((currentExecutionTask = executionTask) === null ||
                  currentExecutionTask === undefined
                    ? undefined
                    : currentExecutionTask.catch) == "function"
                ) {
                  executionTask.catch(setTaskCompletionStatusToCompleted);
                }
                failedResponses.push(executionTask);
                if (taskHasBeenAborted) {
                  taskHasBeenAborted();
                  taskHasBeenAborted = null;
                }
                if (
                  !taskCompletionStatus &&
                  failedResponses.length &&
                  failedResponses.length >= maxConcurrentStreams
                ) {
                  await new nativePromiseImplementation((wasTaskAborted) => {
                    checkIfTaskWasAborted = wasTaskAborted;
                  });
                }
              }
            }
            failedResponses.push(___validateAndHandleAbortSignal);
          } catch (handleError) {
            let _processPromiseRejection = handlePromiseRejection(handleError);
            handlePromiseResolution(
              _processPromiseRejection,
              undefined,
              setTaskCompletionStatusToCompleted,
            );
            failedResponses.push(_processPromiseRejection);
          } finally {
            var ____abortSignal;
            taskCompletionStatus = true;
            if (taskHasBeenAborted) {
              taskHasBeenAborted();
              taskHasBeenAborted = null;
            }
            if (
              validateAndProcessStreamOptions != null &&
              (____abortSignal = validateAndProcessStreamOptions.signal) !==
                null &&
              ____abortSignal !== undefined
            ) {
              ____abortSignal.removeEventListener(
                "abort",
                onAbortControllerTriggered,
              );
            }
          }
        }
        handleFailedTaskExecution();
        try {
          while (true) {
            while (failedResponses.length > 0) {
              let initialFailedResponse = await failedResponses[0];
              if (initialFailedResponse === ___validateAndHandleAbortSignal) {
                return;
              }
              if (abortSignal.aborted) {
                throw new AbortSignalError();
              }
              if (initialFailedResponse !== __validateAndHandleAbortSignal) {
                yield initialFailedResponse;
              }
              failedResponses.shift();
              if (checkIfTaskWasAborted) {
                checkIfTaskWasAborted();
                checkIfTaskWasAborted = null;
              }
            }
            await new nativePromiseImplementation((taskAborted) => {
              taskHasBeenAborted = taskAborted;
            });
          }
        } finally {
          abortControllerInstance.abort();
          taskCompletionStatus = true;
          if (checkIfTaskWasAborted) {
            checkIfTaskWasAborted();
            checkIfTaskWasAborted = null;
          }
        }
      }.call(this);
    }
    function generateAsyncIterableWithAbortHandling(defaultValue = undefined) {
      if (defaultValue != null) {
        validateDataObjectStructure(defaultValue, "options");
      }
      if (defaultValue?.signal != null) {
        validateAbortSignal(defaultValue.signal, "options.signal");
      }
      return async function* () {
        let currentAsyncItemIndex = 0;
        for await (let asyncItem of this) {
          var abortSignalFromDefaultValue;
          if (
            defaultValue != null &&
            (abortSignalFromDefaultValue = defaultValue.signal) !== null &&
            abortSignalFromDefaultValue !== undefined &&
            abortSignalFromDefaultValue.aborted
          ) {
            throw new AbortSignalError({
              cause: defaultValue.signal.reason,
            });
          }
          yield [currentAsyncItemIndex++, asyncItem];
        }
      }.call(this);
    }
    async function checkIfResponseSegmentsAreSorted(
      __validateAndRetrieveStreamProperties,
      defaultValue = undefined,
    ) {
      for await (let responseSegmentProperties of handleAndSortResponseSegments.call(
        this,
        __validateAndRetrieveStreamProperties,
        defaultValue,
      )) {
        return true;
      }
      return false;
    }
    async function asyncFunctionValidateStreamPropertiesAndScoreAsync(
      validateAndExtractStreamProperties,
      currentPlayerScore = undefined,
    ) {
      if (typeof validateAndExtractStreamProperties != "function") {
        throw new ERR_INVALID_ARGUMENT_TYPE_FOR_ABORT_SIGNAL(
          "fn",
          ["Function", "AsyncFunction"],
          validateAndExtractStreamProperties,
        );
      }
      return !(await checkIfResponseSegmentsAreSorted.call(
        this,
        async (
          ...asyncValidateAndRetrieveIntrinsicPropsAwaitValidateAndExtractStreamPropertiesValidateAndRetrieveIntrinsicProps
        ) =>
          !(await validateAndExtractStreamProperties(
            ...asyncValidateAndRetrieveIntrinsicPropsAwaitValidateAndExtractStreamPropertiesValidateAndRetrieveIntrinsicProps,
          )),
        currentPlayerScore,
      ));
    }
    async function fetchIntrinsicPropertiesFromTask(
      taskItemHandler,
      handlePromiseRejectionAndAbort,
    ) {
      for await (let responseSegments of handleAndSortResponseSegments.call(
        this,
        taskItemHandler,
        handlePromiseRejectionAndAbort,
      )) {
        return responseSegments;
      }
    }
    async function _validateAndProcessData(
      validateAndRetrieveProperties,
      validateAndFetchIntrinsicProperties,
    ) {
      if (typeof validateAndRetrieveProperties != "function") {
        throw new ERR_INVALID_ARGUMENT_TYPE_FOR_ABORT_SIGNAL(
          "fn",
          ["Function", "AsyncFunction"],
          validateAndRetrieveProperties,
        );
      }
      async function validatePropertiesAndProcessAbort(
        handleAbortedTaskResponses,
        handleAbortedTasks,
      ) {
        await validateAndRetrieveProperties(
          handleAbortedTaskResponses,
          handleAbortedTasks,
        );
        return __validateAndHandleAbortSignal;
      }
      for await (let propertyValidationStatusStream of ________validateAndRetrieveStreamProperties.call(
        this,
        validatePropertiesAndProcessAbort,
        validateAndFetchIntrinsicProperties,
      ));
    }
    function handleAndSortResponseSegments(
      handleAbortedResponses,
      handleAbortedResponsesAndTasks,
    ) {
      if (typeof handleAbortedResponses != "function") {
        throw new ERR_INVALID_ARGUMENT_TYPE_FOR_ABORT_SIGNAL(
          "fn",
          ["Function", "AsyncFunction"],
          handleAbortedResponses,
        );
      }
      async function processAbortedResponseSegments(
        _handleAbortedResponsesAndTasks,
        _handleAbortedTaskResponses,
      ) {
        if (
          await handleAbortedResponses(
            _handleAbortedResponsesAndTasks,
            _handleAbortedTaskResponses,
          )
        ) {
          return _handleAbortedResponsesAndTasks;
        } else {
          return __validateAndHandleAbortSignal;
        }
      }
      return ________validateAndRetrieveStreamProperties.call(
        this,
        processAbortedResponseSegments,
        handleAbortedResponsesAndTasks,
      );
    }
    var _validateAndProcessAbortSignal = class extends ERR_REQUIRED_ARGUMENTS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function initializeComparisonProcessWithAbortHandling(
      checkBigIntComparison,
      handleAbortableAsyncIterable,
      handleAsyncOperationWithAbort,
    ) {
      var _abortSignal;
      if (typeof checkBigIntComparison != "function") {
        throw new ERR_INVALID_ARGUMENT_TYPE_FOR_ABORT_SIGNAL(
          "reducer",
          ["Function", "AsyncFunction"],
          checkBigIntComparison,
        );
      }
      if (handleAsyncOperationWithAbort != null) {
        validateDataObjectStructure(handleAsyncOperationWithAbort, "options");
      }
      if (handleAsyncOperationWithAbort?.signal != null) {
        validateAbortSignal(
          handleAsyncOperationWithAbort.signal,
          "options.signal",
        );
      }
      let hasAdditionalArguments = arguments.length > 1;
      if (
        handleAsyncOperationWithAbort != null &&
        (_abortSignal = handleAsyncOperationWithAbort.signal) !== null &&
        _abortSignal !== undefined &&
        _abortSignal.aborted
      ) {
        let createAbortSignalErrorForAsyncOperation = new AbortSignalError(
          undefined,
          {
            cause: handleAsyncOperationWithAbort.signal.reason,
          },
        );
        this.once("error", () => {});
        await isStreamFinished(
          this.destroy(createAbortSignalErrorForAsyncOperation),
        );
        throw createAbortSignalErrorForAsyncOperation;
      }
      let abortSignalErrorBasedOnComparison = new AbortControllerFallback();
      let abortSignalError = abortSignalErrorBasedOnComparison.signal;
      if (
        handleAsyncOperationWithAbort != null &&
        handleAsyncOperationWithAbort.signal
      ) {
        let abortListenerOptions = {
          once: true,
          [abortSignalKey]: this,
        };
        handleAsyncOperationWithAbort.signal.addEventListener(
          "abort",
          () => abortSignalErrorBasedOnComparison.abort(),
          abortListenerOptions,
        );
      }
      let __abortSignal = false;
      try {
        for await (let asyncCharacterSegment of this) {
          var _abortControllerSignal;
          __abortSignal = true;
          if (
            handleAsyncOperationWithAbort != null &&
            (_abortControllerSignal = handleAsyncOperationWithAbort.signal) !==
              null &&
            _abortControllerSignal !== undefined &&
            _abortControllerSignal.aborted
          ) {
            throw new AbortSignalError();
          }
          if (hasAdditionalArguments) {
            handleAbortableAsyncIterable = await checkBigIntComparison(
              handleAbortableAsyncIterable,
              asyncCharacterSegment,
              {
                signal: abortSignalError,
              },
            );
          } else {
            handleAbortableAsyncIterable = asyncCharacterSegment;
            hasAdditionalArguments = true;
          }
        }
        if (!__abortSignal && !hasAdditionalArguments) {
          throw new _validateAndProcessAbortSignal();
        }
      } finally {
        abortSignalErrorBasedOnComparison.abort();
      }
      return handleAbortableAsyncIterable;
    }
    async function processVersionItems(isPrereleaseVersionConditionMet) {
      if (isPrereleaseVersionConditionMet != null) {
        validateDataObjectStructure(isPrereleaseVersionConditionMet, "options");
      }
      if (isPrereleaseVersionConditionMet?.signal != null) {
        validateAbortSignal(
          isPrereleaseVersionConditionMet.signal,
          "options.signal",
        );
      }
      let collectedVersionItems = [];
      for await (let versionItemToCollect of this) {
        var prereleaseAbortSignal;
        if (
          isPrereleaseVersionConditionMet != null &&
          (prereleaseAbortSignal = isPrereleaseVersionConditionMet.signal) !==
            null &&
          prereleaseAbortSignal !== undefined &&
          prereleaseAbortSignal.aborted
        ) {
          throw new AbortSignalError(undefined, {
            cause: isPrereleaseVersionConditionMet.signal.reason,
          });
        }
        arrayPushToEnd(collectedVersionItems, versionItemToCollect);
      }
      return collectedVersionItems;
    }
    function retrieveAndYieldValidatedStreamProperties(
      validateAbortResponsesAndRetrieveSegments,
      validateAndHandleAbortedResponses,
    ) {
      let streamPropertiesAfterValidation =
        ________validateAndRetrieveStreamProperties.call(
          this,
          validateAbortResponsesAndRetrieveSegments,
          validateAndHandleAbortedResponses,
        );
      return async function* () {
        for await (let propertyStreamYield of streamPropertiesAfterValidation) {
          yield* propertyStreamYield;
        }
      }.call(this);
    }
    function normalizeAndValidateSemverValue(validateSemverComparison) {
      validateSemverComparison = GlobalNumberInstance(validateSemverComparison);
      if (_isValueNaN(validateSemverComparison)) {
        return 0;
      }
      if (validateSemverComparison < 0) {
        throw new ERR_OUT_OF_RANGE_EXCEPTION(
          "number",
          ">= 0",
          validateSemverComparison,
        );
      }
      return validateSemverComparison;
    }
    function createAbortableAsyncGenerator(
      isVersionRangeCheckValid,
      _defaultValue = undefined,
    ) {
      if (_defaultValue != null) {
        validateDataObjectStructure(_defaultValue, "options");
      }
      if (_defaultValue?.signal != null) {
        validateAbortSignal(_defaultValue.signal, "options.signal");
      }
      isVersionRangeCheckValid = normalizeAndValidateSemverValue(
        isVersionRangeCheckValid,
      );
      return async function* () {
        var ___abortSignal;
        if (
          _defaultValue != null &&
          (___abortSignal = _defaultValue.signal) !== null &&
          ___abortSignal !== undefined &&
          ___abortSignal.aborted
        ) {
          throw new AbortSignalError();
        }
        for await (let availableItem of this) {
          var ______abortSignal;
          if (
            _defaultValue != null &&
            (______abortSignal = _defaultValue.signal) !== null &&
            ______abortSignal !== undefined &&
            ______abortSignal.aborted
          ) {
            throw new AbortSignalError();
          }
          if (isVersionRangeCheckValid-- <= 0) {
            yield availableItem;
          }
        }
      }.call(this);
    }
    function handleVersionComparisonWithAbortOption(
      compareVersionsHandlingAbort,
      currentUserSession = undefined,
    ) {
      if (currentUserSession != null) {
        validateDataObjectStructure(currentUserSession, "options");
      }
      if (currentUserSession?.signal != null) {
        validateAbortSignal(currentUserSession.signal, "options.signal");
      }
      compareVersionsHandlingAbort = normalizeAndValidateSemverValue(
        compareVersionsHandlingAbort,
      );
      return async function* () {
        var userSessionSignalControl;
        if (
          currentUserSession != null &&
          (userSessionSignalControl = currentUserSession.signal) !== null &&
          userSessionSignalControl !== undefined &&
          userSessionSignalControl.aborted
        ) {
          throw new AbortSignalError();
        }
        for await (let asyncSessionItem of this) {
          var userSignal;
          if (
            currentUserSession != null &&
            (userSignal = currentUserSession.signal) !== null &&
            userSignal !== undefined &&
            userSignal.aborted
          ) {
            throw new AbortSignalError();
          }
          if (compareVersionsHandlingAbort-- > 0) {
            yield asyncSessionItem;
          } else {
            return;
          }
        }
      }.call(this);
    }
    _validateAndHandleAbortSignal.exports.streamReturningOperators = {
      asIndexedPairs: generateAsyncIterableWithAbortHandling,
      drop: createAbortableAsyncGenerator,
      filter: handleAndSortResponseSegments,
      flatMap: retrieveAndYieldValidatedStreamProperties,
      map: ________validateAndRetrieveStreamProperties,
      take: handleVersionComparisonWithAbortOption,
    };
    _validateAndHandleAbortSignal.exports.promiseReturningOperators = {
      every: asyncFunctionValidateStreamPropertiesAndScoreAsync,
      forEach: _validateAndProcessData,
      reduce: initializeComparisonProcessWithAbortHandling,
      toArray: processVersionItems,
      some: checkIfResponseSegmentsAreSorted,
      find: fetchIntrinsicPropertiesFromTask,
    };
  },
);
var processVersionValidationAndAbortSignals = lazyModuleInitializer(
  (verifySemanticVersioningRange, handleInvalidSemanticVersioning) => {
    var _isSemVerRangeValid = isSemVerRangeValid();
    var {
      aggregateTwoErrors: combineErrorMessages,
      codes: { ERR_MULTIPLE_CALLBACK: ERR_INVALID_MULTIPLE_CALLBACK_USAGE },
      AbortError: AbortError,
    } = fetchNodeValuePostTraversal();
    var { Symbol: fetchUniqueSymbol } = performComparisonOperation();
    var {
      kDestroyed: isEncodingProcessTerminated,
      isDestroyed: isCharacterEncodingValidAndActive,
      isFinished: isCharacterEncodingProcessComplete,
      isServerRequest: isIncomingRequestValid,
    } = scheduleTimeoutWithArguments();
    var createUniqueSymbolForDestruction = fetchUniqueSymbol("kDestroy");
    var fetchConstructionSymbol = fetchUniqueSymbol("kConstruct");
    function processSemanticVersioningResults(
      retrieveValidatedSemanticVersions,
      validateAndYieldSemanticVersionProperties,
      getAsyncIterableFromValidatedSemverProperties,
    ) {
      if (retrieveValidatedSemanticVersions) {
        retrieveValidatedSemanticVersions.stack;
        if (
          validateAndYieldSemanticVersionProperties &&
          !validateAndYieldSemanticVersionProperties.errored
        ) {
          validateAndYieldSemanticVersionProperties.errored =
            retrieveValidatedSemanticVersions;
        }
        if (
          getAsyncIterableFromValidatedSemverProperties &&
          !getAsyncIterableFromValidatedSemverProperties.errored
        ) {
          getAsyncIterableFromValidatedSemverProperties.errored =
            retrieveValidatedSemanticVersions;
        }
      }
    }
    function processStreamsAndHandleDestruction(
      _validateSemverComparison,
      validateAndNormalizeVersionComparison,
    ) {
      let ____readableStreamState = this._readableState;
      let ______writableStreamState = this._writableState;
      let currentStreamState =
        ______writableStreamState || ____readableStreamState;
      if (
        (______writableStreamState && ______writableStreamState.destroyed) ||
        (____readableStreamState && ____readableStreamState.destroyed)
      ) {
        if (typeof validateAndNormalizeVersionComparison == "function") {
          validateAndNormalizeVersionComparison();
        }
        return this;
      } else {
        processSemanticVersioningResults(
          _validateSemverComparison,
          ______writableStreamState,
          ____readableStreamState,
        );
        if (______writableStreamState) {
          ______writableStreamState.destroyed = true;
        }
        if (____readableStreamState) {
          ____readableStreamState.destroyed = true;
        }
        if (currentStreamState.constructed) {
          processOptionsAndSessionData(
            this,
            _validateSemverComparison,
            validateAndNormalizeVersionComparison,
          );
        } else {
          this.once(
            createUniqueSymbolForDestruction,
            function (processVersionComparisonsAndHandleAbort) {
              processOptionsAndSessionData(
                this,
                combineErrorMessages(
                  processVersionComparisonsAndHandleAbort,
                  _validateSemverComparison,
                ),
                validateAndNormalizeVersionComparison,
              );
            },
          );
        }
        return this;
      }
    }
    function processOptionsAndSessionData(
      validateAndRetrieveOptionsSignal,
      validateUserSessionAndHandleAbort,
      handleAbortSignalError,
    ) {
      let isIntrinsicPropertyBeingProcessed = false;
      function handleIntrinsicPropertyProcessing(
        validateAndRetrieveCharacterEncoding,
      ) {
        if (isIntrinsicPropertyBeingProcessed) {
          return;
        }
        isIntrinsicPropertyBeingProcessed = true;
        let ___readableStreamState =
          validateAndRetrieveOptionsSignal._readableState;
        let _____writableStreamState =
          validateAndRetrieveOptionsSignal._writableState;
        processSemanticVersioningResults(
          validateAndRetrieveCharacterEncoding,
          _____writableStreamState,
          ___readableStreamState,
        );
        if (_____writableStreamState) {
          _____writableStreamState.closed = true;
        }
        if (___readableStreamState) {
          ___readableStreamState.closed = true;
        }
        if (typeof handleAbortSignalError == "function") {
          handleAbortSignalError(validateAndRetrieveCharacterEncoding);
        }
        if (validateAndRetrieveCharacterEncoding) {
          _isSemVerRangeValid.nextTick(
            processSemanticVersionStream,
            validateAndRetrieveOptionsSignal,
            validateAndRetrieveCharacterEncoding,
          );
        } else {
          _isSemVerRangeValid.nextTick(
            triggerCloseIfWritableOrReadableStateEmitted,
            validateAndRetrieveOptionsSignal,
          );
        }
      }
      try {
        validateAndRetrieveOptionsSignal._destroy(
          validateUserSessionAndHandleAbort || null,
          handleIntrinsicPropertyProcessing,
        );
      } catch (processingError) {
        handleIntrinsicPropertyProcessing(processingError);
      }
    }
    function processSemanticVersionStream(
      validateAndRetrieveSemanticVersionData,
      handleSemanticVersionComparison,
    ) {
      _handleStreamError(
        validateAndRetrieveSemanticVersionData,
        handleSemanticVersionComparison,
      );
      triggerCloseIfWritableOrReadableStateEmitted(
        validateAndRetrieveSemanticVersionData,
      );
    }
    function triggerCloseIfWritableOrReadableStateEmitted(
      ___validateAndRetrieveIntrinsicProperties,
    ) {
      let ____________readableStreamState =
        ___validateAndRetrieveIntrinsicProperties._readableState;
      let ___________writableStreamState =
        ___validateAndRetrieveIntrinsicProperties._writableState;
      if (___________writableStreamState) {
        ___________writableStreamState.closeEmitted = true;
      }
      if (____________readableStreamState) {
        ____________readableStreamState.closeEmitted = true;
      }
      if (
        (___________writableStreamState &&
          ___________writableStreamState.emitClose) ||
        (____________readableStreamState &&
          ____________readableStreamState.emitClose)
      ) {
        ___validateAndRetrieveIntrinsicProperties.emit("close");
      }
    }
    function _handleStreamError(
      validateAndRetrieveSemanticVersionProperties,
      _validateAndRetrieveSemanticVersionProperties,
    ) {
      let _readableState =
        validateAndRetrieveSemanticVersionProperties._readableState;
      let _writableState =
        validateAndRetrieveSemanticVersionProperties._writableState;
      if (
        (!_writableState || !_writableState.errorEmitted) &&
        (!_readableState || !_readableState.errorEmitted)
      ) {
        if (_writableState) {
          _writableState.errorEmitted = true;
        }
        if (_readableState) {
          _readableState.errorEmitted = true;
        }
        validateAndRetrieveSemanticVersionProperties.emit(
          "error",
          _validateAndRetrieveSemanticVersionProperties,
        );
      }
    }
    function resetStreamStates() {
      let _____readableStreamState = this._readableState;
      let _______writableStreamState = this._writableState;
      if (_____readableStreamState) {
        _____readableStreamState.constructed = true;
        _____readableStreamState.closed = false;
        _____readableStreamState.closeEmitted = false;
        _____readableStreamState.destroyed = false;
        _____readableStreamState.errored = null;
        _____readableStreamState.errorEmitted = false;
        _____readableStreamState.reading = false;
        _____readableStreamState.ended =
          _____readableStreamState.readable === false;
        _____readableStreamState.endEmitted =
          _____readableStreamState.readable === false;
      }
      if (_______writableStreamState) {
        _______writableStreamState.constructed = true;
        _______writableStreamState.destroyed = false;
        _______writableStreamState.closed = false;
        _______writableStreamState.closeEmitted = false;
        _______writableStreamState.errored = null;
        _______writableStreamState.errorEmitted = false;
        _______writableStreamState.finalCalled = false;
        _______writableStreamState.prefinished = false;
        _______writableStreamState.ended =
          _______writableStreamState.writable === false;
        _______writableStreamState.ending =
          _______writableStreamState.writable === false;
        _______writableStreamState.finished =
          _______writableStreamState.writable === false;
      }
    }
    function processStreamStateAndVersionManagement(
      handleStreamStateClosure,
      handleVersionStateManagement,
      initializePatternMatchingRegex,
    ) {
      let _readableStreamState = handleStreamStateClosure._readableState;
      let writableStreamState = handleStreamStateClosure._writableState;
      if (
        (writableStreamState && writableStreamState.destroyed) ||
        (_readableStreamState && _readableStreamState.destroyed)
      ) {
        return this;
      }
      if (
        (_readableStreamState && _readableStreamState.autoDestroy) ||
        (writableStreamState && writableStreamState.autoDestroy)
      ) {
        handleStreamStateClosure.destroy(handleVersionStateManagement);
      } else if (handleVersionStateManagement) {
        handleVersionStateManagement.stack;
        if (writableStreamState && !writableStreamState.errored) {
          writableStreamState.errored = handleVersionStateManagement;
        }
        if (_readableStreamState && !_readableStreamState.errored) {
          _readableStreamState.errored = handleVersionStateManagement;
        }
        if (initializePatternMatchingRegex) {
          _isSemVerRangeValid.nextTick(
            _handleStreamError,
            handleStreamStateClosure,
            handleVersionStateManagement,
          );
        } else {
          _handleStreamError(
            handleStreamStateClosure,
            handleVersionStateManagement,
          );
        }
      }
    }
    function initializeStreamConstructionStates(
      emitCloseIfStateClosed,
      initializePatternRegex,
    ) {
      if (typeof emitCloseIfStateClosed._construct != "function") {
        return;
      }
      let __________readableStreamState = emitCloseIfStateClosed._readableState;
      let __________writableStreamState = emitCloseIfStateClosed._writableState;
      if (__________readableStreamState) {
        __________readableStreamState.constructed = false;
      }
      if (__________writableStreamState) {
        __________writableStreamState.constructed = false;
      }
      emitCloseIfStateClosed.once(
        fetchConstructionSymbol,
        initializePatternRegex,
      );
      if (
        !(emitCloseIfStateClosed.listenerCount(fetchConstructionSymbol) > 1)
      ) {
        _isSemVerRangeValid.nextTick(
          importAndInitializeModule,
          emitCloseIfStateClosed,
        );
      }
    }
    function importAndInitializeModule(handleStreamError) {
      let hasModuleBeenInitialized = false;
      function setupModuleHandler(initializeAndValidateStreamStates) {
        if (hasModuleBeenInitialized) {
          processStreamStateAndVersionManagement(
            handleStreamError,
            initializeAndValidateStreamStates ??
              new ERR_INVALID_MULTIPLE_CALLBACK_USAGE(),
          );
          return;
        }
        hasModuleBeenInitialized = true;
        let ______readableStreamState = handleStreamError._readableState;
        let ________writableStreamState = handleStreamError._writableState;
        let activeStreamState =
          ________writableStreamState || ______readableStreamState;
        if (______readableStreamState) {
          ______readableStreamState.constructed = true;
        }
        if (________writableStreamState) {
          ________writableStreamState.constructed = true;
        }
        if (activeStreamState.destroyed) {
          handleStreamError.emit(
            createUniqueSymbolForDestruction,
            initializeAndValidateStreamStates,
          );
        } else if (initializeAndValidateStreamStates) {
          processStreamStateAndVersionManagement(
            handleStreamError,
            initializeAndValidateStreamStates,
            true,
          );
        } else {
          _isSemVerRangeValid.nextTick(
            triggerConstructionSymbolEmit,
            handleStreamError,
          );
        }
      }
      try {
        handleStreamError._construct(setupModuleHandler);
      } catch (errorHandling) {
        setupModuleHandler(errorHandling);
      }
    }
    function triggerConstructionSymbolEmit(updateStreamStateFlags) {
      updateStreamStateFlags.emit(fetchConstructionSymbol);
    }
    function isWritableStreamTrimmable(initializeWritableStreamState) {
      return (
        initializeWritableStreamState &&
        initializeWritableStreamState.setHeader &&
        typeof initializeWritableStreamState.abort == "function"
      );
    }
    function emitCloseSignalToStream(handleStreamStateAndRegex) {
      handleStreamStateAndRegex.emit("close");
    }
    function handleErrorAndCheckSemVerValidity(
      initializeAndValidateStreamState,
      initializeStreamState,
    ) {
      initializeAndValidateStreamState.emit("error", initializeStreamState);
      _isSemVerRangeValid.nextTick(
        emitCloseSignalToStream,
        initializeAndValidateStreamState,
      );
    }
    function processMatchCreationRequest(
      handleStreamStateAndVersionManagement,
      initializePatternMatchingState,
    ) {
      if (
        !!handleStreamStateAndVersionManagement &&
        !isCharacterEncodingValidAndActive(
          handleStreamStateAndVersionManagement,
        )
      ) {
        if (
          !initializePatternMatchingState &&
          !isCharacterEncodingProcessComplete(
            handleStreamStateAndVersionManagement,
          )
        ) {
          initializePatternMatchingState = new AbortError();
        }
        if (isIncomingRequestValid(handleStreamStateAndVersionManagement)) {
          handleStreamStateAndVersionManagement.socket = null;
          handleStreamStateAndVersionManagement.destroy(
            initializePatternMatchingState,
          );
        } else if (
          isWritableStreamTrimmable(handleStreamStateAndVersionManagement)
        ) {
          handleStreamStateAndVersionManagement.abort();
        } else if (
          isWritableStreamTrimmable(handleStreamStateAndVersionManagement.req)
        ) {
          handleStreamStateAndVersionManagement.req.abort();
        } else if (
          typeof handleStreamStateAndVersionManagement.destroy == "function"
        ) {
          handleStreamStateAndVersionManagement.destroy(
            initializePatternMatchingState,
          );
        } else if (
          typeof handleStreamStateAndVersionManagement.close == "function"
        ) {
          handleStreamStateAndVersionManagement.close();
        } else if (initializePatternMatchingState) {
          _isSemVerRangeValid.nextTick(
            handleErrorAndCheckSemVerValidity,
            handleStreamStateAndVersionManagement,
            initializePatternMatchingState,
          );
        } else {
          _isSemVerRangeValid.nextTick(
            emitCloseSignalToStream,
            handleStreamStateAndVersionManagement,
          );
        }
        if (!handleStreamStateAndVersionManagement.destroyed) {
          handleStreamStateAndVersionManagement[isEncodingProcessTerminated] =
            true;
        }
      }
    }
    handleInvalidSemanticVersioning.exports = {
      construct: initializeStreamConstructionStates,
      destroyer: processMatchCreationRequest,
      destroy: processStreamsAndHandleDestruction,
      undestroy: resetStreamStates,
      errorOrDestroy: processStreamStateAndVersionManagement,
    };
  },
);
var resetStreamConstructionStates = lazyModuleInitializer(
  (validateAndCompare, validateAndCompareProperties) => {
    var getReflectObject = typeof Reflect == "object" ? Reflect : null;
    var invokeFunctionWithContext =
      getReflectObject && typeof getReflectObject.apply == "function"
        ? getReflectObject.apply
        : function (
            initializeStreamImportHandler,
            validateAndInitializeModuleImport,
            initializeStreamImport,
          ) {
            return Function.prototype.apply.call(
              initializeStreamImportHandler,
              validateAndInitializeModuleImport,
              initializeStreamImport,
            );
          };
    var retrieveAllObjectKeys;
    if (getReflectObject && typeof getReflectObject.ownKeys == "function") {
      retrieveAllObjectKeys = getReflectObject.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      retrieveAllObjectKeys = function (handleStreamInitialization) {
        return Object.getOwnPropertyNames(handleStreamInitialization).concat(
          Object.getOwnPropertySymbols(handleStreamInitialization),
        );
      };
    } else {
      retrieveAllObjectKeys = function (isStreamStatesValid) {
        return Object.getOwnPropertyNames(isStreamStatesValid);
      };
    }
    function logStreamStateWarning(_isStreamStatesValid) {
      if (console && console.warn) {
        console.warn(_isStreamStatesValid);
      }
    }
    var _retrieveAllObjectKeys =
      Number.isNaN ||
      function (validateStreamStates) {
        return validateStreamStates !== validateStreamStates;
      };
    function setupComponentFunctionality() {
      setupComponentFunctionality.init.call(this);
    }
    validateAndCompareProperties.exports = setupComponentFunctionality;
    validateAndCompareProperties.exports.once = _handleVersionComparisonEvent;
    setupComponentFunctionality.EventEmitter = setupComponentFunctionality;
    setupComponentFunctionality.prototype._events = undefined;
    setupComponentFunctionality.prototype._eventsCount = 0;
    setupComponentFunctionality.prototype._maxListeners = undefined;
    var retrieveAllObjectKeysIncludingSymbols = 10;
    function validateSemanticVersionListener(
      emitErrorAndValidateSemanticVersion,
    ) {
      if (typeof emitErrorAndValidateSemanticVersion != "function") {
        throw new TypeError(
          'The "listener" argument must be of type Function. Received type ' +
            typeof emitErrorAndValidateSemanticVersion,
        );
      }
    }
    Object.defineProperty(setupComponentFunctionality, "defaultMaxListeners", {
      enumerable: true,
      get() {
        return retrieveAllObjectKeysIncludingSymbols;
      },
      set(setMaxListenersLimit) {
        if (
          typeof setMaxListenersLimit != "number" ||
          setMaxListenersLimit < 0 ||
          _retrieveAllObjectKeys(setMaxListenersLimit)
        ) {
          throw new RangeError(
            'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
              setMaxListenersLimit +
              ".",
          );
        }
        retrieveAllObjectKeysIncludingSymbols = setMaxListenersLimit;
      },
    });
    setupComponentFunctionality.init = function () {
      if (
        this._events === undefined ||
        this._events === Object.getPrototypeOf(this)._events
      ) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || undefined;
    };
    setupComponentFunctionality.prototype.setMaxListeners = function (
      versionValidationPromise,
    ) {
      if (
        typeof versionValidationPromise != "number" ||
        versionValidationPromise < 0 ||
        _retrieveAllObjectKeys(versionValidationPromise)
      ) {
        throw new RangeError(
          'The value of "n" is out of range. It must be a non-negative number. Received ' +
            versionValidationPromise +
            ".",
        );
      }
      this._maxListeners = versionValidationPromise;
      return this;
    };
    function retrieveMaxListeners(handleStreamLifecycleManagement) {
      if (handleStreamLifecycleManagement._maxListeners === undefined) {
        return setupComponentFunctionality.defaultMaxListeners;
      } else {
        return handleStreamLifecycleManagement._maxListeners;
      }
    }
    setupComponentFunctionality.prototype.getMaxListeners = function () {
      return retrieveMaxListeners(this);
    };
    setupComponentFunctionality.prototype.emit = function (
      validateVersionComponents,
    ) {
      var eventHandlerArgs = [];
      for (
        var currentEventHandlerPosition = 1;
        currentEventHandlerPosition < arguments.length;
        currentEventHandlerPosition++
      ) {
        eventHandlerArgs.push(arguments[currentEventHandlerPosition]);
      }
      var isValidationErrorFlag = validateVersionComponents === "error";
      var eventHandlersByType = this._events;
      if (eventHandlersByType !== undefined) {
        isValidationErrorFlag =
          isValidationErrorFlag && eventHandlersByType.error === undefined;
      } else if (!isValidationErrorFlag) {
        return false;
      }
      if (isValidationErrorFlag) {
        var firstEventHandlerError;
        if (eventHandlerArgs.length > 0) {
          firstEventHandlerError = eventHandlerArgs[0];
        }
        if (firstEventHandlerError instanceof Error) {
          throw firstEventHandlerError;
        }
        var createUnhandledError = new Error(
          "Unhandled error." +
            (firstEventHandlerError
              ? " (" + firstEventHandlerError.message + ")"
              : ""),
        );
        createUnhandledError.context = firstEventHandlerError;
        throw createUnhandledError;
      }
      var handleEventError = eventHandlersByType[validateVersionComponents];
      if (handleEventError === undefined) {
        return false;
      }
      if (typeof handleEventError == "function") {
        invokeFunctionWithContext(handleEventError, this, eventHandlerArgs);
      } else {
        for (
          var eventHandlerCount = handleEventError.length,
            parsedPassengerHeaders = parsePassengerHeaderData(
              handleEventError,
              eventHandlerCount,
            ),
            currentEventHandlerPosition = 0;
          currentEventHandlerPosition < eventHandlerCount;
          ++currentEventHandlerPosition
        ) {
          invokeFunctionWithContext(
            parsedPassengerHeaders[currentEventHandlerPosition],
            this,
            eventHandlerArgs,
          );
        }
      }
      return true;
    };
    function initializeAndSetupVersionComparisonHandler(
      handleVersionValidation,
      __handleVersionComparison,
      handleVersionComparison,
      initializeVersionComparisonWorker,
    ) {
      var versionComparisonHandler;
      var _eventListenersMap;
      var _versionComparisonHandler;
      validateSemanticVersionListener(handleVersionComparison);
      _eventListenersMap = handleVersionValidation._events;
      if (_eventListenersMap === undefined) {
        _eventListenersMap = handleVersionValidation._events =
          Object.create(null);
        handleVersionValidation._eventsCount = 0;
      } else {
        if (_eventListenersMap.newListener !== undefined) {
          handleVersionValidation.emit(
            "newListener",
            __handleVersionComparison,
            handleVersionComparison.listener
              ? handleVersionComparison.listener
              : handleVersionComparison,
          );
          _eventListenersMap = handleVersionValidation._events;
        }
        _versionComparisonHandler =
          _eventListenersMap[__handleVersionComparison];
      }
      if (_versionComparisonHandler === undefined) {
        _versionComparisonHandler = _eventListenersMap[
          __handleVersionComparison
        ] = handleVersionComparison;
        ++handleVersionValidation._eventsCount;
      } else {
        if (typeof _versionComparisonHandler == "function") {
          _versionComparisonHandler = _eventListenersMap[
            __handleVersionComparison
          ] = initializeVersionComparisonWorker
            ? [handleVersionComparison, _versionComparisonHandler]
            : [_versionComparisonHandler, handleVersionComparison];
        } else if (initializeVersionComparisonWorker) {
          _versionComparisonHandler.unshift(handleVersionComparison);
        } else {
          _versionComparisonHandler.push(handleVersionComparison);
        }
        versionComparisonHandler = retrieveMaxListeners(
          handleVersionValidation,
        );
        if (
          versionComparisonHandler > 0 &&
          _versionComparisonHandler.length > versionComparisonHandler &&
          !_versionComparisonHandler.warned
        ) {
          _versionComparisonHandler.warned = true;
          var eventEmitterMemoryLeakWarning = new Error(
            "Possible EventEmitter memory leak detected. " +
              _versionComparisonHandler.length +
              " " +
              String(__handleVersionComparison) +
              " listeners added. Use emitter.setMaxListeners() to increase limit",
          );
          eventEmitterMemoryLeakWarning.name = "MaxListenersExceededWarning";
          eventEmitterMemoryLeakWarning.emitter = handleVersionValidation;
          eventEmitterMemoryLeakWarning.type = __handleVersionComparison;
          eventEmitterMemoryLeakWarning.count =
            _versionComparisonHandler.length;
          logStreamStateWarning(eventEmitterMemoryLeakWarning);
        }
      }
      return handleVersionValidation;
    }
    setupComponentFunctionality.prototype.addListener = function (
      comparePrereleaseVersionStrings,
      validateBlobVersionsAgainstExpected,
    ) {
      return initializeAndSetupVersionComparisonHandler(
        this,
        comparePrereleaseVersionStrings,
        validateBlobVersionsAgainstExpected,
        false,
      );
    };
    setupComponentFunctionality.prototype.on =
      setupComponentFunctionality.prototype.addListener;
    setupComponentFunctionality.prototype.prependListener = function (
      generateBlobURL,
      EventEmitterHandler,
    ) {
      return initializeAndSetupVersionComparisonHandler(
        this,
        generateBlobURL,
        EventEmitterHandler,
        true,
      );
    };
    function invokeListenerOnceAndRemove() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) {
          return this.listener.call(this.target);
        } else {
          return this.listener.apply(this.target, arguments);
        }
      }
    }
    function initializeBlobURLListenerAndTrigger(
      _generateBlobURL,
      handleValidationErrorEvent,
      handleValidationErrors,
    ) {
      var createBlobURLEventListener = {
        fired: false,
        wrapFn: undefined,
        target: _generateBlobURL,
        type: handleValidationErrorEvent,
        listener: handleValidationErrors,
      };
      var bindBlobURLListenerToInvokeOnce = invokeListenerOnceAndRemove.bind(
        createBlobURLEventListener,
      );
      bindBlobURLListenerToInvokeOnce.listener = handleValidationErrors;
      createBlobURLEventListener.wrapFn = bindBlobURLListenerToInvokeOnce;
      return bindBlobURLListenerToInvokeOnce;
    }
    setupComponentFunctionality.prototype.once = function (
      handleVersionAndDownloadBlob,
      processUTF8String,
    ) {
      validateSemanticVersionListener(processUTF8String);
      this.on(
        handleVersionAndDownloadBlob,
        initializeBlobURLListenerAndTrigger(
          this,
          handleVersionAndDownloadBlob,
          processUTF8String,
        ),
      );
      return this;
    };
    setupComponentFunctionality.prototype.prependOnceListener = function (
      createBlobURLFromData,
      processPassengerHeaderData,
    ) {
      validateSemanticVersionListener(processPassengerHeaderData);
      this.prependListener(
        createBlobURLFromData,
        initializeBlobURLListenerAndTrigger(
          this,
          createBlobURLFromData,
          processPassengerHeaderData,
        ),
      );
      return this;
    };
    setupComponentFunctionality.prototype.removeListener = function (
      initializeEventHandlers,
      __initializeVersionComparisonHandler,
    ) {
      var _eventListener;
      var eventListenersMap;
      var currentEventListenerIndex;
      var _currentEventListenerIndex;
      var currentEventListener;
      validateSemanticVersionListener(__initializeVersionComparisonHandler);
      eventListenersMap = this._events;
      if (eventListenersMap === undefined) {
        return this;
      }
      _eventListener = eventListenersMap[initializeEventHandlers];
      if (_eventListener === undefined) {
        return this;
      }
      if (
        _eventListener === __initializeVersionComparisonHandler ||
        _eventListener.listener === __initializeVersionComparisonHandler
      ) {
        if (--this._eventsCount === 0) {
          this._events = Object.create(null);
        } else {
          delete eventListenersMap[initializeEventHandlers];
          if (eventListenersMap.removeListener) {
            this.emit(
              "removeListener",
              initializeEventHandlers,
              _eventListener.listener || __initializeVersionComparisonHandler,
            );
          }
        }
      } else if (typeof _eventListener != "function") {
        currentEventListenerIndex = -1;
        _currentEventListenerIndex = _eventListener.length - 1;
        for (; _currentEventListenerIndex >= 0; _currentEventListenerIndex--) {
          if (
            _eventListener[_currentEventListenerIndex] ===
              __initializeVersionComparisonHandler ||
            _eventListener[_currentEventListenerIndex].listener ===
              __initializeVersionComparisonHandler
          ) {
            currentEventListener =
              _eventListener[_currentEventListenerIndex].listener;
            currentEventListenerIndex = _currentEventListenerIndex;
            break;
          }
        }
        if (currentEventListenerIndex < 0) {
          return this;
        }
        if (currentEventListenerIndex === 0) {
          _eventListener.shift();
        } else {
          shiftVersionsToRemovePrerelease(
            _eventListener,
            currentEventListenerIndex,
          );
        }
        if (_eventListener.length === 1) {
          eventListenersMap[initializeEventHandlers] = _eventListener[0];
        }
        if (eventListenersMap.removeListener !== undefined) {
          this.emit(
            "removeListener",
            initializeEventHandlers,
            currentEventListener || __initializeVersionComparisonHandler,
          );
        }
      }
      return this;
    };
    setupComponentFunctionality.prototype.off =
      setupComponentFunctionality.prototype.removeListener;
    setupComponentFunctionality.prototype.removeAllListeners = function (
      logMessageToConsole,
    ) {
      var eventListenerCleanup;
      var eventListenersManager;
      var eventListenerIndex;
      eventListenersManager = this._events;
      if (eventListenersManager === undefined) {
        return this;
      }
      if (eventListenersManager.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (eventListenersManager[logMessageToConsole] !== undefined) {
          if (--this._eventsCount === 0) {
            this._events = Object.create(null);
          } else {
            delete eventListenersManager[logMessageToConsole];
          }
        }
        return this;
      }
      if (arguments.length === 0) {
        var listenerEventKeys = Object.keys(eventListenersManager);
        var listenerEvent;
        for (
          eventListenerIndex = 0;
          eventListenerIndex < listenerEventKeys.length;
          ++eventListenerIndex
        ) {
          listenerEvent = listenerEventKeys[eventListenerIndex];
          if (listenerEvent !== "removeListener") {
            this.removeAllListeners(listenerEvent);
          }
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      eventListenerCleanup = eventListenersManager[logMessageToConsole];
      if (typeof eventListenerCleanup == "function") {
        this.removeListener(logMessageToConsole, eventListenerCleanup);
      } else if (eventListenerCleanup !== undefined) {
        for (
          eventListenerIndex = eventListenerCleanup.length - 1;
          eventListenerIndex >= 0;
          eventListenerIndex--
        ) {
          this.removeListener(
            logMessageToConsole,
            eventListenerCleanup[eventListenerIndex],
          );
        }
      }
      return this;
    };
    function extractBlobURLListenersForTarFile(
      _createAndTriggerBlobURLListener,
      __createAndTriggerBlobURLListener,
      addOnceListenerForBlobURLGeneration,
    ) {
      var blobURLCreationEventListeners =
        _createAndTriggerBlobURLListener._events;
      if (blobURLCreationEventListeners === undefined) {
        return [];
      }
      var blobURLCreationListener =
        blobURLCreationEventListeners[__createAndTriggerBlobURLListener];
      if (blobURLCreationListener === undefined) {
        return [];
      } else if (typeof blobURLCreationListener == "function") {
        if (addOnceListenerForBlobURLGeneration) {
          return [blobURLCreationListener.listener || blobURLCreationListener];
        } else {
          return [blobURLCreationListener];
        }
      } else if (addOnceListenerForBlobURLGeneration) {
        return getListenersFromPrereleaseVersions(blobURLCreationListener);
      } else {
        return parsePassengerHeaderData(
          blobURLCreationListener,
          blobURLCreationListener.length,
        );
      }
    }
    setupComponentFunctionality.prototype.listeners = function (
      processNextTarFile,
    ) {
      return extractBlobURLListenersForTarFile(this, processNextTarFile, true);
    };
    setupComponentFunctionality.prototype.rawListeners = function (
      readNextTarFile,
    ) {
      return extractBlobURLListenersForTarFile(this, readNextTarFile, false);
    };
    setupComponentFunctionality.listenerCount = function (
      removeEventListener,
      removeEventListenerForVersionComparison,
    ) {
      if (typeof removeEventListener.listenerCount == "function") {
        return removeEventListener.listenerCount(
          removeEventListenerForVersionComparison,
        );
      } else {
        return getCountOfEventHandlersForRemoval.call(
          removeEventListener,
          removeEventListenerForVersionComparison,
        );
      }
    };
    setupComponentFunctionality.prototype.listenerCount =
      getCountOfEventHandlersForRemoval;
    function getCountOfEventHandlersForRemoval(handleEventListenerRemoval) {
      var eventHandlersMap = this._events;
      if (eventHandlersMap !== undefined) {
        var getEventListenerRemovalHandler =
          eventHandlersMap[handleEventListenerRemoval];
        if (typeof getEventListenerRemovalHandler == "function") {
          return 1;
        }
        if (getEventListenerRemovalHandler !== undefined) {
          return getEventListenerRemovalHandler.length;
        }
      }
      return 0;
    }
    setupComponentFunctionality.prototype.eventNames = function () {
      if (this._eventsCount > 0) {
        return retrieveAllObjectKeys(this._events);
      } else {
        return [];
      }
    };
    function parsePassengerHeaderData(
      removeEventListenerAndCleanUp,
      handlePaxHeaderParsing,
    ) {
      var parsedPassengerHeaderArray = new Array(handlePaxHeaderParsing);
      for (
        var passengerHeaderIndex = 0;
        passengerHeaderIndex < handlePaxHeaderParsing;
        ++passengerHeaderIndex
      ) {
        parsedPassengerHeaderArray[passengerHeaderIndex] =
          removeEventListenerAndCleanUp[passengerHeaderIndex];
      }
      return parsedPassengerHeaderArray;
    }
    function shiftVersionsToRemovePrerelease(
      compareVersionWithPrerelease,
      compareVersionAgainstPrerelease,
    ) {
      for (
        ;
        compareVersionAgainstPrerelease + 1 <
        compareVersionWithPrerelease.length;
        compareVersionAgainstPrerelease++
      ) {
        compareVersionWithPrerelease[compareVersionAgainstPrerelease] =
          compareVersionWithPrerelease[compareVersionAgainstPrerelease + 1];
      }
      compareVersionWithPrerelease.pop();
    }
    function getListenersFromPrereleaseVersions(_compareVersionWithPrerelease) {
      for (
        var eventListeners = new Array(_compareVersionWithPrerelease.length),
          listenerIndex = 0;
        listenerIndex < eventListeners.length;
        ++listenerIndex
      ) {
        eventListeners[listenerIndex] =
          _compareVersionWithPrerelease[listenerIndex].listener ||
          _compareVersionWithPrerelease[listenerIndex];
      }
      return eventListeners;
    }
    function _handleVersionComparisonEvent(
      __compareVersionWithPrerelease,
      ___compareVersionWithPrerelease,
    ) {
      return new Promise(function (
        ____compareVersionWithPrerelease,
        removeAllEventListeners,
      ) {
        function removeErrorListenerAndValidateVersions(
          removeAllEventListenersOrByLogMessage,
        ) {
          __compareVersionWithPrerelease.removeListener(
            ___compareVersionWithPrerelease,
            cleanupErrorListenerAndValidateVersions,
          );
          removeAllEventListeners(removeAllEventListenersOrByLogMessage);
        }
        function cleanupErrorListenerAndValidateVersions() {
          if (
            typeof __compareVersionWithPrerelease.removeListener == "function"
          ) {
            __compareVersionWithPrerelease.removeListener(
              "error",
              removeErrorListenerAndValidateVersions,
            );
          }
          ____compareVersionWithPrerelease([].slice.call(arguments));
        }
        processEventListenerConfig(
          __compareVersionWithPrerelease,
          ___compareVersionWithPrerelease,
          cleanupErrorListenerAndValidateVersions,
          {
            once: true,
          },
        );
        if (___compareVersionWithPrerelease !== "error") {
          processBlobURLCleanupAndErrorHandling(
            __compareVersionWithPrerelease,
            removeErrorListenerAndValidateVersions,
            {
              once: true,
            },
          );
        }
      });
    }
    function processBlobURLCleanupAndErrorHandling(
      removeAllBlobURLListeners,
      getTarFileListenersWithBlobURL,
      manageEventListeners,
    ) {
      if (typeof removeAllBlobURLListeners.on == "function") {
        processEventListenerConfig(
          removeAllBlobURLListeners,
          "error",
          getTarFileListenersWithBlobURL,
          manageEventListeners,
        );
      }
    }
    function processEventListenerConfig(
      eventListenerConfig,
      eventListenerMap,
      eventListenerMapping,
      eventListenersMap,
    ) {
      if (typeof eventListenerConfig.on == "function") {
        if (eventListenersMap.once) {
          eventListenerConfig.once(eventListenerMap, eventListenerMapping);
        } else {
          eventListenerConfig.on(eventListenerMap, eventListenerMapping);
        }
      } else if (typeof eventListenerConfig.addEventListener == "function") {
        eventListenerConfig.addEventListener(
          eventListenerMap,
          function retrieveTarFileListeners(getBlobURLListeners) {
            if (eventListenersMap.once) {
              eventListenerConfig.removeEventListener(
                eventListenerMap,
                retrieveTarFileListeners,
              );
            }
            eventListenerMapping(getBlobURLListeners);
          },
        );
      } else {
        throw new TypeError(
          'The "emitter" argument must be of type EventEmitter. Received type ' +
            typeof eventListenerConfig,
        );
      }
    }
  },
);
var processTarFileListenerArray = lazyModuleInitializer(
  (_initializeStreamPipeline, initializeStreamEventProcessing) => {
    var { ArrayIsArray: isArray, ObjectSetPrototypeOf: setPrototype } =
      performComparisonOperation();
    var { EventEmitter: __StreamEventEmitter } =
      resetStreamConstructionStates();
    function setupProcessEventListeners(processEventListenerArray) {
      __StreamEventEmitter.call(this, processEventListenerArray);
    }
    setPrototype(
      setupProcessEventListeners.prototype,
      __StreamEventEmitter.prototype,
    );
    setPrototype(setupProcessEventListeners, __StreamEventEmitter);
    setupProcessEventListeners.prototype.pipe = function (
      getTarFileListenersAndCount,
      getEventHandlerLengthBasedOnRemoval,
    ) {
      let eventEmitterContext = this;
      function manageWritableStreamPause(countEventListenersByType) {
        if (
          getTarFileListenersAndCount.writable &&
          getTarFileListenersAndCount.write(countEventListenersByType) ===
            false &&
          eventEmitterContext.pause
        ) {
          eventEmitterContext.pause();
        }
      }
      eventEmitterContext.on("data", manageWritableStreamPause);
      function resumeReadableStream() {
        if (eventEmitterContext.readable && eventEmitterContext.resume) {
          eventEmitterContext.resume();
        }
      }
      getTarFileListenersAndCount.on("drain", resumeReadableStream);
      if (
        !getTarFileListenersAndCount._isStdio &&
        (!getEventHandlerLengthBasedOnRemoval ||
          getEventHandlerLengthBasedOnRemoval.end !== false)
      ) {
        eventEmitterContext.on("end", terminateProcessIfIncomplete);
        eventEmitterContext.on("close", stopPendingProcess);
      }
      let hasProcessCompleted = false;
      function terminateProcessIfIncomplete() {
        if (!hasProcessCompleted) {
          hasProcessCompleted = true;
          getTarFileListenersAndCount.end();
        }
      }
      function stopPendingProcess() {
        if (!hasProcessCompleted) {
          hasProcessCompleted = true;
          if (typeof getTarFileListenersAndCount.destroy == "function") {
            getTarFileListenersAndCount.destroy();
          }
        }
      }
      function emitErrorForPaxHeaderData(processPaxHeaderData) {
        cleanupEventListeners();
        if (__StreamEventEmitter.listenerCount(this, "error") === 0) {
          this.emit("error", processPaxHeaderData);
        }
      }
      registerEventHandlerWithVersionComparison(
        eventEmitterContext,
        "error",
        emitErrorForPaxHeaderData,
      );
      registerEventHandlerWithVersionComparison(
        getTarFileListenersAndCount,
        "error",
        emitErrorForPaxHeaderData,
      );
      function cleanupEventListeners() {
        eventEmitterContext.removeListener("data", manageWritableStreamPause);
        getTarFileListenersAndCount.removeListener(
          "drain",
          resumeReadableStream,
        );
        eventEmitterContext.removeListener("end", terminateProcessIfIncomplete);
        eventEmitterContext.removeListener("close", stopPendingProcess);
        eventEmitterContext.removeListener("error", emitErrorForPaxHeaderData);
        getTarFileListenersAndCount.removeListener(
          "error",
          emitErrorForPaxHeaderData,
        );
        eventEmitterContext.removeListener("end", cleanupEventListeners);
        eventEmitterContext.removeListener("close", cleanupEventListeners);
        getTarFileListenersAndCount.removeListener(
          "close",
          cleanupEventListeners,
        );
      }
      eventEmitterContext.on("end", cleanupEventListeners);
      eventEmitterContext.on("close", cleanupEventListeners);
      getTarFileListenersAndCount.on("close", cleanupEventListeners);
      getTarFileListenersAndCount.emit("pipe", eventEmitterContext);
      return getTarFileListenersAndCount;
    };
    function registerEventHandlerWithVersionComparison(
      handleVersionComparisonAndRemoveListeners,
      handleVersionComparisonEvent,
      ___handleVersionComparison,
    ) {
      if (
        typeof handleVersionComparisonAndRemoveListeners.prependListener ==
        "function"
      ) {
        return handleVersionComparisonAndRemoveListeners.prependListener(
          handleVersionComparisonEvent,
          ___handleVersionComparison,
        );
      }
      if (
        !handleVersionComparisonAndRemoveListeners._events ||
        !handleVersionComparisonAndRemoveListeners._events[
          handleVersionComparisonEvent
        ]
      ) {
        handleVersionComparisonAndRemoveListeners.on(
          handleVersionComparisonEvent,
          ___handleVersionComparison,
        );
      } else if (
        isArray(
          handleVersionComparisonAndRemoveListeners._events[
            handleVersionComparisonEvent
          ],
        )
      ) {
        handleVersionComparisonAndRemoveListeners._events[
          handleVersionComparisonEvent
        ].unshift(___handleVersionComparison);
      } else {
        handleVersionComparisonAndRemoveListeners._events[
          handleVersionComparisonEvent
        ] = [
          ___handleVersionComparison,
          handleVersionComparisonAndRemoveListeners._events[
            handleVersionComparisonEvent
          ],
        ];
      }
    }
    initializeStreamEventProcessing.exports = {
      Stream: setupProcessEventListeners,
      prependListener: registerEventHandlerWithVersionComparison,
    };
  },
);
var handleErrorAndVersionComparison = lazyModuleInitializer(
  (validateAndAttachAbortSignal, ____validateAndHandleAbortSignal) => {
    var {
      AbortError: AbortSignalValidationError,
      codes: abortSignalErrorCodes,
    } = fetchNodeValuePostTraversal();
    var _validateSemverPrerelease = validateStreamVersionState();
    var { ERR_INVALID_ARG_TYPE: AbortSignalTypeError } = abortSignalErrorCodes;
    var validateAndEnsureAbortSignalIsValid = (
      userAbortSignal,
      _validateAbortSignal,
    ) => {
      if (
        typeof userAbortSignal != "object" ||
        !("aborted" in userAbortSignal)
      ) {
        throw new AbortSignalTypeError(
          _validateAbortSignal,
          "AbortSignal",
          userAbortSignal,
        );
      }
    };
    function isValidPipeableStringConfiguration(
      handleEventListenerConfiguration,
    ) {
      return (
        !!handleEventListenerConfiguration &&
        typeof handleEventListenerConfiguration.pipe == "function"
      );
    }
    ____validateAndHandleAbortSignal.exports.addAbortSignal = function (
      isEventListenerConfigured,
      isEventListenerConfiguredCorrectly,
    ) {
      validateAndEnsureAbortSignalIsValid(isEventListenerConfigured, "signal");
      if (
        !isValidPipeableStringConfiguration(isEventListenerConfiguredCorrectly)
      ) {
        throw new AbortSignalTypeError(
          "stream",
          "stream.Stream",
          isEventListenerConfiguredCorrectly,
        );
      }
      return ____validateAndHandleAbortSignal.exports.addAbortSignalNoValidate(
        isEventListenerConfigured,
        isEventListenerConfiguredCorrectly,
      );
    };
    ____validateAndHandleAbortSignal.exports.addAbortSignalNoValidate =
      function (setupTarFileEventListeners, sanitizeUserInputAndParse) {
        if (
          typeof setupTarFileEventListeners != "object" ||
          !("aborted" in setupTarFileEventListeners)
        ) {
          return sanitizeUserInputAndParse;
        }
        let handleAbortEvent = () => {
          sanitizeUserInputAndParse.destroy(
            new AbortSignalValidationError(undefined, {
              cause: setupTarFileEventListeners.reason,
            }),
          );
        };
        if (setupTarFileEventListeners.aborted) {
          handleAbortEvent();
        } else {
          setupTarFileEventListeners.addEventListener(
            "abort",
            handleAbortEvent,
          );
          _validateSemverPrerelease(sanitizeUserInputAndParse, () =>
            setupTarFileEventListeners.removeEventListener(
              "abort",
              handleAbortEvent,
            ),
          );
        }
        return sanitizeUserInputAndParse;
      };
  },
);
var parseAndReturnString = lazyModuleInitializer(
  (DoublyLinkedListManager, DoublyLinkedListExporter) => {
    var {
      StringPrototypeSlice: stringSliceFunction,
      SymbolIterator: _SymbolHandler,
      TypedArrayPrototypeSet: TypedArraySetValues,
      Uint8Array: DataBufferUint8Array,
    } = performComparisonOperation();
    retrieveAndValidateIntrinsicPropertyValue();
    var { Buffer: BufferManager } = defineESModuleWithProperties(
      intrinsicPropertiesManager,
    );
    var { inspect: validateAndInspectBuffer } =
      validateAndProcessArrayBufferForProcessing();
    DoublyLinkedListExporter.exports = class {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(addNodeToLinkedList) {
        let createNewNode = {
          data: addNodeToLinkedList,
          next: null,
        };
        if (this.length > 0) {
          this.tail.next = createNewNode;
        } else {
          this.head = createNewNode;
        }
        this.tail = createNewNode;
        ++this.length;
      }
      unshift(addNodeToFrontInLinkedList) {
        let createNodeWithData = {
          data: addNodeToFrontInLinkedList,
          next: this.head,
        };
        if (this.length === 0) {
          this.tail = createNodeWithData;
        }
        this.head = createNodeWithData;
        ++this.length;
      }
      shift() {
        if (this.length === 0) {
          return;
        }
        let removedHeadElement = this.head.data;
        if (this.length === 1) {
          this.head = this.tail = null;
        } else {
          this.head = this.head.next;
        }
        --this.length;
        return removedHeadElement;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(joinElementsWithDelimiter) {
        if (this.length === 0) {
          return "";
        }
        let currentListNode = this.head;
        let joinedElements = "" + currentListNode.data;
        while ((currentListNode = currentListNode.next) !== null) {
          joinedElements += joinElementsWithDelimiter + currentListNode.data;
        }
        return joinedElements;
      }
      concat(calculateTotalBufferLength) {
        if (this.length === 0) {
          return BufferManager.alloc(0);
        }
        let allocateCombinedBuffer = BufferManager.allocUnsafe(
          calculateTotalBufferLength >>> 0,
        );
        let currentBufferNode = this.head;
        let currentBufferPosition = 0;
        while (currentBufferNode) {
          TypedArraySetValues(
            allocateCombinedBuffer,
            currentBufferNode.data,
            currentBufferPosition,
          );
          currentBufferPosition += currentBufferNode.data.length;
          currentBufferNode = currentBufferNode.next;
        }
        return allocateCombinedBuffer;
      }
      consume(consumeFromHeadCount, isBufferModeEnabled) {
        let currentHeadData = this.head.data;
        if (consumeFromHeadCount < currentHeadData.length) {
          let extractedHeadData = currentHeadData.slice(
            0,
            consumeFromHeadCount,
          );
          this.head.data = currentHeadData.slice(consumeFromHeadCount);
          return extractedHeadData;
        }
        if (consumeFromHeadCount === currentHeadData.length) {
          return this.shift();
        } else if (isBufferModeEnabled) {
          return this._getString(consumeFromHeadCount);
        } else {
          return this._getBuffer(consumeFromHeadCount);
        }
      }
      first() {
        return this.head.data;
      }
      *[_SymbolHandler]() {
        for (
          let currentNodeIterator = this.head;
          currentNodeIterator;
          currentNodeIterator = currentNodeIterator.next
        ) {
          yield currentNodeIterator.data;
        }
      }
      _getString(extractSubstringAndUpdateList) {
        let accumulatedSubstring = "";
        let nodeToProcess = this.head;
        let totalProcessedNodes = 0;
        do {
          let currentNodeContent = nodeToProcess.data;
          if (extractSubstringAndUpdateList > currentNodeContent.length) {
            accumulatedSubstring += currentNodeContent;
            extractSubstringAndUpdateList -= currentNodeContent.length;
          } else {
            if (extractSubstringAndUpdateList === currentNodeContent.length) {
              accumulatedSubstring += currentNodeContent;
              ++totalProcessedNodes;
              if (nodeToProcess.next) {
                this.head = nodeToProcess.next;
              } else {
                this.head = this.tail = null;
              }
            } else {
              accumulatedSubstring += stringSliceFunction(
                currentNodeContent,
                0,
                extractSubstringAndUpdateList,
              );
              this.head = nodeToProcess;
              nodeToProcess.data = stringSliceFunction(
                currentNodeContent,
                extractSubstringAndUpdateList,
              );
            }
            break;
          }
          ++totalProcessedNodes;
        } while ((nodeToProcess = nodeToProcess.next) !== null);
        this.length -= totalProcessedNodes;
        return accumulatedSubstring;
      }
      _getBuffer(allocateBufferForDataProcessing) {
        let allocatedBufferForDataProcessing = BufferManager.allocUnsafe(
          allocateBufferForDataProcessing,
        );
        let remainingBufferSizeForDataProcessing =
          allocateBufferForDataProcessing;
        let currentBufferSegment = this.head;
        let completedDataProcessingSegments = 0;
        do {
          let dataToProcessFromBuffer = currentBufferSegment.data;
          if (
            allocateBufferForDataProcessing > dataToProcessFromBuffer.length
          ) {
            TypedArraySetValues(
              allocatedBufferForDataProcessing,
              dataToProcessFromBuffer,
              remainingBufferSizeForDataProcessing -
                allocateBufferForDataProcessing,
            );
            allocateBufferForDataProcessing -= dataToProcessFromBuffer.length;
          } else {
            if (
              allocateBufferForDataProcessing === dataToProcessFromBuffer.length
            ) {
              TypedArraySetValues(
                allocatedBufferForDataProcessing,
                dataToProcessFromBuffer,
                remainingBufferSizeForDataProcessing -
                  allocateBufferForDataProcessing,
              );
              ++completedDataProcessingSegments;
              if (currentBufferSegment.next) {
                this.head = currentBufferSegment.next;
              } else {
                this.head = this.tail = null;
              }
            } else {
              TypedArraySetValues(
                allocatedBufferForDataProcessing,
                new DataBufferUint8Array(
                  dataToProcessFromBuffer.buffer,
                  dataToProcessFromBuffer.byteOffset,
                  allocateBufferForDataProcessing,
                ),
                remainingBufferSizeForDataProcessing -
                  allocateBufferForDataProcessing,
              );
              this.head = currentBufferSegment;
              currentBufferSegment.data = dataToProcessFromBuffer.slice(
                allocateBufferForDataProcessing,
              );
            }
            break;
          }
          ++completedDataProcessingSegments;
        } while ((currentBufferSegment = currentBufferSegment.next) !== null);
        this.length -= completedDataProcessingSegments;
        return allocatedBufferForDataProcessing;
      }
      [Symbol.for("nodejs.util.inspect.custom")](
        customBufferInspection,
        bufferInspectionOptions,
      ) {
        return validateAndInspectBuffer(this, {
          ...bufferInspectionOptions,
          depth: 0,
          customInspect: false,
        });
      }
    };
  },
);
var getErrorStackTrace = lazyModuleInitializer(
  (retrieveHighWaterMarkOrDefault, _retrieveHighWaterMarkOrDefault) => {
    var {
      MathFloor: getMathFloor,
      NumberIsInteger: isValidNonNegativeInteger,
    } = performComparisonOperation();
    var { ERR_INVALID_ARG_VALUE: ERR_INVALID_ARGUMENT_VALUE } =
      fetchNodeValuePostTraversal().codes;
    function calculateHighWaterMark(
      processAndFormatString,
      _processAndFormatString,
      comparisonCallbackFunction,
    ) {
      return (
        processAndFormatString.highWaterMark ??
        (_processAndFormatString
          ? processAndFormatString[comparisonCallbackFunction]
          : null)
      );
    }
    function determineDefaultBufferSize(executeOnce) {
      if (executeOnce) {
        return 16;
      } else {
        return 16384;
      }
    }
    function handleCallbackResolutionForBufferManagement(
      manageLinkedListInvocation,
      processDelimiter,
      processCallback,
      processPromiseResult,
    ) {
      let highWaterMark = calculateHighWaterMark(
        processDelimiter,
        processPromiseResult,
        processCallback,
      );
      if (highWaterMark != null) {
        if (!isValidNonNegativeInteger(highWaterMark) || highWaterMark < 0) {
          let resolvedOptionsValue = processPromiseResult
            ? "options." + processCallback
            : "options.highWaterMark";
          throw new ERR_INVALID_ARGUMENT_VALUE(
            resolvedOptionsValue,
            highWaterMark,
          );
        }
        return getMathFloor(highWaterMark);
      }
      return determineDefaultBufferSize(manageLinkedListInvocation.objectMode);
    }
    _retrieveHighWaterMarkOrDefault.exports = {
      getHighWaterMark: handleCallbackResolutionForBufferManagement,
      getDefaultHighWaterMark: determineDefaultBufferSize,
    };
  },
);
var formatStringWithDelimiter = lazyModuleInitializer(
  (bufferUtility, bufferModuleExports) => {
    retrieveAndValidateIntrinsicPropertyValue();
    var initializeBufferModule = defineESModuleWithProperties(
      intrinsicPropertiesManager,
    );
    var bufferModule = initializeBufferModule.Buffer;
    function mergeNodeDataIntoJoinString(
      concatenateNodeData,
      joinStringWithData,
    ) {
      for (var joinKeyWithNodeData in concatenateNodeData) {
        joinStringWithData[joinKeyWithNodeData] =
          concatenateNodeData[joinKeyWithNodeData];
      }
    }
    if (
      bufferModule.from &&
      bufferModule.alloc &&
      bufferModule.allocUnsafe &&
      bufferModule.allocUnsafeSlow
    ) {
      bufferModuleExports.exports = initializeBufferModule;
    } else {
      mergeNodeDataIntoJoinString(initializeBufferModule, bufferUtility);
      bufferUtility.Buffer = processAndEvaluateNodeBuffer;
    }
    function processAndEvaluateNodeBuffer(
      processNodeDataForBuffer,
      evaluateNodeData,
      inputData,
    ) {
      return bufferModule(
        processNodeDataForBuffer,
        evaluateNodeData,
        inputData,
      );
    }
    processAndEvaluateNodeBuffer.prototype = Object.create(
      bufferModule.prototype,
    );
    mergeNodeDataIntoJoinString(bufferModule, processAndEvaluateNodeBuffer);
    processAndEvaluateNodeBuffer.from = function (
      extractDataFromBuffer,
      _retrieveData,
      iterateOverNodes,
    ) {
      if (typeof extractDataFromBuffer == "number") {
        throw new TypeError("Argument must not be a number");
      }
      return bufferModule(
        extractDataFromBuffer,
        _retrieveData,
        iterateOverNodes,
      );
    };
    processAndEvaluateNodeBuffer.alloc = function (
      getNodeData,
      substringToConsume,
      substringRetrievalCount,
    ) {
      if (typeof getNodeData != "number") {
        throw new TypeError("Argument must be a number");
      }
      var dataBuffer = bufferModule(getNodeData);
      if (substringToConsume !== undefined) {
        if (typeof substringRetrievalCount == "string") {
          dataBuffer.fill(substringToConsume, substringRetrievalCount);
        } else {
          dataBuffer.fill(substringToConsume);
        }
      } else {
        dataBuffer.fill(0);
      }
      return dataBuffer;
    };
    processAndEvaluateNodeBuffer.allocUnsafe = function (
      retrieveDataAndUpdateList,
    ) {
      if (typeof retrieveDataAndUpdateList != "number") {
        throw new TypeError("Argument must be a number");
      }
      return bufferModule(retrieveDataAndUpdateList);
    };
    processAndEvaluateNodeBuffer.allocUnsafeSlow = function (
      getSubstringFromBuffer,
    ) {
      if (typeof getSubstringFromBuffer != "number") {
        throw new TypeError("Argument must be a number");
      }
      return initializeBufferModule.SlowBuffer(getSubstringFromBuffer);
    };
  },
);
var isNodeDataError = lazyModuleInitializer(
  (checkValidEncodingAndDetermineFormat) => {
    var encodingValidator = formatStringWithDelimiter().Buffer;
    var isSupportedEncoding =
      encodingValidator.isEncoding ||
      function (isTypedArray) {
        isTypedArray = "" + isTypedArray;
        switch (isTypedArray && isTypedArray.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
    function resolveCharacterEncoding(requestAbortControllerSignal) {
      if (!requestAbortControllerSignal) {
        return "utf8";
      }
      var hasCheckedForEncoding;
      while (true) {
        switch (requestAbortControllerSignal) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return requestAbortControllerSignal;
          default:
            if (hasCheckedForEncoding) {
              return;
            }
            requestAbortControllerSignal = (
              "" + requestAbortControllerSignal
            ).toLowerCase();
            hasCheckedForEncoding = true;
        }
      }
    }
    function checkAndResolveEncoding(processAndAllocateBufferData) {
      var resolvedCharacterEncoding = resolveCharacterEncoding(
        processAndAllocateBufferData,
      );
      if (
        typeof resolvedCharacterEncoding != "string" &&
        (encodingValidator.isEncoding === isSupportedEncoding ||
          !isSupportedEncoding(processAndAllocateBufferData))
      ) {
        throw new Error("Unknown encoding: " + processAndAllocateBufferData);
      }
      return resolvedCharacterEncoding || processAndAllocateBufferData;
    }
    checkValidEncodingAndDetermineFormat.StringDecoder = setupEncodingProcessor;
    function setupEncodingProcessor(allocateAndProcessBufferData) {
      this.encoding = checkAndResolveEncoding(allocateAndProcessBufferData);
      var byteSize;
      switch (this.encoding) {
        case "utf16le":
          this.text = processUTF16ErrorsAndExtractDescriptions;
          this.end = writeAndAppendDescriptions;
          byteSize = 4;
          break;
        case "utf8":
          this.fillLast = handleInvalidArgumentAndCopyCharacters;
          byteSize = 4;
          break;
        case "base64":
          this.text = encodeToBase64WithPadding;
          this.end = generateEncodedDescription;
          byteSize = 3;
          break;
        default:
          this.write = convertLogErrorToString;
          this.end = generateDescriptionBasedOnRandomIndex;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = encodingValidator.allocUnsafe(byteSize);
    }
    setupEncodingProcessor.prototype.write = function (validateHighWaterMark) {
      if (validateHighWaterMark.length === 0) {
        return "";
      }
      var lastFilledByte;
      var byteIndexToProcess;
      if (this.lastNeed) {
        lastFilledByte = this.fillLast(validateHighWaterMark);
        if (lastFilledByte === undefined) {
          return "";
        }
        byteIndexToProcess = this.lastNeed;
        this.lastNeed = 0;
      } else {
        byteIndexToProcess = 0;
      }
      if (byteIndexToProcess < validateHighWaterMark.length) {
        if (lastFilledByte) {
          return (
            lastFilledByte +
            this.text(validateHighWaterMark, byteIndexToProcess)
          );
        } else {
          return this.text(validateHighWaterMark, byteIndexToProcess);
        }
      } else {
        return lastFilledByte || "";
      }
    };
    setupEncodingProcessor.prototype.end = formatAndWriteBufferEncoding;
    setupEncodingProcessor.prototype.text = copyAndEncodePropertyWithValidation;
    setupEncodingProcessor.prototype.fillLast = function (
      calculateEncodedLengthInBytes,
    ) {
      if (this.lastNeed <= calculateEncodedLengthInBytes.length) {
        calculateEncodedLengthInBytes.copy(
          this.lastChar,
          this.lastTotal - this.lastNeed,
          0,
          this.lastNeed,
        );
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      calculateEncodedLengthInBytes.copy(
        this.lastChar,
        this.lastTotal - this.lastNeed,
        0,
        calculateEncodedLengthInBytes.length,
      );
      this.lastNeed -= calculateEncodedLengthInBytes.length;
    };
    function determineCategoryBasedOnRandomValue(exportRandomValueHandler) {
      if (exportRandomValueHandler <= 127) {
        return 0;
      } else if (exportRandomValueHandler >> 5 === 6) {
        return 2;
      } else if (exportRandomValueHandler >> 4 === 14) {
        return 3;
      } else if (exportRandomValueHandler >> 3 === 30) {
        return 4;
      } else if (exportRandomValueHandler >> 6 === 2) {
        return -1;
      } else {
        return -2;
      }
    }
    function handleRandomValueProcessing(
      formatNodeBufferValue,
      processAndValidateBufferData,
      validateAndFormatBufferData,
    ) {
      var currentProcessIndex = processAndValidateBufferData.length - 1;
      if (currentProcessIndex < validateAndFormatBufferData) {
        return 0;
      }
      var derivedRandomCategory = determineCategoryBasedOnRandomValue(
        processAndValidateBufferData[currentProcessIndex],
      );
      if (derivedRandomCategory >= 0) {
        if (derivedRandomCategory > 0) {
          formatNodeBufferValue.lastNeed = derivedRandomCategory - 1;
        }
        return derivedRandomCategory;
      } else if (
        --currentProcessIndex < validateAndFormatBufferData ||
        derivedRandomCategory === -2
      ) {
        return 0;
      } else {
        derivedRandomCategory = determineCategoryBasedOnRandomValue(
          processAndValidateBufferData[currentProcessIndex],
        );
        if (derivedRandomCategory >= 0) {
          if (derivedRandomCategory > 0) {
            formatNodeBufferValue.lastNeed = derivedRandomCategory - 2;
          }
          return derivedRandomCategory;
        } else if (
          --currentProcessIndex < validateAndFormatBufferData ||
          derivedRandomCategory === -2
        ) {
          return 0;
        } else {
          derivedRandomCategory = determineCategoryBasedOnRandomValue(
            processAndValidateBufferData[currentProcessIndex],
          );
          if (derivedRandomCategory >= 0) {
            if (derivedRandomCategory > 0) {
              if (derivedRandomCategory === 2) {
                derivedRandomCategory = 0;
              } else {
                formatNodeBufferValue.lastNeed = derivedRandomCategory - 3;
              }
            }
            return derivedRandomCategory;
          } else {
            return 0;
          }
        }
      }
    }
    function _processAbortOperation(
      handleOperationAbortError,
      handleAbortSignal,
      _handleAbortSignal,
    ) {
      if ((handleAbortSignal[0] & 192) !== 128) {
        handleOperationAbortError.lastNeed = 0;
        return "�";
      }
      if (
        handleOperationAbortError.lastNeed > 1 &&
        handleAbortSignal.length > 1
      ) {
        if ((handleAbortSignal[1] & 192) !== 128) {
          handleOperationAbortError.lastNeed = 1;
          return "�";
        }
        if (
          handleOperationAbortError.lastNeed > 2 &&
          handleAbortSignal.length > 2 &&
          (handleAbortSignal[2] & 192) !== 128
        ) {
          handleOperationAbortError.lastNeed = 2;
          return "�";
        }
      }
    }
    function handleInvalidArgumentAndCopyCharacters(validateEncodingType) {
      var charactersLeftToProcess = this.lastTotal - this.lastNeed;
      var handleAbortAndProcessCharacters = _processAbortOperation(
        this,
        validateEncodingType,
        charactersLeftToProcess,
      );
      if (handleAbortAndProcessCharacters !== undefined) {
        return handleAbortAndProcessCharacters;
      }
      if (this.lastNeed <= validateEncodingType.length) {
        validateEncodingType.copy(
          this.lastChar,
          charactersLeftToProcess,
          0,
          this.lastNeed,
        );
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      validateEncodingType.copy(
        this.lastChar,
        charactersLeftToProcess,
        0,
        validateEncodingType.length,
      );
      this.lastNeed -= validateEncodingType.length;
    }
    function copyAndEncodePropertyWithValidation(
      encodingParameter,
      validateEncodingAndHandleBufferData,
    ) {
      var processedRandomValue = handleRandomValueProcessing(
        this,
        encodingParameter,
        validateEncodingAndHandleBufferData,
      );
      if (!this.lastNeed) {
        return encodingParameter.toString(
          "utf8",
          validateEncodingAndHandleBufferData,
        );
      }
      this.lastTotal = processedRandomValue;
      var calculatedCopyOffset =
        encodingParameter.length - (processedRandomValue - this.lastNeed);
      encodingParameter.copy(this.lastChar, 0, calculatedCopyOffset);
      return encodingParameter.toString(
        "utf8",
        validateEncodingAndHandleBufferData,
        calculatedCopyOffset,
      );
    }
    function formatAndWriteBufferEncoding(initializeBufferEncodingHandler) {
      var encodedBufferWriteResult =
        initializeBufferEncodingHandler &&
        initializeBufferEncodingHandler.length
          ? this.write(initializeBufferEncodingHandler)
          : "";
      if (this.lastNeed) {
        return encodedBufferWriteResult + "�";
      } else {
        return encodedBufferWriteResult;
      }
    }
    function processUTF16ErrorsAndExtractDescriptions(
      handleEncodingErrors,
      _initializeEncodingHandler,
    ) {
      if (
        (handleEncodingErrors.length - _initializeEncodingHandler) % 2 ===
        0
      ) {
        var errorHandlingEncodedString = handleEncodingErrors.toString(
          "utf16le",
          _initializeEncodingHandler,
        );
        if (errorHandlingEncodedString) {
          var lastErrorCharacterCode = errorHandlingEncodedString.charCodeAt(
            errorHandlingEncodedString.length - 1,
          );
          if (
            lastErrorCharacterCode >= 55296 &&
            lastErrorCharacterCode <= 56319
          ) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] =
              handleEncodingErrors[handleEncodingErrors.length - 2];
            this.lastChar[1] =
              handleEncodingErrors[handleEncodingErrors.length - 1];
            return errorHandlingEncodedString.slice(0, -1);
          }
        }
        return errorHandlingEncodedString;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = handleEncodingErrors[handleEncodingErrors.length - 1];
      return handleEncodingErrors.toString(
        "utf16le",
        _initializeEncodingHandler,
        handleEncodingErrors.length - 1,
      );
    }
    function writeAndAppendDescriptions(concatenateInstanceDescriptions) {
      var contentToWrite =
        concatenateInstanceDescriptions &&
        concatenateInstanceDescriptions.length
          ? this.write(concatenateInstanceDescriptions)
          : "";
      if (this.lastNeed) {
        var charactersLeftToWrite = this.lastTotal - this.lastNeed;
        return (
          contentToWrite +
          this.lastChar.toString("utf16le", 0, charactersLeftToWrite)
        );
      }
      return contentToWrite;
    }
    function encodeToBase64WithPadding(
      exportedRandomValue,
      handleMessageAppend,
    ) {
      var paddingBytesRequired =
        (exportedRandomValue.length - handleMessageAppend) % 3;
      if (paddingBytesRequired === 0) {
        return exportedRandomValue.toString("base64", handleMessageAppend);
      } else {
        this.lastNeed = 3 - paddingBytesRequired;
        this.lastTotal = 3;
        if (paddingBytesRequired === 1) {
          this.lastChar[0] =
            exportedRandomValue[exportedRandomValue.length - 1];
        } else {
          this.lastChar[0] =
            exportedRandomValue[exportedRandomValue.length - 2];
          this.lastChar[1] =
            exportedRandomValue[exportedRandomValue.length - 1];
        }
        return exportedRandomValue.toString(
          "base64",
          handleMessageAppend,
          exportedRandomValue.length - paddingBytesRequired,
        );
      }
    }
    function generateEncodedDescription(calculateParameterDescription) {
      var encodedParameterDescription =
        calculateParameterDescription && calculateParameterDescription.length
          ? this.write(calculateParameterDescription)
          : "";
      if (this.lastNeed) {
        return (
          encodedParameterDescription +
          this.lastChar.toString("base64", 0, 3 - this.lastNeed)
        );
      } else {
        return encodedParameterDescription;
      }
    }
    function convertLogErrorToString(logInvalidArgumentTypeError) {
      return logInvalidArgumentTypeError.toString(this.encoding);
    }
    function generateDescriptionBasedOnRandomIndex(getRandomValueIndex) {
      if (getRandomValueIndex && getRandomValueIndex.length) {
        return this.write(getRandomValueIndex);
      } else {
        return "";
      }
    }
  },
);
var generateErrorMessage = lazyModuleInitializer(
  (
    createStreamFromErrorHandlingForValidation,
    createStreamWithValidationErrors,
  ) => {
    var _____isSemanticVersionRangeValid = isSemVerRangeValid();
    var {
      PromisePrototypeThen: handlePromiseThenOperation,
      SymbolAsyncIterator: AsyncIteratorSymbol,
      SymbolIterator: AsyncIterableIterator,
    } = performComparisonOperation();
    retrieveAndValidateIntrinsicPropertyValue();
    var { Buffer: BufferUtility } = defineESModuleWithProperties(
      intrinsicPropertiesManager,
    );
    var {
      ERR_INVALID_ARG_TYPE: _ERR_INVALID_ARGUMENT_TYPE,
      ERR_STREAM_NULL_VALUES: ERR_STREAM_NULL_INPUTS,
    } = fetchNodeValuePostTraversal().codes;
    function createStreamFromAsyncIterable(
      _handleInvalidArgumentError,
      processAbortOperation,
      abortOperationErrorFormatter,
    ) {
      let asyncIterableStream;
      if (
        typeof processAbortOperation == "string" ||
        processAbortOperation instanceof BufferUtility
      ) {
        return new _handleInvalidArgumentError({
          objectMode: true,
          ...abortOperationErrorFormatter,
          read() {
            this.push(processAbortOperation);
            this.push(null);
          },
        });
      }
      let isValidAsyncIterable;
      if (processAbortOperation && processAbortOperation[AsyncIteratorSymbol]) {
        isValidAsyncIterable = true;
        asyncIterableStream = processAbortOperation[AsyncIteratorSymbol]();
      } else if (
        processAbortOperation &&
        processAbortOperation[AsyncIterableIterator]
      ) {
        isValidAsyncIterable = false;
        asyncIterableStream = processAbortOperation[AsyncIterableIterator]();
      } else {
        throw new _ERR_INVALID_ARGUMENT_TYPE(
          "iterable",
          ["Iterable"],
          processAbortOperation,
        );
      }
      let createAsyncIterableStream = new _handleInvalidArgumentError({
        objectMode: true,
        highWaterMark: 1,
        ...abortOperationErrorFormatter,
      });
      let _createStreamFromAsyncIterable = false;
      createAsyncIterableStream._read = function () {
        if (!_createStreamFromAsyncIterable) {
          _createStreamFromAsyncIterable = true;
          handleAsyncIterableStream();
        }
      };
      createAsyncIterableStream._destroy = function (
        handleOperationAbortionError,
        _generateErrorMessage,
      ) {
        handlePromiseThenOperation(
          handleAsyncIteratorException(handleOperationAbortionError),
          () =>
            _____isSemanticVersionRangeValid.nextTick(
              _generateErrorMessage,
              handleOperationAbortionError,
            ),
          (______isSemanticVersionRangeValid) =>
            _____isSemanticVersionRangeValid.nextTick(
              _generateErrorMessage,
              ______isSemanticVersionRangeValid || handleOperationAbortionError,
            ),
        );
      };
      async function handleAsyncIteratorException(
        buildMissingArgumentsWarningMessage,
      ) {
        let isMissingArgumentsWarningMessage =
          buildMissingArgumentsWarningMessage != null;
        let isAsyncIterableThrowCapable =
          typeof asyncIterableStream.throw == "function";
        if (isMissingArgumentsWarningMessage && isAsyncIterableThrowCapable) {
          let { value: asyncIteratorResult, done: isAsyncIteratorDone } =
            await asyncIterableStream.throw(
              buildMissingArgumentsWarningMessage,
            );
          await asyncIteratorResult;
          if (isAsyncIteratorDone) {
            return;
          }
        }
        if (typeof asyncIterableStream.return == "function") {
          let { value: returnedValue } = await asyncIterableStream.return();
          await returnedValue;
        }
      }
      async function handleAsyncIterableStream() {
        while (true) {
          try {
            let { value: nextStreamItem, done: isAsyncIterableComplete } =
              isValidAsyncIterable
                ? await asyncIterableStream.next()
                : asyncIterableStream.next();
            if (isAsyncIterableComplete) {
              createAsyncIterableStream.push(null);
            } else {
              let finalStreamItem =
                nextStreamItem && typeof nextStreamItem.then == "function"
                  ? await nextStreamItem
                  : nextStreamItem;
              if (finalStreamItem === null) {
                _createStreamFromAsyncIterable = false;
                throw new ERR_STREAM_NULL_INPUTS();
              }
              if (createAsyncIterableStream.push(finalStreamItem)) {
                continue;
              }
              _createStreamFromAsyncIterable = false;
            }
          } catch (asyncIterableStreamError) {
            createAsyncIterableStream.destroy(asyncIterableStreamError);
          }
          break;
        }
      }
      return createAsyncIterableStream;
    }
    createStreamWithValidationErrors.exports = createStreamFromAsyncIterable;
  },
);
var _handleEncodingErrors = lazyModuleInitializer(
  (initializeStreamHandler, streamHandlerExports) => {
    var _isSemVerRangeValid = isSemVerRangeValid();
    var {
      ArrayPrototypeIndexOf: ArrayPrototypeIndexOfElement,
      NumberIsInteger: isNumberInteger,
      NumberIsNaN: isValueNaN,
      NumberParseInt: parseStringToInt,
      ObjectDefineProperties: defineObjectPropertiesWithAttributes,
      ObjectKeys: getObjectKeysAsArray,
      ObjectSetPrototypeOf: setStreamPrototype,
      Promise: PromiseHandler,
      SafeSet: SafeSetHandler,
      SymbolAsyncIterator: AsyncIterableSymbol,
      Symbol: SymbolHandler,
    } = performComparisonOperation();
    streamHandlerExports.exports = StreamRangeValidator;
    StreamRangeValidator.ReadableState = setupStreamOptionsForProcessing;
    var { EventEmitter: StreamEventEmitter } = resetStreamConstructionStates();
    var {
      Stream: StreamProcessor,
      prependListener: addStreamListenerAtBeginning,
    } = processTarFileListenerArray();
    retrieveAndValidateIntrinsicPropertyValue();
    var { Buffer: _BufferHandler } = defineESModuleWithProperties(
      intrinsicPropertiesManager,
    );
    var { addAbortSignal: _________initializeStreamHandler } =
      handleErrorAndVersionComparison();
    var setupAndValidateStreamHandler = validateStreamVersionState();
    var initializeStreamOptionsHandler =
      validateAndProcessArrayBufferForProcessing().debuglog(
        "stream",
        (initializeStreamHandlerOptions) => {
          initializeStreamOptionsHandler = initializeStreamHandlerOptions;
        },
      );
    var initializeStreamHandlerForProcessing = parseAndReturnString();
    var setupStreamHandlerWithValidation =
      processVersionValidationAndAbortSignals();
    var {
      getHighWaterMark: __initializeStreamProcessingHandler,
      getDefaultHighWaterMark: _initializeStreamValidator,
    } = getErrorStackTrace();
    var {
      aggregateTwoErrors: initializeStreamEventHandlers,
      codes: {
        ERR_INVALID_ARG_TYPE: setupStreamHandlerWithContext,
        ERR_METHOD_NOT_IMPLEMENTED: initializeStreamHandlerBasedOnUsage,
        ERR_OUT_OF_RANGE: _initializeStreamEventHandlers,
        ERR_STREAM_PUSH_AFTER_EOF: initializeStreamHandlerWithValidation,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT:
          createStreamHandlerWithImplementation,
      },
    } = fetchNodeValuePostTraversal();
    var { validateObject: _initializeStreamHandler } = handleStreamErrorTypes();
    var __initializeStreamHandler = SymbolHandler("kPaused");
    var { StringDecoder: __initializeStreamEventHandlers } = isNodeDataError();
    var ___initializeStreamHandler = generateErrorMessage();
    setStreamPrototype(
      StreamRangeValidator.prototype,
      StreamProcessor.prototype,
    );
    setStreamPrototype(StreamRangeValidator, StreamProcessor);
    var setupStreamHandling = () => {};
    var { errorOrDestroy: ___initializeStreamEventHandlers } =
      setupStreamHandlerWithValidation;
    function setupStreamOptionsForProcessing(
      validateAndReturnPropertyLength,
      createStreamWithErrorHandling,
      validateStreamInputAndProcess,
    ) {
      if (typeof validateStreamInputAndProcess != "boolean") {
        validateStreamInputAndProcess =
          createStreamWithErrorHandling instanceof setupStreamEventHandlers();
      }
      this.objectMode =
        !!validateAndReturnPropertyLength &&
        !!validateAndReturnPropertyLength.objectMode;
      if (validateStreamInputAndProcess) {
        this.objectMode =
          this.objectMode ||
          (!!validateAndReturnPropertyLength &&
            !!validateAndReturnPropertyLength.readableObjectMode);
      }
      if (validateAndReturnPropertyLength) {
        this.highWaterMark = __initializeStreamProcessingHandler(
          this,
          validateAndReturnPropertyLength,
          "readableHighWaterMark",
          validateStreamInputAndProcess,
        );
      } else {
        this.highWaterMark = _initializeStreamValidator(false);
      }
      this.buffer = new initializeStreamHandlerForProcessing();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.constructed = true;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this[__initializeStreamHandler] = null;
      this.errorEmitted = false;
      this.emitClose =
        !validateAndReturnPropertyLength ||
        validateAndReturnPropertyLength.emitClose !== false;
      this.autoDestroy =
        !validateAndReturnPropertyLength ||
        validateAndReturnPropertyLength.autoDestroy !== false;
      this.destroyed = false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this.defaultEncoding =
        (validateAndReturnPropertyLength &&
          validateAndReturnPropertyLength.defaultEncoding) ||
        "utf8";
      this.awaitDrainWriters = null;
      this.multiAwaitDrain = false;
      this.readingMore = false;
      this.dataEmitted = false;
      this.decoder = null;
      this.encoding = null;
      if (
        validateAndReturnPropertyLength &&
        validateAndReturnPropertyLength.encoding
      ) {
        this.decoder = new __initializeStreamEventHandlers(
          validateAndReturnPropertyLength.encoding,
        );
        this.encoding = validateAndReturnPropertyLength.encoding;
      }
    }
    function StreamRangeValidator(isNumberWithinRange) {
      if (!(this instanceof StreamRangeValidator)) {
        return new StreamRangeValidator(isNumberWithinRange);
      }
      let isSettingUpEventHandlers = this instanceof setupStreamEventHandlers();
      this._readableState = new setupStreamOptionsForProcessing(
        isNumberWithinRange,
        this,
        isSettingUpEventHandlers,
      );
      if (isNumberWithinRange) {
        if (typeof isNumberWithinRange.read == "function") {
          this._read = isNumberWithinRange.read;
        }
        if (typeof isNumberWithinRange.destroy == "function") {
          this._destroy = isNumberWithinRange.destroy;
        }
        if (typeof isNumberWithinRange.construct == "function") {
          this._construct = isNumberWithinRange.construct;
        }
        if (isNumberWithinRange.signal && !isSettingUpEventHandlers) {
          _________initializeStreamHandler(isNumberWithinRange.signal, this);
        }
      }
      StreamProcessor.call(this, isNumberWithinRange);
      setupStreamHandlerWithValidation.construct(this, () => {
        if (this._readableState.needReadable) {
          handleStreamProcessing(this, this._readableState);
        }
      });
    }
    StreamRangeValidator.prototype.destroy =
      setupStreamHandlerWithValidation.destroy;
    StreamRangeValidator.prototype._undestroy =
      setupStreamHandlerWithValidation.undestroy;
    StreamRangeValidator.prototype._destroy = function (
      validateAsyncValueStream,
      isValidIntegerInRange,
    ) {
      isValidIntegerInRange(validateAsyncValueStream);
    };
    StreamRangeValidator.prototype[StreamEventEmitter.captureRejectionSymbol] =
      function (validateNumberInRange) {
        this.destroy(validateNumberInRange);
      };
    StreamRangeValidator.prototype.push = function (
      _validateNumberInRange,
      validateStreamGenerator,
    ) {
      return processStreamCacheEntry(
        this,
        _validateNumberInRange,
        validateStreamGenerator,
        false,
      );
    };
    StreamRangeValidator.prototype.unshift = function (
      validateUserInputString,
      isCacheKeyValid,
    ) {
      return processStreamCacheEntry(
        this,
        validateUserInputString,
        isCacheKeyValid,
        true,
      );
    };
    function processStreamCacheEntry(
      validateStreamHandlerConstraints,
      isCacheValueValid,
      validateCacheEntry,
      validateAndCacheStreamEntry,
    ) {
      initializeStreamOptionsHandler("readableAddChunk", isCacheValueValid);
      let __readableStreamState =
        validateStreamHandlerConstraints._readableState;
      let streamEntryBuffer;
      if (!__readableStreamState.objectMode) {
        if (typeof isCacheValueValid == "string") {
          validateCacheEntry =
            validateCacheEntry || __readableStreamState.defaultEncoding;
          if (__readableStreamState.encoding !== validateCacheEntry) {
            if (validateAndCacheStreamEntry && __readableStreamState.encoding) {
              isCacheValueValid = _BufferHandler
                .from(isCacheValueValid, validateCacheEntry)
                .toString(__readableStreamState.encoding);
            } else {
              isCacheValueValid = _BufferHandler.from(
                isCacheValueValid,
                validateCacheEntry,
              );
              validateCacheEntry = "";
            }
          }
        } else if (isCacheValueValid instanceof _BufferHandler) {
          validateCacheEntry = "";
        } else if (StreamProcessor._isUint8Array(isCacheValueValid)) {
          isCacheValueValid =
            StreamProcessor._uint8ArrayToBuffer(isCacheValueValid);
          validateCacheEntry = "";
        } else if (isCacheValueValid != null) {
          streamEntryBuffer = new setupStreamHandlerWithContext(
            "chunk",
            ["string", "Buffer", "Uint8Array"],
            isCacheValueValid,
          );
        }
      }
      if (streamEntryBuffer) {
        ___initializeStreamEventHandlers(
          validateStreamHandlerConstraints,
          streamEntryBuffer,
        );
      } else if (isCacheValueValid === null) {
        __readableStreamState.reading = false;
        completePendingTasksProcessing(
          validateStreamHandlerConstraints,
          __readableStreamState,
        );
      } else if (
        __readableStreamState.objectMode ||
        (isCacheValueValid && isCacheValueValid.length > 0)
      ) {
        if (validateAndCacheStreamEntry) {
          if (__readableStreamState.endEmitted) {
            ___initializeStreamEventHandlers(
              validateStreamHandlerConstraints,
              new createStreamHandlerWithImplementation(),
            );
          } else {
            if (
              __readableStreamState.destroyed ||
              __readableStreamState.errored
            ) {
              return false;
            }
            manageDataBufferFlow(
              validateStreamHandlerConstraints,
              __readableStreamState,
              isCacheValueValid,
              true,
            );
          }
        } else if (__readableStreamState.ended) {
          ___initializeStreamEventHandlers(
            validateStreamHandlerConstraints,
            new initializeStreamHandlerWithValidation(),
          );
        } else {
          if (
            __readableStreamState.destroyed ||
            __readableStreamState.errored
          ) {
            return false;
          }
          __readableStreamState.reading = false;
          if (__readableStreamState.decoder && !validateCacheEntry) {
            isCacheValueValid =
              __readableStreamState.decoder.write(isCacheValueValid);
            if (
              __readableStreamState.objectMode ||
              isCacheValueValid.length !== 0
            ) {
              manageDataBufferFlow(
                validateStreamHandlerConstraints,
                __readableStreamState,
                isCacheValueValid,
                false,
              );
            } else {
              handleStreamProcessing(
                validateStreamHandlerConstraints,
                __readableStreamState,
              );
            }
          } else {
            manageDataBufferFlow(
              validateStreamHandlerConstraints,
              __readableStreamState,
              isCacheValueValid,
              false,
            );
          }
        }
      } else if (!validateAndCacheStreamEntry) {
        __readableStreamState.reading = false;
        handleStreamProcessing(
          validateStreamHandlerConstraints,
          __readableStreamState,
        );
      }
      return (
        !__readableStreamState.ended &&
        (__readableStreamState.length < __readableStreamState.highWaterMark ||
          __readableStreamState.length === 0)
      );
    }
    function manageDataBufferFlow(
      isValidSignalName,
      _validateAndReturnPropertyLength,
      validateArrayLengthForStream,
      validateArrayLengthForStreamHandler,
    ) {
      if (
        _validateAndReturnPropertyLength.flowing &&
        _validateAndReturnPropertyLength.length === 0 &&
        !_validateAndReturnPropertyLength.sync &&
        isValidSignalName.listenerCount("data") > 0
      ) {
        if (_validateAndReturnPropertyLength.multiAwaitDrain) {
          _validateAndReturnPropertyLength.awaitDrainWriters.clear();
        } else {
          _validateAndReturnPropertyLength.awaitDrainWriters = null;
        }
        _validateAndReturnPropertyLength.dataEmitted = true;
        isValidSignalName.emit("data", validateArrayLengthForStream);
      } else {
        if (_validateAndReturnPropertyLength.objectMode) {
          _validateAndReturnPropertyLength.length += 1;
        } else {
          _validateAndReturnPropertyLength.length +=
            validateArrayLengthForStream.length;
        }
        if (validateArrayLengthForStreamHandler) {
          _validateAndReturnPropertyLength.buffer.unshift(
            validateArrayLengthForStream,
          );
        } else {
          _validateAndReturnPropertyLength.buffer.push(
            validateArrayLengthForStream,
          );
        }
        if (_validateAndReturnPropertyLength.needReadable) {
          _processReadableStream(isValidSignalName);
        }
      }
      handleStreamProcessing(
        isValidSignalName,
        _validateAndReturnPropertyLength,
      );
    }
    StreamRangeValidator.prototype.isPaused = function () {
      let _currentStreamState = this._readableState;
      return (
        _currentStreamState[__initializeStreamHandler] === true ||
        _currentStreamState.flowing === false
      );
    };
    StreamRangeValidator.prototype.setEncoding = function (
      initializeStreamWithAbortSignalValidation,
    ) {
      let streamEventHandler = new __initializeStreamEventHandlers(
        initializeStreamWithAbortSignalValidation,
      );
      this._readableState.decoder = streamEventHandler;
      this._readableState.encoding = this._readableState.decoder.encoding;
      let readableBuffer = this._readableState.buffer;
      let combinedOutput = "";
      for (let readableStreamItem of readableBuffer) {
        combinedOutput += streamEventHandler.write(readableStreamItem);
      }
      readableBuffer.clear();
      if (combinedOutput !== "") {
        readableBuffer.push(combinedOutput);
      }
      this._readableState.length = combinedOutput.length;
      return this;
    };
    var initializeStreamEventHandler = 1073741824;
    function checkAndAdjustStreamNodeSize(isStreamNodeRemovable) {
      if (isStreamNodeRemovable > initializeStreamEventHandler) {
        throw new _initializeStreamEventHandlers(
          "size",
          "<= 1GiB",
          isStreamNodeRemovable,
        );
      }
      isStreamNodeRemovable--;
      isStreamNodeRemovable |= isStreamNodeRemovable >>> 1;
      isStreamNodeRemovable |= isStreamNodeRemovable >>> 2;
      isStreamNodeRemovable |= isStreamNodeRemovable >>> 4;
      isStreamNodeRemovable |= isStreamNodeRemovable >>> 8;
      isStreamNodeRemovable |= isStreamNodeRemovable >>> 16;
      isStreamNodeRemovable++;
      return isStreamNodeRemovable;
    }
    function calculateStreamDataLength(
      validateStreamValueRange,
      _validateStreamHandlerConstraints,
    ) {
      if (
        validateStreamValueRange <= 0 ||
        (_validateStreamHandlerConstraints.length === 0 &&
          _validateStreamHandlerConstraints.ended)
      ) {
        return 0;
      } else if (_validateStreamHandlerConstraints.objectMode) {
        return 1;
      } else if (isValueNaN(validateStreamValueRange)) {
        if (
          _validateStreamHandlerConstraints.flowing &&
          _validateStreamHandlerConstraints.length
        ) {
          return _validateStreamHandlerConstraints.buffer.first().length;
        } else {
          return _validateStreamHandlerConstraints.length;
        }
      } else if (
        validateStreamValueRange <= _validateStreamHandlerConstraints.length
      ) {
        return validateStreamValueRange;
      } else if (_validateStreamHandlerConstraints.ended) {
        return _validateStreamHandlerConstraints.length;
      } else {
        return 0;
      }
    }
    StreamRangeValidator.prototype.read = function (
      validateStreamCachingConstraints,
    ) {
      initializeStreamOptionsHandler("read", validateStreamCachingConstraints);
      if (validateStreamCachingConstraints === undefined) {
        validateStreamCachingConstraints = NaN;
      } else if (!isNumberInteger(validateStreamCachingConstraints)) {
        validateStreamCachingConstraints = parseStringToInt(
          validateStreamCachingConstraints,
          10,
        );
      }
      let readableState = this._readableState;
      let validatedReadSize = validateStreamCachingConstraints;
      if (validateStreamCachingConstraints > readableState.highWaterMark) {
        readableState.highWaterMark = checkAndAdjustStreamNodeSize(
          validateStreamCachingConstraints,
        );
      }
      if (validateStreamCachingConstraints !== 0) {
        readableState.emittedReadable = false;
      }
      if (
        validateStreamCachingConstraints === 0 &&
        readableState.needReadable &&
        ((readableState.highWaterMark !== 0
          ? readableState.length >= readableState.highWaterMark
          : readableState.length > 0) ||
          readableState.ended)
      ) {
        initializeStreamOptionsHandler(
          "read: emitReadable",
          readableState.length,
          readableState.ended,
        );
        if (readableState.length === 0 && readableState.ended) {
          processStreamEndEvent(this);
        } else {
          _processReadableStream(this);
        }
        return null;
      }
      validateStreamCachingConstraints = calculateStreamDataLength(
        validateStreamCachingConstraints,
        readableState,
      );
      if (validateStreamCachingConstraints === 0 && readableState.ended) {
        if (readableState.length === 0) {
          processStreamEndEvent(this);
        }
        return null;
      }
      let streamCachingConstraints = readableState.needReadable;
      initializeStreamOptionsHandler("need readable", streamCachingConstraints);
      if (
        readableState.length === 0 ||
        readableState.length - validateStreamCachingConstraints <
          readableState.highWaterMark
      ) {
        streamCachingConstraints = true;
        initializeStreamOptionsHandler(
          "length less than watermark",
          streamCachingConstraints,
        );
      }
      if (
        readableState.ended ||
        readableState.reading ||
        readableState.destroyed ||
        readableState.errored ||
        !readableState.constructed
      ) {
        streamCachingConstraints = false;
        initializeStreamOptionsHandler(
          "reading, ended or constructing",
          streamCachingConstraints,
        );
      } else if (streamCachingConstraints) {
        initializeStreamOptionsHandler("do read");
        readableState.reading = true;
        readableState.sync = true;
        if (readableState.length === 0) {
          readableState.needReadable = true;
        }
        try {
          this._read(readableState.highWaterMark);
        } catch (streamInitializationError) {
          ___initializeStreamEventHandlers(this, streamInitializationError);
        }
        readableState.sync = false;
        if (!readableState.reading) {
          validateStreamCachingConstraints = calculateStreamDataLength(
            validatedReadSize,
            readableState,
          );
        }
      }
      let _validatedReadSize;
      if (validateStreamCachingConstraints > 0) {
        _validatedReadSize = _handleStreamDataProcessing(
          validateStreamCachingConstraints,
          readableState,
        );
      } else {
        _validatedReadSize = null;
      }
      if (_validatedReadSize === null) {
        readableState.needReadable =
          readableState.length <= readableState.highWaterMark;
        validateStreamCachingConstraints = 0;
      } else {
        readableState.length -= validateStreamCachingConstraints;
        if (readableState.multiAwaitDrain) {
          readableState.awaitDrainWriters.clear();
        } else {
          readableState.awaitDrainWriters = null;
        }
      }
      if (readableState.length === 0) {
        if (!readableState.ended) {
          readableState.needReadable = true;
        }
        if (
          validatedReadSize !== validateStreamCachingConstraints &&
          readableState.ended
        ) {
          processStreamEndEvent(this);
        }
      }
      if (
        _validatedReadSize !== null &&
        !readableState.errorEmitted &&
        !readableState.closeEmitted
      ) {
        readableState.dataEmitted = true;
        this.emit("data", _validatedReadSize);
      }
      return _validatedReadSize;
    };
    function completePendingTasksProcessing(
      processPendingDataTasks,
      _handlePendingTasks,
    ) {
      initializeStreamOptionsHandler("onEofChunk");
      if (!_handlePendingTasks.ended) {
        if (_handlePendingTasks.decoder) {
          let completedTasks = _handlePendingTasks.decoder.end();
          if (completedTasks && completedTasks.length) {
            _handlePendingTasks.buffer.push(completedTasks);
            if (_handlePendingTasks.objectMode) {
              _handlePendingTasks.length += 1;
            } else {
              _handlePendingTasks.length += completedTasks.length;
            }
          }
        }
        _handlePendingTasks.ended = true;
        if (_handlePendingTasks.sync) {
          _processReadableStream(processPendingDataTasks);
        } else {
          _handlePendingTasks.needReadable = false;
          _handlePendingTasks.emittedReadable = true;
          handleReadableStreamForValidation(processPendingDataTasks);
        }
      }
    }
    function _processReadableStream(queueTaskForProcessing) {
      let ______________readableStreamState =
        queueTaskForProcessing._readableState;
      initializeStreamOptionsHandler(
        "emitReadable",
        ______________readableStreamState.needReadable,
        ______________readableStreamState.emittedReadable,
      );
      ______________readableStreamState.needReadable = false;
      if (!______________readableStreamState.emittedReadable) {
        initializeStreamOptionsHandler(
          "emitReadable",
          ______________readableStreamState.flowing,
        );
        ______________readableStreamState.emittedReadable = true;
        _isSemVerRangeValid.nextTick(
          handleReadableStreamForValidation,
          queueTaskForProcessing,
        );
      }
    }
    function handleReadableStreamForValidation(
      initializeStreamHandlerForValidation,
    ) {
      let streamReadableState =
        initializeStreamHandlerForValidation._readableState;
      initializeStreamOptionsHandler(
        "emitReadable_",
        streamReadableState.destroyed,
        streamReadableState.length,
        streamReadableState.ended,
      );
      if (
        !streamReadableState.destroyed &&
        !streamReadableState.errored &&
        (streamReadableState.length || streamReadableState.ended)
      ) {
        initializeStreamHandlerForValidation.emit("readable");
        streamReadableState.emittedReadable = false;
      }
      streamReadableState.needReadable =
        !streamReadableState.flowing &&
        !streamReadableState.ended &&
        streamReadableState.length <= streamReadableState.highWaterMark;
      processReadableStream(initializeStreamHandlerForValidation);
    }
    function handleStreamProcessing(
      isStreamNodeRemovableFlag,
      validateStreamBufferConstraints,
    ) {
      if (
        !validateStreamBufferConstraints.readingMore &&
        validateStreamBufferConstraints.constructed
      ) {
        validateStreamBufferConstraints.readingMore = true;
        _isSemVerRangeValid.nextTick(
          handleCharacterStreamReading,
          isStreamNodeRemovableFlag,
          validateStreamBufferConstraints,
        );
      }
    }
    function handleCharacterStreamReading(
      determineStreamBufferLength,
      determineLengthOfStreamWithConstraints,
    ) {
      while (
        !determineLengthOfStreamWithConstraints.reading &&
        !determineLengthOfStreamWithConstraints.ended &&
        (determineLengthOfStreamWithConstraints.length <
          determineLengthOfStreamWithConstraints.highWaterMark ||
          (determineLengthOfStreamWithConstraints.flowing &&
            determineLengthOfStreamWithConstraints.length === 0))
      ) {
        let defaultStreamCharacterLength =
          determineLengthOfStreamWithConstraints.length;
        initializeStreamOptionsHandler("maybeReadMore read 0");
        determineStreamBufferLength.read(0);
        if (
          defaultStreamCharacterLength ===
          determineLengthOfStreamWithConstraints.length
        ) {
          break;
        }
      }
      determineLengthOfStreamWithConstraints.readingMore = false;
    }
    StreamRangeValidator.prototype._read = function (
      validateAndProcessInputCharacterEncoding,
    ) {
      throw new initializeStreamHandlerBasedOnUsage("_read()");
    };
    StreamRangeValidator.prototype.pipe = function (
      validateAndAdjustStreamConstraints,
      initializeStreamEventListenerBindings,
    ) {
      let streamHandlerContext = this;
      let _readableStreamState = this._readableState;
      if (_readableStreamState.pipes.length === 1) {
        if (!_readableStreamState.multiAwaitDrain) {
          _readableStreamState.multiAwaitDrain = true;
          _readableStreamState.awaitDrainWriters = new SafeSetHandler(
            _readableStreamState.awaitDrainWriters
              ? [_readableStreamState.awaitDrainWriters]
              : [],
          );
        }
      }
      _readableStreamState.pipes.push(validateAndAdjustStreamConstraints);
      initializeStreamOptionsHandler(
        "pipe count=%d opts=%j",
        _readableStreamState.pipes.length,
        initializeStreamEventListenerBindings,
      );
      let handleStreamTerminationCondition =
        (!initializeStreamEventListenerBindings ||
          initializeStreamEventListenerBindings.end !== false) &&
        validateAndAdjustStreamConstraints !== _isSemVerRangeValid.stdout &&
        validateAndAdjustStreamConstraints !== _isSemVerRangeValid.stderr
          ? handleStreamTermination
          : handleStreamUnpiping;
      if (_readableStreamState.endEmitted) {
        _isSemVerRangeValid.nextTick(handleStreamTerminationCondition);
      } else {
        streamHandlerContext.once("end", handleStreamTerminationCondition);
      }
      validateAndAdjustStreamConstraints.on(
        "unpipe",
        handleReadableStreamUnpipeEvent,
      );
      function handleReadableStreamUnpipeEvent(
        validateReadableStreamConstraints,
        isValidReadableStream,
      ) {
        initializeStreamOptionsHandler("onunpipe");
        if (
          validateReadableStreamConstraints === streamHandlerContext &&
          isValidReadableStream &&
          isValidReadableStream.hasUnpiped === false
        ) {
          isValidReadableStream.hasUnpiped = true;
          cleanupStreamHandlers();
        }
      }
      function handleStreamTermination() {
        initializeStreamOptionsHandler("onend");
        validateAndAdjustStreamConstraints.end();
      }
      let processStreamPipingAndTermination;
      let handleStreamPipeManagement = false;
      function cleanupStreamHandlers() {
        initializeStreamOptionsHandler("cleanup");
        validateAndAdjustStreamConstraints.removeListener(
          "close",
          detachFinishListenerAndHandleStreamEncoding,
        );
        validateAndAdjustStreamConstraints.removeListener(
          "finish",
          handleStreamCompletion,
        );
        if (processStreamPipingAndTermination) {
          validateAndAdjustStreamConstraints.removeListener(
            "drain",
            processStreamPipingAndTermination,
          );
        }
        validateAndAdjustStreamConstraints.removeListener(
          "error",
          handleStreamErrorForCompatibilityCheck,
        );
        validateAndAdjustStreamConstraints.removeListener(
          "unpipe",
          handleReadableStreamUnpipeEvent,
        );
        streamHandlerContext.removeListener("end", handleStreamTermination);
        streamHandlerContext.removeListener("end", handleStreamUnpiping);
        streamHandlerContext.removeListener("data", ____processStreamData);
        handleStreamPipeManagement = true;
        if (
          processStreamPipingAndTermination &&
          _readableStreamState.awaitDrainWriters &&
          (!validateAndAdjustStreamConstraints._writableState ||
            validateAndAdjustStreamConstraints._writableState.needDrain)
        ) {
          processStreamPipingAndTermination();
        }
      }
      function manageCharacterEncodingInStream() {
        if (!handleStreamPipeManagement) {
          if (
            _readableStreamState.pipes.length === 1 &&
            _readableStreamState.pipes[0] === validateAndAdjustStreamConstraints
          ) {
            initializeStreamOptionsHandler("false write response, pause", 0);
            _readableStreamState.awaitDrainWriters =
              validateAndAdjustStreamConstraints;
            _readableStreamState.multiAwaitDrain = false;
          } else if (
            _readableStreamState.pipes.length > 1 &&
            _readableStreamState.pipes.includes(
              validateAndAdjustStreamConstraints,
            )
          ) {
            initializeStreamOptionsHandler(
              "false write response, pause",
              _readableStreamState.awaitDrainWriters.size,
            );
            _readableStreamState.awaitDrainWriters.add(
              validateAndAdjustStreamConstraints,
            );
          }
          streamHandlerContext.pause();
        }
        if (!processStreamPipingAndTermination) {
          processStreamPipingAndTermination = processStreamDrainEvent(
            streamHandlerContext,
            validateAndAdjustStreamConstraints,
          );
          validateAndAdjustStreamConstraints.on(
            "drain",
            processStreamPipingAndTermination,
          );
        }
      }
      streamHandlerContext.on("data", ____processStreamData);
      function ____processStreamData(checkIfStreamDataObject) {
        initializeStreamOptionsHandler("ondata");
        let processedCharacterEncodingForStream =
          validateAndAdjustStreamConstraints.write(checkIfStreamDataObject);
        initializeStreamOptionsHandler(
          "dest.write",
          processedCharacterEncodingForStream,
        );
        if (processedCharacterEncodingForStream === false) {
          manageCharacterEncodingInStream();
        }
      }
      function handleStreamErrorForCompatibilityCheck(
        isCompatibleVersionCheck,
      ) {
        initializeStreamOptionsHandler("onerror", isCompatibleVersionCheck);
        handleStreamUnpiping();
        validateAndAdjustStreamConstraints.removeListener(
          "error",
          handleStreamErrorForCompatibilityCheck,
        );
        if (validateAndAdjustStreamConstraints.listenerCount("error") === 0) {
          let currentStreamEncodingState =
            validateAndAdjustStreamConstraints._writableState ||
            validateAndAdjustStreamConstraints._readableState;
          if (
            currentStreamEncodingState &&
            !currentStreamEncodingState.errorEmitted
          ) {
            ___initializeStreamEventHandlers(
              validateAndAdjustStreamConstraints,
              isCompatibleVersionCheck,
            );
          } else {
            validateAndAdjustStreamConstraints.emit(
              "error",
              isCompatibleVersionCheck,
            );
          }
        }
      }
      addStreamListenerAtBeginning(
        validateAndAdjustStreamConstraints,
        "error",
        handleStreamErrorForCompatibilityCheck,
      );
      function detachFinishListenerAndHandleStreamEncoding() {
        validateAndAdjustStreamConstraints.removeListener(
          "finish",
          handleStreamCompletion,
        );
        handleStreamUnpiping();
      }
      validateAndAdjustStreamConstraints.once(
        "close",
        detachFinishListenerAndHandleStreamEncoding,
      );
      function handleStreamCompletion() {
        initializeStreamOptionsHandler("onfinish");
        validateAndAdjustStreamConstraints.removeListener(
          "close",
          detachFinishListenerAndHandleStreamEncoding,
        );
        handleStreamUnpiping();
      }
      validateAndAdjustStreamConstraints.once("finish", handleStreamCompletion);
      function handleStreamUnpiping() {
        initializeStreamOptionsHandler("unpipe");
        streamHandlerContext.unpipe(validateAndAdjustStreamConstraints);
      }
      validateAndAdjustStreamConstraints.emit("pipe", streamHandlerContext);
      if (validateAndAdjustStreamConstraints.writableNeedDrain === true) {
        if (_readableStreamState.flowing) {
          manageCharacterEncodingInStream();
        }
      } else if (!_readableStreamState.flowing) {
        initializeStreamOptionsHandler("pipe resume");
        streamHandlerContext.resume();
      }
      return validateAndAdjustStreamConstraints;
    };
    function processStreamDrainEvent(
      isStreamBufferValid,
      isStreamProcessingComplete,
    ) {
      return function () {
        let ___________readableStreamState = isStreamBufferValid._readableState;
        if (
          ___________readableStreamState.awaitDrainWriters ===
          isStreamProcessingComplete
        ) {
          initializeStreamOptionsHandler("pipeOnDrain", 1);
          ___________readableStreamState.awaitDrainWriters = null;
        } else if (___________readableStreamState.multiAwaitDrain) {
          initializeStreamOptionsHandler(
            "pipeOnDrain",
            ___________readableStreamState.awaitDrainWriters.size,
          );
          ___________readableStreamState.awaitDrainWriters.delete(
            isStreamProcessingComplete,
          );
        }
        if (
          (!___________readableStreamState.awaitDrainWriters ||
            ___________readableStreamState.awaitDrainWriters.size === 0) &&
          isStreamBufferValid.listenerCount("data")
        ) {
          isStreamBufferValid.resume();
        }
      };
    }
    StreamRangeValidator.prototype.unpipe = function (hasStreamEnded) {
      let _______readableStreamState = this._readableState;
      let unpipeEventStatus = {
        hasUnpiped: false,
      };
      if (_______readableStreamState.pipes.length === 0) {
        return this;
      }
      if (!hasStreamEnded) {
        let connectedPipes = _______readableStreamState.pipes;
        _______readableStreamState.pipes = [];
        this.pause();
        for (
          let currentPipeIndex = 0;
          currentPipeIndex < connectedPipes.length;
          currentPipeIndex++
        ) {
          connectedPipes[currentPipeIndex].emit("unpipe", this, {
            hasUnpiped: false,
          });
        }
        return this;
      }
      let getPipeIndexByStream = ArrayPrototypeIndexOfElement(
        _______readableStreamState.pipes,
        hasStreamEnded,
      );
      if (getPipeIndexByStream === -1) {
        return this;
      } else {
        _______readableStreamState.pipes.splice(getPipeIndexByStream, 1);
        if (_______readableStreamState.pipes.length === 0) {
          this.pause();
        }
        hasStreamEnded.emit("unpipe", this, unpipeEventStatus);
        return this;
      }
    };
    StreamRangeValidator.prototype.on = function (
      isValidWritableStreamRangeParser,
      hasPatchVersionConcluded,
    ) {
      let parsedReadableStreamData = StreamProcessor.prototype.on.call(
        this,
        isValidWritableStreamRangeParser,
        hasPatchVersionConcluded,
      );
      let currentReadableState = this._readableState;
      if (isValidWritableStreamRangeParser === "data") {
        currentReadableState.readableListening =
          this.listenerCount("readable") > 0;
        if (currentReadableState.flowing !== false) {
          this.resume();
        }
      } else if (
        isValidWritableStreamRangeParser === "readable" &&
        !currentReadableState.endEmitted &&
        !currentReadableState.readableListening
      ) {
        currentReadableState.readableListening =
          currentReadableState.needReadable = true;
        currentReadableState.flowing = false;
        currentReadableState.emittedReadable = false;
        initializeStreamOptionsHandler(
          "on readable",
          currentReadableState.length,
          currentReadableState.reading,
        );
        if (currentReadableState.length) {
          _processReadableStream(this);
        } else if (!currentReadableState.reading) {
          _isSemVerRangeValid.nextTick(
            processReadableStreamWithErrorHandling,
            this,
          );
        }
      }
      return parsedReadableStreamData;
    };
    StreamRangeValidator.prototype.addListener =
      StreamRangeValidator.prototype.on;
    StreamRangeValidator.prototype.removeListener = function (
      areStreamHandlersActive,
      _isWritableVersionRangeValid,
    ) {
      let handleStreamListenerAndFlowStatus =
        StreamProcessor.prototype.removeListener.call(
          this,
          areStreamHandlersActive,
          _isWritableVersionRangeValid,
        );
      if (areStreamHandlersActive === "readable") {
        _isSemVerRangeValid.nextTick(manageStreamFlowListeningStatus, this);
      }
      return handleStreamListenerAndFlowStatus;
    };
    StreamRangeValidator.prototype.off =
      StreamRangeValidator.prototype.removeListener;
    StreamRangeValidator.prototype.removeAllListeners = function (
      handleStreamCharacterEncoding,
    ) {
      let removedEventListenersResult =
        StreamProcessor.prototype.removeAllListeners.apply(this, arguments);
      if (
        handleStreamCharacterEncoding === "readable" ||
        handleStreamCharacterEncoding === undefined
      ) {
        _isSemVerRangeValid.nextTick(manageStreamFlowListeningStatus, this);
      }
      return removedEventListenersResult;
    };
    function manageStreamFlowListeningStatus(handleWritableErrors) {
      let __readableState = handleWritableErrors._readableState;
      __readableState.readableListening =
        handleWritableErrors.listenerCount("readable") > 0;
      if (
        __readableState.resumeScheduled &&
        __readableState[__initializeStreamHandler] === false
      ) {
        __readableState.flowing = true;
      } else if (handleWritableErrors.listenerCount("data") > 0) {
        handleWritableErrors.resume();
      } else if (!__readableState.readableListening) {
        __readableState.flowing = null;
      }
    }
    function processReadableStreamWithErrorHandling(
      handleStreamDataProcessing,
    ) {
      initializeStreamOptionsHandler("readable nexttick read 0");
      handleStreamDataProcessing.read(0);
    }
    StreamRangeValidator.prototype.resume = function () {
      let __________________readableStreamState = this._readableState;
      if (!__________________readableStreamState.flowing) {
        initializeStreamOptionsHandler("resume");
        __________________readableStreamState.flowing =
          !__________________readableStreamState.readableListening;
        prepareStreamResume(this, __________________readableStreamState);
      }
      __________________readableStreamState[__initializeStreamHandler] = false;
      return this;
    };
    function prepareStreamResume(
      isStreamVersionAdjustmentComplete,
      isStreamUpdateVersionConstraintsComplete,
    ) {
      if (!isStreamUpdateVersionConstraintsComplete.resumeScheduled) {
        isStreamUpdateVersionConstraintsComplete.resumeScheduled = true;
        _isSemVerRangeValid.nextTick(
          processStreamResume,
          isStreamVersionAdjustmentComplete,
          isStreamUpdateVersionConstraintsComplete,
        );
      }
    }
    function processStreamResume(
      isStreamDataCompatible,
      handleVersionCompatibilityError,
    ) {
      initializeStreamOptionsHandler(
        "resume",
        handleVersionCompatibilityError.reading,
      );
      if (!handleVersionCompatibilityError.reading) {
        isStreamDataCompatible.read(0);
      }
      handleVersionCompatibilityError.resumeScheduled = false;
      isStreamDataCompatible.emit("resume");
      processReadableStream(isStreamDataCompatible);
      if (
        handleVersionCompatibilityError.flowing &&
        !handleVersionCompatibilityError.reading
      ) {
        isStreamDataCompatible.read(0);
      }
    }
    StreamRangeValidator.prototype.pause = function () {
      initializeStreamOptionsHandler(
        "call pause flowing=%j",
        this._readableState.flowing,
      );
      if (this._readableState.flowing !== false) {
        initializeStreamOptionsHandler("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[__initializeStreamHandler] = true;
      return this;
    };
    function processReadableStream(
      validateAndAdjustStreamForVersionCompatibility,
    ) {
      let ___readableStreamState =
        validateAndAdjustStreamForVersionCompatibility._readableState;
      for (
        initializeStreamOptionsHandler("flow", ___readableStreamState.flowing);
        ___readableStreamState.flowing &&
        validateAndAdjustStreamForVersionCompatibility.read() !== null;

      ) {}
    }
    StreamRangeValidator.prototype.wrap = function (isStreamActiveOrClosed) {
      let streamIsPaused = false;
      isStreamActiveOrClosed.on("data", (itemToAddToStream) => {
        if (!this.push(itemToAddToStream) && isStreamActiveOrClosed.pause) {
          streamIsPaused = true;
          isStreamActiveOrClosed.pause();
        }
      });
      isStreamActiveOrClosed.on("end", () => {
        this.push(null);
      });
      isStreamActiveOrClosed.on("error", (initializeEventStreamHandler) => {
        ___initializeStreamEventHandlers(this, initializeEventStreamHandler);
      });
      isStreamActiveOrClosed.on("close", () => {
        this.destroy();
      });
      isStreamActiveOrClosed.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (streamIsPaused && isStreamActiveOrClosed.resume) {
          streamIsPaused = false;
          isStreamActiveOrClosed.resume();
        }
      };
      let getStreamMethodsAsArray = getObjectKeysAsArray(
        isStreamActiveOrClosed,
      );
      for (
        let methodArrayIndex = 1;
        methodArrayIndex < getStreamMethodsAsArray.length;
        methodArrayIndex++
      ) {
        let streamMethod = getStreamMethodsAsArray[methodArrayIndex];
        if (
          this[streamMethod] === undefined &&
          typeof isStreamActiveOrClosed[streamMethod] == "function"
        ) {
          this[streamMethod] = isStreamActiveOrClosed[streamMethod].bind(
            isStreamActiveOrClosed,
          );
        }
      }
      return this;
    };
    StreamRangeValidator.prototype[AsyncIterableSymbol] = function () {
      return createStreamLifecycleValidator(this);
    };
    StreamRangeValidator.prototype.iterator = function (
      _isStreamProcessingComplete,
    ) {
      if (_isStreamProcessingComplete !== undefined) {
        _initializeStreamHandler(_isStreamProcessingComplete, "options");
      }
      return createStreamLifecycleValidator(this, _isStreamProcessingComplete);
    };
    function createStreamLifecycleValidator(
      validateStreamReadabilityOrWritability,
      validateReadableStreamErrors,
    ) {
      if (typeof validateStreamReadabilityOrWritability.read != "function") {
        validateStreamReadabilityOrWritability = StreamRangeValidator.wrap(
          validateStreamReadabilityOrWritability,
          {
            objectMode: true,
          },
        );
      }
      let streamLifecycleValidator =
        asyncFunctionHandleStreamLifecycleValidateSemanticVersionPrereleaseHandleStreamUnpipe(
          validateStreamReadabilityOrWritability,
          validateReadableStreamErrors,
        );
      streamLifecycleValidator.stream = validateStreamReadabilityOrWritability;
      return streamLifecycleValidator;
    }
    async function* asyncFunctionHandleStreamLifecycleValidateSemanticVersionPrereleaseHandleStreamUnpipe(
      validateSemanticVersionPrerelease,
      handleStreamUnpipe,
    ) {
      let manageStreamStatus = setupStreamHandling;
      function updateStreamStatusBasedOnValidation(validateSemverPrerelease) {
        if (this === validateSemanticVersionPrerelease) {
          manageStreamStatus();
          manageStreamStatus = setupStreamHandling;
        } else {
          manageStreamStatus = validateSemverPrerelease;
        }
      }
      validateSemanticVersionPrerelease.on(
        "readable",
        updateStreamStatusBasedOnValidation,
      );
      let streamErrorHandler;
      let streamHandlerSetup = setupAndValidateStreamHandler(
        validateSemanticVersionPrerelease,
        {
          writable: false,
        },
        (isStreamHandlerInitialized) => {
          if (isStreamHandlerInitialized) {
            streamErrorHandler = initializeStreamEventHandlers(
              streamErrorHandler,
              isStreamHandlerInitialized,
            );
          } else {
            streamErrorHandler = null;
          }
          manageStreamStatus();
          manageStreamStatus = setupStreamHandling;
        },
      );
      try {
        while (true) {
          let prereleaseVersionData =
            validateSemanticVersionPrerelease.destroyed
              ? null
              : validateSemanticVersionPrerelease.read();
          if (prereleaseVersionData !== null) {
            yield prereleaseVersionData;
          } else {
            if (streamErrorHandler) {
              throw streamErrorHandler;
            }
            if (streamErrorHandler === null) {
              return;
            }
            await new PromiseHandler(updateStreamStatusBasedOnValidation);
          }
        }
      } catch (errorHandlingCallback) {
        streamErrorHandler = initializeStreamEventHandlers(
          streamErrorHandler,
          errorHandlingCallback,
        );
        throw streamErrorHandler;
      } finally {
        if (
          (streamErrorHandler ||
            handleStreamUnpipe?.destroyOnReturn !== false) &&
          (streamErrorHandler === undefined ||
            validateSemanticVersionPrerelease._readableState.autoDestroy)
        ) {
          setupStreamHandlerWithValidation.destroyer(
            validateSemanticVersionPrerelease,
            null,
          );
        } else {
          validateSemanticVersionPrerelease.off(
            "readable",
            updateStreamStatusBasedOnValidation,
          );
          streamHandlerSetup();
        }
      }
    }
    defineObjectPropertiesWithAttributes(StreamRangeValidator.prototype, {
      readable: {
        __proto__: null,
        get() {
          let isStreamReadable = this._readableState;
          return (
            !!isStreamReadable &&
            isStreamReadable.readable !== false &&
            !isStreamReadable.destroyed &&
            !isStreamReadable.errorEmitted &&
            !isStreamReadable.endEmitted
          );
        },
        set(updateReadableState) {
          if (this._readableState) {
            this._readableState.readable = !!updateReadableState;
          }
        },
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.dataEmitted;
        },
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get() {
          return (
            this._readableState.readable !== false &&
            (!!this._readableState.destroyed ||
              !!this._readableState.errored) &&
            !this._readableState.endEmitted
          );
        },
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.highWaterMark;
        },
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState && this._readableState.buffer;
        },
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.flowing;
        },
        set(updateFlowingState) {
          if (this._readableState) {
            this._readableState.flowing = updateFlowingState;
          }
        },
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        },
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          if (this._readableState) {
            return this._readableState.objectMode;
          } else {
            return false;
          }
        },
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          if (this._readableState) {
            return this._readableState.encoding;
          } else {
            return null;
          }
        },
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          if (this._readableState) {
            return this._readableState.errored;
          } else {
            return null;
          }
        },
      },
      closed: {
        __proto__: null,
        get() {
          if (this._readableState) {
            return this._readableState.closed;
          } else {
            return false;
          }
        },
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          if (this._readableState) {
            return this._readableState.destroyed;
          } else {
            return false;
          }
        },
        set(updateReadableStateDestructionStatus) {
          if (this._readableState) {
            this._readableState.destroyed =
              updateReadableStateDestructionStatus;
          }
        },
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          if (this._readableState) {
            return this._readableState.endEmitted;
          } else {
            return false;
          }
        },
      },
    });
    defineObjectPropertiesWithAttributes(
      setupStreamOptionsForProcessing.prototype,
      {
        pipesCount: {
          __proto__: null,
          get() {
            return this.pipes.length;
          },
        },
        paused: {
          __proto__: null,
          get() {
            return this[__initializeStreamHandler] !== false;
          },
          set(isStreamHandlerInitialized) {
            this[__initializeStreamHandler] = !!isStreamHandlerInitialized;
          },
        },
      },
    );
    StreamRangeValidator._fromList = _handleStreamDataProcessing;
    function _handleStreamDataProcessing(
      processStreamData,
      handleStreamDataEventHandlers,
    ) {
      if (handleStreamDataEventHandlers.length === 0) {
        return null;
      }
      let _extractedStreamData;
      if (handleStreamDataEventHandlers.objectMode) {
        _extractedStreamData = handleStreamDataEventHandlers.buffer.shift();
      } else if (
        !processStreamData ||
        processStreamData >= handleStreamDataEventHandlers.length
      ) {
        if (handleStreamDataEventHandlers.decoder) {
          _extractedStreamData = handleStreamDataEventHandlers.buffer.join("");
        } else if (handleStreamDataEventHandlers.buffer.length === 1) {
          _extractedStreamData = handleStreamDataEventHandlers.buffer.first();
        } else {
          _extractedStreamData = handleStreamDataEventHandlers.buffer.concat(
            handleStreamDataEventHandlers.length,
          );
        }
        handleStreamDataEventHandlers.buffer.clear();
      } else {
        _extractedStreamData = handleStreamDataEventHandlers.buffer.consume(
          processStreamData,
          handleStreamDataEventHandlers.decoder,
        );
      }
      return _extractedStreamData;
    }
    function processStreamEndEvent(handleStreamCompletion) {
      let _________________readableStreamState =
        handleStreamCompletion._readableState;
      initializeStreamOptionsHandler(
        "endReadable",
        _________________readableStreamState.endEmitted,
      );
      if (!_________________readableStreamState.endEmitted) {
        _________________readableStreamState.ended = true;
        _isSemVerRangeValid.nextTick(
          handleStreamEndingAndErrors,
          _________________readableStreamState,
          handleStreamCompletion,
        );
      }
    }
    function handleStreamEndingAndErrors(
      processStreamErrors,
      initializeStreamProcessingHandler,
    ) {
      initializeStreamOptionsHandler(
        "endReadableNT",
        processStreamErrors.endEmitted,
        processStreamErrors.length,
      );
      if (
        !processStreamErrors.errored &&
        !processStreamErrors.closeEmitted &&
        !processStreamErrors.endEmitted &&
        processStreamErrors.length === 0
      ) {
        processStreamErrors.endEmitted = true;
        initializeStreamProcessingHandler.emit("end");
        if (
          initializeStreamProcessingHandler.writable &&
          initializeStreamProcessingHandler.allowHalfOpen === false
        ) {
          _isSemVerRangeValid.nextTick(
            terminateStreamIfWritable,
            initializeStreamProcessingHandler,
          );
        } else if (processStreamErrors.autoDestroy) {
          let _______________writableStreamState =
            initializeStreamProcessingHandler._writableState;
          if (
            !_______________writableStreamState ||
            (_______________writableStreamState.autoDestroy &&
              (_______________writableStreamState.finished ||
                _______________writableStreamState.writable === false))
          ) {
            initializeStreamProcessingHandler.destroy();
          }
        }
      }
    }
    function terminateStreamIfWritable(resetStreamHandlerOnEvent) {
      if (
        resetStreamHandlerOnEvent.writable &&
        !resetStreamHandlerOnEvent.writableEnded &&
        !resetStreamHandlerOnEvent.destroyed
      ) {
        resetStreamHandlerOnEvent.end();
      }
    }
    StreamRangeValidator.from = function (
      cleanupStreamHandlers,
      stopProcessingStreamListeners,
    ) {
      return ___initializeStreamHandler(
        StreamRangeValidator,
        cleanupStreamHandlers,
        stopProcessingStreamListeners,
      );
    };
    var setupStreamHandlerWithValidations;
    function initializeStreamHandlerIfNeeded() {
      if (setupStreamHandlerWithValidations === undefined) {
        setupStreamHandlerWithValidations = {};
      }
      return setupStreamHandlerWithValidations;
    }
    StreamRangeValidator.fromWeb = function (
      handleStreamCompleteListener,
      initializeAndHandleStreamError,
    ) {
      return initializeStreamHandlerIfNeeded().newStreamReadableFromReadableStream(
        handleStreamCompleteListener,
        initializeAndHandleStreamError,
      );
    };
    StreamRangeValidator.toWeb = function (
      clearEventListenersAfterCompletion,
      cleanupProcessListeners,
    ) {
      return initializeStreamHandlerIfNeeded().newReadableStreamFromStreamReadable(
        clearEventListenersAfterCompletion,
        cleanupProcessListeners,
      );
    };
    StreamRangeValidator.wrap = function (
      handleSignalAndErrorDuringStreamProcessing,
      handleStreamErrorAndCleanup,
    ) {
      return new StreamRangeValidator({
        objectMode:
          handleSignalAndErrorDuringStreamProcessing.readableObjectMode ??
          handleSignalAndErrorDuringStreamProcessing.objectMode ??
          true,
        ...handleStreamErrorAndCleanup,
        destroy(_streamCleanupHandler, cleanupAfterStreamTermination) {
          setupStreamHandlerWithValidation.destroyer(
            handleSignalAndErrorDuringStreamProcessing,
            _streamCleanupHandler,
          );
          cleanupAfterStreamTermination(_streamCleanupHandler);
        },
      }).wrap(handleSignalAndErrorDuringStreamProcessing);
    };
  },
);
var ___validateAndRetrieveStreamProperties = lazyModuleInitializer(
  (validateAndExportModuleStream, exportedStreamHandlerModule) => {
    var isSemanticVersionRangeValid = isSemVerRangeValid();
    var {
      ArrayPrototypeSlice: ArrayElementsExtractor,
      Error: _StreamErrorHandler,
      FunctionPrototypeSymbolHasInstance: isFunctionInstanceCheck,
      ObjectDefineProperty: defineObjectPropertyWithAttributes,
      ObjectDefineProperties: _defineObjectPropertiesWithAttributes,
      ObjectSetPrototypeOf: initializeObjectPrototype,
      StringPrototypeToLowerCase: stringToLowerCase,
      Symbol: createUniqueSymbol,
      SymbolHasInstance: isSymbolType,
    } = performComparisonOperation();
    exportedStreamHandlerModule.exports = StreamEventProcessor;
    StreamEventProcessor.WritableState = configureStreamSettings;
    var { EventEmitter: _StreamEventEmitter } = resetStreamConstructionStates();
    var extractedStreamData = processTarFileListenerArray().Stream;
    retrieveAndValidateIntrinsicPropertyValue();
    var { Buffer: DataBuffer } = defineESModuleWithProperties(
      intrinsicPropertiesManager,
    );
    var validateAndExportVersionedData =
      processVersionValidationAndAbortSignals();
    var { addAbortSignal: attachAbortControllerSignal } =
      handleErrorAndVersionComparison();
    var {
      getHighWaterMark: validateAndExportStreamModules,
      getDefaultHighWaterMark: _validateAndExportModuleStream,
    } = getErrorStackTrace();
    var {
      ERR_INVALID_ARG_TYPE: _isSemanticVersionRangeValid,
      ERR_METHOD_NOT_IMPLEMENTED: _validateSemanticVersionRange,
      ERR_MULTIPLE_CALLBACK: _validateAndExportStreamModules,
      ERR_STREAM_CANNOT_PIPE: __isSemanticVersionRangeValid,
      ERR_STREAM_DESTROYED: ___isSemanticVersionRangeValid,
      ERR_STREAM_ALREADY_FINISHED: __validateAndExportStreamModules,
      ERR_STREAM_NULL_VALUES: __validateAndRetrieveIntrinsicPropertyValue,
      ERR_STREAM_WRITE_AFTER_END: __validateAndExportModuleStream,
      ERR_UNKNOWN_ENCODING: ____isSemanticVersionRangeValid,
    } = fetchNodeValuePostTraversal().codes;
    var { errorOrDestroy: validateAndExportModules } =
      validateAndExportVersionedData;
    initializeObjectPrototype(
      StreamEventProcessor.prototype,
      extractedStreamData.prototype,
    );
    initializeObjectPrototype(StreamEventProcessor, extractedStreamData);
    function setupApplication() {}
    var ___validateAndExportStreamModules = createUniqueSymbol("kOnFinished");
    function configureStreamSettings(
      validateAndRetrieveProperties,
      getReadableStateIntrinsicProperties,
      getReadableStateProperties,
    ) {
      if (typeof getReadableStateProperties != "boolean") {
        getReadableStateProperties =
          getReadableStateIntrinsicProperties instanceof
          setupStreamEventHandlers();
      }
      this.objectMode =
        !!validateAndRetrieveProperties &&
        !!validateAndRetrieveProperties.objectMode;
      if (getReadableStateProperties) {
        this.objectMode =
          this.objectMode ||
          (!!validateAndRetrieveProperties &&
            !!validateAndRetrieveProperties.writableObjectMode);
      }
      if (validateAndRetrieveProperties) {
        this.highWaterMark = validateAndExportStreamModules(
          this,
          validateAndRetrieveProperties,
          "writableHighWaterMark",
          getReadableStateProperties,
        );
      } else {
        this.highWaterMark = _validateAndExportModuleStream(false);
      }
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      let shouldDetermineMaxAgeSettingsUpdate =
        !!validateAndRetrieveProperties &&
        validateAndRetrieveProperties.decodeStrings === false;
      this.decodeStrings = !shouldDetermineMaxAgeSettingsUpdate;
      this.defaultEncoding =
        (validateAndRetrieveProperties &&
          validateAndRetrieveProperties.defaultEncoding) ||
        "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = handleStreamDefaultReturnValue.bind(
        undefined,
        getReadableStateIntrinsicProperties,
      );
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      setupProcessStreamBuffering(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose =
        !validateAndRetrieveProperties ||
        validateAndRetrieveProperties.emitClose !== false;
      this.autoDestroy =
        !validateAndRetrieveProperties ||
        validateAndRetrieveProperties.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[___validateAndExportStreamModules] = [];
    }
    function setupProcessStreamBuffering(_processStreamData) {
      _processStreamData.buffered = [];
      _processStreamData.bufferedIndex = 0;
      _processStreamData.allBuffers = true;
      _processStreamData.allNoop = true;
    }
    configureStreamSettings.prototype.getBuffer = function () {
      return ArrayElementsExtractor(this.buffered, this.bufferedIndex);
    };
    defineObjectPropertyWithAttributes(
      configureStreamSettings.prototype,
      "bufferedRequestCount",
      {
        __proto__: null,
        get() {
          return this.buffered.length - this.bufferedIndex;
        },
      },
    );
    function StreamEventProcessor(__handleAbortSignal) {
      let isStreamEventHandlersInitialized =
        this instanceof setupStreamEventHandlers();
      if (
        !isStreamEventHandlersInitialized &&
        !isFunctionInstanceCheck(StreamEventProcessor, this)
      ) {
        return new StreamEventProcessor(__handleAbortSignal);
      }
      this._writableState = new configureStreamSettings(
        __handleAbortSignal,
        this,
        isStreamEventHandlersInitialized,
      );
      if (__handleAbortSignal) {
        if (typeof __handleAbortSignal.write == "function") {
          this._write = __handleAbortSignal.write;
        }
        if (typeof __handleAbortSignal.writev == "function") {
          this._writev = __handleAbortSignal.writev;
        }
        if (typeof __handleAbortSignal.destroy == "function") {
          this._destroy = __handleAbortSignal.destroy;
        }
        if (typeof __handleAbortSignal.final == "function") {
          this._final = __handleAbortSignal.final;
        }
        if (typeof __handleAbortSignal.construct == "function") {
          this._construct = __handleAbortSignal.construct;
        }
        if (__handleAbortSignal.signal) {
          attachAbortControllerSignal(__handleAbortSignal.signal, this);
        }
      }
      extractedStreamData.call(this, __handleAbortSignal);
      validateAndExportVersionedData.construct(this, () => {
        let ___currentWritableState = this._writableState;
        if (!___currentWritableState.writing) {
          handleBufferedCharacterSegments(this, ___currentWritableState);
        }
        processAndCompareStreamVersionOperators(this, ___currentWritableState);
      });
    }
    defineObjectPropertyWithAttributes(StreamEventProcessor, isSymbolType, {
      __proto__: null,
      value(isStreamSettingsInitialized) {
        if (isFunctionInstanceCheck(this, isStreamSettingsInitialized)) {
          return true;
        } else if (this !== StreamEventProcessor) {
          return false;
        } else {
          return (
            isStreamSettingsInitialized &&
            isStreamSettingsInitialized._writableState instanceof
              configureStreamSettings
          );
        }
      },
    });
    StreamEventProcessor.prototype.pipe = function () {
      validateAndExportModules(this, new __isSemanticVersionRangeValid());
    };
    function _validateAndInitializeStreamProcessing(
      handleStreamProcessingAndErrorHandling,
      initializeStreamWithValidations,
      _initializeStreamProcessingHandler,
      handleStreamErrorsAndEnqueue,
    ) {
      let ___writableStreamState =
        handleStreamProcessingAndErrorHandling._writableState;
      if (typeof _initializeStreamProcessingHandler == "function") {
        handleStreamErrorsAndEnqueue = _initializeStreamProcessingHandler;
        _initializeStreamProcessingHandler =
          ___writableStreamState.defaultEncoding;
      } else {
        if (!_initializeStreamProcessingHandler) {
          _initializeStreamProcessingHandler =
            ___writableStreamState.defaultEncoding;
        } else if (
          _initializeStreamProcessingHandler !== "buffer" &&
          !DataBuffer.isEncoding(_initializeStreamProcessingHandler)
        ) {
          throw new ____isSemanticVersionRangeValid(
            _initializeStreamProcessingHandler,
          );
        }
        if (typeof handleStreamErrorsAndEnqueue != "function") {
          handleStreamErrorsAndEnqueue = setupApplication;
        }
      }
      if (initializeStreamWithValidations === null) {
        throw new __validateAndRetrieveIntrinsicPropertyValue();
      }
      if (!___writableStreamState.objectMode) {
        if (typeof initializeStreamWithValidations == "string") {
          if (___writableStreamState.decodeStrings !== false) {
            initializeStreamWithValidations = DataBuffer.from(
              initializeStreamWithValidations,
              _initializeStreamProcessingHandler,
            );
            _initializeStreamProcessingHandler = "buffer";
          }
        } else if (initializeStreamWithValidations instanceof DataBuffer) {
          _initializeStreamProcessingHandler = "buffer";
        } else if (
          extractedStreamData._isUint8Array(initializeStreamWithValidations)
        ) {
          initializeStreamWithValidations =
            extractedStreamData._uint8ArrayToBuffer(
              initializeStreamWithValidations,
            );
          _initializeStreamProcessingHandler = "buffer";
        } else {
          throw new _isSemanticVersionRangeValid(
            "chunk",
            ["string", "Buffer", "Uint8Array"],
            initializeStreamWithValidations,
          );
        }
      }
      let ____writableStreamState;
      if (___writableStreamState.ending) {
        ____writableStreamState = new __validateAndExportModuleStream();
      } else if (___writableStreamState.destroyed) {
        ____writableStreamState = new ___isSemanticVersionRangeValid("write");
      }
      if (____writableStreamState) {
        isSemanticVersionRangeValid.nextTick(
          handleStreamErrorsAndEnqueue,
          ____writableStreamState,
        );
        validateAndExportModules(
          handleStreamProcessingAndErrorHandling,
          ____writableStreamState,
          true,
        );
        return ____writableStreamState;
      } else {
        ___writableStreamState.pendingcb++;
        return manageStreamBufferAndValidation(
          handleStreamProcessingAndErrorHandling,
          ___writableStreamState,
          initializeStreamWithValidations,
          _initializeStreamProcessingHandler,
          handleStreamErrorsAndEnqueue,
        );
      }
    }
    StreamEventProcessor.prototype.write = function (
      validateAndProcessSignalOptions,
      validateAndPrepareOptionsForProcessing,
      validateAndProcessOptionsForModuleExports,
    ) {
      return (
        _validateAndInitializeStreamProcessing(
          this,
          validateAndProcessSignalOptions,
          validateAndPrepareOptionsForProcessing,
          validateAndProcessOptionsForModuleExports,
        ) === true
      );
    };
    StreamEventProcessor.prototype.cork = function () {
      this._writableState.corked++;
    };
    StreamEventProcessor.prototype.uncork = function () {
      let __currentWritableState = this._writableState;
      if (__currentWritableState.corked) {
        __currentWritableState.corked--;
        if (!__currentWritableState.writing) {
          handleBufferedCharacterSegments(this, __currentWritableState);
        }
      }
    };
    StreamEventProcessor.prototype.setDefaultEncoding = function (
      abortSignalHandler,
    ) {
      if (typeof abortSignalHandler == "string") {
        abortSignalHandler = stringToLowerCase(abortSignalHandler);
      }
      if (!DataBuffer.isEncoding(abortSignalHandler)) {
        throw new ____isSemanticVersionRangeValid(abortSignalHandler);
      }
      this._writableState.defaultEncoding = abortSignalHandler;
      return this;
    };
    function manageStreamBufferAndValidation(
      initializeStreamAndProperties,
      retrieveStreamSettingsProperties,
      _processAndExportIntrinsicProperties,
      initializeStreamProperties,
      validateAndRetrieveStreamSettings,
    ) {
      let bufferSizeIncrement = retrieveStreamSettingsProperties.objectMode
        ? 1
        : _processAndExportIntrinsicProperties.length;
      retrieveStreamSettingsProperties.length += bufferSizeIncrement;
      let isBufferBelowHighWaterMark =
        retrieveStreamSettingsProperties.length <
        retrieveStreamSettingsProperties.highWaterMark;
      if (!isBufferBelowHighWaterMark) {
        retrieveStreamSettingsProperties.needDrain = true;
      }
      if (
        retrieveStreamSettingsProperties.writing ||
        retrieveStreamSettingsProperties.corked ||
        retrieveStreamSettingsProperties.errored ||
        !retrieveStreamSettingsProperties.constructed
      ) {
        retrieveStreamSettingsProperties.buffered.push({
          chunk: _processAndExportIntrinsicProperties,
          encoding: initializeStreamProperties,
          callback: validateAndRetrieveStreamSettings,
        });
        if (
          retrieveStreamSettingsProperties.allBuffers &&
          initializeStreamProperties !== "buffer"
        ) {
          retrieveStreamSettingsProperties.allBuffers = false;
        }
        if (
          retrieveStreamSettingsProperties.allNoop &&
          validateAndRetrieveStreamSettings !== setupApplication
        ) {
          retrieveStreamSettingsProperties.allNoop = false;
        }
      } else {
        retrieveStreamSettingsProperties.writelen = bufferSizeIncrement;
        retrieveStreamSettingsProperties.writecb =
          validateAndRetrieveStreamSettings;
        retrieveStreamSettingsProperties.writing = true;
        retrieveStreamSettingsProperties.sync = true;
        initializeStreamAndProperties._write(
          _processAndExportIntrinsicProperties,
          initializeStreamProperties,
          retrieveStreamSettingsProperties.onwrite,
        );
        retrieveStreamSettingsProperties.sync = false;
      }
      return (
        isBufferBelowHighWaterMark &&
        !retrieveStreamSettingsProperties.errored &&
        !retrieveStreamSettingsProperties.destroyed
      );
    }
    function executeWriteOperationWithSignalHandling(
      initializeStreamWithSignalHandling,
      initializeStreamWithAbortSignal,
      initializeWritableStreamSettingsAndAttachHandlers,
      handleAbortSignalAndRetrieveProperties,
      initializeAbortSignalHandlers,
      handleAbortSignalAndProcessWritableState,
      initializeAbortSignalHandling,
    ) {
      initializeStreamWithAbortSignal.writelen =
        handleAbortSignalAndRetrieveProperties;
      initializeStreamWithAbortSignal.writecb = initializeAbortSignalHandling;
      initializeStreamWithAbortSignal.writing = true;
      initializeStreamWithAbortSignal.sync = true;
      if (initializeStreamWithAbortSignal.destroyed) {
        initializeStreamWithAbortSignal.onwrite(
          new ___isSemanticVersionRangeValid("write"),
        );
      } else if (initializeWritableStreamSettingsAndAttachHandlers) {
        initializeStreamWithSignalHandling._writev(
          initializeAbortSignalHandlers,
          initializeStreamWithAbortSignal.onwrite,
        );
      } else {
        initializeStreamWithSignalHandling._write(
          initializeAbortSignalHandlers,
          handleAbortSignalAndProcessWritableState,
          initializeStreamWithAbortSignal.onwrite,
        );
      }
      initializeStreamWithAbortSignal.sync = false;
    }
    function handleStreamSettingsAndExport(
      _validateAndRetrieveStreamSettings,
      __validateAndRetrieveStreamSettings,
      ____validateAndRetrieveStreamProperties,
      validateAndInitializeStreamSettings,
    ) {
      --__validateAndRetrieveStreamSettings.pendingcb;
      validateAndInitializeStreamSettings(
        ____validateAndRetrieveStreamProperties,
      );
      processBufferedStreamSegments(__validateAndRetrieveStreamSettings);
      validateAndExportModules(
        _validateAndRetrieveStreamSettings,
        ____validateAndRetrieveStreamProperties,
      );
    }
    function handleStreamDefaultReturnValue(
      initializeStreamHandler,
      defaultEncodingValue,
    ) {
      let writableState = initializeStreamHandler._writableState;
      let isWritableStateSynchronous = writableState.sync;
      let onWriteComplete = writableState.writecb;
      if (typeof onWriteComplete != "function") {
        validateAndExportModules(
          initializeStreamHandler,
          new _validateAndExportStreamModules(),
        );
        return;
      }
      writableState.writing = false;
      writableState.writecb = null;
      writableState.length -= writableState.writelen;
      writableState.writelen = 0;
      if (defaultEncodingValue) {
        defaultEncodingValue.stack;
        writableState.errored ||= defaultEncodingValue;
        if (
          initializeStreamHandler._readableState &&
          !initializeStreamHandler._readableState.errored
        ) {
          initializeStreamHandler._readableState.errored = defaultEncodingValue;
        }
        if (isWritableStateSynchronous) {
          isSemanticVersionRangeValid.nextTick(
            handleStreamSettingsAndExport,
            initializeStreamHandler,
            writableState,
            defaultEncodingValue,
            onWriteComplete,
          );
        } else {
          handleStreamSettingsAndExport(
            initializeStreamHandler,
            writableState,
            defaultEncodingValue,
            onWriteComplete,
          );
        }
      } else {
        if (writableState.buffered.length > writableState.bufferedIndex) {
          handleBufferedCharacterSegments(
            initializeStreamHandler,
            writableState,
          );
        }
        if (isWritableStateSynchronous) {
          if (
            writableState.afterWriteTickInfo !== null &&
            writableState.afterWriteTickInfo.cb === onWriteComplete
          ) {
            writableState.afterWriteTickInfo.count++;
          } else {
            writableState.afterWriteTickInfo = {
              count: 1,
              cb: onWriteComplete,
              stream: initializeStreamHandler,
              state: writableState,
            };
            isSemanticVersionRangeValid.nextTick(
              handlePostWriteProcessing,
              writableState.afterWriteTickInfo,
            );
          }
        } else {
          handleAbortProcessingFlow(
            initializeStreamHandler,
            writableState,
            1,
            onWriteComplete,
          );
        }
      }
    }
    function handlePostWriteProcessing({
      stream: itemProcessingStream,
      state: currentItemProcessingStatus,
      count: totalProcessedItems,
      cb: processItemCallback,
    }) {
      currentItemProcessingStatus.afterWriteTickInfo = null;
      return handleAbortProcessingFlow(
        itemProcessingStream,
        currentItemProcessingStatus,
        totalProcessedItems,
        processItemCallback,
      );
    }
    function handleAbortProcessingFlow(
      handleAbortSignal,
      ___handleAbortSignal,
      ____handleAbortSignal,
      handleAbortSignalDuringProcessing,
    ) {
      for (
        !___handleAbortSignal.ending &&
        !handleAbortSignal.destroyed &&
        ___handleAbortSignal.length === 0 &&
        ___handleAbortSignal.needDrain &&
        ((___handleAbortSignal.needDrain = false),
        handleAbortSignal.emit("drain"));
        ____handleAbortSignal-- > 0;

      ) {
        ___handleAbortSignal.pendingcb--;
        handleAbortSignalDuringProcessing();
      }
      if (___handleAbortSignal.destroyed) {
        processBufferedStreamSegments(___handleAbortSignal);
      }
      processAndCompareStreamVersionOperators(
        handleAbortSignal,
        ___handleAbortSignal,
      );
    }
    function processBufferedStreamSegments(manageStreamBufferAndProcessing) {
      if (manageStreamBufferAndProcessing.writing) {
        return;
      }
      for (
        let currentBufferedIndex =
          manageStreamBufferAndProcessing.bufferedIndex;
        currentBufferedIndex < manageStreamBufferAndProcessing.buffered.length;
        ++currentBufferedIndex
      ) {
        var currentErrorStatus;
        let { chunk: dataStreamChunk, callback: dataStreamProcessingCallback } =
          manageStreamBufferAndProcessing.buffered[currentBufferedIndex];
        let dataStreamChunkLength = manageStreamBufferAndProcessing.objectMode
          ? 1
          : dataStreamChunk.length;
        manageStreamBufferAndProcessing.length -= dataStreamChunkLength;
        dataStreamProcessingCallback(
          (currentErrorStatus = manageStreamBufferAndProcessing.errored) !==
            null && currentErrorStatus !== undefined
            ? currentErrorStatus
            : new ___isSemanticVersionRangeValid("write"),
        );
      }
      let exportedStreamModules =
        manageStreamBufferAndProcessing[
          ___validateAndExportStreamModules
        ].splice(0);
      for (
        let currentModuleIndex = 0;
        currentModuleIndex < exportedStreamModules.length;
        currentModuleIndex++
      ) {
        var hasSignalError;
        exportedStreamModules[currentModuleIndex](
          (hasSignalError = manageStreamBufferAndProcessing.errored) !== null &&
            hasSignalError !== undefined
            ? hasSignalError
            : new ___isSemanticVersionRangeValid("end"),
        );
      }
      setupProcessStreamBuffering(manageStreamBufferAndProcessing);
    }
    function handleBufferedCharacterSegments(
      processAndValidateStreamSettings,
      processStreamSettingsBuffer,
    ) {
      if (
        processStreamSettingsBuffer.corked ||
        processStreamSettingsBuffer.bufferProcessing ||
        processStreamSettingsBuffer.destroyed ||
        !processStreamSettingsBuffer.constructed
      ) {
        return;
      }
      let {
        buffered: handlePendingBufferedCharacters,
        bufferedIndex: currentBufferedCharacterIndex,
        objectMode: isInObjectMode,
      } = processStreamSettingsBuffer;
      let countOfPendingBufferedSegments =
        handlePendingBufferedCharacters.length - currentBufferedCharacterIndex;
      if (!countOfPendingBufferedSegments) {
        return;
      }
      let initialBufferedCharacterIndex = currentBufferedCharacterIndex;
      processStreamSettingsBuffer.bufferProcessing = true;
      if (
        countOfPendingBufferedSegments > 1 &&
        processAndValidateStreamSettings._writev
      ) {
        processStreamSettingsBuffer.pendingcb -=
          countOfPendingBufferedSegments - 1;
        let executeBufferedCallbacksWithPending =
          processStreamSettingsBuffer.allNoop
            ? setupApplication
            : (processPendingCallbacks) => {
                for (
                  let currentBufferedIndex = initialBufferedCharacterIndex;
                  currentBufferedIndex < handlePendingBufferedCharacters.length;
                  ++currentBufferedIndex
                ) {
                  handlePendingBufferedCharacters[
                    currentBufferedIndex
                  ].callback(processPendingCallbacks);
                }
              };
        let currentBufferedCallbacks =
          processStreamSettingsBuffer.allNoop &&
          initialBufferedCharacterIndex === 0
            ? handlePendingBufferedCharacters
            : ArrayElementsExtractor(
                handlePendingBufferedCharacters,
                initialBufferedCharacterIndex,
              );
        currentBufferedCallbacks.allBuffers =
          processStreamSettingsBuffer.allBuffers;
        executeWriteOperationWithSignalHandling(
          processAndValidateStreamSettings,
          processStreamSettingsBuffer,
          true,
          processStreamSettingsBuffer.length,
          currentBufferedCallbacks,
          "",
          executeBufferedCallbacksWithPending,
        );
        setupProcessStreamBuffering(processStreamSettingsBuffer);
      } else {
        do {
          let {
            chunk: bufferedCharacterSegment,
            encoding: characterEncoding,
            callback: _onWriteComplete,
          } = handlePendingBufferedCharacters[initialBufferedCharacterIndex];
          handlePendingBufferedCharacters[initialBufferedCharacterIndex++] =
            null;
          let _bufferedSegmentLength = isInObjectMode
            ? 1
            : bufferedCharacterSegment.length;
          executeWriteOperationWithSignalHandling(
            processAndValidateStreamSettings,
            processStreamSettingsBuffer,
            false,
            _bufferedSegmentLength,
            bufferedCharacterSegment,
            characterEncoding,
            _onWriteComplete,
          );
        } while (
          initialBufferedCharacterIndex <
            handlePendingBufferedCharacters.length &&
          !processStreamSettingsBuffer.writing
        );
        if (
          initialBufferedCharacterIndex ===
          handlePendingBufferedCharacters.length
        ) {
          setupProcessStreamBuffering(processStreamSettingsBuffer);
        } else if (initialBufferedCharacterIndex > 256) {
          handlePendingBufferedCharacters.splice(
            0,
            initialBufferedCharacterIndex,
          );
          processStreamSettingsBuffer.bufferedIndex = 0;
        } else {
          processStreamSettingsBuffer.bufferedIndex =
            initialBufferedCharacterIndex;
        }
      }
      processStreamSettingsBuffer.bufferProcessing = false;
    }
    StreamEventProcessor.prototype._write = function (
      validateVersionRangeWithOptionsEnhanced,
      processWritableStateOnReturn,
      validateStreamHandlerStateAndEncode,
    ) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk: validateVersionRangeWithOptionsEnhanced,
              encoding: processWritableStateOnReturn,
            },
          ],
          validateStreamHandlerStateAndEncode,
        );
      } else {
        throw new _validateSemanticVersionRange("_write()");
      }
    };
    StreamEventProcessor.prototype._writev = null;
    StreamEventProcessor.prototype.end = function (
      validateSignalIntegrity,
      _____handleAbortSignal,
      writeCompletionHandler,
    ) {
      let currentWritableState = this._writableState;
      if (typeof validateSignalIntegrity == "function") {
        writeCompletionHandler = validateSignalIntegrity;
        validateSignalIntegrity = null;
        _____handleAbortSignal = null;
      } else if (typeof _____handleAbortSignal == "function") {
        writeCompletionHandler = _____handleAbortSignal;
        _____handleAbortSignal = null;
      }
      let validationError;
      if (validateSignalIntegrity != null) {
        let streamProcessingInitializationResult =
          _validateAndInitializeStreamProcessing(
            this,
            validateSignalIntegrity,
            _____handleAbortSignal,
          );
        if (
          streamProcessingInitializationResult instanceof _StreamErrorHandler
        ) {
          validationError = streamProcessingInitializationResult;
        }
      }
      if (currentWritableState.corked) {
        currentWritableState.corked = 1;
        this.uncork();
      }
      if (!validationError) {
        if (!currentWritableState.errored && !currentWritableState.ending) {
          currentWritableState.ending = true;
          processAndCompareStreamVersionOperators(
            this,
            currentWritableState,
            true,
          );
          currentWritableState.ended = true;
        } else if (currentWritableState.finished) {
          validationError = new __validateAndExportStreamModules("end");
        } else if (currentWritableState.destroyed) {
          validationError = new ___isSemanticVersionRangeValid("end");
        }
      }
      if (typeof writeCompletionHandler == "function") {
        if (validationError || currentWritableState.finished) {
          isSemanticVersionRangeValid.nextTick(
            writeCompletionHandler,
            validationError,
          );
        } else {
          currentWritableState[___validateAndExportStreamModules].push(
            writeCompletionHandler,
          );
        }
      }
      return this;
    };
    function isVersionReadyForProcessing(evaluateVersionConstraints) {
      return (
        evaluateVersionConstraints.ending &&
        !evaluateVersionConstraints.destroyed &&
        evaluateVersionConstraints.constructed &&
        evaluateVersionConstraints.length === 0 &&
        !evaluateVersionConstraints.errored &&
        evaluateVersionConstraints.buffered.length === 0 &&
        !evaluateVersionConstraints.finished &&
        !evaluateVersionConstraints.writing &&
        !evaluateVersionConstraints.errorEmitted &&
        !evaluateVersionConstraints.closeEmitted
      );
    }
    function handleVersionComparisonOperators(
      processBufferedSegments,
      evaluateVersionComparison,
    ) {
      let isCurrentlyProcessingVersionComparison = false;
      function processVersionCompatibilityOperators(
        evaluateVersionCompatibilityOperators,
      ) {
        if (isCurrentlyProcessingVersionComparison) {
          validateAndExportModules(
            processBufferedSegments,
            evaluateVersionCompatibilityOperators ??
              _validateAndExportStreamModules(),
          );
          return;
        }
        isCurrentlyProcessingVersionComparison = true;
        evaluateVersionComparison.pendingcb--;
        if (evaluateVersionCompatibilityOperators) {
          let validatedVersionComparisonOperators =
            evaluateVersionComparison[___validateAndExportStreamModules].splice(
              0,
            );
          for (
            let currentOperatorFunctionIndex = 0;
            currentOperatorFunctionIndex <
            validatedVersionComparisonOperators.length;
            currentOperatorFunctionIndex++
          ) {
            validatedVersionComparisonOperators[currentOperatorFunctionIndex](
              evaluateVersionCompatibilityOperators,
            );
          }
          validateAndExportModules(
            processBufferedSegments,
            evaluateVersionCompatibilityOperators,
            evaluateVersionComparison.sync,
          );
        } else if (isVersionReadyForProcessing(evaluateVersionComparison)) {
          evaluateVersionComparison.prefinished = true;
          processBufferedSegments.emit("prefinish");
          evaluateVersionComparison.pendingcb++;
          isSemanticVersionRangeValid.nextTick(
            finalizeBufferedStreamAndExecuteCallbacks,
            processBufferedSegments,
            evaluateVersionComparison,
          );
        }
      }
      evaluateVersionComparison.sync = true;
      evaluateVersionComparison.pendingcb++;
      try {
        processBufferedSegments._final(processVersionCompatibilityOperators);
      } catch (versionCompatibilityError) {
        processVersionCompatibilityOperators(versionCompatibilityError);
      }
      evaluateVersionComparison.sync = false;
    }
    function processVersionComparisonEvents(
      _handleVersionComparison,
      __handleVersionComparison,
    ) {
      if (
        !__handleVersionComparison.prefinished &&
        !__handleVersionComparison.finalCalled
      ) {
        if (
          typeof _handleVersionComparison._final == "function" &&
          !__handleVersionComparison.destroyed
        ) {
          __handleVersionComparison.finalCalled = true;
          handleVersionComparisonOperators(
            _handleVersionComparison,
            __handleVersionComparison,
          );
        } else {
          __handleVersionComparison.prefinished = true;
          _handleVersionComparison.emit("prefinish");
        }
      }
    }
    function processAndCompareStreamVersionOperators(
      processBufferedSegmentsAndExecuteCallbacks,
      processBufferedStreamSettingsAndCallbacks,
      handleSemanticVersionComparison,
    ) {
      if (
        isVersionReadyForProcessing(processBufferedStreamSettingsAndCallbacks)
      ) {
        processVersionComparisonEvents(
          processBufferedSegmentsAndExecuteCallbacks,
          processBufferedStreamSettingsAndCallbacks,
        );
        if (processBufferedStreamSettingsAndCallbacks.pendingcb === 0) {
          if (handleSemanticVersionComparison) {
            processBufferedStreamSettingsAndCallbacks.pendingcb++;
            isSemanticVersionRangeValid.nextTick(
              (
                handleVersionOperatorProcessingAndStreamExecution,
                versionProcessingPayload,
              ) => {
                if (isVersionReadyForProcessing(versionProcessingPayload)) {
                  finalizeBufferedStreamAndExecuteCallbacks(
                    handleVersionOperatorProcessingAndStreamExecution,
                    versionProcessingPayload,
                  );
                } else {
                  versionProcessingPayload.pendingcb--;
                }
              },
              processBufferedSegmentsAndExecuteCallbacks,
              processBufferedStreamSettingsAndCallbacks,
            );
          } else if (
            isVersionReadyForProcessing(
              processBufferedStreamSettingsAndCallbacks,
            )
          ) {
            processBufferedStreamSettingsAndCallbacks.pendingcb++;
            finalizeBufferedStreamAndExecuteCallbacks(
              processBufferedSegmentsAndExecuteCallbacks,
              processBufferedStreamSettingsAndCallbacks,
            );
          }
        }
      }
    }
    function finalizeBufferedStreamAndExecuteCallbacks(
      manageBufferedStreamSegmentsAndSettings,
      _processBufferedCharacterSegments,
    ) {
      _processBufferedCharacterSegments.pendingcb--;
      _processBufferedCharacterSegments.finished = true;
      let executedCallbacks =
        _processBufferedCharacterSegments[
          ___validateAndExportStreamModules
        ].splice(0);
      for (
        let callbackExecutionIndex = 0;
        callbackExecutionIndex < executedCallbacks.length;
        callbackExecutionIndex++
      ) {
        executedCallbacks[callbackExecutionIndex]();
      }
      manageBufferedStreamSegmentsAndSettings.emit("finish");
      if (_processBufferedCharacterSegments.autoDestroy) {
        let ___________________readableStreamState =
          manageBufferedStreamSegmentsAndSettings._readableState;
        if (
          !___________________readableStreamState ||
          (___________________readableStreamState.autoDestroy &&
            (___________________readableStreamState.endEmitted ||
              ___________________readableStreamState.readable === false))
        ) {
          manageBufferedStreamSegmentsAndSettings.destroy();
        }
      }
    }
    _defineObjectPropertiesWithAttributes(StreamEventProcessor.prototype, {
      closed: {
        __proto__: null,
        get() {
          if (this._writableState) {
            return this._writableState.closed;
          } else {
            return false;
          }
        },
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._writableState) {
            return this._writableState.destroyed;
          } else {
            return false;
          }
        },
        set(updateWritableStateDestroyedFlag) {
          if (this._writableState) {
            this._writableState.destroyed = updateWritableStateDestroyedFlag;
          }
        },
      },
      writable: {
        __proto__: null,
        get() {
          let isWritableStateValid = this._writableState;
          return (
            !!isWritableStateValid &&
            isWritableStateValid.writable !== false &&
            !isWritableStateValid.destroyed &&
            !isWritableStateValid.errored &&
            !isWritableStateValid.ending &&
            !isWritableStateValid.ended
          );
        },
        set(updateWritableStateBasedOnInput) {
          if (this._writableState) {
            this._writableState.writable = !!updateWritableStateBasedOnInput;
          }
        },
      },
      writableFinished: {
        __proto__: null,
        get() {
          if (this._writableState) {
            return this._writableState.finished;
          } else {
            return false;
          }
        },
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          if (this._writableState) {
            return this._writableState.objectMode;
          } else {
            return false;
          }
        },
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        },
      },
      writableEnded: {
        __proto__: null,
        get() {
          if (this._writableState) {
            return this._writableState.ending;
          } else {
            return false;
          }
        },
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          let ____currentWritableState = this._writableState;
          if (____currentWritableState) {
            return (
              !____currentWritableState.destroyed &&
              !____currentWritableState.ending &&
              ____currentWritableState.needDrain
            );
          } else {
            return false;
          }
        },
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        },
      },
      writableCorked: {
        __proto__: null,
        get() {
          if (this._writableState) {
            return this._writableState.corked;
          } else {
            return 0;
          }
        },
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        },
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          if (this._writableState) {
            return this._writableState.errored;
          } else {
            return null;
          }
        },
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get() {
          return (
            this._writableState.writable !== false &&
            (!!this._writableState.destroyed ||
              !!this._writableState.errored) &&
            !this._writableState.finished
          );
        },
      },
    });
    var processVersioningOperatorsResult =
      validateAndExportVersionedData.destroy;
    StreamEventProcessor.prototype.destroy = function (
      validateAndRetrieveVersionCompatibilityOperators,
      processAndExportVersionOperators,
    ) {
      let _currentWritableState = this._writableState;
      if (
        !_currentWritableState.destroyed &&
        (_currentWritableState.bufferedIndex <
          _currentWritableState.buffered.length ||
          _currentWritableState[___validateAndExportStreamModules].length)
      ) {
        isSemanticVersionRangeValid.nextTick(
          processBufferedStreamSegments,
          _currentWritableState,
        );
      }
      processVersioningOperatorsResult.call(
        this,
        validateAndRetrieveVersionCompatibilityOperators,
        processAndExportVersionOperators,
      );
      return this;
    };
    StreamEventProcessor.prototype._undestroy =
      validateAndExportVersionedData.undestroy;
    StreamEventProcessor.prototype._destroy = function (
      _isStreamInErrorState,
      processVersionEvaluation,
    ) {
      processVersionEvaluation(_isStreamInErrorState);
    };
    StreamEventProcessor.prototype[_StreamEventEmitter.captureRejectionSymbol] =
      function (handleStreamProcessing) {
        this.destroy(handleStreamProcessing);
      };
    var validateAndRetrieveSemanticVersionRange;
    function initializeSemVerRangeIfNeeded() {
      if (validateAndRetrieveSemanticVersionRange === undefined) {
        validateAndRetrieveSemanticVersionRange = {};
      }
      return validateAndRetrieveSemanticVersionRange;
    }
    StreamEventProcessor.fromWeb = function (
      _processVersionOperators,
      processVersionOperatorsAndHandleCallbacks,
    ) {
      return initializeSemVerRangeIfNeeded().newStreamWritableFromWritableStream(
        _processVersionOperators,
        processVersionOperatorsAndHandleCallbacks,
      );
    };
    StreamEventProcessor.toWeb = function (
      handleVersionComparisonAndProcessSegments,
    ) {
      return initializeSemVerRangeIfNeeded().newWritableStreamFromStreamWritable(
        handleVersionComparisonAndProcessSegments,
      );
    };
  },
);
var isVersionComparisonComplete = lazyModuleInitializer(
  (validateAndProcessInputStream, initializeBlobCreation) => {
    var isSemVerRangeValid = isSemVerRangeValid();
    retrieveAndValidateIntrinsicPropertyValue();
    var defineESModuleForIntrinsicProperties = defineESModuleWithProperties(
      intrinsicPropertiesManager,
    );
    var {
      isReadable: isReadableStreamFlag,
      isWritable: isWritableStreamFlag,
      isIterable: isStreamIterable,
      isNodeStream: isNodeReadableStream,
      isReadableNodeStream: isReadableNodeStreamFlag,
      isWritableNodeStream: _isWritableStreamFlag,
      isDuplexNodeStream: isBidirectionalNodeStream,
    } = scheduleTimeoutWithArguments();
    var validateStreamAndPrereleaseVersion = validateStreamVersionState();
    var {
      AbortError: abortProcessingError,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARGUMENT_TYPE,
        ERR_INVALID_RETURN_VALUE: ERR_INVALID_RETURNED_VALUE,
      },
    } = fetchNodeValuePostTraversal();
    var { destroyer: streamTerminationHandler } =
      processVersionValidationAndAbortSignals();
    var setupEventListenersForBlobCreation = setupStreamEventHandlers();
    var validateAndProcessInputStreamProperties = _handleEncodingErrors();
    var { createDeferredPromise: _retrieveAndValidateIntrinsicPropertyValue } =
      validateAndProcessArrayBufferForProcessing();
    var setupStreamProcessingPipeline = generateErrorMessage();
    var validateAndInitializeInputStream =
      globalThis.Blob || defineESModuleForIntrinsicProperties.Blob;
    var validateAndInitializeStreamSetup =
      typeof validateAndInitializeInputStream !== "undefined"
        ? function (finalizeStreamProcessingAndInvokeCallbacks) {
            return (
              finalizeStreamProcessingAndInvokeCallbacks instanceof
              validateAndInitializeInputStream
            );
          }
        : function (finalizeStreamProcessingAndCallbacks) {
            return false;
          };
    var initializeModuleForIntrinsicPropertyValidation =
      globalThis.AbortController || writeUint16LittleEndian().AbortController;
    var { FunctionPrototypeCall: _retrieveAndValidateIntrinsicProperty } =
      performComparisonOperation();
    var validateAndInitializeStreamProcessing = class extends setupEventListenersForBlobCreation {
      constructor(streamConfig) {
        super(streamConfig);
        if (streamConfig?.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (streamConfig?.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    initializeBlobCreation.exports = function processModuleImport(
      setupStreamReaderAndDispatchEvent,
      setupModuleState,
    ) {
      if (isBidirectionalNodeStream(setupStreamReaderAndDispatchEvent)) {
        return setupStreamReaderAndDispatchEvent;
      }
      if (isReadableNodeStreamFlag(setupStreamReaderAndDispatchEvent)) {
        return setupStreamProcessing({
          readable: setupStreamReaderAndDispatchEvent,
        });
      }
      if (_isWritableStreamFlag(setupStreamReaderAndDispatchEvent)) {
        return setupStreamProcessing({
          writable: setupStreamReaderAndDispatchEvent,
        });
      }
      if (isNodeReadableStream(setupStreamReaderAndDispatchEvent)) {
        return setupStreamProcessing({
          writable: false,
          readable: false,
        });
      }
      if (typeof setupStreamReaderAndDispatchEvent == "function") {
        let {
          value: asyncIterableStream,
          write: writeDataToAsyncIterableStream,
          final: finalizeStreamProcessingAndCleanUp,
          destroy: cleanupStreamProcessingAndReleaseResources,
        } = createAsyncIterableWithCancellation(
          setupStreamReaderAndDispatchEvent,
        );
        if (isStreamIterable(asyncIterableStream)) {
          return setupStreamProcessingPipeline(
            validateAndInitializeStreamProcessing,
            asyncIterableStream,
            {
              objectMode: true,
              write: writeDataToAsyncIterableStream,
              final: finalizeStreamProcessingAndCleanUp,
              destroy: cleanupStreamProcessingAndReleaseResources,
            },
          );
        }
        let retrieveStreamValueThenMethod = asyncIterableStream?.then;
        if (typeof retrieveStreamValueThenMethod == "function") {
          let streamProcessorInstance;
          let validateAndManageAsyncStreamValue =
            _retrieveAndValidateIntrinsicProperty(
              retrieveStreamValueThenMethod,
              asyncIterableStream,
              (validateReturnValue) => {
                if (validateReturnValue != null) {
                  throw new ERR_INVALID_RETURNED_VALUE(
                    "nully",
                    "body",
                    validateReturnValue,
                  );
                }
              },
              (_streamTerminationHandler) => {
                streamTerminationHandler(
                  streamProcessorInstance,
                  _streamTerminationHandler,
                );
              },
            );
          return (streamProcessorInstance =
            new validateAndInitializeStreamProcessing({
              objectMode: true,
              readable: false,
              write: writeDataToAsyncIterableStream,
              final(finalizeAndHandleStream) {
                finalizeStreamProcessingAndCleanUp(async () => {
                  try {
                    await validateAndManageAsyncStreamValue;
                    isSemVerRangeValid.nextTick(finalizeAndHandleStream, null);
                  } catch (handleErrorInStreamOperation) {
                    isSemVerRangeValid.nextTick(
                      finalizeAndHandleStream,
                      handleErrorInStreamOperation,
                    );
                  }
                });
              },
              destroy: cleanupStreamProcessingAndReleaseResources,
            }));
        }
        throw new ERR_INVALID_RETURNED_VALUE(
          "Iterable, AsyncIterable or AsyncFunction",
          setupModuleState,
          asyncIterableStream,
        );
      }
      if (validateAndInitializeStreamSetup(setupStreamReaderAndDispatchEvent)) {
        return processModuleImport(
          setupStreamReaderAndDispatchEvent.arrayBuffer(),
        );
      }
      if (isStreamIterable(setupStreamReaderAndDispatchEvent)) {
        return setupStreamProcessingPipeline(
          validateAndInitializeStreamProcessing,
          setupStreamReaderAndDispatchEvent,
          {
            objectMode: true,
            writable: false,
          },
        );
      }
      if (
        typeof setupStreamReaderAndDispatchEvent?.writable == "object" ||
        typeof setupStreamReaderAndDispatchEvent?.readable == "object"
      ) {
        let readableStream =
          setupStreamReaderAndDispatchEvent != null &&
          setupStreamReaderAndDispatchEvent.readable
            ? isReadableNodeStreamFlag(
                setupStreamReaderAndDispatchEvent?.readable,
              )
              ? setupStreamReaderAndDispatchEvent?.readable
              : processModuleImport(setupStreamReaderAndDispatchEvent.readable)
            : undefined;
        let writableStream =
          setupStreamReaderAndDispatchEvent != null &&
          setupStreamReaderAndDispatchEvent.writable
            ? _isWritableStreamFlag(setupStreamReaderAndDispatchEvent?.writable)
              ? setupStreamReaderAndDispatchEvent?.writable
              : processModuleImport(setupStreamReaderAndDispatchEvent.writable)
            : undefined;
        return setupStreamProcessing({
          readable: readableStream,
          writable: writableStream,
        });
      }
      let streamHandlerFunction = setupStreamReaderAndDispatchEvent?.then;
      if (typeof streamHandlerFunction == "function") {
        let intrinsicPropertyValues;
        _retrieveAndValidateIntrinsicProperty(
          streamHandlerFunction,
          setupStreamReaderAndDispatchEvent,
          (addIntrinsicPropertyValue) => {
            if (addIntrinsicPropertyValue != null) {
              intrinsicPropertyValues.push(addIntrinsicPropertyValue);
            }
            intrinsicPropertyValues.push(null);
          },
          (streamTerminationCompletionHandler) => {
            streamTerminationHandler(
              intrinsicPropertyValues,
              streamTerminationCompletionHandler,
            );
          },
        );
        return (intrinsicPropertyValues =
          new validateAndInitializeStreamProcessing({
            objectMode: true,
            writable: false,
            read() {},
          }));
      }
      throw new ERR_INVALID_ARGUMENT_TYPE(
        setupModuleState,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise",
        ],
        setupStreamReaderAndDispatchEvent,
      );
    };
    function createAsyncIterableWithCancellation(getMatchingVersionIndex) {
      let {
        promise: pendingMatchingIndexPromise,
        resolve: resolveMatchingIndex,
      } = _retrieveAndValidateIntrinsicPropertyValue();
      let createAbortableAsyncIterable =
        new initializeModuleForIntrinsicPropertyValidation();
      let abortControllerSignal = createAbortableAsyncIterable.signal;
      return {
        value: getMatchingVersionIndex(
          (async function* () {
            while (true) {
              let handleMatchingIndexPromise = pendingMatchingIndexPromise;
              pendingMatchingIndexPromise = null;
              let {
                chunk: matchingIndexDataChunk,
                done: isMatchingIndexCompleted,
                cb: onMatchingIndexDataReceived,
              } = await handleMatchingIndexPromise;
              isSemVerRangeValid.nextTick(onMatchingIndexDataReceived);
              if (isMatchingIndexCompleted) {
                return;
              }
              if (abortControllerSignal.aborted) {
                throw new abortProcessingError(undefined, {
                  cause: abortControllerSignal.reason,
                });
              }
              ({
                promise: pendingMatchingIndexPromise,
                resolve: resolveMatchingIndex,
              } = _retrieveAndValidateIntrinsicPropertyValue());
              yield matchingIndexDataChunk;
            }
          })(),
          {
            signal: abortControllerSignal,
          },
        ),
        write(
          processAndSendChunkData,
          handleChunkProcessing,
          onChunkSendComplete,
        ) {
          let processAndSendChunkWithCallback = resolveMatchingIndex;
          resolveMatchingIndex = null;
          processAndSendChunkWithCallback({
            chunk: processAndSendChunkData,
            done: false,
            cb: onChunkSendComplete,
          });
        },
        final(handleResolutionCompletion) {
          let completeResolutionAndInvokeCallback = resolveMatchingIndex;
          resolveMatchingIndex = null;
          completeResolutionAndInvokeCallback({
            done: true,
            cb: handleResolutionCompletion,
          });
        },
        destroy(
          terminateProcessAndCallback,
          executeTerminationAndCleanupCallback,
        ) {
          createAbortableAsyncIterable.abort();
          executeTerminationAndCleanupCallback(terminateProcessAndCallback);
        },
      };
    }
    function setupStreamProcessing(configureMaxEventListeners) {
      let inputStream =
        configureMaxEventListeners.readable &&
        typeof configureMaxEventListeners.readable.read != "function"
          ? validateAndProcessInputStreamProperties.wrap(
              configureMaxEventListeners.readable,
            )
          : configureMaxEventListeners.readable;
      let outputStream = configureMaxEventListeners.writable;
      let isInputStreamReady = !!isReadableStreamFlag(inputStream);
      let isOutputStreamReady = !!isWritableStreamFlag(outputStream);
      let streamHandler;
      let _streamErrorHandler;
      let ___processStreamData;
      let _handleStreamError;
      let __handleStreamProcessing;
      function handleStreamingError(maxEventListeners) {
        let streamErrorCallback = _handleStreamError;
        _handleStreamError = null;
        if (streamErrorCallback) {
          streamErrorCallback(maxEventListeners);
        } else if (maxEventListeners) {
          __handleStreamProcessing.destroy(maxEventListeners);
        } else if (!isInputStreamReady && !isOutputStreamReady) {
          __handleStreamProcessing.destroy();
        }
      }
      __handleStreamProcessing = new validateAndInitializeStreamProcessing({
        readableObjectMode:
          inputStream != null && !!inputStream.readableObjectMode,
        writableObjectMode:
          outputStream != null && !!outputStream.writableObjectMode,
        readable: isInputStreamReady,
        writable: isOutputStreamReady,
      });
      if (isOutputStreamReady) {
        validateStreamAndPrereleaseVersion(
          outputStream,
          (errorHandlingStreamHandler) => {
            isOutputStreamReady = false;
            if (errorHandlingStreamHandler) {
              streamTerminationHandler(inputStream, errorHandlingStreamHandler);
            }
            handleStreamingError(errorHandlingStreamHandler);
          },
        );
        __handleStreamProcessing._write = function (
          setMaximumListeners,
          setMaxStreamListeners,
          setMaxListenersForStreamProcessing,
        ) {
          if (outputStream.write(setMaximumListeners, setMaxStreamListeners)) {
            setMaxListenersForStreamProcessing();
          } else {
            streamHandler = setMaxListenersForStreamProcessing;
          }
        };
        __handleStreamProcessing._final = function (
          validateAndRetrieveIntrinsicPropertyValue,
        ) {
          outputStream.end();
          _streamErrorHandler = validateAndRetrieveIntrinsicPropertyValue;
        };
        outputStream.on("drain", function () {
          if (streamHandler) {
            let initializeStreamHandlerAndExecute = streamHandler;
            streamHandler = null;
            initializeStreamHandlerAndExecute();
          }
        });
        outputStream.on("finish", function () {
          if (_streamErrorHandler) {
            let streamCleanupHandler = _streamErrorHandler;
            _streamErrorHandler = null;
            streamCleanupHandler();
          }
        });
      }
      if (isInputStreamReady) {
        validateStreamAndPrereleaseVersion(
          inputStream,
          (_streamErrorHandler) => {
            isInputStreamReady = false;
            if (_streamErrorHandler) {
              streamTerminationHandler(inputStream, _streamErrorHandler);
            }
            handleStreamingError(_streamErrorHandler);
          },
        );
        inputStream.on("readable", function () {
          if (___processStreamData) {
            let processIncomingStreamData = ___processStreamData;
            ___processStreamData = null;
            processIncomingStreamData();
          }
        });
        inputStream.on("end", function () {
          __handleStreamProcessing.push(null);
        });
        __handleStreamProcessing._read = function () {
          while (true) {
            let streamData = inputStream.read();
            if (streamData === null) {
              ___processStreamData = __handleStreamProcessing._read;
              return;
            }
            if (!__handleStreamProcessing.push(streamData)) {
              return;
            }
          }
        };
      }
      __handleStreamProcessing._destroy = function (
        handleStreamReaderAndDispatchEvent,
        compareStreamVersionsAndInitialize,
      ) {
        if (
          !handleStreamReaderAndDispatchEvent &&
          _handleStreamError !== null
        ) {
          handleStreamReaderAndDispatchEvent = new abortProcessingError();
        }
        ___processStreamData = null;
        streamHandler = null;
        _streamErrorHandler = null;
        if (_handleStreamError === null) {
          compareStreamVersionsAndInitialize(
            handleStreamReaderAndDispatchEvent,
          );
        } else {
          _handleStreamError = compareStreamVersionsAndInitialize;
          streamTerminationHandler(
            outputStream,
            handleStreamReaderAndDispatchEvent,
          );
          streamTerminationHandler(
            inputStream,
            handleStreamReaderAndDispatchEvent,
          );
        }
      };
      return __handleStreamProcessing;
    }
  },
);
var setupStreamEventHandlers = lazyModuleInitializer(
  (initializeErrorHandling, handleCustomErrors) => {
    var {
      ObjectDefineProperties: defineObjectProperties,
      ObjectGetOwnPropertyDescriptor: getOwnPropertyDescriptor,
      ObjectKeys: getIntrinsicPropertyKeys,
      ObjectSetPrototypeOf: setPrototype,
    } = performComparisonOperation();
    handleCustomErrors.exports = VersionEventHandler;
    var errorHandlingMiddleware = _handleEncodingErrors();
    var _______validateAndRetrieveStreamProperties =
      ___validateAndRetrieveStreamProperties();
    setPrototype(
      VersionEventHandler.prototype,
      errorHandlingMiddleware.prototype,
    );
    setPrototype(VersionEventHandler, errorHandlingMiddleware);
    {
      let streamPropertyKeys = getIntrinsicPropertyKeys(
        _______validateAndRetrieveStreamProperties.prototype,
      );
      for (
        let intrinsicPropertyIndex = 0;
        intrinsicPropertyIndex < streamPropertyKeys.length;
        intrinsicPropertyIndex++
      ) {
        let streamPropertyKey = streamPropertyKeys[intrinsicPropertyIndex];
        VersionEventHandler.prototype[streamPropertyKey] ||=
          _______validateAndRetrieveStreamProperties.prototype[
            streamPropertyKey
          ];
      }
    }
    function VersionEventHandler(handleVersionComparisonEvent) {
      if (!(this instanceof VersionEventHandler)) {
        return new VersionEventHandler(handleVersionComparisonEvent);
      }
      errorHandlingMiddleware.call(this, handleVersionComparisonEvent);
      _______validateAndRetrieveStreamProperties.call(
        this,
        handleVersionComparisonEvent,
      );
      if (handleVersionComparisonEvent) {
        this.allowHalfOpen =
          handleVersionComparisonEvent.allowHalfOpen !== false;
        if (handleVersionComparisonEvent.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (handleVersionComparisonEvent.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    defineObjectProperties(VersionEventHandler.prototype, {
      writable: {
        __proto__: null,
        ...getOwnPropertyDescriptor(
          _______validateAndRetrieveStreamProperties.prototype,
          "writable",
        ),
      },
      writableHighWaterMark: {
        __proto__: null,
        ...getOwnPropertyDescriptor(
          _______validateAndRetrieveStreamProperties.prototype,
          "writableHighWaterMark",
        ),
      },
      writableObjectMode: {
        __proto__: null,
        ...getOwnPropertyDescriptor(
          _______validateAndRetrieveStreamProperties.prototype,
          "writableObjectMode",
        ),
      },
      writableBuffer: {
        __proto__: null,
        ...getOwnPropertyDescriptor(
          _______validateAndRetrieveStreamProperties.prototype,
          "writableBuffer",
        ),
      },
      writableLength: {
        __proto__: null,
        ...getOwnPropertyDescriptor(
          _______validateAndRetrieveStreamProperties.prototype,
          "writableLength",
        ),
      },
      writableFinished: {
        __proto__: null,
        ...getOwnPropertyDescriptor(
          _______validateAndRetrieveStreamProperties.prototype,
          "writableFinished",
        ),
      },
      writableCorked: {
        __proto__: null,
        ...getOwnPropertyDescriptor(
          _______validateAndRetrieveStreamProperties.prototype,
          "writableCorked",
        ),
      },
      writableEnded: {
        __proto__: null,
        ...getOwnPropertyDescriptor(
          _______validateAndRetrieveStreamProperties.prototype,
          "writableEnded",
        ),
      },
      writableNeedDrain: {
        __proto__: null,
        ...getOwnPropertyDescriptor(
          _______validateAndRetrieveStreamProperties.prototype,
          "writableNeedDrain",
        ),
      },
      destroyed: {
        __proto__: null,
        get() {
          if (
            this._readableState === undefined ||
            this._writableState === undefined
          ) {
            return false;
          } else {
            return (
              this._readableState.destroyed && this._writableState.destroyed
            );
          }
        },
        set(updateStreamDestroyedState) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = updateStreamDestroyedState;
            this._writableState.destroyed = updateStreamDestroyedState;
          }
        },
      },
    });
    var _initializeErrorHandling;
    function __initializeErrorHandling() {
      if (_initializeErrorHandling === undefined) {
        _initializeErrorHandling = {};
      }
      return _initializeErrorHandling;
    }
    VersionEventHandler.fromWeb = function (
      handleWritableStreamDownload,
      removeEventListener,
    ) {
      return __initializeErrorHandling().newStreamDuplexFromReadableWritablePair(
        handleWritableStreamDownload,
        removeEventListener,
      );
    };
    VersionEventHandler.toWeb = function (streamEventListenerWrapper) {
      return __initializeErrorHandling().newReadableWritablePairFromDuplex(
        streamEventListenerWrapper,
      );
    };
    var initializeErrorHandlingAndEnhanceProperties;
    VersionEventHandler.from = function (_handleStreamErrorAndCleanup) {
      initializeErrorHandlingAndEnhanceProperties ||=
        isVersionComparisonComplete();
      return initializeErrorHandlingAndEnhanceProperties(
        _handleStreamErrorAndCleanup,
        "body",
      );
    };
  },
);
var __removeEventListener = lazyModuleInitializer(
  (
    initializeCustomReadableStreamWithHandlers,
    createCustomReadableStreamWithHandlers,
  ) => {
    var {
      ObjectSetPrototypeOf: assignEventListenersToPrototype,
      Symbol: createEventCallbackSymbol,
    } = performComparisonOperation();
    createCustomReadableStreamWithHandlers.exports =
      ____initializeStreamHandler;
    var { ERR_METHOD_NOT_IMPLEMENTED: ERR_METHOD_NOT_IMPLEMENTED_CW } =
      fetchNodeValuePostTraversal().codes;
    var streamEventHandlers = setupStreamEventHandlers();
    var { getHighWaterMark: retrieveMaximumBufferCapacity } =
      getErrorStackTrace();
    assignEventListenersToPrototype(
      ____initializeStreamHandler.prototype,
      streamEventHandlers.prototype,
    );
    assignEventListenersToPrototype(
      ____initializeStreamHandler,
      streamEventHandlers,
    );
    var eventCallbackSymbol = createEventCallbackSymbol("kCallback");
    function ____initializeStreamHandler(__removeEventListener) {
      if (!(this instanceof ____initializeStreamHandler)) {
        return new ____initializeStreamHandler(__removeEventListener);
      }
      let maxBufferCapacity = __removeEventListener
        ? retrieveMaximumBufferCapacity(
            this,
            __removeEventListener,
            "readableHighWaterMark",
            true,
          )
        : null;
      if (maxBufferCapacity === 0) {
        __removeEventListener = {
          ...__removeEventListener,
          highWaterMark: null,
          readableHighWaterMark: maxBufferCapacity,
          writableHighWaterMark:
            __removeEventListener.writableHighWaterMark || 0,
        };
      }
      streamEventHandlers.call(this, __removeEventListener);
      this._readableState.sync = false;
      this[eventCallbackSymbol] = null;
      if (__removeEventListener) {
        if (typeof __removeEventListener.transform == "function") {
          this._transform = __removeEventListener.transform;
        }
        if (typeof __removeEventListener.flush == "function") {
          this._flush = __removeEventListener.flush;
        }
      }
      this.on("prefinish", flushStreamIfNecessary);
    }
    function processFlushAndHandleStreamErrors(
      handleStreamTerminationAndErrorProcessing,
    ) {
      if (typeof this._flush == "function" && !this.destroyed) {
        this._flush((eventOrTerminationObject, dataToPush) => {
          if (eventOrTerminationObject) {
            if (handleStreamTerminationAndErrorProcessing) {
              handleStreamTerminationAndErrorProcessing(
                eventOrTerminationObject,
              );
            } else {
              this.destroy(eventOrTerminationObject);
            }
            return;
          }
          if (dataToPush != null) {
            this.push(dataToPush);
          }
          this.push(null);
          if (handleStreamTerminationAndErrorProcessing) {
            handleStreamTerminationAndErrorProcessing();
          }
        });
      } else {
        this.push(null);
        if (handleStreamTerminationAndErrorProcessing) {
          handleStreamTerminationAndErrorProcessing();
        }
      }
    }
    function flushStreamIfNecessary() {
      if (this._final !== processFlushAndHandleStreamErrors) {
        processFlushAndHandleStreamErrors.call(this);
      }
    }
    ____initializeStreamHandler.prototype._final =
      processFlushAndHandleStreamErrors;
    ____initializeStreamHandler.prototype._transform = function (
      cleanupEventHandlers,
      removeAllEventListeners,
      detachLogMessageListener,
    ) {
      throw new ERR_METHOD_NOT_IMPLEMENTED_CW("_transform()");
    };
    ____initializeStreamHandler.prototype._write = function (
      _____validateAndRetrieveStreamProperties,
      _handleVersionComparisonEvent,
      versionComparisonEventEmitter,
    ) {
      let _________readableStreamState = this._readableState;
      let _________writableStreamState = this._writableState;
      let currentReadableStreamLength = _________readableStreamState.length;
      this._transform(
        _____validateAndRetrieveStreamProperties,
        _handleVersionComparisonEvent,
        (processEventOrQueueData, eventDataToQueue) => {
          if (processEventOrQueueData) {
            versionComparisonEventEmitter(processEventOrQueueData);
            return;
          }
          if (eventDataToQueue != null) {
            this.push(eventDataToQueue);
          }
          if (
            _________writableStreamState.ended ||
            currentReadableStreamLength ===
              _________readableStreamState.length ||
            _________readableStreamState.length <
              _________readableStreamState.highWaterMark
          ) {
            versionComparisonEventEmitter();
          } else {
            this[eventCallbackSymbol] = versionComparisonEventEmitter;
          }
        },
      );
    };
    ____initializeStreamHandler.prototype._read = function () {
      if (this[eventCallbackSymbol]) {
        let invokeEventCallback = this[eventCallbackSymbol];
        this[eventCallbackSymbol] = null;
        invokeEventCallback();
      }
    };
  },
);
var _removeEventListenerForVersionComparison = lazyModuleInitializer(
  (initializeEventListenerManager, _eventListenerManager) => {
    var { ObjectSetPrototypeOf: setPrototypeChain } =
      performComparisonOperation();
    _eventListenerManager.exports = EventListenerController;
    var BaseEventListener = __removeEventListener();
    setPrototypeChain(
      EventListenerController.prototype,
      BaseEventListener.prototype,
    );
    setPrototypeChain(EventListenerController, BaseEventListener);
    function EventListenerController(disableEventListeners) {
      if (!(this instanceof EventListenerController)) {
        return new EventListenerController(disableEventListeners);
      }
      BaseEventListener.call(this, disableEventListeners);
    }
    EventListenerController.prototype._transform = function (
      logMessagePostListener,
      getEventListenersForElement,
      retrieveEventListeners,
    ) {
      retrieveEventListeners(null, logMessagePostListener);
    };
  },
);
var _retrieveEventListeners = lazyModuleInitializer(
  (
    setupValidationAndListenersForSemVerRanges,
    _setupValidationAndListenersForSemVerRanges,
  ) => {
    var isSemVerRangeValidResult = isSemVerRangeValid();
    var {
      ArrayIsArray: checkIfArray,
      Promise: _PromiseHandler,
      SymbolAsyncIterator: asyncIteratorSymbolForSemVerRange,
    } = performComparisonOperation();
    var validateSemverPrereleaseVersion = validateStreamVersionState();
    var { once: registerSingleCallbackWithOnce } =
      validateAndProcessArrayBufferForProcessing();
    var evaluateSemVerOperatorsForValidation =
      processVersionValidationAndAbortSignals();
    var __initializeEventListeners = setupStreamEventHandlers();
    var {
      aggregateTwoErrors: combineErrorMessagesForSemVerValidation,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_SEMVER_ARGUMENT_TYPE,
        ERR_INVALID_RETURN_VALUE: ERROR_INVALID_SEMVER_RETURN_VALUE,
        ERR_MISSING_ARGS: ERROR_INVALID_SEMVER_ARGUMENTS,
        ERR_STREAM_DESTROYED: ERR_STREAM_TERMINATED,
        ERR_STREAM_PREMATURE_CLOSE: ERROR_STREAM_UNEXPECTED_CLOSE,
      },
      AbortError: AbortErrorForSemVerValidation,
    } = fetchNodeValuePostTraversal();
    var {
      validateFunction: isValidSemVerRangeResult,
      validateAbortSignal: __setupValidationAndListenersForSemVerRanges,
    } = handleStreamErrorTypes();
    var {
      isIterable: setupSemVerValidationAndListeners,
      isReadable: validateSemVerRangeValidity,
      isReadableNodeStream: _setupSemVerValidationAndListeners,
      isNodeStream: isValidSemVerRange,
    } = scheduleTimeoutWithArguments();
    var semVerRangeValidationResult =
      globalThis.AbortController || writeUint16LittleEndian().AbortController;
    var setupSemVerValidationAndEventListeners;
    var isSemanticVersioningRangeValid;
    function setupEventListenerForErrorHandling(
      initializeErrorHandler,
      _getEventListenersCount,
      retrieveErrorHandler,
    ) {
      let isErrorHandlerClosed = false;
      initializeErrorHandler.on("close", () => {
        isErrorHandlerClosed = true;
      });
      let validatedSemverPrereleaseVersion = validateSemverPrereleaseVersion(
        initializeErrorHandler,
        {
          readable: _getEventListenersCount,
          writable: retrieveErrorHandler,
        },
        (defaultListenerIsClosed) => {
          isErrorHandlerClosed = !defaultListenerIsClosed;
        },
      );
      return {
        destroy: (closeErrorHandlerAndDestroy) => {
          if (!isErrorHandlerClosed) {
            isErrorHandlerClosed = true;
            evaluateSemVerOperatorsForValidation.destroyer(
              initializeErrorHandler,
              closeErrorHandlerAndDestroy || new ERR_STREAM_TERMINATED("pipe"),
            );
          }
        },
        cleanup: validatedSemverPrereleaseVersion,
      };
    }
    function retrieveMostRecentErrorHandler(_retrieveErrorHandler) {
      isValidSemVerRangeResult(
        _retrieveErrorHandler[_retrieveErrorHandler.length - 1],
        "streams[stream.length - 1]",
      );
      return _retrieveErrorHandler.pop();
    }
    function validateAndSetupVersionComparisonStream(
      handleVersionComparisonStream,
    ) {
      if (setupSemVerValidationAndListeners(handleVersionComparisonStream)) {
        return handleVersionComparisonStream;
      }
      if (_setupSemVerValidationAndListeners(handleVersionComparisonStream)) {
        return handleSemanticVersioningAsyncListeners(
          handleVersionComparisonStream,
        );
      }
      throw new ERR_INVALID_SEMVER_ARGUMENT_TYPE(
        "val",
        ["Readable", "Iterable", "AsyncIterable"],
        handleVersionComparisonStream,
      );
    }
    async function* handleSemanticVersioningAsyncListeners(
      cleanupAndRemoveEventListeners,
    ) {
      isSemanticVersioningRangeValid ||= _handleEncodingErrors();
      yield* isSemanticVersioningRangeValid.prototype[
        asyncIteratorSymbolForSemVerRange
      ].call(cleanupAndRemoveEventListeners);
    }
    async function handleVersionWithPrereleaseUpdates(
      _____compareVersionWithPrerelease,
      validateStreamVersionAndCleanupListeners,
      compareVersionWithPrereleaseEventHandler,
      { end: completionHandler },
    ) {
      let latestProcessedReceivedValue;
      let deferredPrereleaseCallback = null;
      let updateLatestProcessedReceivedValueAndExecutePendingCallback = (
        handleReceivedValue,
      ) => {
        if (handleReceivedValue) {
          latestProcessedReceivedValue = handleReceivedValue;
        }
        if (deferredPrereleaseCallback) {
          let invokeDeferredCallbackBeforeRelease = deferredPrereleaseCallback;
          deferredPrereleaseCallback = null;
          invokeDeferredCallbackBeforeRelease();
        }
      };
      let createDeferredPrereleaseHandler = () =>
        new _PromiseHandler(
          (
            processLatestValueAndInvokeCallback,
            processAndInvokeCallbackWithLatestValue,
          ) => {
            if (latestProcessedReceivedValue) {
              processAndInvokeCallbackWithLatestValue(
                latestProcessedReceivedValue,
              );
            } else {
              deferredPrereleaseCallback = () => {
                if (latestProcessedReceivedValue) {
                  processAndInvokeCallbackWithLatestValue(
                    latestProcessedReceivedValue,
                  );
                } else {
                  processLatestValueAndInvokeCallback();
                }
              };
            }
          },
        );
      validateStreamVersionAndCleanupListeners.on(
        "drain",
        updateLatestProcessedReceivedValueAndExecutePendingCallback,
      );
      let validatePrereleaseVersion = validateSemverPrereleaseVersion(
        validateStreamVersionAndCleanupListeners,
        {
          readable: false,
        },
        updateLatestProcessedReceivedValueAndExecutePendingCallback,
      );
      try {
        if (validateStreamVersionAndCleanupListeners.writableNeedDrain) {
          await createDeferredPrereleaseHandler();
        }
        for await (let prereleaseVersion of _____compareVersionWithPrerelease) {
          if (
            !validateStreamVersionAndCleanupListeners.write(prereleaseVersion)
          ) {
            await createDeferredPrereleaseHandler();
          }
        }
        if (completionHandler) {
          validateStreamVersionAndCleanupListeners.end();
        }
        await createDeferredPrereleaseHandler();
        compareVersionWithPrereleaseEventHandler();
      } catch (errorHandlingInVersionComparison) {
        compareVersionWithPrereleaseEventHandler(
          latestProcessedReceivedValue !== errorHandlingInVersionComparison
            ? combineErrorMessagesForSemVerValidation(
                latestProcessedReceivedValue,
                errorHandlingInVersionComparison,
              )
            : errorHandlingInVersionComparison,
        );
      } finally {
        validatePrereleaseVersion();
        validateStreamVersionAndCleanupListeners.off(
          "drain",
          updateLatestProcessedReceivedValueAndExecutePendingCallback,
        );
      }
    }
    function validateAndRegisterErrorHandlerWithVersionCheck(
      ...errorHandlerRegistrationDetails
    ) {
      return validateAndCompareSemverVersions(
        errorHandlerRegistrationDetails,
        registerSingleCallbackWithOnce(
          retrieveMostRecentErrorHandler(errorHandlerRegistrationDetails),
        ),
      );
    }
    function validateAndCompareSemverVersions(
      validateAndCompareVersionsWithPrerelease,
      validateAndHandleStreamVersioning,
      ___handleVersionComparison,
    ) {
      if (
        validateAndCompareVersionsWithPrerelease.length === 1 &&
        checkIfArray(validateAndCompareVersionsWithPrerelease[0])
      ) {
        validateAndCompareVersionsWithPrerelease =
          validateAndCompareVersionsWithPrerelease[0];
      }
      if (validateAndCompareVersionsWithPrerelease.length < 2) {
        throw new ERROR_INVALID_SEMVER_ARGUMENTS("streams");
      }
      let semverRangeValidationResult = new semVerRangeValidationResult();
      let versionValidationAbortSignal = semverRangeValidationResult.signal;
      let versionComparisonAbortSignal = ___handleVersionComparison?.signal;
      let semverComparisonResults = [];
      __setupValidationAndListenersForSemVerRanges(
        versionComparisonAbortSignal,
        "options.signal",
      );
      function processAbortErrorForSemVerValidation() {
        handleVersionComparisonEventProcessing(
          new AbortErrorForSemVerValidation(),
        );
      }
      versionComparisonAbortSignal?.addEventListener(
        "abort",
        processAbortErrorForSemVerValidation,
      );
      let handleVersionComparisonSignal;
      let handleSemverVersionComparison;
      let _semverComparisonResults = [];
      let semverComparisonAbortSignal = 0;
      function processVersionComparisonEvent(__handleVersionComparisonEvent) {
        handleVersionComparisonEventProcessing(
          __handleVersionComparisonEvent,
          --semverComparisonAbortSignal === 0,
        );
      }
      function handleVersionComparisonEventProcessing(
        ___handleVersionComparisonEvent,
        handleVersionComparisonEvents,
      ) {
        if (
          ___handleVersionComparisonEvent &&
          (!handleVersionComparisonSignal ||
            handleVersionComparisonSignal.code === "ERR_STREAM_PREMATURE_CLOSE")
        ) {
          handleVersionComparisonSignal = ___handleVersionComparisonEvent;
        }
        if (
          !!handleVersionComparisonSignal ||
          !!handleVersionComparisonEvents
        ) {
          while (_semverComparisonResults.length) {
            _semverComparisonResults.shift()(handleVersionComparisonSignal);
          }
          versionComparisonAbortSignal?.removeEventListener(
            "abort",
            processAbortErrorForSemVerValidation,
          );
          semverRangeValidationResult.abort();
          if (handleVersionComparisonEvents) {
            if (!handleVersionComparisonSignal) {
              semverComparisonResults.forEach((computeOrderTotal) =>
                computeOrderTotal(),
              );
            }
            isSemVerRangeValidResult.nextTick(
              validateAndHandleStreamVersioning,
              handleVersionComparisonSignal,
              handleSemverVersionComparison,
            );
          }
        }
      }
      let validateAndCompareSemverRangesWithAbort;
      for (
        let currentVersionIterationIndex = 0;
        currentVersionIterationIndex <
        validateAndCompareVersionsWithPrerelease.length;
        currentVersionIterationIndex++
      ) {
        let currentVersion =
          validateAndCompareVersionsWithPrerelease[
            currentVersionIterationIndex
          ];
        let isNextStableVersionAvailable =
          currentVersionIterationIndex <
          validateAndCompareVersionsWithPrerelease.length - 1;
        let isCurrentVersionReleased = currentVersionIterationIndex > 0;
        let shouldCompareVersionsForUpgrade =
          isNextStableVersionAvailable ||
          ___handleVersionComparison?.end !== false;
        let isCurrentVersionTheMostRecentStableRelease =
          currentVersionIterationIndex ===
          validateAndCompareVersionsWithPrerelease.length - 1;
        if (isValidSemVerRange(currentVersion)) {
          let handleVersionError = function (
            processSectionedValuesForValidatingSemVerRanges,
          ) {
            if (
              processSectionedValuesForValidatingSemVerRanges &&
              processSectionedValuesForValidatingSemVerRanges.name !==
                "AbortError" &&
              processSectionedValuesForValidatingSemVerRanges.code !==
                "ERR_STREAM_PREMATURE_CLOSE"
            ) {
              processVersionComparisonEvent(
                processSectionedValuesForValidatingSemVerRanges,
              );
            }
          };
          var handleVersionComparisonError = handleVersionError;
          if (shouldCompareVersionsForUpgrade) {
            let {
              destroy: removeErrorHandlingEventListener,
              cleanup: _removeErrorHandlingEventListener,
            } = setupEventListenerForErrorHandling(
              currentVersion,
              isNextStableVersionAvailable,
              isCurrentVersionReleased,
            );
            _semverComparisonResults.push(removeErrorHandlingEventListener);
            if (
              validateSemVerRangeValidity(currentVersion) &&
              isCurrentVersionTheMostRecentStableRelease
            ) {
              semverComparisonResults.push(_removeErrorHandlingEventListener);
            }
          }
          currentVersion.on("error", handleVersionError);
          if (
            validateSemVerRangeValidity(currentVersion) &&
            isCurrentVersionTheMostRecentStableRelease
          ) {
            semverComparisonResults.push(() => {
              currentVersion.removeListener("error", handleVersionError);
            });
          }
        }
        if (currentVersionIterationIndex === 0) {
          if (typeof currentVersion == "function") {
            validateAndCompareSemverRangesWithAbort = currentVersion({
              signal: versionValidationAbortSignal,
            });
            if (
              !setupSemVerValidationAndListeners(
                validateAndCompareSemverRangesWithAbort,
              )
            ) {
              throw new ERROR_INVALID_SEMVER_RETURN_VALUE(
                "Iterable, AsyncIterable or Stream",
                "source",
                validateAndCompareSemverRangesWithAbort,
              );
            }
          } else if (
            setupSemVerValidationAndListeners(currentVersion) ||
            _setupSemVerValidationAndListeners(currentVersion)
          ) {
            validateAndCompareSemverRangesWithAbort = currentVersion;
          } else {
            validateAndCompareSemverRangesWithAbort =
              __initializeEventListeners.from(currentVersion);
          }
        } else if (typeof currentVersion == "function") {
          validateAndCompareSemverRangesWithAbort =
            validateAndSetupVersionComparisonStream(
              validateAndCompareSemverRangesWithAbort,
            );
          validateAndCompareSemverRangesWithAbort = currentVersion(
            validateAndCompareSemverRangesWithAbort,
            {
              signal: versionValidationAbortSignal,
            },
          );
          if (isNextStableVersionAvailable) {
            if (
              !setupSemVerValidationAndListeners(
                validateAndCompareSemverRangesWithAbort,
                true,
              )
            ) {
              throw new ERROR_INVALID_SEMVER_RETURN_VALUE(
                "AsyncIterable",
                "transform[" + (currentVersionIterationIndex - 1) + "]",
                validateAndCompareSemverRangesWithAbort,
              );
            }
          } else {
            var currentVersionComparisonPromise;
            setupSemVerValidationAndEventListeners ||=
              _removeEventListenerForVersionComparison();
            let semverValidationStream =
              new setupSemVerValidationAndEventListeners({
                objectMode: true,
              });
            let versionComparisonPromiseHandler =
              (currentVersionComparisonPromise =
                validateAndCompareSemverRangesWithAbort) === null ||
              currentVersionComparisonPromise === undefined
                ? undefined
                : currentVersionComparisonPromise.then;
            if (typeof versionComparisonPromiseHandler == "function") {
              semverComparisonAbortSignal++;
              versionComparisonPromiseHandler.call(
                validateAndCompareSemverRangesWithAbort,
                (____handleVersionComparison) => {
                  handleSemverVersionComparison = ____handleVersionComparison;
                  if (____handleVersionComparison != null) {
                    semverValidationStream.write(____handleVersionComparison);
                  }
                  if (shouldCompareVersionsForUpgrade) {
                    semverValidationStream.end();
                  }
                  isSemVerRangeValidResult.nextTick(
                    processVersionComparisonEvent,
                  );
                },
                (validateAndHandleVersionStream) => {
                  semverValidationStream.destroy(
                    validateAndHandleVersionStream,
                  );
                  isSemVerRangeValidResult.nextTick(
                    processVersionComparisonEvent,
                    validateAndHandleVersionStream,
                  );
                },
              );
            } else if (
              setupSemVerValidationAndListeners(
                validateAndCompareSemverRangesWithAbort,
                true,
              )
            ) {
              semverComparisonAbortSignal++;
              handleVersionWithPrereleaseUpdates(
                validateAndCompareSemverRangesWithAbort,
                semverValidationStream,
                processVersionComparisonEvent,
                {
                  end: shouldCompareVersionsForUpgrade,
                },
              );
            } else {
              throw new ERROR_INVALID_SEMVER_RETURN_VALUE(
                "AsyncIterable or Promise",
                "destination",
                validateAndCompareSemverRangesWithAbort,
              );
            }
            validateAndCompareSemverRangesWithAbort = semverValidationStream;
            let {
              destroy: handleSemverComparisonPromise,
              cleanup: handleVersionComparisonPromise,
            } = setupEventListenerForErrorHandling(
              validateAndCompareSemverRangesWithAbort,
              false,
              true,
            );
            _semverComparisonResults.push(handleSemverComparisonPromise);
            if (isCurrentVersionTheMostRecentStableRelease) {
              semverComparisonResults.push(handleVersionComparisonPromise);
            }
          }
        } else if (isValidSemVerRange(currentVersion)) {
          if (
            _setupSemVerValidationAndListeners(
              validateAndCompareSemverRangesWithAbort,
            )
          ) {
            semverComparisonAbortSignal += 2;
            let __versionComparisonOutcome = manageAbortSignalAndStreamEvents(
              validateAndCompareSemverRangesWithAbort,
              currentVersion,
              processVersionComparisonEvent,
              {
                end: shouldCompareVersionsForUpgrade,
              },
            );
            if (
              validateSemVerRangeValidity(currentVersion) &&
              isCurrentVersionTheMostRecentStableRelease
            ) {
              semverComparisonResults.push(__versionComparisonOutcome);
            }
          } else if (
            setupSemVerValidationAndListeners(
              validateAndCompareSemverRangesWithAbort,
            )
          ) {
            semverComparisonAbortSignal++;
            handleVersionWithPrereleaseUpdates(
              validateAndCompareSemverRangesWithAbort,
              currentVersion,
              processVersionComparisonEvent,
              {
                end: shouldCompareVersionsForUpgrade,
              },
            );
          } else {
            throw new ERR_INVALID_SEMVER_ARGUMENT_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable"],
              validateAndCompareSemverRangesWithAbort,
            );
          }
          validateAndCompareSemverRangesWithAbort = currentVersion;
        } else {
          validateAndCompareSemverRangesWithAbort =
            __initializeEventListeners.from(currentVersion);
        }
      }
      if (
        (versionValidationAbortSignal != null &&
          versionValidationAbortSignal.aborted) ||
        (versionComparisonAbortSignal != null &&
          versionComparisonAbortSignal.aborted)
      ) {
        isSemVerRangeValidResult.nextTick(processAbortErrorForSemVerValidation);
      }
      return validateAndCompareSemverRangesWithAbort;
    }
    function manageAbortSignalAndStreamEvents(
      validateAbortSignalForVersionComparison,
      handleVersionComparisonAbortSignal,
      ____handleVersionComparisonEvent,
      { end: completionTimestamp },
    ) {
      let isVersionComparisonStreamClosed = false;
      handleVersionComparisonAbortSignal.on("close", () => {
        if (!isVersionComparisonStreamClosed) {
          ____handleVersionComparisonEvent(new ERROR_STREAM_UNEXPECTED_CLOSE());
        }
      });
      validateAbortSignalForVersionComparison.pipe(
        handleVersionComparisonAbortSignal,
        {
          end: completionTimestamp,
        },
      );
      if (completionTimestamp) {
        validateAbortSignalForVersionComparison.once("end", () => {
          isVersionComparisonStreamClosed = true;
          handleVersionComparisonAbortSignal.end();
        });
      } else {
        ____handleVersionComparisonEvent();
      }
      validateSemverPrereleaseVersion(
        validateAbortSignalForVersionComparison,
        {
          readable: true,
          writable: false,
        },
        (handleStreamCloseErrorEvent) => {
          let __readableStreamState =
            validateAbortSignalForVersionComparison._readableState;
          if (
            handleStreamCloseErrorEvent &&
            handleStreamCloseErrorEvent.code === "ERR_STREAM_PREMATURE_CLOSE" &&
            __readableStreamState &&
            __readableStreamState.ended &&
            !__readableStreamState.errored &&
            !__readableStreamState.errorEmitted
          ) {
            validateAbortSignalForVersionComparison
              .once("end", ____handleVersionComparisonEvent)
              .once("error", ____handleVersionComparisonEvent);
          } else {
            ____handleVersionComparisonEvent(handleStreamCloseErrorEvent);
          }
        },
      );
      return validateSemverPrereleaseVersion(
        handleVersionComparisonAbortSignal,
        {
          readable: false,
          writable: true,
        },
        ____handleVersionComparisonEvent,
      );
    }
    _setupValidationAndListenersForSemVerRanges.exports = {
      pipelineImpl: validateAndCompareSemverVersions,
      pipeline: validateAndRegisterErrorHandlerWithVersionCheck,
    };
  },
);
var validateAndHandleVersionError = lazyModuleInitializer(
  (____initializeStreamEventHandlers, validateAndHandleStreamOutput) => {
    var { pipeline: initializeStreamPipeline } = _retrieveEventListeners();
    var _setupStreamEventHandlers = setupStreamEventHandlers();
    var { destroyer: streamCleanupHandler } =
      processVersionValidationAndAbortSignals();
    var {
      isNodeStream: isNodeStream,
      isReadable: isReadableStream,
      isWritable: isWritableStream,
    } = scheduleTimeoutWithArguments();
    var {
      AbortError: StreamAbortError,
      codes: {
        ERR_INVALID_ARG_VALUE: STREAM_VALIDATION_ERROR_INVALID_ARGUMENT_VALUE,
        ERR_MISSING_ARGS: STREAM_VALIDATION_ERROR_MISSING_ARGUMENTS,
      },
    } = fetchNodeValuePostTraversal();
    validateAndHandleStreamOutput.exports = function (
      ...setupAndValidateStreams
    ) {
      if (setupAndValidateStreams.length === 0) {
        throw new STREAM_VALIDATION_ERROR_MISSING_ARGUMENTS("streams");
      }
      if (setupAndValidateStreams.length === 1) {
        return _setupStreamEventHandlers.from(setupAndValidateStreams[0]);
      }
      let streamsToValidate = [...setupAndValidateStreams];
      if (typeof setupAndValidateStreams[0] == "function") {
        setupAndValidateStreams[0] = _setupStreamEventHandlers.from(
          setupAndValidateStreams[0],
        );
      }
      if (
        typeof setupAndValidateStreams[setupAndValidateStreams.length - 1] ==
        "function"
      ) {
        let lastValidatedStreamHandlerIndex =
          setupAndValidateStreams.length - 1;
        setupAndValidateStreams[lastValidatedStreamHandlerIndex] =
          _setupStreamEventHandlers.from(
            setupAndValidateStreams[lastValidatedStreamHandlerIndex],
          );
      }
      for (
        let streamIndex = 0;
        streamIndex < setupAndValidateStreams.length;
        ++streamIndex
      ) {
        if (isNodeStream(setupAndValidateStreams[streamIndex])) {
          if (
            streamIndex < setupAndValidateStreams.length - 1 &&
            !isReadableStream(setupAndValidateStreams[streamIndex])
          ) {
            throw new STREAM_VALIDATION_ERROR_INVALID_ARGUMENT_VALUE(
              "streams[" + streamIndex + "]",
              streamsToValidate[streamIndex],
              "must be readable",
            );
          }
          if (
            streamIndex > 0 &&
            !isWritableStream(setupAndValidateStreams[streamIndex])
          ) {
            throw new STREAM_VALIDATION_ERROR_INVALID_ARGUMENT_VALUE(
              "streams[" + streamIndex + "]",
              streamsToValidate[streamIndex],
              "must be writable",
            );
          }
        }
      }
      let finalStreamHandler;
      let currentStreamIndex;
      let indexOfLastStreamToValidate;
      let validateAndSetupStreams;
      let lastValidatedStreamPosition;
      function appendVersionToStream(appendVersionToList) {
        let validateAndSetupStreamsPrior = validateAndSetupStreams;
        validateAndSetupStreams = null;
        if (validateAndSetupStreamsPrior) {
          validateAndSetupStreamsPrior(appendVersionToList);
        } else if (appendVersionToList) {
          lastValidatedStreamPosition.destroy(appendVersionToList);
        } else if (!lastStreamIndex && !lastStreamToValidateIndex) {
          lastValidatedStreamPosition.destroy();
        }
      }
      let validateAndSetupStreamHandlers = setupAndValidateStreams[0];
      let validateAndPrepareStreamHandlers = initializeStreamPipeline(
        setupAndValidateStreams,
        appendVersionToStream,
      );
      let lastStreamToValidateIndex = !!isWritableStream(
        validateAndSetupStreamHandlers,
      );
      let lastStreamIndex = !!isReadableStream(
        validateAndPrepareStreamHandlers,
      );
      lastValidatedStreamPosition = new _setupStreamEventHandlers({
        writableObjectMode:
          validateAndSetupStreamHandlers != null &&
          !!validateAndSetupStreamHandlers.writableObjectMode,
        readableObjectMode:
          validateAndPrepareStreamHandlers != null &&
          !!validateAndPrepareStreamHandlers.writableObjectMode,
        writable: lastStreamToValidateIndex,
        readable: lastStreamIndex,
      });
      if (lastStreamToValidateIndex) {
        lastValidatedStreamPosition._write = function (
          validateAndCompareVersions,
          mergeVersionBuffers,
          validateAndHandleVersionComparison,
        ) {
          if (
            validateAndSetupStreamHandlers.write(
              validateAndCompareVersions,
              mergeVersionBuffers,
            )
          ) {
            validateAndHandleVersionComparison();
          } else {
            finalStreamHandler = validateAndHandleVersionComparison;
          }
        };
        lastValidatedStreamPosition._final = function (
          validateAndAllocateBufferFromLinkedList,
        ) {
          validateAndSetupStreamHandlers.end();
          currentStreamIndex = validateAndAllocateBufferFromLinkedList;
        };
        validateAndSetupStreamHandlers.on("drain", function () {
          if (finalStreamHandler) {
            let invokeFinalStreamHandler = finalStreamHandler;
            finalStreamHandler = null;
            invokeFinalStreamHandler();
          }
        });
        validateAndPrepareStreamHandlers.on("finish", function () {
          if (currentStreamIndex) {
            let initializeStreamIndex = currentStreamIndex;
            currentStreamIndex = null;
            initializeStreamIndex();
          }
        });
      }
      if (lastStreamIndex) {
        validateAndPrepareStreamHandlers.on("readable", function () {
          if (indexOfLastStreamToValidate) {
            let executeValidationStream = indexOfLastStreamToValidate;
            indexOfLastStreamToValidate = null;
            executeValidationStream();
          }
        });
        validateAndPrepareStreamHandlers.on("end", function () {
          lastValidatedStreamPosition.push(null);
        });
        lastValidatedStreamPosition._read = function () {
          while (true) {
            let currentStreamData = validateAndPrepareStreamHandlers.read();
            if (currentStreamData === null) {
              indexOfLastStreamToValidate = lastValidatedStreamPosition._read;
              return;
            }
            if (!lastValidatedStreamPosition.push(currentStreamData)) {
              return;
            }
          }
        };
      }
      lastValidatedStreamPosition._destroy = function (
        processVersionComparisonResults,
        validateAndProcessVersionStream,
      ) {
        if (
          !processVersionComparisonResults &&
          validateAndSetupStreams !== null
        ) {
          processVersionComparisonResults = new StreamAbortError();
        }
        indexOfLastStreamToValidate = null;
        finalStreamHandler = null;
        currentStreamIndex = null;
        if (validateAndSetupStreams === null) {
          validateAndProcessVersionStream(processVersionComparisonResults);
        } else {
          validateAndSetupStreams = validateAndProcessVersionStream;
          streamCleanupHandler(
            validateAndPrepareStreamHandlers,
            processVersionComparisonResults,
          );
        }
      };
      return lastValidatedStreamPosition;
    };
  },
);
var addVersionComparisonResultToBuffer = lazyModuleInitializer(
  (_executePipelineWithSignal, executePipelineWithSignalAndHandleError) => {
    var { ArrayPrototypePop: getLastArgument, Promise: PromiseExecutor } =
      performComparisonOperation();
    var {
      isIterable: isObjectNonStreamIterable,
      isNodeStream: isNodeStreamObject,
    } = scheduleTimeoutWithArguments();
    var { pipelineImpl: pipelineImplementationFunction } =
      _retrieveEventListeners();
    var { finished: pipelineCompletionPromise } = validateStreamVersionState();
    function executeDataPipelineWithSignal(
      ...executeDataPipelineWithSignalAndOptions
    ) {
      return new PromiseExecutor(
        (processPipelineOutcome, logPipelineExecutionError) => {
          let pipelineExecutionControlOptions;
          let pipelineTerminationFlag;
          let latestPipelineExecutionResult =
            executeDataPipelineWithSignalAndOptions[
              executeDataPipelineWithSignalAndOptions.length - 1
            ];
          if (
            latestPipelineExecutionResult &&
            typeof latestPipelineExecutionResult == "object" &&
            !isNodeStreamObject(latestPipelineExecutionResult) &&
            !isObjectNonStreamIterable(latestPipelineExecutionResult)
          ) {
            let dataPipelineExecutionOutcome = getLastArgument(
              executeDataPipelineWithSignalAndOptions,
            );
            pipelineExecutionControlOptions =
              dataPipelineExecutionOutcome.signal;
            pipelineTerminationFlag = dataPipelineExecutionOutcome.end;
          }
          pipelineImplementationFunction(
            executeDataPipelineWithSignalAndOptions,
            (currentPipelineExecutionStatus, pipelineExecutionOutcome) => {
              if (currentPipelineExecutionStatus) {
                logPipelineExecutionError(currentPipelineExecutionStatus);
              } else {
                processPipelineOutcome(pipelineExecutionOutcome);
              }
            },
            {
              signal: pipelineExecutionControlOptions,
              end: pipelineTerminationFlag,
            },
          );
        },
      );
    }
    executePipelineWithSignalAndHandleError.exports = {
      finished: pipelineCompletionPromise,
      pipeline: executeDataPipelineWithSignal,
    };
  },
);
var _handleVersionComparisonStream = lazyModuleInitializer(
  (exportSectionedValuesForProcessing, _exportSectionedValuesForProcessing) => {
    retrieveAndValidateIntrinsicPropertyValue();
    var { Buffer: BufferData } = defineESModuleWithProperties(
      intrinsicPropertiesManager,
    );
    var {
      ObjectDefineProperty: defineObjectPropertyWithDescriptor,
      ObjectKeys: getObjectKeys,
      ReflectApply: executeReflectiveFunctionCall,
    } = performComparisonOperation();
    var {
      promisify: { custom: promisifyCustomFunction },
    } = validateAndProcessArrayBufferForProcessing();
    var {
      streamReturningOperators: dataStreamOperators,
      promiseReturningOperators: asyncOperationHandlers,
    } = __validateAndRetrieveIntrinsicProperties();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR: ERR_INVALID_CONSTRUCTOR },
    } = fetchNodeValuePostTraversal();
    var handleVersionError = validateAndHandleVersionError();
    var { pipeline: dataProcessingPipeline } = _retrieveEventListeners();
    var { destroyer: streamCleaner } =
      processVersionValidationAndAbortSignals();
    var validateSemanticVersionPrerelease = validateStreamVersionState();
    var handleSectionedValuesExport = addVersionComparisonResultToBuffer();
    var __exportSectionedValuesForProcessing = scheduleTimeoutWithArguments();
    var ___exportSectionedValuesForProcessing =
      (_exportSectionedValuesForProcessing.exports =
        processTarFileListenerArray().Stream);
    ___exportSectionedValuesForProcessing.isDisturbed =
      __exportSectionedValuesForProcessing.isDisturbed;
    ___exportSectionedValuesForProcessing.isErrored =
      __exportSectionedValuesForProcessing.isErrored;
    ___exportSectionedValuesForProcessing.isReadable =
      __exportSectionedValuesForProcessing.isReadable;
    ___exportSectionedValuesForProcessing.Readable = _handleEncodingErrors();
    for (let streamOperatorName of getObjectKeys(dataStreamOperators)) {
      let createStreamOperatorWithValidation = function (
        ...createDataStreamOperator
      ) {
        if (new.target) {
          throw ERR_INVALID_CONSTRUCTOR();
        }
        return ___exportSectionedValuesForProcessing.Readable.from(
          executeReflectiveFunctionCall(
            createValidatedDataStreamOperator,
            this,
            createDataStreamOperator,
          ),
        );
      };
      validatePrereleaseVersion = createStreamOperatorWithValidation;
      let createValidatedDataStreamOperator =
        dataStreamOperators[streamOperatorName];
      defineObjectPropertyWithDescriptor(
        createStreamOperatorWithValidation,
        "name",
        {
          __proto__: null,
          value: createValidatedDataStreamOperator.name,
        },
      );
      defineObjectPropertyWithDescriptor(
        createStreamOperatorWithValidation,
        "length",
        {
          __proto__: null,
          value: createValidatedDataStreamOperator.length,
        },
      );
      defineObjectPropertyWithDescriptor(
        ___exportSectionedValuesForProcessing.Readable.prototype,
        streamOperatorName,
        {
          __proto__: null,
          value: createStreamOperatorWithValidation,
          enumerable: false,
          configurable: true,
          writable: true,
        },
      );
    }
    var validatePrereleaseVersion;
    for (let operationKey of getObjectKeys(asyncOperationHandlers)) {
      let __validateSemanticVersionPrerelease = function (...argumentsList) {
        if (new.target) {
          throw ERR_INVALID_CONSTRUCTOR();
        }
        return executeReflectiveFunctionCall(
          asyncOperationHandler,
          this,
          argumentsList,
        );
      };
      validatePrereleaseVersion = __validateSemanticVersionPrerelease;
      let asyncOperationHandler = asyncOperationHandlers[operationKey];
      defineObjectPropertyWithDescriptor(
        __validateSemanticVersionPrerelease,
        "name",
        {
          __proto__: null,
          value: asyncOperationHandler.name,
        },
      );
      defineObjectPropertyWithDescriptor(
        __validateSemanticVersionPrerelease,
        "length",
        {
          __proto__: null,
          value: asyncOperationHandler.length,
        },
      );
      defineObjectPropertyWithDescriptor(
        ___exportSectionedValuesForProcessing.Readable.prototype,
        operationKey,
        {
          __proto__: null,
          value: __validateSemanticVersionPrerelease,
          enumerable: false,
          configurable: true,
          writable: true,
        },
      );
    }
    var validatePrereleaseVersion;
    ___exportSectionedValuesForProcessing.Writable =
      ___validateAndRetrieveStreamProperties();
    ___exportSectionedValuesForProcessing.Duplex = setupStreamEventHandlers();
    ___exportSectionedValuesForProcessing.Transform = __removeEventListener();
    ___exportSectionedValuesForProcessing.PassThrough =
      _removeEventListenerForVersionComparison();
    ___exportSectionedValuesForProcessing.pipeline = dataProcessingPipeline;
    var { addAbortSignal: ____exportSectionedValuesForProcessing } =
      handleErrorAndVersionComparison();
    ___exportSectionedValuesForProcessing.addAbortSignal =
      ____exportSectionedValuesForProcessing;
    ___exportSectionedValuesForProcessing.finished =
      validateSemanticVersionPrerelease;
    ___exportSectionedValuesForProcessing.destroy = streamCleaner;
    ___exportSectionedValuesForProcessing.compose = handleVersionError;
    defineObjectPropertyWithDescriptor(
      ___exportSectionedValuesForProcessing,
      "promises",
      {
        __proto__: null,
        configurable: true,
        enumerable: true,
        get() {
          return handleSectionedValuesExport;
        },
      },
    );
    defineObjectPropertyWithDescriptor(
      dataProcessingPipeline,
      promisifyCustomFunction,
      {
        __proto__: null,
        enumerable: true,
        get() {
          return handleSectionedValuesExport.pipeline;
        },
      },
    );
    defineObjectPropertyWithDescriptor(
      validateSemanticVersionPrerelease,
      promisifyCustomFunction,
      {
        __proto__: null,
        enumerable: true,
        get() {
          return handleSectionedValuesExport.finished;
        },
      },
    );
    ___exportSectionedValuesForProcessing.Stream =
      ___exportSectionedValuesForProcessing;
    ___exportSectionedValuesForProcessing._isUint8Array = function (
      allocateAndValidateBufferFromStream,
    ) {
      return allocateAndValidateBufferFromStream instanceof Uint8Array;
    };
    ___exportSectionedValuesForProcessing._uint8ArrayToBuffer = function (
      __conditionalModuleLoader,
    ) {
      return BufferData.from(
        __conditionalModuleLoader.buffer,
        __conditionalModuleLoader.byteOffset,
        __conditionalModuleLoader.byteLength,
      );
    };
  },
);
var validateEncodingIntegrity = lazyModuleInitializer(
  (initializeStreamExportUtilities, dataStreamUtilities) => {
    var validateEncodingIntegrityStatus = validateEncodingIntegrity();
    {
      let versionComparisonStreamHandler = _handleVersionComparisonStream();
      let _addVersionComparisonResultToBuffer =
        addVersionComparisonResultToBuffer();
      let releaseVersionComparisonStream =
        versionComparisonStreamHandler.Readable.destroy;
      dataStreamUtilities.exports = versionComparisonStreamHandler.Readable;
      dataStreamUtilities.exports._uint8ArrayToBuffer =
        versionComparisonStreamHandler._uint8ArrayToBuffer;
      dataStreamUtilities.exports._isUint8Array =
        versionComparisonStreamHandler._isUint8Array;
      dataStreamUtilities.exports.isDisturbed =
        versionComparisonStreamHandler.isDisturbed;
      dataStreamUtilities.exports.isErrored =
        versionComparisonStreamHandler.isErrored;
      dataStreamUtilities.exports.isReadable =
        versionComparisonStreamHandler.isReadable;
      dataStreamUtilities.exports.Readable =
        versionComparisonStreamHandler.Readable;
      dataStreamUtilities.exports.Writable =
        versionComparisonStreamHandler.Writable;
      dataStreamUtilities.exports.Duplex =
        versionComparisonStreamHandler.Duplex;
      dataStreamUtilities.exports.Transform =
        versionComparisonStreamHandler.Transform;
      dataStreamUtilities.exports.PassThrough =
        versionComparisonStreamHandler.PassThrough;
      dataStreamUtilities.exports.addAbortSignal =
        versionComparisonStreamHandler.addAbortSignal;
      dataStreamUtilities.exports.finished =
        versionComparisonStreamHandler.finished;
      dataStreamUtilities.exports.destroy =
        versionComparisonStreamHandler.destroy;
      dataStreamUtilities.exports.destroy = releaseVersionComparisonStream;
      dataStreamUtilities.exports.pipeline =
        versionComparisonStreamHandler.pipeline;
      dataStreamUtilities.exports.compose =
        versionComparisonStreamHandler.compose;
      Object.defineProperty(versionComparisonStreamHandler, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return _addVersionComparisonResultToBuffer;
        },
      });
      dataStreamUtilities.exports.Stream =
        versionComparisonStreamHandler.Stream;
    }
    dataStreamUtilities.exports.default = dataStreamUtilities.exports;
  },
);
var isEncodingValid = initializeObjectWithProperties(isPromiseValid());
var isAbortSignalProcessed = "/nodebox";
var isEncodingSupportedForProcessing = isAbortSignalProcessed;
function checkIfEncodingIsSupported() {
  return isEncodingSupportedForProcessing;
}
function normalizeFilePathSegments(
  versionStreamDecoder,
  validateStreamAndProcessVersion,
) {
  var cleanedFilePathSegments = [];
  for (
    var ___currentSegmentIndex = 0;
    ___currentSegmentIndex < versionStreamDecoder.length;
    ___currentSegmentIndex++
  ) {
    var pathSegment = versionStreamDecoder[___currentSegmentIndex];
    if (!!pathSegment && pathSegment !== ".") {
      if (pathSegment === "..") {
        if (
          cleanedFilePathSegments.length &&
          cleanedFilePathSegments[cleanedFilePathSegments.length - 1] !== ".."
        ) {
          cleanedFilePathSegments.pop();
        } else if (validateStreamAndProcessVersion) {
          cleanedFilePathSegments.push("..");
        }
      } else {
        cleanedFilePathSegments.push(pathSegment);
      }
    }
  }
  return cleanedFilePathSegments;
}
var pipelineExecutionSignal =
  /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
function extractPipelineExecutionResults(executePipelineWithOptions) {
  return pipelineExecutionSignal.exec(executePipelineWithOptions).slice(1);
}
function buildFilePathFromSegments(..._buildFilePathFromSegments) {
  var constructedFilePath = "";
  for (
    var isRootPathFound = false,
      __currentSegmentIndex = _buildFilePathFromSegments.length - 1;
    __currentSegmentIndex >= -1 && !isRootPathFound;
    __currentSegmentIndex--
  ) {
    var currentFilePathSegment =
      __currentSegmentIndex >= 0
        ? _buildFilePathFromSegments[__currentSegmentIndex]
        : checkIfEncodingIsSupported();
    if (isEncodingValid.default.isString(currentFilePathSegment)) {
      if (!currentFilePathSegment) {
        continue;
      }
    } else {
      throw new TypeError("Arguments to path.resolve must be strings");
    }
    constructedFilePath = currentFilePathSegment + "/" + constructedFilePath;
    isRootPathFound = currentFilePathSegment[0] === "/";
  }
  constructedFilePath = normalizeFilePathSegments(
    constructedFilePath.split("/"),
    !isRootPathFound,
  ).join("/");
  return (isRootPathFound ? "/" : "") + constructedFilePath || ".";
}
function doesPathBeginWithSlash(DataBufferWriter) {
  return DataBufferWriter.charAt(0) === "/";
}
function convertAndCleanFilePath(initializeBufferForEncoding) {
  var isPathAbsolute = doesPathBeginWithSlash(initializeBufferForEncoding);
  var isFilePathTerminatedWithSlash =
    initializeBufferForEncoding &&
    initializeBufferForEncoding[initializeBufferForEncoding.length - 1] === "/";
  initializeBufferForEncoding = normalizeFilePathSegments(
    initializeBufferForEncoding.split("/"),
    !isPathAbsolute,
  ).join("/");
  if (!initializeBufferForEncoding && !isPathAbsolute) {
    initializeBufferForEncoding = ".";
  }
  if (initializeBufferForEncoding && isFilePathTerminatedWithSlash) {
    initializeBufferForEncoding += "/";
  }
  return (isPathAbsolute ? "/" : "") + initializeBufferForEncoding;
}
function concatenatePathSegments(..._concatenatePathSegments) {
  var concatenatedPathSegments = "";
  for (
    var pathSegmentIndex = 0;
    pathSegmentIndex < _concatenatePathSegments.length;
    pathSegmentIndex++
  ) {
    var currentPathElement = _concatenatePathSegments[pathSegmentIndex];
    if (!isEncodingValid.default.isString(currentPathElement)) {
      throw new TypeError("Arguments to path.join must be strings");
    }
    if (currentPathElement) {
      if (concatenatedPathSegments) {
        concatenatedPathSegments += "/" + currentPathElement;
      } else {
        concatenatedPathSegments += currentPathElement;
      }
    }
  }
  return convertAndCleanFilePath(concatenatedPathSegments);
}
function formatAndFormatByteLength(calculateByteBufferLength) {
  var getFormattedByteSize = extractPipelineExecutionResults(
    calculateByteBufferLength,
  );
  var byteLengthValueBeforeUnit = getFormattedByteSize[0];
  var formattedByteSizeUnit = getFormattedByteSize[1];
  if (!byteLengthValueBeforeUnit && !formattedByteSizeUnit) {
    return ".";
  } else {
    formattedByteSizeUnit &&= formattedByteSizeUnit.substr(
      0,
      formattedByteSizeUnit.length - 1,
    );
    return byteLengthValueBeforeUnit + formattedByteSizeUnit;
  }
}
var ___calculateEncodedByteLength = initializeObjectWithProperties(
  createStyledOutputHandler(),
);
var getEncodedByteSize = Object.create;
var validateStreamOperatorPrerequisite = Object.defineProperty;
var _validateStreamOperatorPrerequisite = Object.getOwnPropertyDescriptor;
var calculateUtf8ByteLength = Object.getOwnPropertyNames;
var getEncodedByteLength = Object.getPrototypeOf;
var lastEncodedByteCountForStream = Object.prototype.hasOwnProperty;
var calculateByteLength = (
  setPropertyOrAssignValue,
  propertyKeyToAssign,
  valueToAssignBasedOnProperty,
) =>
  propertyKeyToAssign in setPropertyOrAssignValue
    ? validateStreamOperatorPrerequisite(
        setPropertyOrAssignValue,
        propertyKeyToAssign,
        {
          enumerable: true,
          configurable: true,
          writable: true,
          value: valueToAssignBasedOnProperty,
        },
      )
    : (setPropertyOrAssignValue[propertyKeyToAssign] =
        valueToAssignBasedOnProperty);
var validatePromiseReturningOperator = (
  initializeModule,
  initializeAndLoadModule,
) =>
  function () {
    if (!initializeAndLoadModule) {
      (0, initializeModule[calculateUtf8ByteLength(initializeModule)[0]])(
        (initializeAndLoadModule = {
          exports: {},
        }).exports,
        initializeAndLoadModule,
      );
    }
    return initializeAndLoadModule.exports;
  };
var executePromiseReturningOperator = (
  calculateUtf8LengthForObjectProperties,
  calculateUtf8ByteLengthForObject,
  excludedByteValueForEncoding,
  isPropertyDefinedInObject,
) => {
  if (
    (calculateUtf8ByteLengthForObject &&
      typeof calculateUtf8ByteLengthForObject == "object") ||
    typeof calculateUtf8ByteLengthForObject == "function"
  ) {
    for (let byteValueForEncoding of calculateUtf8ByteLength(
      calculateUtf8ByteLengthForObject,
    )) {
      if (
        !lastEncodedByteCountForStream.call(
          calculateUtf8LengthForObjectProperties,
          byteValueForEncoding,
        ) &&
        byteValueForEncoding !== excludedByteValueForEncoding
      ) {
        validateStreamOperatorPrerequisite(
          calculateUtf8LengthForObjectProperties,
          byteValueForEncoding,
          {
            get: () => calculateUtf8ByteLengthForObject[byteValueForEncoding],
            enumerable:
              !(isPropertyDefinedInObject = _validateStreamOperatorPrerequisite(
                calculateUtf8ByteLengthForObject,
                byteValueForEncoding,
              )) || isPropertyDefinedInObject.enumerable,
          },
        );
      }
    }
  }
  return calculateUtf8LengthForObjectProperties;
};
var lastGeneratedRandomNumber = (
  processEncodedDataForValidation,
  encodedDataByteCount,
  validatedByteSize,
) => {
  if (processEncodedDataForValidation != null) {
    validatedByteSize = getEncodedByteSize(
      getEncodedByteLength(processEncodedDataForValidation),
    );
  } else {
    validatedByteSize = {};
  }
  return executePromiseReturningOperator(
    encodedDataByteCount ||
      !processEncodedDataForValidation ||
      !processEncodedDataForValidation.__esModule
      ? validateStreamOperatorPrerequisite(validatedByteSize, "default", {
          value: processEncodedDataForValidation,
          enumerable: true,
        })
      : validatedByteSize,
    processEncodedDataForValidation,
  );
};
var currentRandomValueForDataProcessing = (
  calculateAndReturnStringByteLength,
  inputString,
  calculatedStringByteLength,
) => {
  calculateByteLength(
    calculateAndReturnStringByteLength,
    typeof inputString != "symbol" ? inputString + "" : inputString,
    calculatedStringByteLength,
  );
  return calculatedStringByteLength;
};
var sectionedValuesExporter = (
  validateValuePresenceOrThrow,
  validatePresenceInSet,
  getOperationFailureMessage,
) => {
  if (!validatePresenceInSet.has(validateValuePresenceOrThrow)) {
    throw TypeError("Cannot " + getOperationFailureMessage);
  }
};
var handleSectionedValuesExport = (
  managePrivateFieldAccess,
  retrievePrivateFieldValue,
  getPrivateFieldValue,
) => {
  sectionedValuesExporter(
    managePrivateFieldAccess,
    retrievePrivateFieldValue,
    "read from private field",
  );
  if (getPrivateFieldValue) {
    return getPrivateFieldValue.call(managePrivateFieldAccess);
  } else {
    return retrievePrivateFieldValue.get(managePrivateFieldAccess);
  }
};
var computeRemainingValue = (
  registerPrivateMember,
  privateMemberRegistry,
  registerPrivateMemberUtil,
) => {
  if (privateMemberRegistry.has(registerPrivateMember)) {
    throw TypeError("Cannot add the same private member more than once");
  }
  if (privateMemberRegistry instanceof WeakSet) {
    privateMemberRegistry.add(registerPrivateMember);
  } else {
    privateMemberRegistry.set(registerPrivateMember, registerPrivateMemberUtil);
  }
};
var validateAndTransformOutputBuffer = (
  handleAndStoreValue,
  managePrivateFieldStorage,
  dataToPersist,
  persistValueWithCallback,
) => {
  sectionedValuesExporter(
    handleAndStoreValue,
    managePrivateFieldStorage,
    "write to private field",
  );
  if (persistValueWithCallback) {
    persistValueWithCallback.call(handleAndStoreValue, dataToPersist);
  } else {
    managePrivateFieldStorage.set(handleAndStoreValue, dataToPersist);
  }
  return dataToPersist;
};
var validateDataEncodingIntegrity = (
  exportAndReturnProcessedValue,
  exportedProcessedPrivateMethodValue,
  getExportedProcessedValue,
) => {
  sectionedValuesExporter(
    exportAndReturnProcessedValue,
    exportedProcessedPrivateMethodValue,
    "access private method",
  );
  return getExportedProcessedValue;
};
var convertUint8ArrayToBuffer = validatePromiseReturningOperator({
  "../../node_modules/.pnpm/cuid@2.1.8/node_modules/cuid/lib/pad.js"(
    zeroPadBufferToMatchEncoding,
    _zeroPadBufferToMatchEncoding,
  ) {
    _zeroPadBufferToMatchEncoding.exports = function (
      computeRemainingByteBuffer,
      processCharacterEncoding,
    ) {
      var paddedByteBuffer = "000000000" + computeRemainingByteBuffer;
      return paddedByteBuffer.substr(
        paddedByteBuffer.length - processCharacterEncoding,
      );
    };
  },
});
var initializeStreamUtilities = validatePromiseReturningOperator({
  "../../node_modules/.pnpm/cuid@2.1.8/node_modules/cuid/lib/fingerprint.browser.js"(
    generateBrowserFingerprint,
    _exportBrowserFingerprint,
  ) {
    var generateBrowserFingerprintBuffer = convertUint8ArrayToBuffer();
    var browserContext = typeof window == "object" ? window : self;
    var totalGlobalVariablesInContext = Object.keys(browserContext).length;
    var countOfMimeTypesInBrowser = navigator.mimeTypes
      ? navigator.mimeTypes.length
      : 0;
    var generateUniqueBrowserIdentifier = generateBrowserFingerprintBuffer(
      (countOfMimeTypesInBrowser + navigator.userAgent.length).toString(36) +
        totalGlobalVariablesInContext.toString(36),
      4,
    );
    _exportBrowserFingerprint.exports = function () {
      return generateUniqueBrowserIdentifier;
    };
  },
});
var convertObjectPropertyToUTF8 = validatePromiseReturningOperator({
  "../../node_modules/.pnpm/cuid@2.1.8/node_modules/cuid/lib/getRandomValue.browser.js"(
    getRandomValue,
    getSecureRandomValue,
  ) {
    var getRandomNormalizedValue;
    var isCryptoSupported =
      (typeof window !== "undefined" && (window.crypto || window.msCrypto)) ||
      (typeof self !== "undefined" && self.crypto);
    if (isCryptoSupported) {
      maxUint32RandomValue = Math.pow(2, 32) - 1;
      getRandomNormalizedValue = function () {
        return Math.abs(
          isCryptoSupported.getRandomValues(new Uint32Array(1))[0] /
            maxUint32RandomValue,
        );
      };
    } else {
      getRandomNormalizedValue = Math.random;
    }
    var maxUint32RandomValue;
    getSecureRandomValue.exports = getRandomNormalizedValue;
  },
});
var processPathSegmentsForNormalization = validatePromiseReturningOperator({
  "../../node_modules/.pnpm/cuid@2.1.8/node_modules/cuid/index.js"(
    generateUniqueIdentifier,
    generateFormattedUniqueIdentifierId,
  ) {
    var initializeUniqueIdentifierStream = initializeStreamUtilities();
    var convertUint8ArrayToBufferFormattedIdentifier =
      convertUint8ArrayToBuffer();
    var generateCuidUniqueIdentifier = convertObjectPropertyToUTF8();
    var currentUniqueIdentifierIndex = 0;
    var uniqueIdentifierBitLength = 4;
    var base36Value = 36;
    var maxAllowedUniqueIdentifiers = Math.pow(
      base36Value,
      uniqueIdentifierBitLength,
    );
    function createCUIDBufferIdentifier() {
      return convertUint8ArrayToBufferFormattedIdentifier(
        (
          (generateCuidUniqueIdentifier() * maxAllowedUniqueIdentifiers) <<
          0
        ).toString(base36Value),
        uniqueIdentifierBitLength,
      );
    }
    function retrieveNextAvailableIdentifier() {
      if (currentUniqueIdentifierIndex < maxAllowedUniqueIdentifiers) {
        currentUniqueIdentifierIndex = currentUniqueIdentifierIndex;
      } else {
        currentUniqueIdentifierIndex = 0;
      }
      currentUniqueIdentifierIndex++;
      return currentUniqueIdentifierIndex - 1;
    }
    function createCustomIdentifier() {
      var identifierPrefix = "c";
      var currentTimestampBase36 = new Date().getTime().toString(base36Value);
      var bufferFormattedUniqueIdentifier =
        convertUint8ArrayToBufferFormattedIdentifier(
          retrieveNextAvailableIdentifier().toString(base36Value),
          uniqueIdentifierBitLength,
        );
      var _initializeUniqueIdentifierStream =
        initializeUniqueIdentifierStream();
      var formattedUniqueIdentifiers =
        createCUIDBufferIdentifier() + createCUIDBufferIdentifier();
      return (
        identifierPrefix +
        currentTimestampBase36 +
        bufferFormattedUniqueIdentifier +
        _initializeUniqueIdentifierStream +
        formattedUniqueIdentifiers
      );
    }
    createCustomIdentifier.slug = function () {
      var _currentTimestampBase36 = new Date().getTime().toString(36);
      var lastFourDigitsOfUniqueId = retrieveNextAvailableIdentifier()
        .toString(36)
        .slice(-4);
      var _identifierPrefix =
        initializeUniqueIdentifierStream().slice(0, 1) +
        initializeUniqueIdentifierStream().slice(-1);
      var lastTwoDigitsOfFormattedUniqueIdentifier =
        createCUIDBufferIdentifier().slice(-2);
      return (
        _currentTimestampBase36.slice(-2) +
        lastFourDigitsOfUniqueId +
        _identifierPrefix +
        lastTwoDigitsOfFormattedUniqueIdentifier
      );
    };
    createCustomIdentifier.isCuid = function (initializePathBufferForEncoding) {
      if (typeof initializePathBufferForEncoding != "string") {
        return false;
      } else {
        return !!initializePathBufferForEncoding.startsWith("c");
      }
    };
    createCustomIdentifier.isSlug = function (computeEncodedString) {
      if (typeof computeEncodedString != "string") {
        return false;
      }
      var computeEncodedStringLength = computeEncodedString.length;
      return (
        computeEncodedStringLength >= 7 && computeEncodedStringLength <= 10
      );
    };
    createCustomIdentifier.fingerprint = initializeUniqueIdentifierStream;
    generateFormattedUniqueIdentifierId.exports = createCustomIdentifier;
  },
});
var encodeDataToBase64 = validatePromiseReturningOperator({
  "../../node_modules/.pnpm/@open-draft+deferred-promise@2.1.0/node_modules/@open-draft/deferred-promise/build/createDeferredExecutor.js"(
    deferredPromiseExecutor,
  ) {
    "use strict";

    Object.defineProperty(deferredPromiseExecutor, "__esModule", {
      value: true,
    });
    deferredPromiseExecutor.createDeferredExecutor = undefined;
    function createCustomDeferredPromise() {
      let createDeferredPromise = (
        createDeferredPromiseWithHandlers,
        handlePromiseRejectionForDeferred,
      ) => {
        createDeferredPromise.state = "pending";
        createDeferredPromise.resolve = (processDeferredPromiseResolution) => {
          if (createDeferredPromise.state !== "pending") {
            return;
          }
          createDeferredPromise.result = processDeferredPromiseResolution;
          let completeDeferredPromiseResolution = (createResolvedPromise) => {
            createDeferredPromise.state = "fulfilled";
            return createResolvedPromise;
          };
          return createDeferredPromiseWithHandlers(
            processDeferredPromiseResolution instanceof Promise
              ? processDeferredPromiseResolution
              : Promise.resolve(processDeferredPromiseResolution).then(
                  completeDeferredPromiseResolution,
                ),
          );
        };
        createDeferredPromise.reject = (processPendingPromiseRejection) => {
          if (createDeferredPromise.state === "pending") {
            queueMicrotask(() => {
              createDeferredPromise.state = "rejected";
            });
            return handlePromiseRejectionForDeferred(
              (createDeferredPromise.rejectionReason =
                processPendingPromiseRejection),
            );
          }
        };
      };
      return createDeferredPromise;
    }
    deferredPromiseExecutor.createDeferredExecutor =
      createCustomDeferredPromise;
  },
});
var processAndValidateStreamOperator = validatePromiseReturningOperator({
  "../../node_modules/.pnpm/@open-draft+deferred-promise@2.1.0/node_modules/@open-draft/deferred-promise/build/DeferredPromise.js"(
    _DeferredPromiseHandler,
  ) {
    "use strict";

    Object.defineProperty(_DeferredPromiseHandler, "__esModule", {
      value: true,
    });
    _DeferredPromiseHandler.DeferredPromise = undefined;
    var _createDeferredExecutor = encodeDataToBase64();
    var UserSessionDeferredPromise = class extends Promise {
      #e;
      resolve;
      reject;
      constructor(_currentUserSession = null) {
        let deferredTaskExecutor = (0,
        _createDeferredExecutor.createDeferredExecutor)();
        super((scheduleDeferredTaskExecution, deferredTaskExecutionDelay) => {
          deferredTaskExecutor(
            scheduleDeferredTaskExecution,
            deferredTaskExecutionDelay,
          );
          _currentUserSession?.(
            deferredTaskExecutor.resolve,
            deferredTaskExecutor.reject,
          );
        });
        this.#e = deferredTaskExecutor;
        this.resolve = this.#e.resolve;
        this.reject = this.#e.reject;
      }
      get state() {
        return this.#e.state;
      }
      get rejectionReason() {
        return this.#e.rejectionReason;
      }
      then(processThenPromise, handlePromiseResolutionWithProcessing) {
        return this.#t(
          super.then(processThenPromise, handlePromiseResolutionWithProcessing),
        );
      }
      catch(handleCatchError) {
        return this.#t(super.catch(handleCatchError));
      }
      finally(finalActionHandler) {
        return this.#t(super.finally(finalActionHandler));
      }
      #t(definePromiseResolutionHandlers) {
        return Object.defineProperties(definePromiseResolutionHandlers, {
          resolve: {
            configurable: true,
            value: this.resolve,
          },
          reject: {
            configurable: true,
            value: this.reject,
          },
        });
      }
    };
    _DeferredPromiseHandler.DeferredPromise = UserSessionDeferredPromise;
  },
});
var throwErrorForInvalidArgument = validatePromiseReturningOperator({
  "../../node_modules/.pnpm/@open-draft+deferred-promise@2.1.0/node_modules/@open-draft/deferred-promise/build/index.js"(
    deferredPromiseModuleExports,
  ) {
    "use strict";

    var createPropertyBinding =
      (deferredPromiseModuleExports &&
        deferredPromiseModuleExports.__createBinding) ||
      (Object.create
        ? function (
            validateOutputAndStoreValue,
            createErrorMessageForMissingArguments,
            validateAndHandleMissingArguments,
            _validateAndHandleMissingArguments = validateAndHandleMissingArguments,
          ) {
            var errorHandlerPropertyDescriptor =
              Object.getOwnPropertyDescriptor(
                createErrorMessageForMissingArguments,
                validateAndHandleMissingArguments,
              );
            if (
              !errorHandlerPropertyDescriptor ||
              ("get" in errorHandlerPropertyDescriptor
                ? !createErrorMessageForMissingArguments.__esModule
                : errorHandlerPropertyDescriptor.writable ||
                  errorHandlerPropertyDescriptor.configurable)
            ) {
              errorHandlerPropertyDescriptor = {
                enumerable: true,
                get() {
                  return createErrorMessageForMissingArguments[
                    validateAndHandleMissingArguments
                  ];
                },
              };
            }
            Object.defineProperty(
              validateOutputAndStoreValue,
              _validateAndHandleMissingArguments,
              errorHandlerPropertyDescriptor,
            );
          }
        : function (
            processAsyncDataIterator,
            fetchNextAsyncIteratorValue,
            processIteratorControlFlow,
            _processIteratorControlFlow = processIteratorControlFlow,
          ) {
            processAsyncDataIterator[_processIteratorControlFlow] =
              fetchNextAsyncIteratorValue[processIteratorControlFlow];
          });
    var createPropertyBindingFromModule =
      (deferredPromiseModuleExports &&
        deferredPromiseModuleExports.__exportStar) ||
      function (
        initializeAndExportBrowserFingerprint,
        initializeFingerprintForBrowser,
      ) {
        for (var _propertyName in initializeAndExportBrowserFingerprint) {
          if (
            _propertyName !== "default" &&
            !Object.prototype.hasOwnProperty.call(
              initializeFingerprintForBrowser,
              _propertyName,
            )
          ) {
            createPropertyBinding(
              initializeFingerprintForBrowser,
              initializeAndExportBrowserFingerprint,
              _propertyName,
            );
          }
        }
      };
    Object.defineProperty(deferredPromiseModuleExports, "__esModule", {
      value: true,
    });
    createPropertyBindingFromModule(
      encodeDataToBase64(),
      deferredPromiseModuleExports,
    );
    createPropertyBindingFromModule(
      processAndValidateStreamOperator(),
      deferredPromiseModuleExports,
    );
  },
});
var exportBrowserFingerprint = validatePromiseReturningOperator({
  "../../node_modules/.pnpm/strict-event-emitter@0.4.3/node_modules/strict-event-emitter/lib/MemoryLeakError.js"(
    EventEmitterMemoryLeakError,
  ) {
    "use strict";

    Object.defineProperty(EventEmitterMemoryLeakError, "__esModule", {
      value: true,
    });
    EventEmitterMemoryLeakError.MemoryLeakError = undefined;
    var EventEmitterMemoryLeakWarning = class extends Error {
      emitter;
      type;
      count;
      constructor(
        EventEmitterWarningConstructor,
        maxListenersExceededWarning,
        exceededListenerCount,
      ) {
        super(
          "Possible EventEmitter memory leak detected. " +
            exceededListenerCount +
            " " +
            maxListenersExceededWarning.toString() +
            " listeners added. Use emitter.setMaxListeners() to increase limit",
        );
        this.emitter = EventEmitterWarningConstructor;
        this.type = maxListenersExceededWarning;
        this.count = exceededListenerCount;
        this.name = "MaxListenersExceededWarning";
      }
    };
    EventEmitterMemoryLeakError.MemoryLeakError = EventEmitterMemoryLeakWarning;
  },
});
var processAndNormalizePathSegments = validatePromiseReturningOperator({
  "../../node_modules/.pnpm/strict-event-emitter@0.4.3/node_modules/strict-event-emitter/lib/Emitter.js"(
    ReliableEventEmitter,
  ) {
    "use strict";

    Object.defineProperty(ReliableEventEmitter, "__esModule", {
      value: true,
    });
    ReliableEventEmitter.Emitter = undefined;
    var initializeBrowserFingerprint = exportBrowserFingerprint();
    var pendingEventOutputBuffer;
    var pendingCallbacksBuffer;
    var eventCallbackRegistry;
    var pendingAsyncEventHandlers;
    var eventHandler;
    var processEvent;
    var eventCallbackMap;
    var eventHandlersQueue;
    var internalEventEmitterState;
    var internalEventManagementState;
    var eventStateManager;
    var EventEmitterHandler = class {
      constructor() {
        computeRemainingValue(this, pendingAsyncEventHandlers);
        computeRemainingValue(this, processEvent);
        computeRemainingValue(this, eventHandlersQueue);
        computeRemainingValue(this, internalEventManagementState);
        computeRemainingValue(this, pendingEventOutputBuffer, undefined);
        computeRemainingValue(this, pendingCallbacksBuffer, undefined);
        computeRemainingValue(this, eventCallbackRegistry, undefined);
        validateAndTransformOutputBuffer(
          this,
          pendingEventOutputBuffer,
          new Map(),
        );
        validateAndTransformOutputBuffer(
          this,
          pendingCallbacksBuffer,
          EventEmitterHandler.defaultMaxListeners,
        );
        validateAndTransformOutputBuffer(this, eventCallbackRegistry, false);
      }
      static listenerCount(getListenerCountByIdentifier, listenerId) {
        return getListenerCountByIdentifier.listenerCount(listenerId);
      }
      setMaxListeners(maxListenersBufferSize) {
        validateAndTransformOutputBuffer(
          this,
          pendingCallbacksBuffer,
          maxListenersBufferSize,
        );
        return this;
      }
      getMaxListeners() {
        return handleSectionedValuesExport(this, pendingCallbacksBuffer);
      }
      eventNames() {
        return Array.from(
          handleSectionedValuesExport(this, pendingEventOutputBuffer).keys(),
        );
      }
      emit(_handleDataEncodingErrors, ...errorHandlerParams) {
        let dataEncodingErrorHandlers = validateDataEncodingIntegrity(
          this,
          pendingAsyncEventHandlers,
          eventHandler,
        ).call(this, _handleDataEncodingErrors);
        dataEncodingErrorHandlers.forEach((applyErrorHandler) => {
          applyErrorHandler.apply(this, errorHandlerParams);
        });
        return dataEncodingErrorHandlers.length > 0;
      }
      addListener(addEventListenerWithCallback, handleNewEventListener) {
        validateDataEncodingIntegrity(
          this,
          internalEventManagementState,
          eventStateManager,
        ).call(
          this,
          "newListener",
          addEventListenerWithCallback,
          handleNewEventListener,
        );
        let combinedEventListenerCallbacks = validateDataEncodingIntegrity(
          this,
          pendingAsyncEventHandlers,
          eventHandler,
        )
          .call(this, addEventListenerWithCallback)
          .concat(handleNewEventListener);
        handleSectionedValuesExport(this, pendingEventOutputBuffer).set(
          addEventListenerWithCallback,
          combinedEventListenerCallbacks,
        );
        if (
          handleSectionedValuesExport(this, pendingCallbacksBuffer) > 0 &&
          this.listenerCount(addEventListenerWithCallback) >
            handleSectionedValuesExport(this, pendingCallbacksBuffer) &&
          !handleSectionedValuesExport(this, eventCallbackRegistry)
        ) {
          validateAndTransformOutputBuffer(this, eventCallbackRegistry, true);
          let browserFingerprintMemoryLeakError =
            new initializeBrowserFingerprint.MemoryLeakError(
              this,
              addEventListenerWithCallback,
              this.listenerCount(addEventListenerWithCallback),
            );
          console.warn(browserFingerprintMemoryLeakError);
        }
        return this;
      }
      on(_addEventListenerWithCallback, __eventListenerCallback) {
        return this.addListener(
          _addEventListenerWithCallback,
          __eventListenerCallback,
        );
      }
      once(addDataEncodingErrorListener, handleDataEncodingError) {
        return this.addListener(
          addDataEncodingErrorListener,
          validateDataEncodingIntegrity(
            this,
            eventHandlersQueue,
            internalEventEmitterState,
          ).call(this, addDataEncodingErrorListener, handleDataEncodingError),
        );
      }
      prependListener(pendingEventHandlerKey, eventHandlerCallback) {
        let dataIntegrityErrors = validateDataEncodingIntegrity(
          this,
          pendingAsyncEventHandlers,
          eventHandler,
        ).call(this, pendingEventHandlerKey);
        if (dataIntegrityErrors.length > 0) {
          let combinedEventHandlersAndErrors = [eventHandlerCallback].concat(
            dataIntegrityErrors,
          );
          handleSectionedValuesExport(this, pendingEventOutputBuffer).set(
            pendingEventHandlerKey,
            combinedEventHandlersAndErrors,
          );
        } else {
          handleSectionedValuesExport(this, pendingEventOutputBuffer).set(
            pendingEventHandlerKey,
            dataIntegrityErrors.concat(eventHandlerCallback),
          );
        }
        return this;
      }
      prependOnceListener(
        prependUniqueEventListener,
        prependListenerWithEncodingValidation,
      ) {
        return this.prependListener(
          prependUniqueEventListener,
          validateDataEncodingIntegrity(
            this,
            eventHandlersQueue,
            internalEventEmitterState,
          ).call(
            this,
            prependUniqueEventListener,
            prependListenerWithEncodingValidation,
          ),
        );
      }
      removeListener(handleRemoveDataListener, removeListenerEventEmitter) {
        let dataEncodingValidationErrors = validateDataEncodingIntegrity(
          this,
          pendingAsyncEventHandlers,
          eventHandler,
        ).call(this, handleRemoveDataListener);
        if (dataEncodingValidationErrors.length > 0) {
          validateDataEncodingIntegrity(
            this,
            processEvent,
            eventCallbackMap,
          ).call(
            this,
            dataEncodingValidationErrors,
            removeListenerEventEmitter,
          );
          handleSectionedValuesExport(this, pendingEventOutputBuffer).set(
            handleRemoveDataListener,
            dataEncodingValidationErrors,
          );
          validateDataEncodingIntegrity(
            this,
            internalEventManagementState,
            eventStateManager,
          ).call(
            this,
            "removeListener",
            handleRemoveDataListener,
            removeListenerEventEmitter,
          );
        }
        return this;
      }
      off(removeEventHandlerByType, eventType) {
        return this.removeListener(removeEventHandlerByType, eventType);
      }
      removeAllListeners(removeListenerByIdentifier) {
        if (removeListenerByIdentifier) {
          handleSectionedValuesExport(this, pendingEventOutputBuffer).delete(
            removeListenerByIdentifier,
          );
        } else {
          handleSectionedValuesExport(this, pendingEventOutputBuffer).clear();
        }
        return this;
      }
      listeners(encodedEventData) {
        return Array.from(
          validateDataEncodingIntegrity(
            this,
            pendingAsyncEventHandlers,
            eventHandler,
          ).call(this, encodedEventData),
        );
      }
      listenerCount(eventHandlerValidation) {
        return validateDataEncodingIntegrity(
          this,
          pendingAsyncEventHandlers,
          eventHandler,
        ).call(this, eventHandlerValidation).length;
      }
      rawListeners(fetchEventListeners) {
        return this.listeners(fetchEventListeners);
      }
    };
    var _eventStateManager = EventEmitterHandler;
    pendingEventOutputBuffer = new WeakMap();
    pendingCallbacksBuffer = new WeakMap();
    eventCallbackRegistry = new WeakMap();
    pendingAsyncEventHandlers = new WeakSet();
    eventHandler = function (setUpDeferredStream) {
      return (
        handleSectionedValuesExport(this, pendingEventOutputBuffer).get(
          setUpDeferredStream,
        ) || []
      );
    };
    processEvent = new WeakSet();
    eventCallbackMap = function (DeferredStream, DeferredPromiseHandler) {
      let handlerIndexInStream = DeferredStream.indexOf(DeferredPromiseHandler);
      if (handlerIndexInStream > -1) {
        DeferredStream.splice(handlerIndexInStream, 1);
      }
      return [];
    };
    eventHandlersQueue = new WeakSet();
    internalEventEmitterState = function (
      bindModuleExports,
      setupReadableStreamState,
    ) {
      let unbindAndResetStream = (...streamStateArgs) => {
        this.removeListener(bindModuleExports, unbindAndResetStream);
        setupReadableStreamState.apply(this, streamStateArgs);
      };
      return unbindAndResetStream;
    };
    internalEventManagementState = new WeakSet();
    eventStateManager = function (
      validateArgumentsInRange,
      __validateNumberInRange,
      handleMissingArgumentsError,
    ) {
      this.emit(
        validateArgumentsInRange,
        __validateNumberInRange,
        handleMissingArgumentsError,
      );
    };
    currentRandomValueForDataProcessing(
      _eventStateManager,
      "defaultMaxListeners",
      10,
    );
    ReliableEventEmitter.Emitter = _eventStateManager;
  },
});
var validateNumberWithinSpecifiedRange = validatePromiseReturningOperator({
  "../../node_modules/.pnpm/strict-event-emitter@0.4.3/node_modules/strict-event-emitter/lib/index.js"(
    StrictEventEmitter,
  ) {
    "use strict";

    var createBindingFromModule =
      (StrictEventEmitter && StrictEventEmitter.__createBinding) ||
      (Object.create
        ? function (
            processIteratorControlFlowWithAsyncData,
            handleAsyncDataIteration,
            validateAndPushReadableStreamData,
            __validateAndPushReadableStreamData = validateAndPushReadableStreamData,
          ) {
            var readableStreamDataPropertyDescriptor =
              Object.getOwnPropertyDescriptor(
                handleAsyncDataIteration,
                validateAndPushReadableStreamData,
              );
            if (
              !readableStreamDataPropertyDescriptor ||
              ("get" in readableStreamDataPropertyDescriptor
                ? !handleAsyncDataIteration.__esModule
                : readableStreamDataPropertyDescriptor.writable ||
                  readableStreamDataPropertyDescriptor.configurable)
            ) {
              readableStreamDataPropertyDescriptor = {
                enumerable: true,
                get() {
                  return handleAsyncDataIteration[
                    validateAndPushReadableStreamData
                  ];
                },
              };
            }
            Object.defineProperty(
              processIteratorControlFlowWithAsyncData,
              __validateAndPushReadableStreamData,
              readableStreamDataPropertyDescriptor,
            );
          }
        : function (
            ___validateNumberInRange,
            validateNumberWithinRange,
            validateAndHandleCacheEntry,
            ___validateAndHandleCacheEntry = validateAndHandleCacheEntry,
          ) {
            ___validateNumberInRange[___validateAndHandleCacheEntry] =
              validateNumberWithinRange[validateAndHandleCacheEntry];
          });
    var createBindingForEventEmitter =
      (StrictEventEmitter && StrictEventEmitter.__exportStar) ||
      function (validateListenerCountInRange, _validateCacheEntry) {
        for (var listenerCountValidationKey in validateListenerCountInRange) {
          if (
            listenerCountValidationKey !== "default" &&
            !Object.prototype.hasOwnProperty.call(
              _validateCacheEntry,
              listenerCountValidationKey,
            )
          ) {
            createBindingFromModule(
              _validateCacheEntry,
              validateListenerCountInRange,
              listenerCountValidationKey,
            );
          }
        }
      };
    Object.defineProperty(StrictEventEmitter, "__esModule", {
      value: true,
    });
    createBindingForEventEmitter(
      processAndNormalizePathSegments(),
      StrictEventEmitter,
    );
    createBindingForEventEmitter(
      exportBrowserFingerprint(),
      StrictEventEmitter,
    );
  },
});
var validateListenerCountConstraints = lastGeneratedRandomNumber(
  processPathSegmentsForNormalization(),
);
var addChunkToReadableStream = /(%?)(%([sdjo]))/g;
function handleDataBasedOnValidation(
  handleReadableChunk,
  validateAndProcessCacheEntry,
) {
  switch (validateAndProcessCacheEntry) {
    case "s":
      return handleReadableChunk;
    case "d":
    case "i":
      return Number(handleReadableChunk);
    case "j":
      return JSON.stringify(handleReadableChunk);
    case "o": {
      if (typeof handleReadableChunk == "string") {
        return handleReadableChunk;
      }
      let stringifiedReadableChunk = JSON.stringify(handleReadableChunk);
      if (
        stringifiedReadableChunk === "{}" ||
        stringifiedReadableChunk === "[]" ||
        /^\[object .+?\]$/.test(stringifiedReadableChunk)
      ) {
        return handleReadableChunk;
      } else {
        return stringifiedReadableChunk;
      }
    }
  }
}
function transformAndCacheEventEmitterWithAdditionalPlugins(
  validateAndCacheEventEmitterCallbacks,
  ...transformationsForEventProcessing
) {
  if (transformationsForEventProcessing.length === 0) {
    return validateAndCacheEventEmitterCallbacks;
  }
  let currentTransformationIndex = 0;
  let cachedAndTransformedEventCallbacks =
    validateAndCacheEventEmitterCallbacks.replace(
      addChunkToReadableStream,
      (
        applyTransformationToData,
        isDataValidForProcessing,
        applyTransformationToAndProcessData,
        handleDataTransformation,
      ) => {
        let currentTransformation =
          transformationsForEventProcessing[currentTransformationIndex];
        let validatedAndTransformedData = handleDataBasedOnValidation(
          currentTransformation,
          handleDataTransformation,
        );
        if (isDataValidForProcessing) {
          return applyTransformationToData;
        } else {
          currentTransformationIndex++;
          return validatedAndTransformedData;
        }
      },
    );
  if (currentTransformationIndex < transformationsForEventProcessing.length) {
    cachedAndTransformedEventCallbacks +=
      " " +
      transformationsForEventProcessing
        .slice(currentTransformationIndex)
        .join(" ");
  }
  cachedAndTransformedEventCallbacks =
    cachedAndTransformedEventCallbacks.replace(/%{2,2}/g, "%");
  return cachedAndTransformedEventCallbacks;
}
var eventListenerRegistrationValidator = 2;
function sanitizeCacheStack(_validateCacheEntry) {
  if (!_validateCacheEntry.stack) {
    return;
  }
  let parsedCacheStackLines = _validateCacheEntry.stack.split("\n");
  parsedCacheStackLines.splice(1, eventListenerRegistrationValidator);
  _validateCacheEntry.stack = parsedCacheStackLines.join("\n");
}
var validateDataIntegrityAndHandleEncodingErrors = class extends Error {
  constructor(formattedErrorMessage, ...errorMessageParameters) {
    super(formattedErrorMessage);
    this.message = formattedErrorMessage;
    this.name = "Invariant Violation";
    this.message = transformAndCacheEventEmitterWithAdditionalPlugins(
      formattedErrorMessage,
      ...errorMessageParameters,
    );
    sanitizeCacheStack(this);
  }
};
var validateAndTransformOutputForEventListeners = (
  isCacheEntryValid,
  isCacheEntryValidError,
  ...cacheEntryValidationError
) => {
  if (!isCacheEntryValid) {
    throw new validateDataIntegrityAndHandleEncodingErrors(
      isCacheEntryValidError,
      ...cacheEntryValidationError,
    );
  }
};
validateAndTransformOutputForEventListeners.as = (
  processErrorOrInstantiate,
  handleOrCreateErrorInstance,
  errorOrHandle,
  ...errorHandlingParameters
) => {
  if (!handleOrCreateErrorInstance) {
    throw processErrorOrInstantiate.prototype.name != null
      ? new processErrorOrInstantiate(
          transformAndCacheEventEmitterWithAdditionalPlugins(
            errorOrHandle,
            errorHandlingParameters,
          ),
        )
      : processErrorOrInstantiate(
          transformAndCacheEventEmitterWithAdditionalPlugins(
            errorOrHandle,
            errorHandlingParameters,
          ),
        );
  }
};
var processCacheEntry = lastGeneratedRandomNumber(
  throwErrorForInvalidArgument(),
);
var eventHandler = window.localStorage.CSB_EMULATOR_DEBUG;
var addEventListenerWithValidation = "[0m";
var eventListenerManager = "[32;1m";
var eventHandlerCacheEntry = "[31m";
var isEventListenerValid = "[34m";
var validateCacheEntryIntegrity = "[33;1m";
var isCacheEntryValidForEvent = "[35;1m";
var validateDataCacheIntegrity = "[36;1m";
var cacheEntry = {
  preview: validateCacheEntryIntegrity,
  emulator: isCacheEntryValidForEvent,
  runtime: validateDataCacheIntegrity,
  bridge: isEventListenerValid,
  "runtime:worker": validateDataCacheIntegrity,
};
function logCacheEntryDataWithEncodingError(handleEventWithEncodingError) {
  return function (
    validateAndHandleDataEncodingErrors,
    ...additionalDebugInfo
  ) {
    let determineCacheEntryRoleBasedOnSenderReceiver = () =>
      validateAndHandleDataEncodingErrors.includes("sender")
        ? eventListenerManager + "sender"
        : validateAndHandleDataEncodingErrors.includes("receiver")
          ? eventHandlerCacheEntry + "receiver"
          : "";
    let sanitizedCacheEntry = validateAndHandleDataEncodingErrors.replace(
      /\[.+\]:/,
      "",
    );
    console.debug(
      "" +
        cacheEntry[handleEventWithEncodingError] +
        handleEventWithEncodingError +
        ":" +
        determineCacheEntryRoleBasedOnSenderReceiver() +
        addEventListenerWithValidation +
        ":" +
        sanitizedCacheEntry,
      ...additionalDebugInfo,
    );
  };
}
var processCacheEntryForEventHandler =
  logCacheEntryDataWithEncodingError("emulator");
var validateSectionedValueCaching = class {
  emitter;
  senderPort = null;
  constructor() {
    this.emitter = new EventTarget();
    this.waitForHandshake();
  }
  waitForHandshake() {
    let handshakeCompletionPromise = new processCacheEntry.DeferredPromise();
    let _handleIncomingHandshakeMessage = (_processIncomingMessage) => {
      let { data: incomingMessageData } = _processIncomingMessage;
      processCacheEntryForEventHandler(
        "[message-receiver]: incoming",
        _processIncomingMessage,
      );
      if (incomingMessageData.type === "internal/handshake") {
        validateAndTransformOutputForEventListeners(
          _processIncomingMessage.ports.length > 0,
          "Failed to confirm a MessageReceiver handshake: received event has no ports",
        );
        this.senderPort = _processIncomingMessage.ports[0];
        this.addMessageListener();
        processCacheEntryForEventHandler(
          "[message-receiver]: handshake received!",
          this.senderPort,
        );
        this.send("internal/handshake/done");
        processCacheEntryForEventHandler(
          "[message-receiver]: finish handshake",
        );
      }
    };
    window.addEventListener("message", _handleIncomingHandshakeMessage);
    handshakeCompletionPromise.then(() => {
      window.removeEventListener("message", _handleIncomingHandshakeMessage);
    });
    window.parent.postMessage(
      {
        type: "internal/ready",
      },
      "*",
    );
    return handshakeCompletionPromise;
  }
  addMessageListener() {
    validateAndTransformOutputForEventListeners(
      this.senderPort,
      "[MessageReceiver] Failed to add a message listener: sender port is not defined. Did you forget to await a handshake?",
    );
    this.senderPort.onmessage = (dispatchMessageBasedOnDataEvent) => {
      let dispatchMessageData = dispatchMessageBasedOnDataEvent.data;
      if (dispatchMessageData.type != null) {
        this.emitter.dispatchEvent(
          new MessageEvent(dispatchMessageData.type, {
            data: dispatchMessageData.payload,
          }),
        );
      }
    };
  }
  on(
    registerOperationMessageHandler,
    processOperationPayload,
    messageEventListenerOptions,
  ) {
    this.emitter.addEventListener(
      registerOperationMessageHandler,
      async (handleIncomingMessageEvent) => {
        if (!(handleIncomingMessageEvent instanceof MessageEvent)) {
          return;
        }
        let { operationId: operationIdentifier, payload: operationData } =
          handleIncomingMessageEvent.data;
        try {
          let processedOperationResult =
            await processOperationPayload(operationData);
          this.send("internal/operation/done", {
            operationId: operationIdentifier,
            listenerPayload: processedOperationResult,
          });
        } catch (operationError) {
          if (operationError instanceof Error) {
            this.send("internal/operation/failed", {
              operationId: operationIdentifier,
              error: operationError,
            });
          }
        }
      },
      messageEventListenerOptions,
    );
  }
  send(messageType, ...messageContents) {
    validateAndTransformOutputForEventListeners(
      this.senderPort,
      '[MessageReceiver] Failed to send a message "%j": sender port is not defined. Did you forget to await a handshake?',
      messageType,
    );
    let _messagePayload = messageContents[0] || {};
    processCacheEntryForEventHandler(
      '[message-receiver]: send "%s"',
      messageType,
      _messagePayload,
    );
    this.senderPort.postMessage({
      type: messageType,
      payload: _messagePayload,
    });
  }
};
var incrementNodeRemovalCounter = lastGeneratedRandomNumber(
  throwErrorForInvalidArgument(),
);
var validateAndEmitEvent = lastGeneratedRandomNumber(
  processPathSegmentsForNormalization(),
);
var _incrementNodeRemovalCounter = lastGeneratedRandomNumber(
  validateNumberWithinSpecifiedRange(),
);
var validateNodeRemoval = lastGeneratedRandomNumber(
  throwErrorForInvalidArgument(),
);
var ____validateNumberInRange = logCacheEntryDataWithEncodingError("emulator");
var validateStreamAndPushData = initializeObjectWithProperties(
  createStyledOutputHandler(),
);
var calculateReadableStringLength = 4294967295;
function updateStreamDataMetrics(
  computeVisibleStringLength,
  _____validateNumberInRange,
  calculateReadableLength,
) {
  var streamDataLengthInGigabytes = calculateReadableLength / 4294967296;
  var totalStreamDataSizeInBytes = calculateReadableLength;
  computeVisibleStringLength.setUint32(
    _____validateNumberInRange,
    streamDataLengthInGigabytes,
  );
  computeVisibleStringLength.setUint32(
    _____validateNumberInRange + 4,
    totalStreamDataSizeInBytes,
  );
}
function configureBuffersUsingSignalLength(
  retrieveStreamDataLength,
  validateAndPushStreamData,
  validateStreamDataAndHandleAbortSignal,
) {
  var calculateBufferSizeFromSignalLength = Math.floor(
    validateStreamDataAndHandleAbortSignal / 4294967296,
  );
  var streamDataBufferSize = validateStreamDataAndHandleAbortSignal;
  retrieveStreamDataLength.setUint32(
    validateAndPushStreamData,
    calculateBufferSizeFromSignalLength,
  );
  retrieveStreamDataLength.setUint32(
    validateAndPushStreamData + 4,
    streamDataBufferSize,
  );
}
function computeLargeIntegerFromStreamData(
  _validateAndPushReadableStreamData,
  fetchAndProcessAsyncData,
) {
  var _computeLargeIntegerFromStreamData =
    _validateAndPushReadableStreamData.getInt32(fetchAndProcessAsyncData);
  var lowOrderPartOfLargeInteger = _validateAndPushReadableStreamData.getUint32(
    fetchAndProcessAsyncData + 4,
  );
  return (
    _computeLargeIntegerFromStreamData * 4294967296 + lowOrderPartOfLargeInteger
  );
}
function convertUInt32PairToNumber(
  _validateAndHandleCacheEntry,
  validateReadableStreamAndAssign,
) {
  var extractHighOrderUInt32 = _validateAndHandleCacheEntry.getUint32(
    validateReadableStreamAndAssign,
  );
  var extractLowOrderUInt32 = _validateAndHandleCacheEntry.getUint32(
    validateReadableStreamAndAssign + 4,
  );
  return extractHighOrderUInt32 * 4294967296 + extractLowOrderUInt32;
}
var cacheEntryBufferLength =
  (typeof process === "undefined" ||
    (process == null ? undefined : process.env)?.TEXT_ENCODING !== "never") &&
  typeof TextEncoder !== "undefined" &&
  typeof TextDecoder !== "undefined";
function calculateUtf8ByteSize(validateListenerCountWithinConstraints) {
  for (
    var totalCharacterCount = validateListenerCountWithinConstraints.length,
      byteLength = 0,
      __currentCharacterIndex = 0;
    __currentCharacterIndex < totalCharacterCount;

  ) {
    var currentCharacterCode =
      validateListenerCountWithinConstraints.charCodeAt(
        __currentCharacterIndex++,
      );
    if ((currentCharacterCode & 4294967168) === 0) {
      byteLength++;
      continue;
    } else if ((currentCharacterCode & 4294965248) === 0) {
      byteLength += 2;
    } else {
      if (
        currentCharacterCode >= 55296 &&
        currentCharacterCode <= 56319 &&
        __currentCharacterIndex < totalCharacterCount
      ) {
        var currentCharacterUnicode =
          validateListenerCountWithinConstraints.charCodeAt(
            __currentCharacterIndex,
          );
        if ((currentCharacterUnicode & 64512) === 56320) {
          ++__currentCharacterIndex;
          currentCharacterCode =
            ((currentCharacterCode & 1023) << 10) +
            (currentCharacterUnicode & 1023) +
            65536;
        }
      }
      if ((currentCharacterCode & 4294901760) === 0) {
        byteLength += 3;
      } else {
        byteLength += 4;
      }
    }
  }
  return byteLength;
}
function validateAndProcessDataStream(
  processAndSerializeDataStream,
  processAndValidateReadableStream,
  isStreamReadyForProcessing,
) {
  for (
    var dataStreamTotalLength = processAndSerializeDataStream.length,
      startingIndexForProcessedDataStream = isStreamReadyForProcessing,
      _currentCharacterIndex = 0;
    _currentCharacterIndex < dataStreamTotalLength;

  ) {
    var currentCharacterCharCode = processAndSerializeDataStream.charCodeAt(
      _currentCharacterIndex++,
    );
    if ((currentCharacterCharCode & 4294967168) === 0) {
      processAndValidateReadableStream[startingIndexForProcessedDataStream++] =
        currentCharacterCharCode;
      continue;
    } else if ((currentCharacterCharCode & 4294965248) === 0) {
      processAndValidateReadableStream[startingIndexForProcessedDataStream++] =
        ((currentCharacterCharCode >> 6) & 31) | 192;
    } else {
      if (
        currentCharacterCharCode >= 55296 &&
        currentCharacterCharCode <= 56319 &&
        _currentCharacterIndex < dataStreamTotalLength
      ) {
        var currentCharacterUtf16Code =
          processAndSerializeDataStream.charCodeAt(_currentCharacterIndex);
        if ((currentCharacterUtf16Code & 64512) === 56320) {
          ++_currentCharacterIndex;
          currentCharacterCharCode =
            ((currentCharacterCharCode & 1023) << 10) +
            (currentCharacterUtf16Code & 1023) +
            65536;
        }
      }
      if ((currentCharacterCharCode & 4294901760) === 0) {
        processAndValidateReadableStream[
          startingIndexForProcessedDataStream++
        ] = ((currentCharacterCharCode >> 12) & 15) | 224;
        processAndValidateReadableStream[
          startingIndexForProcessedDataStream++
        ] = ((currentCharacterCharCode >> 6) & 63) | 128;
      } else {
        processAndValidateReadableStream[
          startingIndexForProcessedDataStream++
        ] = ((currentCharacterCharCode >> 18) & 7) | 240;
        processAndValidateReadableStream[
          startingIndexForProcessedDataStream++
        ] = ((currentCharacterCharCode >> 12) & 63) | 128;
        processAndValidateReadableStream[
          startingIndexForProcessedDataStream++
        ] = ((currentCharacterCharCode >> 6) & 63) | 128;
      }
    }
    processAndValidateReadableStream[startingIndexForProcessedDataStream++] =
      (currentCharacterCharCode & 63) | 128;
  }
}
var validateAndSanitizeCacheEntry = cacheEntryBufferLength
  ? new TextEncoder()
  : undefined;
var validateAndTransformCacheEntry = cacheEntryBufferLength
  ? typeof process !== "undefined" &&
    (process == null ? undefined : process.env)?.TEXT_ENCODING !== "force"
    ? 200
    : 0
  : calculateReadableStringLength;
function encodeAndValidateCacheDataChunk(
  validateAndTransformCacheData,
  _validateAndProcessCacheEntry,
  validateAndFormatCacheEntry,
) {
  _validateAndProcessCacheEntry.set(
    validateAndSanitizeCacheEntry.encode(validateAndTransformCacheData),
    validateAndFormatCacheEntry,
  );
}
function processAndEncodeBufferedCacheData(
  validateAndHandleCacheEntryErrors,
  validateAndTransformBufferedData,
  validateAndProcessPendingCacheData,
) {
  validateAndSanitizeCacheEntry.encodeInto(
    validateAndHandleCacheEntryErrors,
    validateAndTransformBufferedData.subarray(
      validateAndProcessPendingCacheData,
    ),
  );
}
var currentDataEntryCount = validateAndSanitizeCacheEntry?.encodeInto
  ? processAndEncodeBufferedCacheData
  : encodeAndValidateCacheDataChunk;
var __validateAndHandleCacheEntry = 4096;
function convertBufferToUtf8(
  validateCacheEntryAndThrowErrorIfInvalid,
  processStreamData,
  _validateAndTransformCacheEntry,
) {
  for (
    var bufferIndex = processStreamData,
      endOfDecodingBufferIndex = bufferIndex + _validateAndTransformCacheEntry,
      unicodeCharactersBuffer = [],
      transformedUnicodeString = "";
    bufferIndex < endOfDecodingBufferIndex;

  ) {
    var currentUtf8Byte =
      validateCacheEntryAndThrowErrorIfInvalid[bufferIndex++];
    if ((currentUtf8Byte & 128) === 0) {
      unicodeCharactersBuffer.push(currentUtf8Byte);
    } else if ((currentUtf8Byte & 224) === 192) {
      var decodedBufferSegment =
        validateCacheEntryAndThrowErrorIfInvalid[bufferIndex++] & 63;
      unicodeCharactersBuffer.push(
        ((currentUtf8Byte & 31) << 6) | decodedBufferSegment,
      );
    } else if ((currentUtf8Byte & 240) === 224) {
      var decodedBufferSegment =
        validateCacheEntryAndThrowErrorIfInvalid[bufferIndex++] & 63;
      var secondDecodedBufferSegment =
        validateCacheEntryAndThrowErrorIfInvalid[bufferIndex++] & 63;
      unicodeCharactersBuffer.push(
        ((currentUtf8Byte & 31) << 12) |
          (decodedBufferSegment << 6) |
          secondDecodedBufferSegment,
      );
    } else if ((currentUtf8Byte & 248) === 240) {
      var decodedBufferSegment =
        validateCacheEntryAndThrowErrorIfInvalid[bufferIndex++] & 63;
      var secondDecodedBufferSegment =
        validateCacheEntryAndThrowErrorIfInvalid[bufferIndex++] & 63;
      var thirdDecodedBufferSegment =
        validateCacheEntryAndThrowErrorIfInvalid[bufferIndex++] & 63;
      var _decodedUnicodeCharacter =
        ((currentUtf8Byte & 7) << 18) |
        (decodedBufferSegment << 12) |
        (secondDecodedBufferSegment << 6) |
        thirdDecodedBufferSegment;
      if (_decodedUnicodeCharacter > 65535) {
        _decodedUnicodeCharacter -= 65536;
        unicodeCharactersBuffer.push(
          ((_decodedUnicodeCharacter >>> 10) & 1023) | 55296,
        );
        _decodedUnicodeCharacter = (_decodedUnicodeCharacter & 1023) | 56320;
      }
      unicodeCharactersBuffer.push(_decodedUnicodeCharacter);
    } else {
      unicodeCharactersBuffer.push(currentUtf8Byte);
    }
    if (unicodeCharactersBuffer.length >= __validateAndHandleCacheEntry) {
      transformedUnicodeString += String.fromCharCode.apply(
        String,
        unicodeCharactersBuffer,
      );
      unicodeCharactersBuffer.length = 0;
    }
  }
  if (unicodeCharactersBuffer.length > 0) {
    transformedUnicodeString += String.fromCharCode.apply(
      String,
      unicodeCharactersBuffer,
    );
  }
  return transformedUnicodeString;
}
var processIncomingMessageForHandshake = cacheEntryBufferLength
  ? new TextDecoder()
  : null;
var logCacheEntryForEventHandling = cacheEntryBufferLength
  ? typeof process !== "undefined" &&
    (process == null ? undefined : process.env)?.TEXT_DECODER !== "force"
    ? 200
    : 0
  : calculateReadableStringLength;
function processReadableStateChangeForHandshake(
  handleIncomingMessageForHandshake,
  handleIncomingHandshakeMessage,
  _handleIncomingMessageForHandshake,
) {
  var createHandshakeMessageSlice = handleIncomingMessageForHandshake.subarray(
    handleIncomingHandshakeMessage,
    handleIncomingHandshakeMessage + _handleIncomingMessageForHandshake,
  );
  return processIncomingMessageForHandshake.decode(createHandshakeMessageSlice);
}
var processIncomingMessage = (function () {
  function IncomingMessageHandler(
    handleIncomingMessage,
    handleReadableStateChange,
  ) {
    this.type = handleIncomingMessage;
    this.data = handleReadableStateChange;
  }
  return IncomingMessageHandler;
})();
var handleIncomingMessageReceiverHandshake = (function () {
  function processReadableStreamMessages(
    handleReadableStateChange,
    registerMessageReceiver,
  ) {
    processReadableStreamMessages =
      Object.setPrototypeOf ||
      ({
        __proto__: [],
      } instanceof Array &&
        function (
          processIncomingMessages,
          handleStreamReadableStateProcessing,
        ) {
          processIncomingMessages.__proto__ =
            handleStreamReadableStateProcessing;
        }) ||
      function (_handleIncomingMessage, validateStreamReadability) {
        for (var incomingStreamValidationKey in validateStreamReadability) {
          if (
            Object.prototype.hasOwnProperty.call(
              validateStreamReadability,
              incomingStreamValidationKey,
            )
          ) {
            _handleIncomingMessage[incomingStreamValidationKey] =
              validateStreamReadability[incomingStreamValidationKey];
          }
        }
      };
    return processReadableStreamMessages(
      handleReadableStateChange,
      registerMessageReceiver,
    );
  }
  return function (executeOperationIfNeeded, initializeMessageListener) {
    if (
      typeof initializeMessageListener != "function" &&
      initializeMessageListener !== null
    ) {
      throw new TypeError(
        "Class extends value " +
          String(initializeMessageListener) +
          " is not a constructor or null",
      );
    }
    processReadableStreamMessages(
      executeOperationIfNeeded,
      initializeMessageListener,
    );
    function initializeNextTickExecution() {
      this.constructor = executeOperationIfNeeded;
    }
    if (initializeMessageListener === null) {
      executeOperationIfNeeded.prototype = Object.create(
        initializeMessageListener,
      );
    } else {
      executeOperationIfNeeded.prototype =
        ((initializeNextTickExecution.prototype =
          initializeMessageListener.prototype),
        new initializeNextTickExecution());
    }
  };
})();
var messageSendingOperation = (function (sendMessageToListener) {
  handleIncomingMessageReceiverHandshake(
    createCharacterEncodingHandler,
    sendMessageToListener,
  );
  function createCharacterEncodingHandler(calculateAndHandleCharacterEncoding) {
    var characterEncodingHandler =
      sendMessageToListener.call(this, calculateAndHandleCharacterEncoding) ||
      this;
    var characterEncodingHandlerPrototype = Object.create(
      createCharacterEncodingHandler.prototype,
    );
    Object.setPrototypeOf(
      characterEncodingHandler,
      characterEncodingHandlerPrototype,
    );
    Object.defineProperty(characterEncodingHandler, "name", {
      configurable: true,
      enumerable: false,
      value: createCharacterEncodingHandler.name,
    });
    return characterEncodingHandler;
  }
  return createCharacterEncodingHandler;
})(Error);
var validateCharacterEncoding = -1;
var validateAndProcessCharacterEncoding = 4294967295;
var validateCharacterEncodingAndProcessStreamData = 17179869183;
function ________validateAndProcessCharacterEncoding(
  processCharacterEncodingValidationAndProcessing,
) {
  var retrieveEncodedCharacterValue =
    processCharacterEncodingValidationAndProcessing.sec;
  var validateAndProcessCharacterEncodingData =
    processCharacterEncodingValidationAndProcessing.nsec;
  if (
    retrieveEncodedCharacterValue >= 0 &&
    validateAndProcessCharacterEncodingData >= 0 &&
    retrieveEncodedCharacterValue <=
      validateCharacterEncodingAndProcessStreamData
  ) {
    if (
      validateAndProcessCharacterEncodingData === 0 &&
      retrieveEncodedCharacterValue <= validateAndProcessCharacterEncoding
    ) {
      var characterEncodingBuffer = new Uint8Array(4);
      var characterEncodingDataViewBuffer = new DataView(
        characterEncodingBuffer.buffer,
      );
      characterEncodingDataViewBuffer.setUint32(
        0,
        retrieveEncodedCharacterValue,
      );
      return characterEncodingBuffer;
    } else {
      var decodedCharacterValue = retrieveEncodedCharacterValue / 4294967296;
      var encodedCharacterValueLow = retrieveEncodedCharacterValue & 4294967295;
      var characterEncodingBuffer = new Uint8Array(8);
      var characterEncodingDataViewBuffer = new DataView(
        characterEncodingBuffer.buffer,
      );
      characterEncodingDataViewBuffer.setUint32(
        0,
        (validateAndProcessCharacterEncodingData << 2) |
          (decodedCharacterValue & 3),
      );
      characterEncodingDataViewBuffer.setUint32(4, encodedCharacterValueLow);
      return characterEncodingBuffer;
    }
  } else {
    var characterEncodingBuffer = new Uint8Array(12);
    var characterEncodingDataViewBuffer = new DataView(
      characterEncodingBuffer.buffer,
    );
    characterEncodingDataViewBuffer.setUint32(
      0,
      validateAndProcessCharacterEncodingData,
    );
    configureBuffersUsingSignalLength(
      characterEncodingDataViewBuffer,
      4,
      retrieveEncodedCharacterValue,
    );
    return characterEncodingBuffer;
  }
}
function getEndEventTimeInNanoseconds(onEndEmittedEvent) {
  var endEventTimestampInMillis = onEndEmittedEvent.getTime();
  var getEventEndTimeInSeconds = Math.floor(endEventTimestampInMillis / 1000);
  var calculateEndEventTime =
    (endEventTimestampInMillis - getEventEndTimeInSeconds * 1000) * 1000000;
  var endEventTimeInSecondsFractional = Math.floor(
    calculateEndEventTime / 1000000000,
  );
  return {
    sec: getEventEndTimeInSeconds + endEventTimeInSecondsFractional,
    nsec: calculateEndEventTime - endEventTimeInSecondsFractional * 1000000000,
  };
}
function validateAndProcessTimestampForEncoding(_calculateUtf8ByteLength) {
  if (_calculateUtf8ByteLength instanceof Date) {
    var endEventTimeInNanosecondsForValidation = getEndEventTimeInNanoseconds(
      _calculateUtf8ByteLength,
    );
    return ________validateAndProcessCharacterEncoding(
      endEventTimeInNanosecondsForValidation,
    );
  } else {
    return null;
  }
}
function extractTimestampFromBuffer(handleStreamUnpipe) {
  var timestampDataViewForStreamBuffer = new DataView(
    handleStreamUnpipe.buffer,
    handleStreamUnpipe.byteOffset,
    handleStreamUnpipe.byteLength,
  );
  switch (handleStreamUnpipe.byteLength) {
    case 4: {
      var timestampInNanosecondsWithOffset =
        timestampDataViewForStreamBuffer.getUint32(0);
      var secondsSinceEpoch = 0;
      return {
        sec: timestampInNanosecondsWithOffset,
        nsec: secondsSinceEpoch,
      };
    }
    case 8: {
      var extractTimestampFromStreamBuffer =
        timestampDataViewForStreamBuffer.getUint32(0);
      var nanosecondsSinceEpoch = timestampDataViewForStreamBuffer.getUint32(4);
      var timestampInNanosecondsWithOffset =
        (extractTimestampFromStreamBuffer & 3) * 4294967296 +
        nanosecondsSinceEpoch;
      var secondsSinceEpoch = extractTimestampFromStreamBuffer >>> 2;
      return {
        sec: timestampInNanosecondsWithOffset,
        nsec: secondsSinceEpoch,
      };
    }
    case 12: {
      var timestampInNanosecondsWithOffset = computeLargeIntegerFromStreamData(
        timestampDataViewForStreamBuffer,
        4,
      );
      var secondsSinceEpoch = timestampDataViewForStreamBuffer.getUint32(0);
      return {
        sec: timestampInNanosecondsWithOffset,
        nsec: secondsSinceEpoch,
      };
    }
    default:
      throw new messageSendingOperation(
        `Unrecognized data size for timestamp (expected 4, 8, or 12): ${handleStreamUnpipe.length}`,
      );
  }
}
function convertProcessEndTimestampToDate(processEndOfCharacterEncoding) {
  var convertProcessEndTimestampToDateObject = extractTimestampFromBuffer(
    processEndOfCharacterEncoding,
  );
  return new Date(
    convertProcessEndTimestampToDateObject.sec * 1000 +
      convertProcessEndTimestampToDateObject.nsec / 1000000,
  );
}
var isDataBeingProcessed = {
  type: validateCharacterEncoding,
  encode: validateAndProcessTimestampForEncoding,
  decode: convertProcessEndTimestampToDate,
};
var processWritablePipes = (function () {
  function DataProcessor() {
    this.builtInEncoders = [];
    this.builtInDecoders = [];
    this.encoders = [];
    this.decoders = [];
    this.register(isDataBeingProcessed);
  }
  DataProcessor.prototype.register = function (
    processAndValidateCharacterEncoding,
  ) {
    var inputCharacterEncodingType = processAndValidateCharacterEncoding.type;
    var encodeCharacterBasedOnType = processAndValidateCharacterEncoding.encode;
    var decodeCharacterEncodingBasedOnType =
      processAndValidateCharacterEncoding.decode;
    if (inputCharacterEncodingType >= 0) {
      this.encoders[inputCharacterEncodingType] = encodeCharacterBasedOnType;
      this.decoders[inputCharacterEncodingType] =
        decodeCharacterEncodingBasedOnType;
    } else {
      var characterEncodingTypeIndex = 1 + inputCharacterEncodingType;
      this.builtInEncoders[characterEncodingTypeIndex] =
        encodeCharacterBasedOnType;
      this.builtInDecoders[characterEncodingTypeIndex] =
        decodeCharacterEncodingBasedOnType;
    }
  };
  DataProcessor.prototype.tryToEncode = function (
    validateAndProcessCharacterEncodingForCacheEntry,
    processCacheDataForEncoding,
  ) {
    for (
      var currentEncoderIndex = 0;
      currentEncoderIndex < this.builtInEncoders.length;
      currentEncoderIndex++
    ) {
      var currentCharacterEncodingHandler =
        this.builtInEncoders[currentEncoderIndex];
      if (currentCharacterEncodingHandler != null) {
        var characterEncodingHandler = currentCharacterEncodingHandler(
          validateAndProcessCharacterEncodingForCacheEntry,
          processCacheDataForEncoding,
        );
        if (characterEncodingHandler != null) {
          var incomingMessageOffset = -1 - currentEncoderIndex;
          return new processIncomingMessage(
            incomingMessageOffset,
            characterEncodingHandler,
          );
        }
      }
    }
    for (
      var currentEncoderIndex = 0;
      currentEncoderIndex < this.encoders.length;
      currentEncoderIndex++
    ) {
      var currentCharacterEncodingHandler = this.encoders[currentEncoderIndex];
      if (currentCharacterEncodingHandler != null) {
        var characterEncodingHandler = currentCharacterEncodingHandler(
          validateAndProcessCharacterEncodingForCacheEntry,
          processCacheDataForEncoding,
        );
        if (characterEncodingHandler != null) {
          var incomingMessageOffset = currentEncoderIndex;
          return new processIncomingMessage(
            incomingMessageOffset,
            characterEncodingHandler,
          );
        }
      }
    }
    if (
      validateAndProcessCharacterEncodingForCacheEntry instanceof
      processIncomingMessage
    ) {
      return validateAndProcessCharacterEncodingForCacheEntry;
    } else {
      return null;
    }
  };
  DataProcessor.prototype.decode = function (
    _validateAndProcessCharacterEncoding,
    decodeUTF8Character,
    validateAndProcessUnicodeCharacterEncoding,
  ) {
    var getDecoderForEncoding =
      decodeUTF8Character < 0
        ? this.builtInDecoders[-1 - decodeUTF8Character]
        : this.decoders[decodeUTF8Character];
    if (getDecoderForEncoding) {
      return getDecoderForEncoding(
        _validateAndProcessCharacterEncoding,
        decodeUTF8Character,
        validateAndProcessUnicodeCharacterEncoding,
      );
    } else {
      return new processIncomingMessage(
        decodeUTF8Character,
        _validateAndProcessCharacterEncoding,
      );
    }
  };
  DataProcessor.defaultCodec = new DataProcessor();
  return DataProcessor;
})();
function convertToUint8ArrayWithValidation(validateAndDecodeCharacterEncoding) {
  if (validateAndDecodeCharacterEncoding instanceof Uint8Array) {
    return validateAndDecodeCharacterEncoding;
  } else if (ArrayBuffer.isView(validateAndDecodeCharacterEncoding)) {
    return new Uint8Array(
      validateAndDecodeCharacterEncoding.buffer,
      validateAndDecodeCharacterEncoding.byteOffset,
      validateAndDecodeCharacterEncoding.byteLength,
    );
  } else if (validateAndDecodeCharacterEncoding instanceof ArrayBuffer) {
    return new Uint8Array(validateAndDecodeCharacterEncoding);
  } else {
    return Uint8Array.from(validateAndDecodeCharacterEncoding);
  }
}
function generateDataViewFromBuffer(handleReadableStateChangeAfterDecoding) {
  if (handleReadableStateChangeAfterDecoding instanceof ArrayBuffer) {
    return new DataView(handleReadableStateChangeAfterDecoding);
  }
  var convertedUint8ArrayForDataView = convertToUint8ArrayWithValidation(
    handleReadableStateChangeAfterDecoding,
  );
  return new DataView(
    convertedUint8ArrayForDataView.buffer,
    convertedUint8ArrayForDataView.byteOffset,
    convertedUint8ArrayForDataView.byteLength,
  );
}
var handleReadableStreamStateManagement = 100;
var processIncomingHandshakeMessage = 2048;
var handleReadableStreamStateProcessing = (function () {
  function WritablePipeSettings(
    processWritablePipesDefaultCodec = processWritablePipes.defaultCodec,
    initialDataValue = undefined,
    __handleReadableStreamStateManagement = handleReadableStreamStateManagement,
    _processIncomingHandshakeMessage = processIncomingHandshakeMessage,
    _isInputValid = false,
    isNewFeatureActive = false,
    userIsLoggedIn = false,
    isBackgroundTaskRunning = false,
  ) {
    this.extensionCodec = processWritablePipesDefaultCodec;
    this.context = initialDataValue;
    this.maxDepth = __handleReadableStreamStateManagement;
    this.initialBufferSize = _processIncomingHandshakeMessage;
    this.sortKeys = _isInputValid;
    this.forceFloat32 = isNewFeatureActive;
    this.ignoreUndefined = userIsLoggedIn;
    this.forceIntegerToFloat = isBackgroundTaskRunning;
    this.pos = 0;
    this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
    this.bytes = new Uint8Array(this.view.buffer);
  }
  WritablePipeSettings.prototype.reinitializeState = function () {
    this.pos = 0;
  };
  WritablePipeSettings.prototype.encodeSharedRef = function (
    updateStreamStateWithIncomingMessage,
  ) {
    this.reinitializeState();
    this.doEncode(updateStreamStateWithIncomingMessage, 1);
    return this.bytes.subarray(0, this.pos);
  };
  WritablePipeSettings.prototype.encode = function (detachReadableStream) {
    this.reinitializeState();
    this.doEncode(detachReadableStream, 1);
    return this.bytes.slice(0, this.pos);
  };
  WritablePipeSettings.prototype.doEncode = function (
    handleIncomingMessageStream,
    disconnectMessageStream,
  ) {
    if (disconnectMessageStream > this.maxDepth) {
      throw new Error(`Too deep objects in depth ${disconnectMessageStream}`);
    }
    if (handleIncomingMessageStream == null) {
      this.encodeNil();
    } else if (typeof handleIncomingMessageStream == "boolean") {
      this.encodeBoolean(handleIncomingMessageStream);
    } else if (typeof handleIncomingMessageStream == "number") {
      this.encodeNumber(handleIncomingMessageStream);
    } else if (typeof handleIncomingMessageStream == "string") {
      this.encodeString(handleIncomingMessageStream);
    } else {
      this.encodeObject(handleIncomingMessageStream, disconnectMessageStream);
    }
  };
  WritablePipeSettings.prototype.ensureBufferSizeToWrite = function (
    managePipeUnpipeOperations,
  ) {
    var calculatedBufferPosition = this.pos + managePipeUnpipeOperations;
    if (this.view.byteLength < calculatedBufferPosition) {
      this.resizeBuffer(calculatedBufferPosition * 2);
    }
  };
  WritablePipeSettings.prototype.resizeBuffer = function (
    processPipeDisconnection,
  ) {
    var _bufferSize = new ArrayBuffer(processPipeDisconnection);
    var _dataByteArray = new Uint8Array(_bufferSize);
    var bufferDataView = new DataView(_bufferSize);
    _dataByteArray.set(this.bytes);
    this.view = bufferDataView;
    this.bytes = _dataByteArray;
  };
  WritablePipeSettings.prototype.encodeNil = function () {
    this.writeU8(192);
  };
  WritablePipeSettings.prototype.encodeBoolean = function (
    __validateAndProcessCharacterEncoding,
  ) {
    if (__validateAndProcessCharacterEncoding === false) {
      this.writeU8(194);
    } else {
      this.writeU8(195);
    }
  };
  WritablePipeSettings.prototype.encodeNumber = function (
    validateAndProcessCharacterEncodingStream,
  ) {
    if (
      Number.isSafeInteger(validateAndProcessCharacterEncodingStream) &&
      !this.forceIntegerToFloat
    ) {
      if (validateAndProcessCharacterEncodingStream >= 0) {
        if (validateAndProcessCharacterEncodingStream < 128) {
          this.writeU8(validateAndProcessCharacterEncodingStream);
        } else if (validateAndProcessCharacterEncodingStream < 256) {
          this.writeU8(204);
          this.writeU8(validateAndProcessCharacterEncodingStream);
        } else if (validateAndProcessCharacterEncodingStream < 65536) {
          this.writeU8(205);
          this.writeU16(validateAndProcessCharacterEncodingStream);
        } else if (validateAndProcessCharacterEncodingStream < 4294967296) {
          this.writeU8(206);
          this.writeU32(validateAndProcessCharacterEncodingStream);
        } else {
          this.writeU8(207);
          this.writeU64(validateAndProcessCharacterEncodingStream);
        }
      } else if (validateAndProcessCharacterEncodingStream >= -32) {
        this.writeU8((validateAndProcessCharacterEncodingStream + 32) | 224);
      } else if (validateAndProcessCharacterEncodingStream >= -128) {
        this.writeU8(208);
        this.writeI8(validateAndProcessCharacterEncodingStream);
      } else if (validateAndProcessCharacterEncodingStream >= -32768) {
        this.writeU8(209);
        this.writeI16(validateAndProcessCharacterEncodingStream);
      } else if (validateAndProcessCharacterEncodingStream >= -2147483648) {
        this.writeU8(210);
        this.writeI32(validateAndProcessCharacterEncodingStream);
      } else {
        this.writeU8(211);
        this.writeI64(validateAndProcessCharacterEncodingStream);
      }
    } else if (this.forceFloat32) {
      this.writeU8(202);
      this.writeF32(validateAndProcessCharacterEncodingStream);
    } else {
      this.writeU8(203);
      this.writeF64(validateAndProcessCharacterEncodingStream);
    }
  };
  WritablePipeSettings.prototype.writeStringHeader = function (
    processCharacterEncodingData,
  ) {
    if (processCharacterEncodingData < 32) {
      this.writeU8(160 + processCharacterEncodingData);
    } else if (processCharacterEncodingData < 256) {
      this.writeU8(217);
      this.writeU8(processCharacterEncodingData);
    } else if (processCharacterEncodingData < 65536) {
      this.writeU8(218);
      this.writeU16(processCharacterEncodingData);
    } else if (processCharacterEncodingData < 4294967296) {
      this.writeU8(219);
      this.writeU32(processCharacterEncodingData);
    } else {
      throw new Error(
        `Too long string: ${processCharacterEncodingData} bytes in UTF-8`,
      );
    }
  };
  WritablePipeSettings.prototype.encodeString = function (
    validateAndProcessEventTimestamp,
  ) {
    var defaultBufferSize = 5;
    var getEventTimestampLength = validateAndProcessEventTimestamp.length;
    if (getEventTimestampLength > validateAndTransformCacheEntry) {
      var eventTimestampUtf8ByteSize = calculateUtf8ByteSize(
        validateAndProcessEventTimestamp,
      );
      this.ensureBufferSizeToWrite(
        defaultBufferSize + eventTimestampUtf8ByteSize,
      );
      this.writeStringHeader(eventTimestampUtf8ByteSize);
      currentDataEntryCount(
        validateAndProcessEventTimestamp,
        this.bytes,
        this.pos,
      );
      this.pos += eventTimestampUtf8ByteSize;
    } else {
      var eventTimestampUtf8ByteSize = calculateUtf8ByteSize(
        validateAndProcessEventTimestamp,
      );
      this.ensureBufferSizeToWrite(
        defaultBufferSize + eventTimestampUtf8ByteSize,
      );
      this.writeStringHeader(eventTimestampUtf8ByteSize);
      validateAndProcessDataStream(
        validateAndProcessEventTimestamp,
        this.bytes,
        this.pos,
      );
      this.pos += eventTimestampUtf8ByteSize;
    }
  };
  WritablePipeSettings.prototype.encodeObject = function (
    extractTimestampFromDataView,
    parseTimestampData,
  ) {
    var encodedTimestampConstraints = this.extensionCodec.tryToEncode(
      extractTimestampFromDataView,
      this.context,
    );
    if (encodedTimestampConstraints != null) {
      this.encodeExtension(encodedTimestampConstraints);
    } else if (Array.isArray(extractTimestampFromDataView)) {
      this.encodeArray(extractTimestampFromDataView, parseTimestampData);
    } else if (ArrayBuffer.isView(extractTimestampFromDataView)) {
      this.encodeBinary(extractTimestampFromDataView);
    } else if (typeof extractTimestampFromDataView == "object") {
      this.encodeMap(extractTimestampFromDataView, parseTimestampData);
    } else {
      throw new Error(
        `Unrecognized object: ${Object.prototype.toString.apply(extractTimestampFromDataView)}`,
      );
    }
  };
  WritablePipeSettings.prototype.encodeBinary = function (
    handleStreamDataValidation,
  ) {
    var suspendUpdateDataByteLength = handleStreamDataValidation.byteLength;
    if (suspendUpdateDataByteLength < 256) {
      this.writeU8(196);
      this.writeU8(suspendUpdateDataByteLength);
    } else if (suspendUpdateDataByteLength < 65536) {
      this.writeU8(197);
      this.writeU16(suspendUpdateDataByteLength);
    } else if (suspendUpdateDataByteLength < 4294967296) {
      this.writeU8(198);
      this.writeU32(suspendUpdateDataByteLength);
    } else {
      throw new Error(`Too large binary: ${suspendUpdateDataByteLength}`);
    }
    var processAndWriteBinaryData = convertToUint8ArrayWithValidation(
      handleStreamDataValidation,
    );
    this.writeU8a(processAndWriteBinaryData);
  };
  WritablePipeSettings.prototype.encodeArray = function (
    registerCharacterEncoding,
    registerEncodingDecodingFunctions,
  ) {
    var characterEncodingCount = registerCharacterEncoding.length;
    if (characterEncodingCount < 16) {
      this.writeU8(144 + characterEncodingCount);
    } else if (characterEncodingCount < 65536) {
      this.writeU8(220);
      this.writeU16(characterEncodingCount);
    } else if (characterEncodingCount < 4294967296) {
      this.writeU8(221);
      this.writeU32(characterEncodingCount);
    } else {
      throw new Error(`Too large array: ${characterEncodingCount}`);
    }
    for (
      var currentDataStreamIndex = 0,
        processCharacterEncodingStreams = registerCharacterEncoding;
      currentDataStreamIndex < processCharacterEncodingStreams.length;
      currentDataStreamIndex++
    ) {
      var activeCharacterEncodingStream =
        processCharacterEncodingStreams[currentDataStreamIndex];
      this.doEncode(
        activeCharacterEncodingStream,
        registerEncodingDecodingFunctions + 1,
      );
    }
  };
  WritablePipeSettings.prototype.countWithoutUndefined = function (
    handleStreamError,
    characterEncodingProcessor,
  ) {
    var countApplicableErrorHandlers = 0;
    for (
      var currentErrorHandlerIndex = 0,
        activeErrorHandlers = characterEncodingProcessor;
      currentErrorHandlerIndex < activeErrorHandlers.length;
      currentErrorHandlerIndex++
    ) {
      var activeErrorHandler = activeErrorHandlers[currentErrorHandlerIndex];
      if (handleStreamError[activeErrorHandler] !== undefined) {
        countApplicableErrorHandlers++;
      }
    }
    return countApplicableErrorHandlers;
  };
  WritablePipeSettings.prototype.encodeMap = function (
    handleCharacterEncodingStream,
    processStreamErrorHandling,
  ) {
    var characterEncodingStreamKeys = Object.keys(
      handleCharacterEncodingStream,
    );
    if (this.sortKeys) {
      characterEncodingStreamKeys.sort();
    }
    var numberOfCharacterEncodingStreamKeys = this.ignoreUndefined
      ? this.countWithoutUndefined(
          handleCharacterEncodingStream,
          characterEncodingStreamKeys,
        )
      : characterEncodingStreamKeys.length;
    if (numberOfCharacterEncodingStreamKeys < 16) {
      this.writeU8(128 + numberOfCharacterEncodingStreamKeys);
    } else if (numberOfCharacterEncodingStreamKeys < 65536) {
      this.writeU8(222);
      this.writeU16(numberOfCharacterEncodingStreamKeys);
    } else if (numberOfCharacterEncodingStreamKeys < 4294967296) {
      this.writeU8(223);
      this.writeU32(numberOfCharacterEncodingStreamKeys);
    } else {
      throw new Error(
        `Too large map object: ${numberOfCharacterEncodingStreamKeys}`,
      );
    }
    for (
      var currentStreamHandlerIndex = 0,
        characterEncodingStreamKeysArray = characterEncodingStreamKeys;
      currentStreamHandlerIndex < characterEncodingStreamKeysArray.length;
      currentStreamHandlerIndex++
    ) {
      var activeCharacterEncodingStreamKey =
        characterEncodingStreamKeysArray[currentStreamHandlerIndex];
      var activeCharacterEncodingStreamHandler =
        handleCharacterEncodingStream[activeCharacterEncodingStreamKey];
      if (
        !this.ignoreUndefined ||
        activeCharacterEncodingStreamHandler !== undefined
      ) {
        this.encodeString(activeCharacterEncodingStreamKey);
        this.doEncode(
          activeCharacterEncodingStreamHandler,
          processStreamErrorHandling + 1,
        );
      }
    }
  };
  WritablePipeSettings.prototype.encodeExtension = function (
    _processAndValidateCharacterEncoding,
  ) {
    var characterDataLength = _processAndValidateCharacterEncoding.data.length;
    if (characterDataLength === 1) {
      this.writeU8(212);
    } else if (characterDataLength === 2) {
      this.writeU8(213);
    } else if (characterDataLength === 4) {
      this.writeU8(214);
    } else if (characterDataLength === 8) {
      this.writeU8(215);
    } else if (characterDataLength === 16) {
      this.writeU8(216);
    } else if (characterDataLength < 256) {
      this.writeU8(199);
      this.writeU8(characterDataLength);
    } else if (characterDataLength < 65536) {
      this.writeU8(200);
      this.writeU16(characterDataLength);
    } else if (characterDataLength < 4294967296) {
      this.writeU8(201);
      this.writeU32(characterDataLength);
    } else {
      throw new Error(`Too large extension object: ${characterDataLength}`);
    }
    this.writeI8(_processAndValidateCharacterEncoding.type);
    this.writeU8a(_processAndValidateCharacterEncoding.data);
  };
  WritablePipeSettings.prototype.writeU8 = function (
    processReadableStreamStateChange,
  ) {
    this.ensureBufferSizeToWrite(1);
    this.view.setUint8(this.pos, processReadableStreamStateChange);
    this.pos++;
  };
  WritablePipeSettings.prototype.writeU8a = function (
    _handleReadableStreamStateManagement,
  ) {
    var readableStreamHandlerLength =
      _handleReadableStreamStateManagement.length;
    this.ensureBufferSizeToWrite(readableStreamHandlerLength);
    this.bytes.set(_handleReadableStreamStateManagement, this.pos);
    this.pos += readableStreamHandlerLength;
  };
  WritablePipeSettings.prototype.writeI8 = function (
    validateSemverPrereleaseInput,
  ) {
    this.ensureBufferSizeToWrite(1);
    this.view.setInt8(this.pos, validateSemverPrereleaseInput);
    this.pos++;
  };
  WritablePipeSettings.prototype.writeU16 = function (
    handleStreamErrorManagement,
  ) {
    this.ensureBufferSizeToWrite(2);
    this.view.setUint16(this.pos, handleStreamErrorManagement);
    this.pos += 2;
  };
  WritablePipeSettings.prototype.writeI16 = function (
    _handleStreamErrorManagement,
  ) {
    this.ensureBufferSizeToWrite(2);
    this.view.setInt16(this.pos, _handleStreamErrorManagement);
    this.pos += 2;
  };
  WritablePipeSettings.prototype.writeU32 = function (destroyStreamOnReturn) {
    this.ensureBufferSizeToWrite(4);
    this.view.setUint32(this.pos, destroyStreamOnReturn);
    this.pos += 4;
  };
  WritablePipeSettings.prototype.writeI32 = function (
    updateWritableStreamState,
  ) {
    this.ensureBufferSizeToWrite(4);
    this.view.setInt32(this.pos, updateWritableStreamState);
    this.pos += 4;
  };
  WritablePipeSettings.prototype.writeF32 = function (resetEncodingState) {
    this.ensureBufferSizeToWrite(4);
    this.view.setFloat32(this.pos, resetEncodingState);
    this.pos += 4;
  };
  WritablePipeSettings.prototype.writeF64 = function (isStreamReadable) {
    this.ensureBufferSizeToWrite(8);
    this.view.setFloat64(this.pos, isStreamReadable);
    this.pos += 8;
  };
  WritablePipeSettings.prototype.writeU64 = function (_isStreamReadable) {
    this.ensureBufferSizeToWrite(8);
    updateStreamDataMetrics(this.view, this.pos, _isStreamReadable);
    this.pos += 8;
  };
  WritablePipeSettings.prototype.writeI64 = function (
    isStreamReadableAndFlowing,
  ) {
    this.ensureBufferSizeToWrite(8);
    configureBuffersUsingSignalLength(
      this.view,
      this.pos,
      isStreamReadableAndFlowing,
    );
    this.pos += 8;
  };
  return WritablePipeSettings;
})();
var __isStreamReadable = {};
function initializeReadableStreamDrain(
  updateReadableFlowState,
  _______isStreamReadable = __isStreamReadable,
) {
  var createReadableStreamHandler = new handleReadableStreamStateProcessing(
    _______isStreamReadable.extensionCodec,
    _______isStreamReadable.context,
    _______isStreamReadable.maxDepth,
    _______isStreamReadable.initialBufferSize,
    _______isStreamReadable.sortKeys,
    _______isStreamReadable.forceFloat32,
    _______isStreamReadable.ignoreUndefined,
    _______isStreamReadable.forceIntegerToFloat,
  );
  return createReadableStreamHandler.encodeSharedRef(updateReadableFlowState);
}
function convertUpdateToHexString(updateReadableFlowingState) {
  return `${updateReadableFlowingState < 0 ? "-" : ""}0x${Math.abs(updateReadableFlowingState).toString(16).padStart(2, "0")}`;
}
var incomingMessageBuffer = 16;
var readableMessageBuffer = 16;
var ___validateAndProcessCharacterEncoding = (function () {
  function MessageCacheBuffer(
    _incomingMessageBuffer = incomingMessageBuffer,
    _readableMessageBuffer = readableMessageBuffer,
  ) {
    this.maxKeyLength = _incomingMessageBuffer;
    this.maxLengthPerKey = _readableMessageBuffer;
    this.hit = 0;
    this.miss = 0;
    this.caches = [];
    for (
      var initializeCaches = 0;
      initializeCaches < this.maxKeyLength;
      initializeCaches++
    ) {
      this.caches.push([]);
    }
  }
  MessageCacheBuffer.prototype.canBeCached = function (streamWritableState) {
    return streamWritableState > 0 && streamWritableState <= this.maxKeyLength;
  };
  MessageCacheBuffer.prototype.find = function (
    getReadableStateProperties,
    encodeDataType,
    getProcessedStateByteLength,
  ) {
    var latestProcessedCache = this.caches[getProcessedStateByteLength - 1];
    _0x5d14ec: for (
      var processedCacheEntryIndex = 0,
        latestProcessedCacheEntries = latestProcessedCache;
      processedCacheEntryIndex < latestProcessedCacheEntries.length;
      processedCacheEntryIndex++
    ) {
      var lastProcessedCacheEntry =
        latestProcessedCacheEntries[processedCacheEntryIndex];
      var lastProcessedCacheEntryBytes = lastProcessedCacheEntry.bytes;
      for (
        var cacheEntryIndex = 0;
        cacheEntryIndex < getProcessedStateByteLength;
        cacheEntryIndex++
      ) {
        if (
          lastProcessedCacheEntryBytes[cacheEntryIndex] !==
          getReadableStateProperties[encodeDataType + cacheEntryIndex]
        ) {
          continue _0x5d14ec;
        }
      }
      return lastProcessedCacheEntry.str;
    }
    return null;
  };
  MessageCacheBuffer.prototype.store = function (
    updateStreamStateToDestroyed,
    characterEncodingStreamValue,
  ) {
    var latestCache = this.caches[updateStreamStateToDestroyed.length - 1];
    var streamDataEntry = {
      bytes: updateStreamStateToDestroyed,
      str: characterEncodingStreamValue,
    };
    if (latestCache.length >= this.maxLengthPerKey) {
      latestCache[(Math.random() * latestCache.length) | 0] = streamDataEntry;
    } else {
      latestCache.push(streamDataEntry);
    }
  };
  MessageCacheBuffer.prototype.decode = function (
    isValidCharacterEncodingStream,
    isStreamValid,
    processCharacterEncodingStream,
  ) {
    var validCharacterEncodingStream = this.find(
      isValidCharacterEncodingStream,
      isStreamValid,
      processCharacterEncodingStream,
    );
    if (validCharacterEncodingStream != null) {
      this.hit++;
      return validCharacterEncodingStream;
    }
    this.miss++;
    var convertedStreamData = convertBufferToUtf8(
      isValidCharacterEncodingStream,
      isStreamValid,
      processCharacterEncodingStream,
    );
    var slicedStreamChunk = Uint8Array.prototype.slice.call(
      isValidCharacterEncodingStream,
      isStreamValid,
      isStreamValid + processCharacterEncodingStream,
    );
    this.store(slicedStreamChunk, convertedStreamData);
    return convertedStreamData;
  };
  return MessageCacheBuffer;
})();
function initializeReadableStreamPromise(
  ___isStreamReadable,
  isReadableStreamEnded,
  setReadableStateToDestroyed,
  _setReadableStateToDestroyed,
) {
  function initializeReadableState(setWritableStateToDestroyed) {
    if (setWritableStateToDestroyed instanceof setReadableStateToDestroyed) {
      return setWritableStateToDestroyed;
    } else {
      return new setReadableStateToDestroyed(function (
        _processCharacterEncodingStream,
      ) {
        _processCharacterEncodingStream(setWritableStateToDestroyed);
      });
    }
  }
  return new (setReadableStateToDestroyed ||= Promise)(function (
    processCharacterEncodingDataBasedOnUTF8Length,
    processAndEncodeCharacterData,
  ) {
    function processReadableStateEnd(writeEncodedCharacterData) {
      try {
        processStreamPauseState(
          _setReadableStateToDestroyed.next(writeEncodedCharacterData),
        );
      } catch (characterDataProcessingError) {
        processAndEncodeCharacterData(characterDataProcessingError);
      }
    }
    function calculateAndHandlePipeLength(calculateWritablePipeStringLength) {
      try {
        processStreamPauseState(
          _setReadableStateToDestroyed.throw(calculateWritablePipeStringLength),
        );
      } catch (characterDataError) {
        processAndEncodeCharacterData(characterDataError);
      }
    }
    function processStreamPauseState(isStreamPaused) {
      if (isStreamPaused.done) {
        processCharacterEncodingDataBasedOnUTF8Length(isStreamPaused.value);
      } else {
        initializeReadableState(isStreamPaused.value).then(
          processReadableStateEnd,
          calculateAndHandlePipeLength,
        );
      }
    }
    processStreamPauseState(
      (_setReadableStateToDestroyed = _setReadableStateToDestroyed.apply(
        ___isStreamReadable,
        isReadableStreamEnded || [],
      )).next(),
    );
  });
}
function createDataProcessingGenerator(
  processAndValidateDataEntry,
  processDataStreamAndUpdatePosition,
) {
  var dataProcessingGeneratorState = {
    label: 0,
    sent() {
      if (dataProcessingGeneratorExecutionContext[0] & 1) {
        throw dataProcessingGeneratorExecutionContext[1];
      }
      return dataProcessingGeneratorExecutionContext[1];
    },
    trys: [],
    ops: [],
  };
  var isGeneratorCurrentlyRunning;
  var dataProcessingGeneratorContext;
  var dataProcessingGeneratorExecutionContext;
  var dataProcessingGeneratorInterface;
  dataProcessingGeneratorInterface = {
    next: generateEventProcessor(0),
    throw: generateEventProcessor(1),
    return: generateEventProcessor(2),
  };
  if (typeof Symbol == "function") {
    dataProcessingGeneratorInterface[Symbol.iterator] = function () {
      return this;
    };
  }
  return dataProcessingGeneratorInterface;
  function generateEventProcessor(handleTimestampEncoding) {
    return function (handleEventProcessingForComparator) {
      return processDataGeneratorStep([
        handleTimestampEncoding,
        handleEventProcessingForComparator,
      ]);
    };
  }
  function processDataGeneratorStep(encodeEventBuffer) {
    if (isGeneratorCurrentlyRunning) {
      throw new TypeError("Generator is already executing.");
    }
    while (dataProcessingGeneratorState) {
      try {
        isGeneratorCurrentlyRunning = 1;
        if (
          dataProcessingGeneratorContext &&
          (dataProcessingGeneratorExecutionContext =
            encodeEventBuffer[0] & 2
              ? dataProcessingGeneratorContext.return
              : encodeEventBuffer[0]
                ? dataProcessingGeneratorContext.throw ||
                  ((dataProcessingGeneratorExecutionContext =
                    dataProcessingGeneratorContext.return) &&
                    dataProcessingGeneratorExecutionContext.call(
                      dataProcessingGeneratorContext,
                    ),
                  0)
                : dataProcessingGeneratorContext.next) &&
          !(dataProcessingGeneratorExecutionContext =
            dataProcessingGeneratorExecutionContext.call(
              dataProcessingGeneratorContext,
              encodeEventBuffer[1],
            )).done
        ) {
          return dataProcessingGeneratorExecutionContext;
        }
        dataProcessingGeneratorContext = 0;
        if (dataProcessingGeneratorExecutionContext) {
          encodeEventBuffer = [
            encodeEventBuffer[0] & 2,
            dataProcessingGeneratorExecutionContext.value,
          ];
        }
        switch (encodeEventBuffer[0]) {
          case 0:
          case 1:
            dataProcessingGeneratorExecutionContext = encodeEventBuffer;
            break;
          case 4:
            dataProcessingGeneratorState.label++;
            return {
              value: encodeEventBuffer[1],
              done: false,
            };
          case 5:
            dataProcessingGeneratorState.label++;
            dataProcessingGeneratorContext = encodeEventBuffer[1];
            encodeEventBuffer = [0];
            continue;
          case 7:
            encodeEventBuffer = dataProcessingGeneratorState.ops.pop();
            dataProcessingGeneratorState.trys.pop();
            continue;
          default:
            dataProcessingGeneratorExecutionContext =
              dataProcessingGeneratorState.trys;
            if (
              !(dataProcessingGeneratorExecutionContext =
                dataProcessingGeneratorExecutionContext.length > 0 &&
                dataProcessingGeneratorExecutionContext[
                  dataProcessingGeneratorExecutionContext.length - 1
                ]) &&
              (encodeEventBuffer[0] === 6 || encodeEventBuffer[0] === 2)
            ) {
              dataProcessingGeneratorState = 0;
              continue;
            }
            if (
              encodeEventBuffer[0] === 3 &&
              (!dataProcessingGeneratorExecutionContext ||
                (encodeEventBuffer[1] >
                  dataProcessingGeneratorExecutionContext[0] &&
                  encodeEventBuffer[1] <
                    dataProcessingGeneratorExecutionContext[3]))
            ) {
              dataProcessingGeneratorState.label = encodeEventBuffer[1];
              break;
            }
            if (
              encodeEventBuffer[0] === 6 &&
              dataProcessingGeneratorState.label <
                dataProcessingGeneratorExecutionContext[1]
            ) {
              dataProcessingGeneratorState.label =
                dataProcessingGeneratorExecutionContext[1];
              dataProcessingGeneratorExecutionContext = encodeEventBuffer;
              break;
            }
            if (
              dataProcessingGeneratorExecutionContext &&
              dataProcessingGeneratorState.label <
                dataProcessingGeneratorExecutionContext[2]
            ) {
              dataProcessingGeneratorState.label =
                dataProcessingGeneratorExecutionContext[2];
              dataProcessingGeneratorState.ops.push(encodeEventBuffer);
              break;
            }
            if (dataProcessingGeneratorExecutionContext[2]) {
              dataProcessingGeneratorState.ops.pop();
            }
            dataProcessingGeneratorState.trys.pop();
            continue;
        }
        encodeEventBuffer = processDataStreamAndUpdatePosition.call(
          processAndValidateDataEntry,
          dataProcessingGeneratorState,
        );
      } catch (dataEncodingError) {
        encodeEventBuffer = [6, dataEncodingError];
        dataProcessingGeneratorContext = 0;
      } finally {
        isGeneratorCurrentlyRunning =
          dataProcessingGeneratorExecutionContext = 0;
      }
    }
    if (encodeEventBuffer[0] & 5) {
      throw encodeEventBuffer[1];
    }
    return {
      value: encodeEventBuffer[0] ? encodeEventBuffer[1] : undefined,
      done: true,
    };
  }
}
function createAsyncIteratorFromIterable(processAndEncodeCharacterEncoding) {
  if (!Symbol.asyncIterator) {
    throw new TypeError("Symbol.asyncIterator is not defined.");
  }
  var getAsyncIterator =
    processAndEncodeCharacterEncoding[Symbol.asyncIterator];
  var asyncIterableProcessingMethods;
  if (getAsyncIterator) {
    return getAsyncIterator.call(processAndEncodeCharacterEncoding);
  } else {
    if (typeof __values == "function") {
      processAndEncodeCharacterEncoding = __values(
        processAndEncodeCharacterEncoding,
      );
    } else {
      processAndEncodeCharacterEncoding =
        processAndEncodeCharacterEncoding[Symbol.iterator]();
    }
    asyncIterableProcessingMethods = {};
    _processSignalAndHandleCharacterEncoding("next");
    _processSignalAndHandleCharacterEncoding("throw");
    _processSignalAndHandleCharacterEncoding("return");
    asyncIterableProcessingMethods[Symbol.asyncIterator] = function () {
      return this;
    };
    return asyncIterableProcessingMethods;
  }
  function _processSignalAndHandleCharacterEncoding(
    processSignalAndHandleCharacterEncoding,
  ) {
    asyncIterableProcessingMethods[processSignalAndHandleCharacterEncoding] =
      processAndEncodeCharacterEncoding[
        processSignalAndHandleCharacterEncoding
      ] &&
      function (__processAndValidateCharacterEncoding) {
        return new Promise(function (
          ____validateAndRetrieveIntrinsicProperties,
          ______validateAndRetrieveStreamProperties,
        ) {
          __processAndValidateCharacterEncoding =
            processAndEncodeCharacterEncoding[
              processSignalAndHandleCharacterEncoding
            ](__processAndValidateCharacterEncoding);
          handleVersionValidationStream(
            ____validateAndRetrieveIntrinsicProperties,
            ______validateAndRetrieveStreamProperties,
            __processAndValidateCharacterEncoding.done,
            __processAndValidateCharacterEncoding.value,
          );
        });
      };
  }
  function handleVersionValidationStream(
    validateStreamDataType,
    isValidVersionRange,
    _validateStreamState,
    __isValidVersionRange,
  ) {
    Promise.resolve(__isValidVersionRange).then(function (
      WritablePipeSettings,
    ) {
      validateStreamDataType({
        value: WritablePipeSettings,
        done: _validateStreamState,
      });
    }, isValidVersionRange);
  }
}
function StreamDataProcessingErrorHandler(__processStreamData) {
  if (this instanceof StreamDataProcessingErrorHandler) {
    this.v = __processStreamData;
    return this;
  } else {
    return new StreamDataProcessingErrorHandler(__processStreamData);
  }
}
function initializeAsyncStreamIterator(
  _processStreamData,
  ____processStreamData,
  ______processStreamData,
) {
  if (!Symbol.asyncIterator) {
    throw new TypeError("Symbol.asyncIterator is not defined.");
  }
  var processedStreamData = ______processStreamData.apply(
    _processStreamData,
    ____processStreamData || [],
  );
  var asyncStreamIterator;
  var pendingAsyncOperationsQueue = [];
  asyncStreamIterator = {};
  enqueueAsyncStreamOperation("next");
  enqueueAsyncStreamOperation("throw");
  enqueueAsyncStreamOperation("return");
  asyncStreamIterator[Symbol.asyncIterator] = function () {
    return this;
  };
  return asyncStreamIterator;
  function enqueueAsyncStreamOperation(_______processStreamData) {
    if (processedStreamData[_______processStreamData]) {
      asyncStreamIterator[_______processStreamData] = function (
        errorHandlingStream,
      ) {
        return new Promise(function (
          updateReadableFlowStateSettings,
          handleStreamErrorHandling,
        ) {
          if (
            !(
              pendingAsyncOperationsQueue.push([
                _______processStreamData,
                errorHandlingStream,
                updateReadableFlowStateSettings,
                handleStreamErrorHandling,
              ]) > 1
            )
          ) {
            mapErrorCodesToReadableStates(
              _______processStreamData,
              errorHandlingStream,
            );
          }
        });
      };
    }
  }
  function mapErrorCodesToReadableStates(
    errorCodesToReadableStateMapping,
    errorResponseCodes,
  ) {
    try {
      handleStreamErrorResponse(
        processedStreamData[errorCodesToReadableStateMapping](
          errorResponseCodes,
        ),
      );
    } catch (_errorHandler) {
      setupCacheAndProcessPendingAsyncOperations(
        pendingAsyncOperationsQueue[0][3],
        _errorHandler,
      );
    }
  }
  function handleStreamErrorResponse(streamStatusErrorCodes) {
    if (
      streamStatusErrorCodes.value instanceof StreamDataProcessingErrorHandler
    ) {
      Promise.resolve(streamStatusErrorCodes.value.v).then(
        processNextNodeTraversal,
        mapCacheBufferErrorToState,
      );
    } else {
      setupCacheAndProcessPendingAsyncOperations(
        pendingAsyncOperationsQueue[0][2],
        streamStatusErrorCodes,
      );
    }
  }
  function processNextNodeTraversal(retrieveNodePropertiesAfterTraversal) {
    mapErrorCodesToReadableStates("next", retrieveNodePropertiesAfterTraversal);
  }
  function mapCacheBufferErrorToState(manageCacheBufferSettings) {
    mapErrorCodesToReadableStates("throw", manageCacheBufferSettings);
  }
  function setupCacheAndProcessPendingAsyncOperations(
    initializeCacheBuffer,
    validateAndRetrieveCacheEntries,
  ) {
    initializeCacheBuffer(validateAndRetrieveCacheEntries);
    pendingAsyncOperationsQueue.shift();
    if (pendingAsyncOperationsQueue.length) {
      mapErrorCodesToReadableStates(
        pendingAsyncOperationsQueue[0][0],
        pendingAsyncOperationsQueue[0][1],
      );
    }
  }
}
function isInputStringOrNumber(validateAndRetrieveReadableProperties) {
  var determineInputType = typeof validateAndRetrieveReadableProperties;
  return determineInputType === "string" || determineInputType === "number";
}
var isMaximumAgeUpdateAllowed = -1;
var validateAndRetrieveCacheEntry = new DataView(new ArrayBuffer(0));
var shouldDecodeCharacterEncoding = new Uint8Array(
  validateAndRetrieveCacheEntry.buffer,
);
var validateAndRetrieveLastCacheEntry = (function () {
  try {
    validateAndRetrieveCacheEntry.getInt8(0);
  } catch (caughtError) {
    return caughtError.constructor;
  }
  throw new Error("never reached");
})();
var shouldDisableStringDecoding = new validateAndRetrieveLastCacheEntry(
  "Insufficient data",
);
var shouldDecodeBasedOnCacheProperties =
  new ___validateAndProcessCharacterEncoding();
var isDecodeStringsAllowed = (function () {
  function configureCodecSettings(
    defaultProcessWritablePipeCodec = processWritablePipes.defaultCodec,
    userDefinedInput = undefined,
    _____calculateReadableStringLength = calculateReadableStringLength,
    ____calculateReadableStringLength = calculateReadableStringLength,
    ___calculateReadableStringLength = calculateReadableStringLength,
    _calculateReadableStringLength = calculateReadableStringLength,
    __calculateReadableStringLength = calculateReadableStringLength,
    shouldDecodeBasedOnProperties = shouldDecodeBasedOnCacheProperties,
  ) {
    this.extensionCodec = defaultProcessWritablePipeCodec;
    this.context = userDefinedInput;
    this.maxStrLength = _____calculateReadableStringLength;
    this.maxBinLength = ____calculateReadableStringLength;
    this.maxArrayLength = ___calculateReadableStringLength;
    this.maxMapLength = _calculateReadableStringLength;
    this.maxExtLength = __calculateReadableStringLength;
    this.keyDecoder = shouldDecodeBasedOnProperties;
    this.totalPos = 0;
    this.pos = 0;
    this.view = validateAndRetrieveCacheEntry;
    this.bytes = shouldDecodeCharacterEncoding;
    this.headByte = isMaximumAgeUpdateAllowed;
    this.stack = [];
  }
  configureCodecSettings.prototype.reinitializeState = function () {
    this.totalPos = 0;
    this.headByte = isMaximumAgeUpdateAllowed;
    this.stack.length = 0;
  };
  configureCodecSettings.prototype.setBuffer = function (
    initializeStreamProperties,
  ) {
    this.bytes = convertToUint8ArrayWithValidation(initializeStreamProperties);
    this.view = generateDataViewFromBuffer(this.bytes);
    this.pos = 0;
  };
  configureCodecSettings.prototype.appendBuffer = function (
    initializeCharacterEncodingProcess,
  ) {
    if (this.headByte === isMaximumAgeUpdateAllowed && !this.hasRemaining(1)) {
      this.setBuffer(initializeCharacterEncodingProcess);
    } else {
      var remainingDataBuffer = this.bytes.subarray(this.pos);
      var validatedCharacterEncodingBuffer = convertToUint8ArrayWithValidation(
        initializeCharacterEncodingProcess,
      );
      var mergedDataBuffer = new Uint8Array(
        remainingDataBuffer.length + validatedCharacterEncodingBuffer.length,
      );
      mergedDataBuffer.set(remainingDataBuffer);
      mergedDataBuffer.set(
        validatedCharacterEncodingBuffer,
        remainingDataBuffer.length,
      );
      this.setBuffer(mergedDataBuffer);
    }
  };
  configureCodecSettings.prototype.hasRemaining = function (
    initializeWritablePipeState,
  ) {
    return this.view.byteLength - this.pos >= initializeWritablePipeState;
  };
  configureCodecSettings.prototype.createExtraByteError = function (
    setupBufferedOperations,
  ) {
    var operationContext = this;
    var currentBufferView = operationContext.view;
    var currentBufferUsage = operationContext.pos;
    return new RangeError(
      `Extra ${currentBufferView.byteLength - currentBufferUsage} of ${currentBufferView.byteLength} byte(s) found at buffer[${setupBufferedOperations}]`,
    );
  };
  configureCodecSettings.prototype.decode = function (
    eventProcessingGenerator,
  ) {
    this.reinitializeState();
    this.setBuffer(eventProcessingGenerator);
    var decodedEventData = this.doDecodeSync();
    if (this.hasRemaining(1)) {
      throw this.createExtraByteError(this.pos);
    }
    return decodedEventData;
  };
  configureCodecSettings.prototype.decodeMulti = function (
    EventGeneratorController,
  ) {
    return createDataProcessingGenerator(
      this,
      function (GeneratorExecutionProcessor) {
        switch (GeneratorExecutionProcessor.label) {
          case 0:
            this.reinitializeState();
            this.setBuffer(EventGeneratorController);
            GeneratorExecutionProcessor.label = 1;
          case 1:
            if (this.hasRemaining(1)) {
              return [4, this.doDecodeSync()];
            } else {
              return [3, 3];
            }
          case 2:
            GeneratorExecutionProcessor.sent();
            return [3, 1];
          case 3:
            return [2];
        }
      },
    );
  };
  configureCodecSettings.prototype.decodeAsync = function (
    executeAbortSignalHandler,
  ) {
    var abortSignalExecutionResult;
    var abortSignalResultValue;
    var handleAbortSignalResult;
    var abortSignalExecutionOutcome;
    return initializeReadableStreamPromise(
      this,
      undefined,
      undefined,
      function () {
        var isAbortSignalHandled;
        var processedAbortSignalData;
        var currentAbortSignalValue;
        var abortSignalHandlerExecuted;
        var abortSignalProcessingResult;
        var abortSignalResultHandler;
        var abortSignalValue;
        var _abortSignalExecutionOutcome;
        return createDataProcessingGenerator(
          this,
          function (_handleAbortSignal) {
            switch (_handleAbortSignal.label) {
              case 0:
                isAbortSignalHandled = false;
                _handleAbortSignal.label = 1;
              case 1:
                _handleAbortSignal.trys.push([1, 6, 7, 12]);
                abortSignalExecutionResult = createAsyncIteratorFromIterable(
                  executeAbortSignalHandler,
                );
                _handleAbortSignal.label = 2;
              case 2:
                return [4, abortSignalExecutionResult.next()];
              case 3:
                abortSignalResultValue = _handleAbortSignal.sent();
                if (abortSignalResultValue.done) {
                  return [3, 5];
                }
                currentAbortSignalValue = abortSignalResultValue.value;
                if (isAbortSignalHandled) {
                  throw this.createExtraByteError(this.totalPos);
                }
                this.appendBuffer(currentAbortSignalValue);
                try {
                  processedAbortSignalData = this.doDecodeSync();
                  isAbortSignalHandled = true;
                } catch (errorCaught) {
                  if (
                    !(errorCaught instanceof validateAndRetrieveLastCacheEntry)
                  ) {
                    throw errorCaught;
                  }
                }
                this.totalPos += this.pos;
                _handleAbortSignal.label = 4;
              case 4:
                return [3, 2];
              case 5:
                return [3, 12];
              case 6:
                abortSignalHandlerExecuted = _handleAbortSignal.sent();
                handleAbortSignalResult = {
                  error: abortSignalHandlerExecuted,
                };
                return [3, 12];
              case 7:
                _handleAbortSignal.trys.push([7, , 10, 11]);
                if (
                  abortSignalResultValue &&
                  !abortSignalResultValue.done &&
                  (abortSignalExecutionOutcome =
                    abortSignalExecutionResult.return)
                ) {
                  return [
                    4,
                    abortSignalExecutionOutcome.call(
                      abortSignalExecutionResult,
                    ),
                  ];
                } else {
                  return [3, 9];
                }
              case 8:
                _handleAbortSignal.sent();
                _handleAbortSignal.label = 9;
              case 9:
                return [3, 11];
              case 10:
                if (handleAbortSignalResult) {
                  throw handleAbortSignalResult.error;
                }
                return [7];
              case 11:
                return [7];
              case 12:
                if (isAbortSignalHandled) {
                  if (this.hasRemaining(1)) {
                    throw this.createExtraByteError(this.totalPos);
                  }
                  return [2, processedAbortSignalData];
                }
                abortSignalProcessingResult = this;
                abortSignalResultHandler = abortSignalProcessingResult.headByte;
                abortSignalValue = abortSignalProcessingResult.pos;
                _abortSignalExecutionOutcome =
                  abortSignalProcessingResult.totalPos;
                throw new RangeError(
                  `Insufficient data in parsing ${convertUpdateToHexString(abortSignalResultHandler)} at ${_abortSignalExecutionOutcome} (${abortSignalValue} in the current buffer)`,
                );
            }
          },
        );
      },
    );
  };
  configureCodecSettings.prototype.decodeArrayStream = function (
    getAsyncIteratorWithErrorHandling,
  ) {
    return this.decodeMultiAsync(getAsyncIteratorWithErrorHandling, true);
  };
  configureCodecSettings.prototype.decodeStream = function (
    processCharacterEncodingAsync,
  ) {
    return this.decodeMultiAsync(processCharacterEncodingAsync, false);
  };
  configureCodecSettings.prototype.decodeMultiAsync = function (
    initializeAsyncStream,
    getCharacterEncodingAsyncIterator,
  ) {
    return initializeAsyncStreamIterator(this, arguments, function () {
      var isWriteStreamProcessingActive;
      var lastProcessedByteIndexForStream;
      var writeStreamChunkBuffer;
      var processedWriteStreamChunk;
      var currentStreamChunk;
      var initializeWriteStreamBuffer;
      var currentWriteStreamBuffer;
      var createWriteStreamDataChunksGenerator;
      var processWriteStreamDataChunks;
      return createDataProcessingGenerator(
        this,
        function (handleAsyncSignalProcessing) {
          switch (handleAsyncSignalProcessing.label) {
            case 0:
              isWriteStreamProcessingActive = getCharacterEncodingAsyncIterator;
              lastProcessedByteIndexForStream = -1;
              handleAsyncSignalProcessing.label = 1;
            case 1:
              handleAsyncSignalProcessing.trys.push([1, 13, 14, 19]);
              writeStreamChunkBuffer = createAsyncIteratorFromIterable(
                initializeAsyncStream,
              );
              handleAsyncSignalProcessing.label = 2;
            case 2:
              return [
                4,
                StreamDataProcessingErrorHandler(writeStreamChunkBuffer.next()),
              ];
            case 3:
              processedWriteStreamChunk = handleAsyncSignalProcessing.sent();
              if (processedWriteStreamChunk.done) {
                return [3, 12];
              }
              currentStreamChunk = processedWriteStreamChunk.value;
              if (
                getCharacterEncodingAsyncIterator &&
                lastProcessedByteIndexForStream === 0
              ) {
                throw this.createExtraByteError(this.totalPos);
              }
              this.appendBuffer(currentStreamChunk);
              if (isWriteStreamProcessingActive) {
                lastProcessedByteIndexForStream = this.readArraySize();
                isWriteStreamProcessingActive = false;
                this.complete();
              }
              handleAsyncSignalProcessing.label = 4;
            case 4:
              handleAsyncSignalProcessing.trys.push([4, 9, , 10]);
              handleAsyncSignalProcessing.label = 5;
            case 5:
              return [4, StreamDataProcessingErrorHandler(this.doDecodeSync())];
            case 6:
              return [4, handleAsyncSignalProcessing.sent()];
            case 7:
              handleAsyncSignalProcessing.sent();
              if (--lastProcessedByteIndexForStream === 0) {
                return [3, 8];
              } else {
                return [3, 5];
              }
            case 8:
              return [3, 10];
            case 9:
              initializeWriteStreamBuffer = handleAsyncSignalProcessing.sent();
              if (
                !(
                  initializeWriteStreamBuffer instanceof
                  validateAndRetrieveLastCacheEntry
                )
              ) {
                throw initializeWriteStreamBuffer;
              }
              return [3, 10];
            case 10:
              this.totalPos += this.pos;
              handleAsyncSignalProcessing.label = 11;
            case 11:
              return [3, 2];
            case 12:
              return [3, 19];
            case 13:
              currentWriteStreamBuffer = handleAsyncSignalProcessing.sent();
              createWriteStreamDataChunksGenerator = {
                error: currentWriteStreamBuffer,
              };
              return [3, 19];
            case 14:
              handleAsyncSignalProcessing.trys.push([14, , 17, 18]);
              if (
                processedWriteStreamChunk &&
                !processedWriteStreamChunk.done &&
                (processWriteStreamDataChunks = writeStreamChunkBuffer.return)
              ) {
                return [
                  4,
                  StreamDataProcessingErrorHandler(
                    processWriteStreamDataChunks.call(writeStreamChunkBuffer),
                  ),
                ];
              } else {
                return [3, 16];
              }
            case 15:
              handleAsyncSignalProcessing.sent();
              handleAsyncSignalProcessing.label = 16;
            case 16:
              return [3, 18];
            case 17:
              if (createWriteStreamDataChunksGenerator) {
                throw createWriteStreamDataChunksGenerator.error;
              }
              return [7];
            case 18:
              return [7];
            case 19:
              return [2];
          }
        },
      );
    });
  };
  configureCodecSettings.prototype.doDecodeSync = function () {
    _0x5be8bc: while (true) {
      var headerByteValueForDecoding = this.readHeadByte();
      var headerByteDecodingResult = undefined;
      if (headerByteValueForDecoding >= 224) {
        headerByteDecodingResult = headerByteValueForDecoding - 256;
      } else if (headerByteValueForDecoding < 192) {
        if (headerByteValueForDecoding < 128) {
          headerByteDecodingResult = headerByteValueForDecoding;
        } else if (headerByteValueForDecoding < 144) {
          var adjustedHeaderForDecoding = headerByteValueForDecoding - 128;
          if (adjustedHeaderForDecoding !== 0) {
            this.pushMapState(adjustedHeaderForDecoding);
            this.complete();
            continue _0x5be8bc;
          } else {
            headerByteDecodingResult = {};
          }
        } else if (headerByteValueForDecoding < 160) {
          var adjustedHeaderForDecoding = headerByteValueForDecoding - 144;
          if (adjustedHeaderForDecoding !== 0) {
            this.pushArrayState(adjustedHeaderForDecoding);
            this.complete();
            continue _0x5be8bc;
          } else {
            headerByteDecodingResult = [];
          }
        } else {
          var decodedHeaderByteValue = headerByteValueForDecoding - 160;
          headerByteDecodingResult = this.decodeUtf8String(
            decodedHeaderByteValue,
            0,
          );
        }
      } else if (headerByteValueForDecoding === 192) {
        headerByteDecodingResult = null;
      } else if (headerByteValueForDecoding === 194) {
        headerByteDecodingResult = false;
      } else if (headerByteValueForDecoding === 195) {
        headerByteDecodingResult = true;
      } else if (headerByteValueForDecoding === 202) {
        headerByteDecodingResult = this.readF32();
      } else if (headerByteValueForDecoding === 203) {
        headerByteDecodingResult = this.readF64();
      } else if (headerByteValueForDecoding === 204) {
        headerByteDecodingResult = this.readU8();
      } else if (headerByteValueForDecoding === 205) {
        headerByteDecodingResult = this.readU16();
      } else if (headerByteValueForDecoding === 206) {
        headerByteDecodingResult = this.readU32();
      } else if (headerByteValueForDecoding === 207) {
        headerByteDecodingResult = this.readU64();
      } else if (headerByteValueForDecoding === 208) {
        headerByteDecodingResult = this.readI8();
      } else if (headerByteValueForDecoding === 209) {
        headerByteDecodingResult = this.readI16();
      } else if (headerByteValueForDecoding === 210) {
        headerByteDecodingResult = this.readI32();
      } else if (headerByteValueForDecoding === 211) {
        headerByteDecodingResult = this.readI64();
      } else if (headerByteValueForDecoding === 217) {
        var decodedHeaderByteValue = this.lookU8();
        headerByteDecodingResult = this.decodeUtf8String(
          decodedHeaderByteValue,
          1,
        );
      } else if (headerByteValueForDecoding === 218) {
        var decodedHeaderByteValue = this.lookU16();
        headerByteDecodingResult = this.decodeUtf8String(
          decodedHeaderByteValue,
          2,
        );
      } else if (headerByteValueForDecoding === 219) {
        var decodedHeaderByteValue = this.lookU32();
        headerByteDecodingResult = this.decodeUtf8String(
          decodedHeaderByteValue,
          4,
        );
      } else if (headerByteValueForDecoding === 220) {
        var adjustedHeaderForDecoding = this.readU16();
        if (adjustedHeaderForDecoding !== 0) {
          this.pushArrayState(adjustedHeaderForDecoding);
          this.complete();
          continue _0x5be8bc;
        } else {
          headerByteDecodingResult = [];
        }
      } else if (headerByteValueForDecoding === 221) {
        var adjustedHeaderForDecoding = this.readU32();
        if (adjustedHeaderForDecoding !== 0) {
          this.pushArrayState(adjustedHeaderForDecoding);
          this.complete();
          continue _0x5be8bc;
        } else {
          headerByteDecodingResult = [];
        }
      } else if (headerByteValueForDecoding === 222) {
        var adjustedHeaderForDecoding = this.readU16();
        if (adjustedHeaderForDecoding !== 0) {
          this.pushMapState(adjustedHeaderForDecoding);
          this.complete();
          continue _0x5be8bc;
        } else {
          headerByteDecodingResult = {};
        }
      } else if (headerByteValueForDecoding === 223) {
        var adjustedHeaderForDecoding = this.readU32();
        if (adjustedHeaderForDecoding !== 0) {
          this.pushMapState(adjustedHeaderForDecoding);
          this.complete();
          continue _0x5be8bc;
        } else {
          headerByteDecodingResult = {};
        }
      } else if (headerByteValueForDecoding === 196) {
        var adjustedHeaderForDecoding = this.lookU8();
        headerByteDecodingResult = this.decodeBinary(
          adjustedHeaderForDecoding,
          1,
        );
      } else if (headerByteValueForDecoding === 197) {
        var adjustedHeaderForDecoding = this.lookU16();
        headerByteDecodingResult = this.decodeBinary(
          adjustedHeaderForDecoding,
          2,
        );
      } else if (headerByteValueForDecoding === 198) {
        var adjustedHeaderForDecoding = this.lookU32();
        headerByteDecodingResult = this.decodeBinary(
          adjustedHeaderForDecoding,
          4,
        );
      } else if (headerByteValueForDecoding === 212) {
        headerByteDecodingResult = this.decodeExtension(1, 0);
      } else if (headerByteValueForDecoding === 213) {
        headerByteDecodingResult = this.decodeExtension(2, 0);
      } else if (headerByteValueForDecoding === 214) {
        headerByteDecodingResult = this.decodeExtension(4, 0);
      } else if (headerByteValueForDecoding === 215) {
        headerByteDecodingResult = this.decodeExtension(8, 0);
      } else if (headerByteValueForDecoding === 216) {
        headerByteDecodingResult = this.decodeExtension(16, 0);
      } else if (headerByteValueForDecoding === 199) {
        var adjustedHeaderForDecoding = this.lookU8();
        headerByteDecodingResult = this.decodeExtension(
          adjustedHeaderForDecoding,
          1,
        );
      } else if (headerByteValueForDecoding === 200) {
        var adjustedHeaderForDecoding = this.lookU16();
        headerByteDecodingResult = this.decodeExtension(
          adjustedHeaderForDecoding,
          2,
        );
      } else if (headerByteValueForDecoding === 201) {
        var adjustedHeaderForDecoding = this.lookU32();
        headerByteDecodingResult = this.decodeExtension(
          adjustedHeaderForDecoding,
          4,
        );
      } else {
        throw new messageSendingOperation(
          `Unrecognized type byte: ${convertUpdateToHexString(headerByteValueForDecoding)}`,
        );
      }
      this.complete();
      for (var executionStack = this.stack; executionStack.length > 0; ) {
        var topExecutionContext = executionStack[executionStack.length - 1];
        if (topExecutionContext.type === 0) {
          topExecutionContext.array[topExecutionContext.position] =
            headerByteDecodingResult;
          topExecutionContext.position++;
          if (topExecutionContext.position === topExecutionContext.size) {
            executionStack.pop();
            headerByteDecodingResult = topExecutionContext.array;
          } else {
            continue _0x5be8bc;
          }
        } else if (topExecutionContext.type === 1) {
          if (!isInputStringOrNumber(headerByteDecodingResult)) {
            throw new messageSendingOperation(
              "The type of key must be string or number but " +
                typeof headerByteDecodingResult,
            );
          }
          if (headerByteDecodingResult === "__proto__") {
            throw new messageSendingOperation(
              "The key __proto__ is not allowed",
            );
          }
          topExecutionContext.key = headerByteDecodingResult;
          topExecutionContext.type = 2;
          continue _0x5be8bc;
        } else {
          topExecutionContext.map[topExecutionContext.key] =
            headerByteDecodingResult;
          topExecutionContext.readCount++;
          if (topExecutionContext.readCount === topExecutionContext.size) {
            executionStack.pop();
            headerByteDecodingResult = topExecutionContext.map;
          } else {
            topExecutionContext.key = null;
            topExecutionContext.type = 1;
            continue _0x5be8bc;
          }
        }
      }
      return headerByteDecodingResult;
    }
  };
  configureCodecSettings.prototype.readHeadByte = function () {
    if (this.headByte === isMaximumAgeUpdateAllowed) {
      this.headByte = this.readU8();
    }
    return this.headByte;
  };
  configureCodecSettings.prototype.complete = function () {
    this.headByte = isMaximumAgeUpdateAllowed;
  };
  configureCodecSettings.prototype.readArraySize = function () {
    var currentArrayTypeByte = this.readHeadByte();
    switch (currentArrayTypeByte) {
      case 220:
        return this.readU16();
      case 221:
        return this.readU32();
      default: {
        if (currentArrayTypeByte < 160) {
          return currentArrayTypeByte - 144;
        }
        throw new messageSendingOperation(
          `Unrecognized array type byte: ${convertUpdateToHexString(currentArrayTypeByte)}`,
        );
      }
    }
  };
  configureCodecSettings.prototype.pushMapState = function (
    processAbortSignalAndBufferData,
  ) {
    if (processAbortSignalAndBufferData > this.maxMapLength) {
      throw new messageSendingOperation(
        `Max length exceeded: map length (${processAbortSignalAndBufferData}) > maxMapLengthLength (${this.maxMapLength})`,
      );
    }
    this.stack.push({
      type: 1,
      size: processAbortSignalAndBufferData,
      key: null,
      readCount: 0,
      map: {},
    });
  };
  configureCodecSettings.prototype.pushArrayState = function (
    processCharacterEncodingSegments,
  ) {
    if (processCharacterEncodingSegments > this.maxArrayLength) {
      throw new messageSendingOperation(
        `Max length exceeded: array length (${processCharacterEncodingSegments}) > maxArrayLength (${this.maxArrayLength})`,
      );
    }
    this.stack.push({
      type: 0,
      size: processCharacterEncodingSegments,
      array: new Array(processCharacterEncodingSegments),
      position: 0,
    });
  };
  configureCodecSettings.prototype.decodeUtf8String = function (
    processBufferedSegments,
    processBufferedWriteStreamData,
  ) {
    var bufferedSegmentLength;
    if (processBufferedSegments > this.maxStrLength) {
      throw new messageSendingOperation(
        `Max length exceeded: UTF-8 byte length (${processBufferedSegments}) > maxStrLength (${this.maxStrLength})`,
      );
    }
    if (
      this.bytes.byteLength <
      this.pos + processBufferedWriteStreamData + processBufferedSegments
    ) {
      throw shouldDisableStringDecoding;
    }
    var updatedPositionAfterProcessing =
      this.pos + processBufferedWriteStreamData;
    var decodedDataSegment;
    if (
      this.stateIsMapKey() &&
      ((bufferedSegmentLength = this.keyDecoder) === null ||
      bufferedSegmentLength === undefined
        ? undefined
        : bufferedSegmentLength.canBeCached(processBufferedSegments))
    ) {
      decodedDataSegment = this.keyDecoder.decode(
        this.bytes,
        updatedPositionAfterProcessing,
        processBufferedSegments,
      );
    } else if (processBufferedSegments > logCacheEntryForEventHandling) {
      decodedDataSegment = processReadableStateChangeForHandshake(
        this.bytes,
        updatedPositionAfterProcessing,
        processBufferedSegments,
      );
    } else {
      decodedDataSegment = convertBufferToUtf8(
        this.bytes,
        updatedPositionAfterProcessing,
        processBufferedSegments,
      );
    }
    this.pos += processBufferedWriteStreamData + processBufferedSegments;
    return decodedDataSegment;
  };
  configureCodecSettings.prototype.stateIsMapKey = function () {
    if (this.stack.length > 0) {
      var getCurrentStackElement = this.stack[this.stack.length - 1];
      return getCurrentStackElement.type === 1;
    }
    return false;
  };
  configureCodecSettings.prototype.decodeBinary = function (
    processWriteStreamBuffer,
    handleCharacterBytesAndStream,
  ) {
    if (processWriteStreamBuffer > this.maxBinLength) {
      throw new messageSendingOperation(
        `Max length exceeded: bin length (${processWriteStreamBuffer}) > maxBinLength (${this.maxBinLength})`,
      );
    }
    if (
      !this.hasRemaining(
        processWriteStreamBuffer + handleCharacterBytesAndStream,
      )
    ) {
      throw shouldDisableStringDecoding;
    }
    var updatedPositionIndex = this.pos + handleCharacterBytesAndStream;
    var byteSegmentToSend = this.bytes.subarray(
      updatedPositionIndex,
      updatedPositionIndex + processWriteStreamBuffer,
    );
    this.pos += handleCharacterBytesAndStream + processWriteStreamBuffer;
    return byteSegmentToSend;
  };
  configureCodecSettings.prototype.decodeExtension = function (
    handleCharacterSegmentProcessing,
    _handleStreamProcessing,
  ) {
    if (handleCharacterSegmentProcessing > this.maxExtLength) {
      throw new messageSendingOperation(
        `Max length exceeded: ext length (${handleCharacterSegmentProcessing}) > maxExtLength (${this.maxExtLength})`,
      );
    }
    var characterValue = this.view.getInt8(this.pos + _handleStreamProcessing);
    var decodedCharacterSegmentWithMetadata = this.decodeBinary(
      handleCharacterSegmentProcessing,
      _handleStreamProcessing + 1,
    );
    return this.extensionCodec.decode(
      decodedCharacterSegmentWithMetadata,
      characterValue,
      this.context,
    );
  };
  configureCodecSettings.prototype.lookU8 = function () {
    return this.view.getUint8(this.pos);
  };
  configureCodecSettings.prototype.lookU16 = function () {
    return this.view.getUint16(this.pos);
  };
  configureCodecSettings.prototype.lookU32 = function () {
    return this.view.getUint32(this.pos);
  };
  configureCodecSettings.prototype.readU8 = function () {
    var fetchNextByteFromView = this.view.getUint8(this.pos);
    this.pos++;
    return fetchNextByteFromView;
  };
  configureCodecSettings.prototype.readI8 = function () {
    var fetchNextInt8Byte = this.view.getInt8(this.pos);
    this.pos++;
    return fetchNextInt8Byte;
  };
  configureCodecSettings.prototype.readU16 = function () {
    var retrieveNextUint16 = this.view.getUint16(this.pos);
    this.pos += 2;
    return retrieveNextUint16;
  };
  configureCodecSettings.prototype.readI16 = function () {
    var readNextInt16Value = this.view.getInt16(this.pos);
    this.pos += 2;
    return readNextInt16Value;
  };
  configureCodecSettings.prototype.readU32 = function () {
    var fetchNextUint32Value = this.view.getUint32(this.pos);
    this.pos += 4;
    return fetchNextUint32Value;
  };
  configureCodecSettings.prototype.readI32 = function () {
    var retrieveIntegerFromView = this.view.getInt32(this.pos);
    this.pos += 4;
    return retrieveIntegerFromView;
  };
  configureCodecSettings.prototype.readU64 = function () {
    var convertedUInt32PairNumber = convertUInt32PairToNumber(
      this.view,
      this.pos,
    );
    this.pos += 8;
    return convertedUInt32PairNumber;
  };
  configureCodecSettings.prototype.readI64 = function () {
    var computeAndRetrieveLargeInteger = computeLargeIntegerFromStreamData(
      this.view,
      this.pos,
    );
    this.pos += 8;
    return computeAndRetrieveLargeInteger;
  };
  configureCodecSettings.prototype.readF32 = function () {
    var retrieveNextFloat32Value = this.view.getFloat32(this.pos);
    this.pos += 4;
    return retrieveNextFloat32Value;
  };
  configureCodecSettings.prototype.readF64 = function () {
    var readFloat64FromView = this.view.getFloat64(this.pos);
    this.pos += 8;
    return readFloat64FromView;
  };
  return configureCodecSettings;
})();
var processStreamEnd = {};
function processStreamStatus(
  decodeByteHeaderToValue,
  _processStreamEnd = processStreamEnd,
) {
  var stringStreamDecoder = new isDecodeStringsAllowed(
    _processStreamEnd.extensionCodec,
    _processStreamEnd.context,
    _processStreamEnd.maxStrLength,
    _processStreamEnd.maxBinLength,
    _processStreamEnd.maxArrayLength,
    _processStreamEnd.maxMapLength,
    _processStreamEnd.maxExtLength,
  );
  return stringStreamDecoder.decode(decodeByteHeaderToValue);
}
var decodeByteHeaderValue = class {
  onWillDisposeEmitter = new _decodeByteHeaderValue();
  onWillDispose = this.onWillDisposeEmitter.event;
  onDidDisposeEmitter = new _decodeByteHeaderValue();
  onDidDispose = this.onDidDisposeEmitter.event;
  toDispose = [];
  isDisposed = false;
  onDispose(abortSignalToken) {
    this.toDispose.push(decodeByteHeaderValue.create(abortSignalToken));
  }
  dispose() {
    if (!this.isDisposed) {
      this.onWillDisposeEmitter.fire(null);
      this.isDisposed = true;
      this.toDispose.forEach((releaseResource) => {
        releaseResource.dispose();
      });
      this.onDidDisposeEmitter.fire(null);
      this.onWillDisposeEmitter.dispose();
      this.onDidDisposeEmitter.dispose();
    }
  }
  static is(isDisposableObject) {
    return typeof isDisposableObject.dispose == "function";
  }
  static create(createDisposableObject) {
    return {
      dispose: createDisposableObject,
    };
  }
};
var _decodeByteHeaderValue = class {
  registeredListeners = new Set();
  _event;
  get event() {
    this._event ||= (listenerRegistrationHandler) => {
      this.registeredListeners.add(listenerRegistrationHandler);
      return decodeByteHeaderValue.create(() => {
        this.registeredListeners.delete(listenerRegistrationHandler);
      });
    };
    return this._event;
  }
  fire(eventPayload) {
    this.registeredListeners.forEach((handleIncomingEventPayload) => {
      handleIncomingEventPayload(eventPayload);
    });
  }
  dispose() {
    this.registeredListeners = new Set();
  }
};
var handleByteHeaderProcessing = (0, validateStreamAndPushData.default)();
var processByteHeaderValue = (initializeReadableStreamDrainWithOptions) =>
  initializeReadableStreamDrain(initializeReadableStreamDrainWithOptions, {
    ignoreUndefined: true,
  });
var processHeaderValueDecoding = class {
  endpoints = new Map();
  nodeMap = new Map();
  onMessageEmitter = new _decodeByteHeaderValue();
  onMessage = this.onMessageEmitter.event;
  constructor() {}
  getEndpointForNode(retrieveEndpointByNodeId) {
    let getEndpointByNodeId = this.nodeMap.get(retrieveEndpointByNodeId);
    if (getEndpointByNodeId) {
      let fetchedEndpointData = this.endpoints.get(getEndpointByNodeId);
      if (fetchedEndpointData) {
        return fetchedEndpointData;
      }
    }
  }
  addEndpoint(routeKey, addEndpointHandlerForRoute) {
    this.endpoints.set(routeKey, addEndpointHandlerForRoute);
    addEndpointHandlerForRoute.onMessage(
      (thisHandleMessageParseMessageDataRouteKey) =>
        this.handleMessage(thisHandleMessageParseMessageDataRouteKey, routeKey),
    );
    let routerAnnounceMessage = processByteHeaderValue({
      $type: "router-announce",
      $origin: handleByteHeaderProcessing,
    });
    addEndpointHandlerForRoute.send(routerAnnounceMessage, [
      routerAnnounceMessage.buffer,
    ]);
  }
  removeEndpoint(removeEndpointById) {
    this.endpoints.delete(removeEndpointById);
  }
  send(sendMessageToRouter, messagePayload, dataLoadingComplete = true) {
    let routerPayloadMessage = {
      $type: "router-message",
      $origin: handleByteHeaderProcessing,
      $target: sendMessageToRouter,
      $data: messagePayload,
    };
    if (sendMessageToRouter !== handleByteHeaderProcessing) {
      let getRouterEndpoint = this.getEndpointForNode(sendMessageToRouter);
      if (!getRouterEndpoint) {
        throw new Error("Endpoint " + sendMessageToRouter + " not registered");
      }
      if (dataLoadingComplete) {
        let processedRouterPayloadMessage =
          processByteHeaderValue(routerPayloadMessage);
        getRouterEndpoint.send(processedRouterPayloadMessage, [
          processedRouterPayloadMessage.buffer,
        ]);
      } else {
        getRouterEndpoint.send(routerPayloadMessage, []);
      }
    } else {
      this.onMessageEmitter.fire(routerPayloadMessage);
    }
  }
  broadcast(
    sendBroadcastMessage,
    excludedEndpointId,
    getBroadcastSourceFunction,
  ) {
    let createBroadcastMessage = {
      $type: "router-broadcast",
      $origin: getBroadcastSourceFunction ?? handleByteHeaderProcessing,
      $data: sendBroadcastMessage,
    };
    if (!excludedEndpointId && !getBroadcastSourceFunction) {
      this.onMessageEmitter.fire(createBroadcastMessage);
    }
    for (let [
      currentEndpointId,
      endpointConnection,
    ] of this.endpoints.entries()) {
      if (currentEndpointId === excludedEndpointId) {
        continue;
      }
      let processedBroadcastMessage = processByteHeaderValue(
        createBroadcastMessage,
      );
      endpointConnection.send(processedBroadcastMessage, [
        processedBroadcastMessage.buffer,
      ]);
    }
  }
  handleMessage(incomingMessagePayload, nodeConnection) {
    let isPayloadUint8Array = incomingMessagePayload instanceof Uint8Array;
    let decodedIncomingMessage = isPayloadUint8Array
      ? processStreamStatus(incomingMessagePayload)
      : incomingMessagePayload;
    if (decodedIncomingMessage.$origin) {
      if (!this.nodeMap.has(decodedIncomingMessage.$origin)) {
        this.nodeMap.set(decodedIncomingMessage.$origin, nodeConnection);
      }
      if (decodedIncomingMessage.$type === "router-broadcast") {
        let decodedMessagePayload = decodedIncomingMessage;
        this.broadcast(
          decodedMessagePayload.$data,
          nodeConnection,
          decodedMessagePayload.$origin,
        );
        this.onMessageEmitter.fire(decodedIncomingMessage);
        return;
      }
      if (decodedIncomingMessage.$type === "router-message") {
        let incomingMessagePayloadForTarget = decodedIncomingMessage;
        if (
          incomingMessagePayloadForTarget.$target === handleByteHeaderProcessing
        ) {
          this.onMessageEmitter.fire(decodedIncomingMessage);
        } else {
          let targetNodeEndpoint = this.getEndpointForNode(
            incomingMessagePayloadForTarget.$target,
          );
          if (targetNodeEndpoint) {
            targetNodeEndpoint.send(
              incomingMessagePayload,
              isPayloadUint8Array ? [incomingMessagePayload.buffer] : [],
            );
          }
        }
        return;
      }
    }
  }
};
var isReadableState;
function initializeReadabilityState() {
  isReadableState ||= new processHeaderValueDecoding();
  return isReadableState;
}
var _isMaximumAgeUpdateAllowed = class extends MessageEvent {
  constructor(initializationData, superOptions) {
    super(initializationData, superOptions);
  }
};
var shouldAllowMaximumAgeUpdate = class extends EventTarget {
  addEventListener(
    registerEventListener,
    eventListenerCallback,
    eventListenerOptions,
  ) {
    return super.addEventListener(
      registerEventListener,
      eventListenerCallback,
      eventListenerOptions,
    );
  }
  removeEventListener(detachEventHandlerByType, detachEventHandler, eventName) {
    return super.removeEventListener(
      detachEventHandlerByType,
      detachEventHandler,
      eventName,
    );
  }
  dispatchEvent(eventToTrigger) {
    return super.dispatchEvent(eventToTrigger);
  }
};
var isArrayOrMapWritable = /(%?)(%([sdjo]))/g;
function transformValueBasedOnType(isArrayWritable, isWritableArray) {
  switch (isWritableArray) {
    case "s":
      return isArrayWritable;
    case "d":
    case "i":
      return Number(isArrayWritable);
    case "j":
      return JSON.stringify(isArrayWritable);
    case "o": {
      if (typeof isArrayWritable == "string") {
        return isArrayWritable;
      }
      let serializedWritable = JSON.stringify(isArrayWritable);
      if (
        serializedWritable === "{}" ||
        serializedWritable === "[]" ||
        /^\[object .+?\]$/.test(serializedWritable)
      ) {
        return isArrayWritable;
      } else {
        return serializedWritable;
      }
    }
  }
}
function populateTemplateWithValues(_isArrayWritable, ...templateValues) {
  if (templateValues.length === 0) {
    return _isArrayWritable;
  }
  let currentTemplateValueIndex = 0;
  let populatedTemplateString = _isArrayWritable.replace(
    isArrayOrMapWritable,
    (
      getValueWithFallback,
      isFallbackValueRequested,
      retrieveValueOrFallback,
      valueTransformationFactor,
    ) => {
      let activeTemplateValue = templateValues[currentTemplateValueIndex];
      let transformedTemplateValue = transformValueBasedOnType(
        activeTemplateValue,
        valueTransformationFactor,
      );
      if (isFallbackValueRequested) {
        return getValueWithFallback;
      } else {
        currentTemplateValueIndex++;
        return transformedTemplateValue;
      }
    },
  );
  if (currentTemplateValueIndex < templateValues.length) {
    populatedTemplateString +=
      " " + templateValues.slice(currentTemplateValueIndex).join(" ");
  }
  populatedTemplateString = populatedTemplateString.replace(/%{2,2}/g, "%");
  return populatedTemplateString;
}
var bufferedStreamState = 2;
function trimStackToRemoveFirstLine(writableStreamState) {
  if (!writableStreamState.stack) {
    return;
  }
  let stackLines = writableStreamState.stack.split("\n");
  stackLines.splice(1, bufferedStreamState);
  writableStreamState.stack = stackLines.join("\n");
}
var _processWriteStreamBuffer = class extends Error {
  constructor(formattedMessageTemplate, ...templateVariableValues) {
    super(formattedMessageTemplate);
    this.message = formattedMessageTemplate;
    this.name = "Invariant Violation";
    this.message = populateTemplateWithValues(
      formattedMessageTemplate,
      ...templateVariableValues,
    );
    trimStackToRemoveFirstLine(this);
  }
};
var isWriteOperationAllowed = (
  checkIfBufferCanBeWrittenTo,
  __bufferSize,
  ...verifyBufferIsWritable
) => {
  if (!checkIfBufferCanBeWrittenTo) {
    throw new _processWriteStreamBuffer(
      __bufferSize,
      ...verifyBufferIsWritable,
    );
  }
};
isWriteOperationAllowed.as = (
  populateTemplateWithValuesAndReplace,
  _populateTemplateWithValues,
  templateStringWithVariables,
  ...templateVariables
) => {
  if (!_populateTemplateWithValues) {
    throw populateTemplateWithValuesAndReplace.prototype.name != null
      ? new populateTemplateWithValuesAndReplace(
          populateTemplateWithValues(
            templateStringWithVariables,
            templateVariables,
          ),
        )
      : populateTemplateWithValuesAndReplace(
          populateTemplateWithValues(
            templateStringWithVariables,
            templateVariables,
          ),
        );
  }
};
function validateByteSegmentForWrite(
  validateAndExtractByteSegment,
  nullOrUndefinedMessage = "Value is nullish",
) {
  isWriteOperationAllowed(
    validateAndExtractByteSegment != null,
    nullOrUndefinedMessage,
  );
  return validateAndExtractByteSegment;
}
var safeDestroyStream = "preview-manager";
var releaseStreamResources = "preview/open";
var resetWritableStreamState = "preview/ready";
var _releaseStreamResources = "preview/port-taken";
var cleanupStreamResources = "preview/close";
var writableBufferState = "preview/closed";
var _writableStreamState = "preview/request";
var __destroyWritableStream = "preview/manager-ack";
var resetWritableStates = "bridge/init";
var terminateWritableStream = "preview/runtime-request";
var _cleanupStreamResources = "preview/runtime-response";
var removeCodecSettings = "{{identifier}}.nodebox.codesandbox.io";
var processCharacterSegmentStream = initializeReadabilityState();
var cleanupPostProcessingHandler = class {
  constructor(currentProjectId) {
    this.projectId = currentProjectId;
    processCharacterSegmentStream.onMessage((processStreamDestruction) => {
      let sourceObject = processStreamDestruction.$origin;
      let streamDestructionData = processStreamDestruction.$data;
      if (streamDestructionData.$channel_name === safeDestroyStream) {
        switch (streamDestructionData.$type) {
          case _writableStreamState: {
            if (processStreamDestruction.$type === "router-broadcast") {
              break;
            }
            let streamDestructionDataWithOrigin = streamDestructionData;
            streamDestructionDataWithOrigin.$bridge_node =
              processStreamDestruction.$origin;
            let getPortConnectionForStream = this.ports.get(
              streamDestructionDataWithOrigin.port,
            );
            if (getPortConnectionForStream) {
              processCharacterSegmentStream.send(
                getPortConnectionForStream,
                streamDestructionDataWithOrigin,
              );
            }
            break;
          }
          case releaseStreamResources: {
            let destructionStreamData = streamDestructionData;
            if (this.ports.has(destructionStreamData.port)) {
              let streamResourceCleanupRequest = {
                $channel_name: safeDestroyStream,
                $type: _releaseStreamResources,
                port: destructionStreamData.port,
              };
              processCharacterSegmentStream.send(
                sourceObject,
                streamResourceCleanupRequest,
              );
            } else {
              this.ports.set(destructionStreamData.port, sourceObject);
              this.openPort(destructionStreamData.port);
            }
            break;
          }
          case cleanupStreamResources: {
            let _destructionStreamData = streamDestructionData;
            this.closePort(_destructionStreamData.port);
            break;
          }
          case resetWritableStreamState: {
            let streamDestructionInfo = streamDestructionData;
            this.bridges.set(
              streamDestructionInfo.port,
              processStreamDestruction.$origin,
            );
            let streamDestructionPayload = {
              $channel_name: safeDestroyStream,
              $type: __destroyWritableStream,
            };
            processCharacterSegmentStream.send(
              processStreamDestruction.$origin,
              streamDestructionPayload,
            );
            let iframeIdentifier = this.getIframeId(streamDestructionData.port);
            let streamBaseUrl = this.getBaseLink(streamDestructionData.port);
            if (this.layoutDevMode) {
              let createPreviewIframe = this.createIframe(
                iframeIdentifier,
                streamBaseUrl,
                "preview",
              );
              createPreviewIframe.style.border = "1px solid black";
              createPreviewIframe.style.height = "40vh";
            }
            this.emitter.dispatchEvent(
              new _isMaximumAgeUpdateAllowed("port/ready", {
                data: {
                  port: streamDestructionInfo.port,
                  url: streamBaseUrl,
                  sourceShellId: validateByteSegmentForWrite(
                    this.ports.values().next().value,
                    "The worker doesn't exist for the given port",
                  ),
                },
              }),
            );
            break;
          }
          case terminateWritableStream: {
            let incomingStreamData = streamDestructionData;
            if (incomingStreamData.data.type === "websocket/open") {
              this.websocketClients.set(
                incomingStreamData.data.wsId,
                incomingStreamData.data.port,
              );
            }
            let connectedWebSocketPort = this.websocketClients.get(
              incomingStreamData.data.wsId,
            );
            if (!connectedWebSocketPort) {
              console.warn(
                "WS Port not found for " + incomingStreamData.data.wsId,
              );
              return;
            }
            let connectedWebSocketInstance = this.ports.get(
              connectedWebSocketPort,
            );
            if (connectedWebSocketInstance) {
              processCharacterSegmentStream.send(
                connectedWebSocketInstance,
                incomingStreamData,
              );
            }
            this.runtimes.set(
              incomingStreamData.runtimeId,
              processStreamDestruction.$origin,
            );
            break;
          }
          case _cleanupStreamResources: {
            let streamDestructionRuntime = streamDestructionData;
            let streamDestructionRuntimeData = this.runtimes.get(
              streamDestructionRuntime.runtimeId,
            );
            if (streamDestructionRuntimeData) {
              processCharacterSegmentStream.send(
                streamDestructionRuntimeData,
                streamDestructionData,
              );
            }
            break;
          }
          default: {
            console.warn("Unkown preview message", streamDestructionData);
            break;
          }
        }
      }
    });
  }
  ports = new Map();
  bridges = new Map();
  websocketClients = new Map();
  runtimes = new Map();
  emitter = new shouldAllowMaximumAgeUpdate();
  layoutDevMode =
    new URLSearchParams(window.location.search).get("layout") === "debug";
  getIframeId(generateIframeIdForProject) {
    return "iframe-" + this.projectId + "-" + generateIframeIdForProject;
  }
  createIframe(
    createAndAppendIframeWithAttributes,
    iframeURL,
    __iframeIdentifier,
  ) {
    let iframeElement = document.createElement("iframe");
    let previewsContainer = document.getElementById("previews-list");
    iframeElement.src = iframeURL;
    iframeElement.allow = "cross-origin-isolated";
    iframeElement.setAttribute(
      "data-frame-id",
      createAndAppendIframeWithAttributes,
    );
    if (__iframeIdentifier) {
      iframeElement.setAttribute("name", __iframeIdentifier);
    }
    previewsContainer?.appendChild(iframeElement);
    return iframeElement;
  }
  getPortFromShellId(findPortByDataProcessorId) {
    return [...this.ports.entries()].find(
      ({ 1: processSensorData }) =>
        processSensorData === findPortByDataProcessorId,
    )?.[0];
  }
  getBaseLink(generateProjectBaseLink) {
    let projectBaseUrl = this.projectId + "-" + generateProjectBaseLink;
    if (removeCodecSettings.includes("{{identifier}}")) {
      return (
        "https://" +
        removeCodecSettings.replace("{{identifier}}", projectBaseUrl)
      );
    } else {
      return "https://" + projectBaseUrl + "." + removeCodecSettings;
    }
  }
  openPort(bridgePort) {
    let bridgeIframeElement = this.getBaseLink(bridgePort);
    let bridgeIframeId = this.getIframeId(bridgePort);
    let _bridgeIframeElement = this.createIframe(
      bridgeIframeId,
      "index.html",
      "bridge",
    );
    if (this.layoutDevMode) {
      _bridgeIframeElement.style.border = "1px solid black";
    }
    document.getElementById("bridge")?.appendChild(_bridgeIframeElement);
    let bridgeIframeContentWindow = _bridgeIframeElement.contentWindow;
    if (!bridgeIframeContentWindow) {
      throw new Error("Could not get iframe contentWindow");
    }
    let communicationChannel = new MessageChannel();
    _bridgeIframeElement.onload = () => {
      let createResetWritableStateMessage = {
        $type: resetWritableStates,
      };
      bridgeIframeContentWindow.postMessage(
        createResetWritableStateMessage,
        "*",
        [communicationChannel.port2],
      );
      processCharacterSegmentStream.addEndpoint(bridgeIframeId, {
        send: (
          postMessageToCommunicationChannel,
          sendMessageToCommunicationChannelWithPorts,
        ) =>
          communicationChannel.port1.postMessage(
            postMessageToCommunicationChannel,
            sendMessageToCommunicationChannelWithPorts,
          ),
        onMessage: (processReceivedMessage) => {
          communicationChannel.port1.onmessage = (__processIncomingMessage) => {
            processReceivedMessage(__processIncomingMessage.data);
          };
        },
      });
    };
    if (this.layoutDevMode) {
      let previewsContainerElement = document.getElementById("previews-list");
      let createLocalhostLink = document.createElement("a");
      createLocalhostLink.setAttribute("data-port", String(bridgePort));
      createLocalhostLink.href = bridgeIframeElement;
      createLocalhostLink.target = "_blank";
      createLocalhostLink.innerText = "localhost:" + bridgePort;
      previewsContainerElement?.appendChild(createLocalhostLink);
    }
  }
  closePort(removePortByIdAndCleanUp) {
    let _iframeIdentifier = this.getIframeId(removePortByIdAndCleanUp);
    document
      .querySelectorAll('[data-frame-id="' + _iframeIdentifier + '"]')
      ?.forEach((deleteDOMElement) => {
        deleteDOMElement.remove();
      });
    document
      .querySelector('[data-port="' + removePortByIdAndCleanUp + '"]')
      ?.remove();
    let removedPortData = this.ports.get(removePortByIdAndCleanUp);
    this.ports.delete(removePortByIdAndCleanUp);
    this.bridges.delete(removePortByIdAndCleanUp);
    processCharacterSegmentStream.removeEndpoint(_iframeIdentifier);
    if (removedPortData) {
      let streamCleanupConfiguration = {
        $channel_name: safeDestroyStream,
        $type: writableBufferState,
        port: removePortByIdAndCleanUp,
      };
      processCharacterSegmentStream.broadcast(streamCleanupConfiguration);
    }
  }
};
var initializeMessageReaderAndEmitEvent = initializeObjectWithProperties(
  createStyledOutputHandler(),
);
retrieveAndValidateIntrinsicPropertyValue();
var setupReaderAndTriggerReadableEvent = window.localStorage.CSB_EMULATOR_DEBUG;
function handleAndEmitProcessedMessages(handleMessageProcessingAndEmitEvent) {
  return function (processAsyncIterableMessages, ...callbackArguments) {};
}
var createStreamReaderAndWriter = initializeObjectWithProperties(
  validateBufferCapacityAndRetrieveLimits(),
);
var initializeReaderAndDispatchEvents = (duplicateErrorWithMessage) => {
  let duplicateErrorWithDetails = new Error(duplicateErrorWithMessage.message);
  for (let _errorIdentifier of Object.keys(duplicateErrorWithMessage)) {
    duplicateErrorWithDetails[_errorIdentifier] =
      duplicateErrorWithMessage[_errorIdentifier];
  }
  return duplicateErrorWithDetails;
};
retrieveAndValidateIntrinsicPropertyValue();
var dataReaderPromise = class extends Error {
  code;
  syscall;
  path;
  errno;
  constructor(
    detailedErrorMessage,
    errorIdentifier,
    systemCall,
    filePath,
    errorNumber,
  ) {
    super(
      "Error: " +
        errorIdentifier +
        ": " +
        detailedErrorMessage +
        ", " +
        systemCall +
        " '" +
        filePath +
        "'",
    );
    this.code = errorIdentifier;
    this.syscall = systemCall;
    this.path = filePath;
    this.errno = errorNumber;
  }
};
var validateWritableData = class extends dataReaderPromise {
  constructor(isFileAlreadyExists, filePathOrURL) {
    super(
      "file already exists",
      "EEXIST",
      isFileAlreadyExists,
      filePathOrURL,
      -17,
    );
  }
};
var dataStreamConfiguration = class extends dataReaderPromise {
  constructor(fileNotFoundErrorCode, fileErrorDetails) {
    super(
      "no such file or directory",
      "ENOENT",
      fileNotFoundErrorCode,
      fileErrorDetails,
      -2,
    );
  }
};
var processWritableArray = class extends dataReaderPromise {
  constructor(illegalDirectoryOperationError, operationContext) {
    super(
      "illegal operation on a directory",
      "EISDIR",
      illegalDirectoryOperationError,
      operationContext,
      -21,
    );
  }
};
var replaceVariablesInTemplateStringAndConvertValues = class extends dataReaderPromise {
  constructor(errorCode, errorMessage) {
    super("not a directory", "ENOTDIR", errorCode, errorMessage, -20);
  }
};
var replaceTemplateVariables = class extends dataReaderPromise {
  constructor(isDirectoryNotEmptyError, directoryNotEmptyErrorCode) {
    super(
      "directory not empty",
      "ENOTEMPTY",
      isDirectoryNotEmptyError,
      directoryNotEmptyErrorCode,
      -39,
    );
  }
};
var variableFormatter = class extends dataReaderPromise {
  constructor(argumentValidationError, validationErrorContext) {
    super(
      "invalid argument",
      "EINVAL",
      argumentValidationError,
      validationErrorContext,
      -22,
    );
  }
};
var handleTemplateVariableProcessing = class extends dataReaderPromise {
  constructor(socketOperationFailureCode, socketOperationException) {
    super(
      "operation not supported on socket",
      "ENOTSUP",
      socketOperationFailureCode,
      socketOperationException,
      -45,
    );
  }
};
var processAndBufferWriteStream = class extends dataReaderPromise {
  constructor(tooManySymbolicLinksError, symbolicLinkDepth) {
    super(
      "too many symbolic links encountered",
      "ELOOP",
      tooManySymbolicLinksError,
      symbolicLinkDepth,
      -62,
    );
  }
};
var handleWriteChunk = {
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  UV_DIRENT_UNKNOWN: 0,
  UV_DIRENT_FILE: 1,
  UV_DIRENT_DIR: 2,
  UV_DIRENT_LINK: 3,
  UV_DIRENT_FIFO: 4,
  UV_DIRENT_SOCKET: 5,
  UV_DIRENT_CHAR: 6,
  UV_DIRENT_BLOCK: 7,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 512,
  O_EXCL: 2048,
  UV_FS_O_FILEMAP: 0,
  O_NOCTTY: 131072,
  O_TRUNC: 1024,
  O_APPEND: 8,
  O_DIRECTORY: 1048576,
  O_NOFOLLOW: 256,
  O_SYNC: 128,
  O_DSYNC: 4194304,
  O_SYMLINK: 2097152,
  O_NONBLOCK: 4,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_COPYFILE_EXCL: 1,
  COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_FICLONE_FORCE: 4,
};
var validateAndReleaseWritableStream = class {
  mode;
  size;
  ino;
  atimeMs;
  mtimeMs;
  ctimeMs;
  birthtimeMs;
  atime;
  mtime;
  ctime;
  birthtime;
  uid;
  gid;
  dev;
  nlink;
  rdev;
  blksize;
  blocks;
  constructor(
    FileMetadata,
    filePermissions,
    linkCount,
    ownerUserId,
    groupOwnerId,
    deviceIdentifier,
    blockSizeBytes,
    inodeIdentifier,
    fileByteSize,
    allocatedBlockCount,
    lastAccessTimeMilliseconds,
    updatedTimeMilliseconds,
    createdTimeMilliseconds,
    creationTimeMilliseconds,
  ) {
    this.dev = FileMetadata;
    this.size = fileByteSize;
    this.ino = inodeIdentifier;
    this.atimeMs = lastAccessTimeMilliseconds;
    this.mtimeMs = updatedTimeMilliseconds;
    this.ctimeMs = createdTimeMilliseconds;
    this.birthtimeMs = createdTimeMilliseconds;
    this.atime = new Date(lastAccessTimeMilliseconds);
    this.mtime = new Date(updatedTimeMilliseconds);
    this.ctime = new Date(createdTimeMilliseconds);
    this.birthtime = new Date(creationTimeMilliseconds);
    this.blocks = allocatedBlockCount;
    this.nlink = linkCount;
    this.uid = ownerUserId;
    this.gid = groupOwnerId;
    this.rdev = deviceIdentifier;
    this.blksize = blockSizeBytes;
    this.mode = filePermissions;
  }
  #e(isCurrentModeWriteChunk) {
    return (this.mode & handleWriteChunk.S_IFMT) === isCurrentModeWriteChunk;
  }
  isFile() {
    return this.#e(handleWriteChunk.S_IFREG);
  }
  isDirectory() {
    return this.#e(handleWriteChunk.S_IFDIR);
  }
  isSymbolicLink() {
    return this.#e(handleWriteChunk.S_IFLNK);
  }
  isSocket() {
    return false;
  }
  isFIFO() {
    return false;
  }
  isCharacterDevice() {
    return false;
  }
  isBlockDevice() {
    return false;
  }
};
var onStreamCompletionCallback = 4096;
function initializeWritableStreamWithHandleMessage(handleStreamMessage) {
  let streamMessageType = handleStreamMessage.type;
  let defaultBufferSize =
    streamMessageType === 0 ? 16895 : streamMessageType === 2 ? 41453 : 33279;
  let computedChunkSizeForStream =
    streamMessageType === 0
      ? 0
      : Math.max(
          8,
          Math.ceil(handleStreamMessage.size / onStreamCompletionCallback),
        );
  return new validateAndReleaseWritableStream(
    1,
    defaultBufferSize,
    1,
    1,
    1,
    0,
    onStreamCompletionCallback,
    handleStreamMessage.ino,
    handleStreamMessage.size,
    computedChunkSizeForStream,
    handleStreamMessage.atimeMs,
    handleStreamMessage.mtimeMs,
    handleStreamMessage.ctimeMs,
    handleStreamMessage.ctimeMs,
  );
}
retrieveAndValidateIntrinsicPropertyValue();
function fetchAndValidateIntrinsicProperties(processReadableStream) {
  return fetchIntrinsicPropertiesWithValidation.from(processReadableStream);
}
function fetchAndValidateReadableStreamProperties(
  processStreamReadinessAndCleanup,
  handleReadableStreamCompletion,
) {
  if (typeof processStreamReadinessAndCleanup == "string") {
    return fetchIntrinsicPropertiesWithValidation.from(
      processStreamReadinessAndCleanup,
      handleReadableStreamCompletion,
    );
  } else {
    return fetchIntrinsicPropertiesWithValidation.from(
      processStreamReadinessAndCleanup,
    );
  }
}
function initializeEventListenerBasedOnType(initializeEventListeners) {
  if (typeof initializeEventListeners == "string") {
    return initializeEventListeners;
  } else if (
    initializeEventListeners instanceof fetchIntrinsicPropertiesWithValidation
  ) {
    return initializeEventListeners.toString("utf-8");
  } else {
    return initializeEventListeners.pathname;
  }
}
function extractPathSegmentsFromFilePath(
  initializeStreamComparisonForVersionEvaluation,
) {
  let _resolvedPathSegments = buildFilePathFromSegments(
    initializeStreamComparisonForVersionEvaluation,
  ).split("/");
  _resolvedPathSegments.shift();
  return _resolvedPathSegments;
}
function joinPathSegments(
  terminateVersionComparisonStream,
  __initializeEventListeners,
) {
  if (
    terminateVersionComparisonStream.endsWith("/") ||
    __initializeEventListeners.startsWith("/")
  ) {
    return terminateVersionComparisonStream + __initializeEventListeners;
  } else {
    return terminateVersionComparisonStream + "/" + __initializeEventListeners;
  }
}
var initializeStreamPortAndNotify = 0;
function increaseNotificationStreamCount() {
  return (initializeStreamPortAndNotify += 1);
}
function handleVersionComparisonSerialization(handleWorkerVersionComparison) {
  if (
    handleWorkerVersionComparison instanceof retrieveEditableStateAttributes ||
    handleWorkerVersionComparison instanceof retrievePortDataBasedOnShellId ||
    handleWorkerVersionComparison instanceof setupVersionComparisonEventHandlers
  ) {
    return handleWorkerVersionComparison.serialize();
  }
  throw new Error("Not serializable");
}
function processWebSocketClientHandlerBasedOnType(
  initializeWebSocketClientHandler,
  handleWebSocketConnectionAndCleanup,
  handleStreamTerminationAndCleanup,
) {
  switch (initializeWebSocketClientHandler.type) {
    case 0:
      return retrieveEditableStateAttributes.deserialize(
        initializeWebSocketClientHandler,
        handleWebSocketConnectionAndCleanup,
        handleStreamTerminationAndCleanup,
      );
    case 1:
      return retrievePortDataBasedOnShellId.deserialize(
        initializeWebSocketClientHandler,
        handleWebSocketConnectionAndCleanup,
        handleStreamTerminationAndCleanup,
      );
    case 2:
      return setupVersionComparisonEventHandlers.deserialize(
        initializeWebSocketClientHandler,
        handleWebSocketConnectionAndCleanup,
      );
    default:
      throw new Error("Unknown node type");
  }
}
var handleWebSocketStreamEvents = class {
  getPath() {
    if (this.parent) {
      if (!this.parent.name && !this.parent.parent) {
        return "/" + this.name;
      } else {
        return this.parent.getPath() + "/" + this.name;
      }
    } else {
      return "/";
    }
  }
  getPathParts(currentPathSegments = []) {
    if (this.name) {
      currentPathSegments.unshift(this.name);
    }
    if (this.parent) {
      currentPathSegments = this.parent.getPathParts(currentPathSegments);
    }
    return currentPathSegments;
  }
  rename(setNameAndUpdateTimestamp) {
    this.name = setNameAndUpdateTimestamp;
    this.stats.mtimeMs = Date.now();
  }
};
function generateIframeMetadata(
  initializeIframeComponentMethods,
  initializeIframeAttributes,
) {
  return {
    type: initializeIframeComponentMethods,
    size: initializeIframeAttributes,
    ino: increaseNotificationStreamCount(),
    mtimeMs: Date.now(),
    ctimeMs: Date.now(),
    atimeMs: Date.now(),
  };
}
var setupVersionComparisonEventHandlers = class extends handleWebSocketStreamEvents {
  name;
  stats;
  target;
  parent;
  constructor(_fileName, outputFilePath, referenceObject) {
    super();
    this.name = _fileName;
    this.stats = generateIframeMetadata(2, 128);
    this.target = outputFilePath;
    this.parent = referenceObject;
  }
  serialize() {
    return {
      type: 2,
      name: this.name,
      stats: this.stats,
      target: this.target,
    };
  }
  static deserialize(createVersionComparisonHandler, versionComparisonStats) {
    let versionComparisonEventHandler = new setupVersionComparisonEventHandlers(
      createVersionComparisonHandler.name,
      createVersionComparisonHandler.target,
      versionComparisonStats,
    );
    versionComparisonEventHandler.stats = createVersionComparisonHandler.stats;
    return versionComparisonEventHandler;
  }
};
var retrievePortDataBasedOnShellId = class extends handleWebSocketStreamEvents {
  constructor(
    fileSystemFile,
    fileData,
    parentFileDirectory,
    fileSystemManager,
  ) {
    super();
    this.coreFS = fileSystemManager;
    this.name = fileSystemFile;
    this.content = fileData;
    this.stats = generateIframeMetadata(1, fileData.byteLength);
    this.parent = parentFileDirectory;
  }
  name;
  stats;
  content;
  parent;
  write(updateContentAndEmitWrite, isUserLoggedIn = false) {
    this.content = updateContentAndEmitWrite;
    this.stats.size = updateContentAndEmitWrite.byteLength;
    this.stats.mtimeMs = Date.now();
    this.coreFS.emitWrite(this, updateContentAndEmitWrite, isUserLoggedIn);
  }
  serialize() {
    return {
      type: 1,
      name: this.name,
      stats: this.stats,
      content: this.content,
    };
  }
  static deserialize(
    createWritableStateInstanceFromDeserializedData,
    processWritableState,
    writableStateConfiguration,
  ) {
    let portDataWritableState = new retrievePortDataBasedOnShellId(
      createWritableStateInstanceFromDeserializedData.name,
      createWritableStateInstanceFromDeserializedData.content,
      processWritableState,
      writableStateConfiguration,
    );
    portDataWritableState.stats =
      createWritableStateInstanceFromDeserializedData.stats;
    return portDataWritableState;
  }
};
var retrieveEditableStateAttributes = class extends handleWebSocketStreamEvents {
  constructor(fileConstructorName, parentDirectoryPath, fileSystemService) {
    super();
    this.coreFS = fileSystemService;
    this.name = fileConstructorName;
    this.parent = parentDirectoryPath;
    this.stats = generateIframeMetadata(0, 128);
  }
  name;
  stats;
  children = new Map();
  parent;
  getChild(retrieveChildById) {
    return this.children.get(retrieveChildById);
  }
  addChild(
    addChildNodeAndNotifyIfEnabled,
    isUserFeatureEnabled = true,
    isFeatureActive = false,
  ) {
    this.children.set(
      addChildNodeAndNotifyIfEnabled.name,
      addChildNodeAndNotifyIfEnabled,
    );
    this.stats.mtimeMs = Date.now();
    if (isUserFeatureEnabled) {
      this.coreFS.emitNodeCreation(
        this,
        addChildNodeAndNotifyIfEnabled,
        isFeatureActive,
      );
    }
  }
  removeChild(
    deleteChildNodeById,
    isAuthenticatedUser = true,
    _isAuthenticatedUser = false,
  ) {
    this.children.delete(deleteChildNodeById);
    this.stats.mtimeMs = Date.now();
    if (isAuthenticatedUser) {
      this.coreFS.emitNodeDeletion(
        this,
        deleteChildNodeById,
        _isAuthenticatedUser,
      );
    }
  }
  serialize() {
    return {
      type: 0,
      name: this.name,
      stats: this.stats,
    };
  }
  static deserialize(
    extractEditableStateAttributes,
    writableStateConfig,
    initializationConfig,
  ) {
    let editableStateProperties = new retrieveEditableStateAttributes(
      extractEditableStateAttributes.name,
      writableStateConfig,
      initializationConfig,
    );
    editableStateProperties.stats = extractEditableStateAttributes.stats;
    return editableStateProperties;
  }
};
var checkIfObjectIsInitialized = class {
  root = new retrieveEditableStateAttributes("", undefined, this);
  emitter = new _decodeByteHeaderValue();
  onFSEvent = this.emitter.event;
  emitNodeCreation(
    emitNodeCreationWithParent,
    nodeCreationData,
    isNodeCreationImmediatelyProcessed,
  ) {
    this.emitter.fire({
      type: "create",
      parent: emitNodeCreationWithParent.getPath(),
      newNode: handleVersionComparisonSerialization(nodeCreationData),
      isSync: isNodeCreationImmediatelyProcessed,
    });
  }
  emitNodeDeletion(
    emitNodeDeletionWithParent,
    targetNodeForDeletion,
    isDeletionSynchronous,
  ) {
    this.emitter.fire({
      type: "remove",
      parent: emitNodeDeletionWithParent.getPath(),
      name: targetNodeForDeletion,
      isSync: isDeletionSynchronous,
    });
  }
  emitWrite(emitFileWriteEvent, contentToWrite, isWriteSynchronous) {
    this.emitter.fire({
      type: "write",
      path: emitFileWriteEvent.getPath(),
      content: contentToWrite,
      isSync: isWriteSynchronous,
    });
  }
  resolveSymlink(resolveSymlinkTarget) {
    let symlinkResolutionCount = 0;
    let resolvedSymlinkTarget = resolveSymlinkTarget;
    while (
      resolvedSymlinkTarget instanceof setupVersionComparisonEventHandlers
    ) {
      if (symlinkResolutionCount > 10) {
        throw new processAndBufferWriteStream(
          "open",
          resolveSymlinkTarget.getPath(),
        );
      }
      resolvedSymlinkTarget = this.getNodeAtPath(
        extractPathSegmentsFromFilePath(resolvedSymlinkTarget.target),
        resolvedSymlinkTarget.target,
      );
      symlinkResolutionCount++;
    }
    return resolvedSymlinkTarget;
  }
  getDirNodeAtPath(getDirectoryNodeByPath) {
    let activeDirectoryNode = this.root;
    if (
      getDirectoryNodeByPath.length === 1 &&
      getDirectoryNodeByPath[0] === ""
    ) {
      return activeDirectoryNode;
    }
    for (let pathSegment of getDirectoryNodeByPath) {
      let childDirectory = activeDirectoryNode.getChild(pathSegment);
      if (childDirectory) {
        if (childDirectory instanceof retrieveEditableStateAttributes) {
          activeDirectoryNode = childDirectory;
        } else if (
          childDirectory instanceof setupVersionComparisonEventHandlers
        ) {
          let resolvedSymlinkedChildDirectoryNode =
            this.resolveSymlink(childDirectory);
          if (
            resolvedSymlinkedChildDirectoryNode instanceof
            retrieveEditableStateAttributes
          ) {
            activeDirectoryNode = resolvedSymlinkedChildDirectoryNode;
          } else {
            throw new replaceVariablesInTemplateStringAndConvertValues(
              "open",
              getDirectoryNodeByPath.join("/"),
            );
          }
        } else {
          throw new dataStreamConfiguration(
            "open",
            getDirectoryNodeByPath.join("/"),
          );
        }
      } else {
        throw new dataStreamConfiguration(
          "open",
          getDirectoryNodeByPath.join("/"),
        );
      }
    }
    return activeDirectoryNode;
  }
  getNodeAtPath(retrieveChildNodeFromPath, parentNodeId) {
    let lastChildNodeId = retrieveChildNodeFromPath.pop();
    if (!lastChildNodeId) {
      return this.root;
    }
    let directoryNode = this.getDirNodeAtPath(retrieveChildNodeFromPath);
    if (!directoryNode) {
      throw new dataStreamConfiguration("open", parentNodeId);
    }
    if (!(directoryNode instanceof retrieveEditableStateAttributes)) {
      throw new replaceVariablesInTemplateStringAndConvertValues(
        "open",
        parentNodeId,
      );
    }
    let retrievedChildNode = directoryNode.getChild(lastChildNodeId);
    if (!retrievedChildNode) {
      throw new dataStreamConfiguration("open", parentNodeId);
    }
    return retrievedChildNode;
  }
  moveNode(
    relocateNodeToPath,
    relocateNodeToNewPath,
    isFeatureToggleActive = false,
  ) {
    let nodeBeingRelocated = this.getNodeAtPath(
      extractPathSegmentsFromFilePath(relocateNodeToPath),
      relocateNodeToPath,
    );
    let resolvedNewPathSegments = extractPathSegmentsFromFilePath(
      relocateNodeToNewPath,
    );
    let newNodeName = resolvedNewPathSegments.pop();
    if (newNodeName) {
      let targetParentNode = this.getDirNodeAtPath(resolvedNewPathSegments);
      nodeBeingRelocated.parent?.removeChild(nodeBeingRelocated.name, false);
      nodeBeingRelocated.rename(newNodeName);
      targetParentNode.addChild(nodeBeingRelocated, false);
      nodeBeingRelocated.parent = targetParentNode;
    }
    this.emitter.fire({
      type: "move",
      oldPath: relocateNodeToPath,
      newPath: relocateNodeToNewPath,
      isSync: isFeatureToggleActive,
    });
    return nodeBeingRelocated;
  }
  _serializeTreeNode(serializeAndRetrieveEditableNode) {
    if (
      serializeAndRetrieveEditableNode instanceof
      retrieveEditableStateAttributes
    ) {
      return {
        ...serializeAndRetrieveEditableNode.serialize(),
        children: [],
      };
    } else {
      return handleVersionComparisonSerialization(
        serializeAndRetrieveEditableNode,
      );
    }
  }
  _serialize(_sourceNode, serializedTreeNode) {
    for (let childNode of _sourceNode.children.values()) {
      if (childNode instanceof retrieveEditableStateAttributes) {
        let serializedChildTreeNode = this._serializeTreeNode(childNode);
        serializedChildTreeNode = this._serialize(
          childNode,
          serializedChildTreeNode,
        );
        serializedTreeNode.children.push(serializedChildTreeNode);
      } else {
        serializedTreeNode.children.push(this._serializeTreeNode(childNode));
      }
    }
    return serializedTreeNode;
  }
  handleSyncEvent(handleSyncEvent) {
    if (!handleSyncEvent.isSync) {
      switch (handleSyncEvent.type) {
        case "create": {
          let parentDirectoryNode = this.getDirNodeAtPath(
            extractPathSegmentsFromFilePath(handleSyncEvent.parent),
          );
          let processedChildNode = processWebSocketClientHandlerBasedOnType(
            handleSyncEvent.newNode,
            parentDirectoryNode,
            this,
          );
          parentDirectoryNode.addChild(processedChildNode, true, true);
          break;
        }
        case "move": {
          this.moveNode(handleSyncEvent.oldPath, handleSyncEvent.newPath, true);
          break;
        }
        case "remove": {
          this.getDirNodeAtPath(
            extractPathSegmentsFromFilePath(handleSyncEvent.parent),
          ).removeChild(handleSyncEvent.name, true, true);
          break;
        }
        case "write": {
          let nodeRetrievedFromSyncPath = this.getNodeAtPath(
            extractPathSegmentsFromFilePath(handleSyncEvent.path),
            handleSyncEvent.path,
          );
          if (
            nodeRetrievedFromSyncPath instanceof retrievePortDataBasedOnShellId
          ) {
            nodeRetrievedFromSyncPath.write(handleSyncEvent.content, true);
          }
          break;
        }
      }
    }
  }
  serialize() {
    let serializedTreeNode = this._serializeTreeNode(this.root);
    return this._serialize(this.root, serializedTreeNode);
  }
  populate(populateChildElements, mainContainer = this.root) {
    for (let childElement of populateChildElements.children) {
      if (childElement.type === 0) {
        let webSocketClientHandlerResponse =
          processWebSocketClientHandlerBasedOnType(
            childElement,
            mainContainer,
            this,
          );
        mainContainer.addChild(webSocketClientHandlerResponse, false);
        this.populate(childElement, webSocketClientHandlerResponse);
      } else {
        mainContainer.addChild(
          processWebSocketClientHandlerBasedOnType(
            childElement,
            mainContainer,
            this,
          ),
          false,
        );
      }
    }
  }
};
var fetchValidSemverRangeEventListeners = initializeObjectWithProperties(
  registerAndValidateEncodingPatterns(),
);
var validateAndFetchEventListeners = initializeObjectWithProperties(
  initializeVersionComparisonPatterns(),
);
var _initializeEventHandlers = initializeObjectWithProperties(
  initializeVersionValidationModule(),
);
function isValidHttpOrHttpsUrl(_initializeEventListeners) {
  let urlObject;
  try {
    urlObject = new URL(_initializeEventListeners);
  } catch {
    return false;
  }
  return urlObject.protocol === "http:" || urlObject.protocol === "https:";
}
function generateCleanURL(...generateCleanURLFromParts) {
  try {
    let cleanedAndNormalizedURL = new URL(generateCleanURLFromParts.join("/"));
    cleanedAndNormalizedURL.pathname = cleanedAndNormalizedURL.pathname.replace(
      /\/+/g,
      "/",
    );
    return cleanedAndNormalizedURL.toString();
  } catch {
    return generateCleanURLFromParts.join("/").replace(/\/+/g, "/");
  }
}
function pauseExecutionForDuration(incrementEventListenerCount) {
  return new Promise((scheduleEventListenerInitialization) =>
    setTimeout(
      scheduleEventListenerInitialization,
      incrementEventListenerCount,
    ),
  );
}
var countEventListeners = new Set([
  408, 429, 424, 499, 444, 502, 503, 504, 599,
]);
function hasStreamTerminationEventListener(processStreamTerminationEvent) {
  return countEventListeners.has(processStreamTerminationEvent);
}
function computeDynamicEventDelay(
  _setupVersionComparisonEventHandlers,
  setupWebSocketEventHandlers,
) {
  let dynamicDelayMultiplier = Math.max(1, Math.random() * 2);
  return Math.min(
    dynamicDelayMultiplier *
      _setupVersionComparisonEventHandlers.minDelayMs *
      Math.pow(
        _setupVersionComparisonEventHandlers.factor,
        setupWebSocketEventHandlers,
      ),
    _setupVersionComparisonEventHandlers.maxDelayMs,
  );
}
async function fetchWithRetryAndExponentialBackoff(
  setupEventListenerCleanup,
  WebSocketStreamEventHandler,
  retryStrategyConfig = {
    maxRetries: 5,
    minDelayMs: 500,
    maxDelayMs: 15000,
    factor: 2,
  },
  numberOfEventListenersActive = 0,
) {
  let attemptFetchWithBackoff = async () => {
    numberOfEventListenersActive += 1;
    let calculatedEventListenerDelay = computeDynamicEventDelay(
      retryStrategyConfig,
      numberOfEventListenersActive,
    );
    await pauseExecutionForDuration(calculatedEventListenerDelay);
    return fetchWithRetryAndExponentialBackoff(
      setupEventListenerCleanup,
      WebSocketStreamEventHandler,
      retryStrategyConfig,
      numberOfEventListenersActive,
    );
  };
  try {
    let setupEventListenerResponse = await fetch(
      setupEventListenerCleanup,
      WebSocketStreamEventHandler,
    );
    if (
      !setupEventListenerResponse.ok &&
      hasStreamTerminationEventListener(setupEventListenerResponse.status) &&
      retryStrategyConfig.maxRetries > numberOfEventListenersActive
    ) {
      return attemptFetchWithBackoff();
    } else {
      return setupEventListenerResponse;
    }
  } catch (fetchAttemptError) {
    if (retryStrategyConfig.maxRetries > numberOfEventListenersActive) {
      return attemptFetchWithBackoff();
    }
    throw fetchAttemptError;
  }
}
var __setupVersionComparisonEventHandlers = class {
  cdnUrl = undefined;
  init(setCdnUrl) {
    this.cdnUrl = setCdnUrl;
  }
  async fetch(fetchResourceFromCDN, fetchRequestOptions) {
    let fetchedResponse = await fetchWithRetryAndExponentialBackoff(
      fetchResourceFromCDN,
      fetchRequestOptions,
    );
    if (!fetchedResponse.ok) {
      let responseTextFromCDN = await fetchedResponse
        .text()
        .catch(() => "Unknown CDN error");
      throw new Error(
        populateTemplateWithValues(
          'Failed to fetch "%s": %s',
          fetchResourceFromCDN,
          responseTextFromCDN,
        ),
      );
    }
    return fetchedResponse;
  }
  async fetchPackage(packageNameAndVersion, specifiedPackageVersion) {
    isWriteOperationAllowed(
      this.cdnUrl,
      'Failed to fetch package "%s@%s": the Sandpack CDN is not defined',
      this.cdnUrl,
    );
    let fetchedPackageFiles;
    try {
      fetchedPackageFiles = await this.fetchPackageFromRegistry(
        packageNameAndVersion,
        specifiedPackageVersion,
      );
    } catch {
      let base64EncodedPackageIdentifierForFetch = btoa(
        packageNameAndVersion + "@" + specifiedPackageVersion,
      );
      let normalizedPackageFetchURL = generateCleanURL(
        this.cdnUrl,
        "/v2/mod/" + base64EncodedPackageIdentifierForFetch,
      );
      let fetchedPackageFilesArrayBuffer = await (
        await this.fetch(normalizedPackageFetchURL)
      ).arrayBuffer();
      fetchedPackageFiles = processStreamStatus(fetchedPackageFilesArrayBuffer);
    }
    return {
      name: packageNameAndVersion,
      version: specifiedPackageVersion,
      files: fetchedPackageFiles,
    };
  }
  async fetchPackageFromRegistry(
    fetchTarballOfPackageFromRegistry,
    _packageVersion,
  ) {
    let tarballPackageUrl = (
      await this.fetch(
        "https://registry.npmjs.org/" +
          fetchTarballOfPackageFromRegistry +
          "/" +
          _packageVersion,
      ).then((fetchJsonDataFromApi) => fetchJsonDataFromApi.json())
    ).dist.tarball;
    let fetchedTarballResponse = await this.fetch(tarballPackageUrl);
    let unzippedPackageBuffer = await aggregateChunksFromReader(
      (await fetchedTarballResponse.blob())
        .stream()
        .pipeThrough(new DecompressionStream("gzip")),
    );
    let initializePackageEventHandlers = await (0,
    _initializeEventHandlers.default)(unzippedPackageBuffer.buffer);
    let extractedPackageBufferMap = {};
    for (let handlePackageEvents of initializePackageEventHandlers) {
      let packageEventListenerName = handlePackageEvents.name.replace(
        /^[^/]+/,
        "",
      );
      if (handlePackageEvents.type === "0") {
        extractedPackageBufferMap[packageEventListenerName] = new Uint8Array(
          handlePackageEvents.buffer,
        );
      }
    }
    return extractedPackageBufferMap;
  }
  async fetchDependencies(dependenciesToFetch) {
    isWriteOperationAllowed(
      this.cdnUrl,
      "Failed to fetch dependencies: the Sandpack CDN is not defined",
      this.cdnUrl,
    );
    if (dependenciesToFetch.length === 0) {
      return Promise.resolve(null);
    }
    let dependencyVersionString = dependenciesToFetch
      .map(
        ([userData, userDataCursor]) =>
          userData + "@" + userDataCursor.replace(/\s+/, ""),
      )
      .sort()
      .join(";");
    let normalizedDependencyFetchUrl = generateCleanURL(
      this.cdnUrl,
      "/v2/deps/" + btoa(dependencyVersionString),
    );
    let dependencyArrayData = await (
      await this.fetch(normalizedDependencyFetchUrl)
    ).arrayBuffer();
    return processStreamStatus(dependencyArrayData);
  }
};
async function aggregateChunksFromReader(______compareVersionWithPrerelease) {
  let streamReader = ______compareVersionWithPrerelease.getReader();
  let bufferedChunks = [];
  let isStreamReadingCompleted = false;
  while (!isStreamReadingCompleted) {
    let { done: isStreamReadingFinished, value: streamDataChunk } =
      await streamReader.read();
    if (isStreamReadingFinished) {
      isStreamReadingCompleted = true;
    } else {
      bufferedChunks.push(streamDataChunk);
    }
  }
  let combinedChunksTotalLength = bufferedChunks.reduce(
    (calculateTotalLengthWithPrefix, prefixLength) =>
      calculateTotalLengthWithPrefix + prefixLength.length,
    0,
  );
  let concatenatedChunksBuffer = new Uint8Array(combinedChunksTotalLength);
  let currentBufferPosition = 0;
  for (let bufferSegment of bufferedChunks) {
    concatenatedChunksBuffer.set(bufferSegment, currentBufferPosition);
    currentBufferPosition += bufferSegment.length;
  }
  return concatenatedChunksBuffer;
}
var initializeWritableStateProperties = initializeObjectWithProperties(
  registerAndValidateEncodingPatterns(),
);
var validateAndCompareVersion = ["~", ".", "/"];
function validateAndGroupNpmPackages(
  _validateAndCompareVersion,
  compareAndValidateVersion,
) {
  let addNpmPackageVersionToSet = (
    addPackageVersionToNpmSet,
    packageVersionToAdd,
  ) => {
    compareAndValidateVersion.npmPackages[addPackageVersionToNpmSet] ||=
      new Set();
    compareAndValidateVersion.npmPackages[addPackageVersionToNpmSet].add(
      packageVersionToAdd,
    );
  };
  for (let [npmPackageName, npmPackageVersion] of Object.entries(
    _validateAndCompareVersion,
  )) {
    if (typeof npmPackageVersion != "string") {
      throw new Error("Invalid package specifier: " + npmPackageVersion);
    }
    if (
      initializeWritableStateProperties.default.validRange(npmPackageVersion)
    ) {
      compareAndValidateVersion.directNpmPackages[npmPackageName] =
        npmPackageVersion;
      addNpmPackageVersionToSet(npmPackageName, npmPackageVersion);
    } else if (npmPackageVersion.startsWith("file:")) {
      compareAndValidateVersion.fileAliases[npmPackageName] =
        npmPackageVersion.substring(5);
    } else if (npmPackageVersion.startsWith("npm:")) {
      let [__packageNameAndVersion, ____packageVersion] = npmPackageVersion
        .substring(4)
        .split("@");
      if (
        !__packageNameAndVersion ||
        !initializeWritableStateProperties.default.validRange(
          ____packageVersion,
        )
      ) {
        throw new Error("Invalid dependency specifier: " + npmPackageVersion);
      }
      addNpmPackageVersionToSet(__packageNameAndVersion, ____packageVersion);
      compareAndValidateVersion.npmAliases[npmPackageName] =
        __packageNameAndVersion + "@" + ____packageVersion;
    } else if (isValidHttpOrHttpsUrl(npmPackageVersion)) {
      compareAndValidateVersion.remotePackages[npmPackageName] =
        npmPackageVersion;
    } else if (validateAndCompareVersion.includes(npmPackageVersion[0])) {
      compareAndValidateVersion.fileAliases[npmPackageName] = npmPackageVersion;
    } else if (npmPackageVersion.includes("/")) {
      compareAndValidateVersion.gitPackages[npmPackageName] = npmPackageVersion;
    } else {
      compareAndValidateVersion.directNpmPackages[npmPackageName] =
        npmPackageVersion;
      addNpmPackageVersionToSet(npmPackageName, npmPackageVersion);
    }
  }
  return compareAndValidateVersion;
}
function groupAndValidateNpmPackages(_______compareVersionWithPrerelease) {
  let groupedNpmPackageVersions = {
    directNpmPackages: {},
    npmPackages: {},
    remotePackages: {},
    gitPackages: {},
    npmAliases: {},
    fileAliases: {},
  };
  if (
    !_______compareVersionWithPrerelease ||
    typeof _______compareVersionWithPrerelease != "object"
  ) {
    _______compareVersionWithPrerelease = {};
  }
  validateAndGroupNpmPackages(
    _______compareVersionWithPrerelease,
    groupedNpmPackageVersions,
  );
  return groupedNpmPackageVersions;
}
function generatePackageDependencySummary(
  comparePrereleaseVersionNumbers,
  isNewFeatureEnabled = true,
) {
  let generatePackageDependencyReport = {
    directNpmPackages: {},
    npmPackages: {},
    remotePackages: {},
    gitPackages: {},
    npmAliases: {},
    fileAliases: {},
  };
  if (comparePrereleaseVersionNumbers.dependencies) {
    validateAndGroupNpmPackages(
      comparePrereleaseVersionNumbers.dependencies,
      generatePackageDependencyReport,
    );
  }
  if (isNewFeatureEnabled && comparePrereleaseVersionNumbers.devDependencies) {
    validateAndGroupNpmPackages(
      comparePrereleaseVersionNumbers.devDependencies,
      generatePackageDependencyReport,
    );
  }
  return generatePackageDependencyReport;
}
var logAndThrowErrorForNodeOperation = initializeObjectWithProperties(
  compareVersionWithPrereleaseFlag(),
);
function convertAndNormalizeErrorHandling(handleErrorDuringNodeProcessing) {
  let parsedErrorObject = (0, logAndThrowErrorForNodeOperation.parse)(
    handleErrorDuringNodeProcessing,
  );
  return Object.entries(parsedErrorObject).reduce(
    (setUserAgeWithCamelCaseKey, [userAge, checkIfUserIsAdult]) => {
      let getUserAgeKeyInCamelCase = userAge.replace(
        /-([a-z])/g,
        (convertToUpperCase, _convertToUpperCase) =>
          _convertToUpperCase.toUpperCase(),
      );
      setUserAgeWithCamelCaseKey[getUserAgeKeyInCamelCase] = checkIfUserIsAdult;
      return setUserAgeWithCamelCaseKey;
    },
    {},
  );
}
function extractErrorDetailsFromLog(logAndHandleError) {
  let splitLogForErrorDetails = logAndHandleError.split("@");
  let extractedErrorType = splitLogForErrorDetails.pop();
  if (!extractedErrorType || !splitLogForErrorDetails.length) {
    throw new Error("Invalid specifier: " + logAndHandleError);
  }
  return [splitLogForErrorDetails.join("@"), extractedErrorType];
}
function convertErrorListenerToPackageInfoArray(errorEventListener) {
  let convertErrorListenerToPackageInfoList = [];
  for (let [_npmPackageName, npmPackageVersionRange] of Object.entries(
    errorEventListener.directNpmPackages,
  )) {
    convertErrorListenerToPackageInfoList.push([
      _npmPackageName,
      {
        name: _npmPackageName,
        range: npmPackageVersionRange,
      },
    ]);
  }
  for (let [npmAlias, npmAliasInfo] of Object.entries(
    errorEventListener.npmAliases,
  )) {
    let [npmPackageNameAndVersion, parsedNpmAliasVersionRange] =
      extractErrorDetailsFromLog(npmAliasInfo);
    if (!parsedNpmAliasVersionRange) {
      throw new Error("Invalid npm alias version range");
    }
    convertErrorListenerToPackageInfoList.push([
      npmAlias,
      {
        name: npmPackageNameAndVersion,
        range: parsedNpmAliasVersionRange,
      },
    ]);
  }
  return convertErrorListenerToPackageInfoList;
}
var handleSyncEventUpdate = class extends shouldAllowMaximumAgeUpdate {
  constructor(fileSystemUtility) {
    super();
    this.fs = fileSystemUtility;
    this.store = new dependencyManagementUtility(this.fs, {
      publicHoistPattern: ["@vuepress/client", "@nuxt*"],
    });
    this.cdnClient = new __setupVersionComparisonEventHandlers();
    this.pendingRequests = new Map();
  }
  store;
  _cdnUrl;
  cdnClient;
  pendingRequests;
  get cdnUrl() {
    return this._cdnUrl;
  }
  set cdnUrl(cdnUrlSetter) {
    isWriteOperationAllowed(
      typeof cdnUrlSetter !== "undefined",
      "Failed to update a CDN URL: the next URL is not defined",
    );
    this._cdnUrl = cdnUrlSetter;
    this.cdnClient.init(cdnUrlSetter);
  }
  get totalPending() {
    return this.pendingRequests.size;
  }
  async installPackage(installPackageByNameAndVersion, __packageVersion) {
    if (
      !this.shouldInstallPackage(
        installPackageByNameAndVersion,
        __packageVersion,
      )
    ) {
      return;
    }
    let fetchedPackagePromise = this.cdnClient.fetchPackage(
      installPackageByNameAndVersion,
      __packageVersion,
    );
    fetchedPackagePromise.then((dispatchProgressUpdate) => {
      this.dispatchEvent(
        new _isMaximumAgeUpdateAllowed("progress", {
          data: {
            name: installPackageByNameAndVersion,
            version: __packageVersion,
            totalPending: this.totalPending,
          },
        }),
      );
      this.store.writeDependency(dispatchProgressUpdate);
    });
    this.equeueRequest(
      installPackageByNameAndVersion,
      __packageVersion,
      fetchedPackagePromise,
    );
    return fetchedPackagePromise;
  }
  shouldInstallPackage(
    isPackagePendingOrInstalled,
    shouldProceedWithPackageInstallation,
  ) {
    return (
      !this.hasInstalledPackage(
        isPackagePendingOrInstalled,
        shouldProceedWithPackageInstallation,
      ) &&
      !this.hasPendingPackage(
        isPackagePendingOrInstalled,
        shouldProceedWithPackageInstallation,
      )
    );
  }
  hasInstalledPackage(__packageIdentifier, isPackageInstalled) {
    return (
      this.store.findPackage(__packageIdentifier, isPackageInstalled) != null
    );
  }
  hasPendingPackage(
    isPackagePendingInRequests,
    checkIfPackageHasPendingRequests,
  ) {
    let getPendingRequestsForPackage = this.pendingRequests.get(
      isPackagePendingInRequests,
    );
    if (getPendingRequestsForPackage) {
      for (let [currentPendingRequest] of getPendingRequestsForPackage) {
        if (
          fetchValidSemverRangeEventListeners.default.satisfies(
            currentPendingRequest,
            checkIfPackageHasPendingRequests,
          )
        ) {
          return true;
        }
      }
    }
    return false;
  }
  equeueRequest(
    trackPendingRequest,
    pendingRequestId,
    requestCompletionPromise,
  ) {
    requestCompletionPromise.finally(() => {
      this.pendingRequests.get(trackPendingRequest)?.delete(pendingRequestId);
      if (this.pendingRequests.get(trackPendingRequest)?.size === 0) {
        this.pendingRequests.delete(trackPendingRequest);
      }
    });
    let activeRequestMap = this.pendingRequests.get(trackPendingRequest);
    if (!activeRequestMap) {
      this.pendingRequests.set(
        trackPendingRequest,
        new Map([[pendingRequestId, requestCompletionPromise]]),
      );
      return;
    }
    activeRequestMap.set(pendingRequestId, requestCompletionPromise);
  }
  async installAllPackages(npmPackageJsonFilePath) {
    let allPendingRequests = Promise.all(this.pendingRequests.values());
    let npmPackageJsonData = JSON.parse(
      this.fs.readFileAsString(npmPackageJsonFilePath),
    );
    let npmDependencyComparisonResult =
      generatePackageDependencySummary(npmPackageJsonData);
    let npmPackagesGroupedByInstallationStatus = Object.entries(
      npmDependencyComparisonResult.npmPackages,
    ).reduce(
      (aggregatePackageInstallations, [isInputValid, isUserInputValid]) => {
        for (let packageToInstall of isUserInputValid) {
          if (this.shouldInstallPackage(isInputValid, packageToInstall)) {
            if (aggregatePackageInstallations[isInputValid]) {
              aggregatePackageInstallations[isInputValid] +=
                "," + packageToInstall;
            } else {
              aggregatePackageInstallations[isInputValid] = packageToInstall;
            }
          }
        }
        return aggregatePackageInstallations;
      },
      {},
    );
    let resolvedDependencies =
      (await this.cdnClient.fetchDependencies(
        Object.entries(npmPackagesGroupedByInstallationStatus),
      )) || {};
    let resolvedPackageDependencies =
      extractUniqueEncodingCapabilities(resolvedDependencies);
    let installationPromisesByStatus = Promise.all(
      resolvedPackageDependencies.map((packageInfo) =>
        this.installPackage(packageInfo.name, packageInfo.version),
      ),
    );
    await Promise.all([allPendingRequests, installationPromisesByStatus]);
    for (let [dependencyIdentifier, dependencyData] of Object.entries(
      resolvedDependencies,
    )) {
      let [dependencyParsingResult, parsedStatusAndValues] =
        extractErrorDetailsFromLog(dependencyIdentifier);
      if (
        !(parsedStatusAndValues[0] >= "0") ||
        !(parsedStatusAndValues[0] <= "9")
      ) {
        this.store.writePackageTag(
          dependencyParsingResult,
          dependencyData,
          parsedStatusAndValues,
        );
      }
    }
    this.store.symlinkStoreDependencies();
    this.store.symlinkRootDependencies(npmPackageJsonData);
  }
};
var readableStreamState = class {
  constructor(_fileSystemManager, medicalRecordInformation = {}) {
    this.fs = _fileSystemManager;
    this.options = medicalRecordInformation;
    this.npmrc = this.parseNpmrcFile();
    this.shouldHoistPackage = this.createHoistPackageMatcher(
      this.npmrc,
      this.options,
    );
    this.fs.mkdir(
      truncatePathToParentDirectory(readableStreamState.STORE_PATH),
      {
        recursive: true,
      },
    );
  }
  npmrc = null;
  packages = new Map();
  shouldHoistPackage;
  parseNpmrcFile() {
    let fullNpmConfigFilePath = concatenatePathSegments(
      isAbortSignalProcessed,
      ".npmrc",
    );
    if (!this.fs.exists(fullNpmConfigFilePath)) {
      return null;
    }
    try {
      return convertAndNormalizeErrorHandling(
        this.fs.readFileAsString(fullNpmConfigFilePath),
      );
    } catch (parseNpmrcError) {
      console.warn(
        '[PackageManager] Failed to parse ".npmrc" file:',
        parseNpmrcError,
      );
      return null;
    }
  }
  createHoistPackageMatcher(
    combineHoistPackageMatchers,
    getCombinedHoistPackageMatcher,
  ) {
    let mergedPublicHoistingPatterns =
      combineHoistPackageMatchers?.publicHoistPattern || [];
    let currentHoistingPublicPatterns =
      getCombinedHoistPackageMatcher.publicHoistPattern || [];
    let createCombinedHoistingPatternMatcher = [
      ...mergedPublicHoistingPatterns,
      ...currentHoistingPublicPatterns,
    ];
    return (0, validateAndFetchEventListeners.createMatcher)(
      createCombinedHoistingPatternMatcher,
    );
  }
  getPackageId(formatPackageIdentifier, packageVersionString) {
    return formatPackageIdentifier + "@" + packageVersionString;
  }
  buildPackageActualPath(resolveNodeModulesPath, resolveNodeModulesActualPath) {
    return concatenatePathSegments(
      resolveNodeModulesActualPath,
      "node_modules",
      resolveNodeModulesPath,
    );
  }
  getPackageRootPath(
    getInstalledPackageVersion,
    resolvePackageVersionInstallationPath,
  ) {
    let installedPackage = this.packages.get(getInstalledPackageVersion);
    isWriteOperationAllowed(
      installedPackage,
      'Failed to get store root path for package "%s@%s": package is not installed',
      getInstalledPackageVersion,
      resolvePackageVersionInstallationPath,
      this.packages,
    );
    let foundPackageVersion = installedPackage.findVersion(
      resolvePackageVersionInstallationPath,
    );
    isWriteOperationAllowed(
      foundPackageVersion,
      'Failed to resolve installation path for "%s@%s": no installation found for this version',
      getInstalledPackageVersion,
      resolvePackageVersionInstallationPath,
    );
    return foundPackageVersion;
  }
  getPackageActualPath(retrievePackageFullPath, retrievePackagePathById) {
    let resolvedPackageBasePath = this.getPackageRootPath(
      retrievePackageFullPath,
      retrievePackagePathById,
    );
    return this.buildPackageActualPath(
      retrievePackageFullPath,
      resolvedPackageBasePath,
    );
  }
  findPackage(retrievePackageRootPathById, packageId) {
    try {
      return this.getPackageRootPath(retrievePackageRootPathById, packageId);
    } catch {
      return null;
    }
  }
  readPackageJson(packageNameAndVersion, _____packageVersion) {
    let resolvedPackageJsonFilePath = this.getPackageActualPath(
      packageNameAndVersion,
      _____packageVersion,
    );
    let packageJsonFileLocation = concatenatePathSegments(
      resolvedPackageJsonFilePath,
      "package.json",
    );
    isWriteOperationAllowed(
      this.fs.exists(packageJsonFileLocation),
      'Failed to read "package.json" for "%s@%s": package is not installed',
      packageNameAndVersion,
      _____packageVersion,
    );
    return JSON.parse(this.fs.readFileAsString(packageJsonFileLocation));
  }
  addFileToSourceInspector(addCommentToSourceInspectorFile, inputText = "") {
    (0, eval)(
      "//\n// " +
        inputText +
        "\n//\n\n//# sourceURL=nodebox://" +
        addCommentToSourceInspectorFile,
    );
  }
  symlink(sourceFileSymlinkCreator, targetSymlinkDestination) {
    if (this.fs.exists(targetSymlinkDestination)) {
      console.warn(
        'Skipping a symlink from "%s" to "%s": target already exists',
        sourceFileSymlinkCreator,
        targetSymlinkDestination,
      );
      return;
    }
    isWriteOperationAllowed(
      this.fs.exists(sourceFileSymlinkCreator),
      '[PackageStore]: Failed to symlink "%s" from "%s": the source does not exist',
      targetSymlinkDestination,
      sourceFileSymlinkCreator,
    );
    this.fs.mkdir(truncatePathToParentDirectory(targetSymlinkDestination), {
      recursive: true,
    });
    this.fs.symlink(sourceFileSymlinkCreator, targetSymlinkDestination);
    this.addFileToSourceInspector(
      targetSymlinkDestination,
      targetSymlinkDestination + " --> " + sourceFileSymlinkCreator,
    );
  }
  writeDependency(storeDependencyInFileSystem) {
    let packageIdentifier = this.getPackageId(
      storeDependencyInFileSystem.name,
      storeDependencyInFileSystem.version,
    );
    let isDependencyHoisted = this.shouldHoistPackage(
      storeDependencyInFileSystem.name,
    );
    let dependencyStoragePath = concatenatePathSegments(
      readableStreamState.STORE_PATH,
      packageIdentifier,
    );
    isWriteOperationAllowed(
      !this.fs.exists(dependencyStoragePath),
      'Failed to write "%s" to the store at "%s": package already exists',
      packageIdentifier,
      dependencyStoragePath,
    );
    let dependencyStorageDirectory = concatenatePathSegments(
      readableStreamState.STORE_PATH,
      packageIdentifier,
      "node_modules",
      storeDependencyInFileSystem.name,
    );
    for (let fileName in storeDependencyInFileSystem.files) {
      let _fileData = storeDependencyInFileSystem.files[fileName];
      let dependencyFilePath = concatenatePathSegments(
        dependencyStorageDirectory,
        fileName,
      );
      this.fs.mkdir(truncatePathToParentDirectory(dependencyFilePath), {
        recursive: true,
      });
      this.fs.writeFileSync(dependencyFilePath, _fileData);
    }
    this.registerPackage(storeDependencyInFileSystem, dependencyStoragePath);
    let _dependencyStoragePath = this.shouldHoistPackage(
      storeDependencyInFileSystem.name,
    )
      ? concatenatePathSegments(isAbortSignalProcessed, "node_modules/.bin")
      : concatenatePathSegments(
          dependencyStorageDirectory,
          "node_modules",
          ".bin",
        );
    this.symlinkBinaries(
      storeDependencyInFileSystem.name,
      storeDependencyInFileSystem.version,
      _dependencyStoragePath,
    );
    if (isDependencyHoisted) {
      let dependencyFileWritePath = concatenatePathSegments(
        isAbortSignalProcessed,
        "node_modules",
        storeDependencyInFileSystem.name,
      );
      this.symlink(dependencyStorageDirectory, dependencyFileWritePath);
    }
    return dependencyStoragePath;
  }
  registerPackage(registerNewPackageWithVersion, packageVersionInfo) {
    let foundPackage = this.packages.get(registerNewPackageWithVersion.name);
    if (foundPackage) {
      foundPackage.addVersion(
        registerNewPackageWithVersion.version,
        packageVersionInfo,
      );
      return;
    }
    this.packages.set(
      registerNewPackageWithVersion.name,
      new isValidUint8Array(registerNewPackageWithVersion.name).addVersion(
        registerNewPackageWithVersion.version,
        packageVersionInfo,
      ),
    );
  }
  getBinaries(retrieveBinariesFromPackage, packageSourcePath) {
    let retrievedPackageId = this.getPackageId(
      retrieveBinariesFromPackage,
      packageSourcePath,
    );
    let _resolvedPackagePath = this.getPackageActualPath(
      retrieveBinariesFromPackage,
      packageSourcePath,
    );
    let _packageJsonContent = this.readPackageJson(
      retrieveBinariesFromPackage,
      packageSourcePath,
    );
    let retrievedBinariesPaths = handleEncodedStringDecoding(
      retrieveBinariesFromPackage,
      _packageJsonContent.bin,
    );
    let resolvedBinariesMap = new Map();
    for (let [binaryName, binaryLocation] of Object.entries(
      retrievedBinariesPaths || {},
    )) {
      let actualBinaryPath = this.resolveBinaryPath(
        retrieveBinariesFromPackage,
        packageSourcePath,
        binaryLocation,
      );
      isWriteOperationAllowed(
        actualBinaryPath,
        'Failed to resolve "%s" binary for package "%s@%s" from "%s": no binary present at the path',
        binaryName,
        retrieveBinariesFromPackage,
        packageSourcePath,
        binaryLocation,
      );
      resolvedBinariesMap.set(binaryName, actualBinaryPath);
    }
    let resolvedBinariesDirectoryPath = _packageJsonContent.directories?.bin;
    if (resolvedBinariesDirectoryPath) {
      let binaryFilesDirectory = concatenatePathSegments(
        _resolvedPackagePath,
        resolvedBinariesDirectoryPath,
      );
      isWriteOperationAllowed(
        this.fs.exists(binaryFilesDirectory),
        'Failed to resolve binaries for package "%s@%s using a custom "directories.bin" (%s): directory does not exist',
        retrievedPackageId,
        binaryFilesDirectory,
      );
      let listOfResolvedBinaryFiles = this.fs.readdir(binaryFilesDirectory);
      for (let resolvedBinaryFileName of listOfResolvedBinaryFiles) {
        if (typeof resolvedBinaryFileName == "string") {
          let _resolvedBinaryFilePath = concatenatePathSegments(
            binaryFilesDirectory,
            resolvedBinaryFileName,
          );
          resolvedBinariesMap.set(
            resolvedBinaryFileName,
            _resolvedBinaryFilePath,
          );
        }
      }
    }
    return resolvedBinariesMap;
  }
  symlinkStoreDependencies() {
    for (let [packageNameWithVersions, packageVersionMapping] of this
      .packages) {
      for (let [
        packageVersion,
        packageVersionEntryPath,
      ] of packageVersionMapping.versions) {
        let resolvedPackagePath = this.getPackageActualPath(
          packageNameWithVersions,
          packageVersion,
        );
        let packageJsonContent = this.readPackageJson(
          packageNameWithVersions,
          packageVersion,
        );
        let resolvedDependencyVersions = groupAndValidateNpmPackages(
          packageJsonContent.dependencies,
        );
        for (let [
          _packageName,
          dependencyInfo,
        ] of convertErrorListenerToPackageInfoArray(
          resolvedDependencyVersions,
        )) {
          let actualPackagePath = this.getPackageActualPath(
            dependencyInfo.name,
            dependencyInfo.range,
          );
          let dependencyNodeModuleSymlinkPath = concatenatePathSegments(
            packageVersionEntryPath,
            "node_modules",
            _packageName,
          );
          this.symlink(actualPackagePath, dependencyNodeModuleSymlinkPath);
          let installedPackageNodeModulesPath = concatenatePathSegments(
            readableStreamState.STORE_PATH,
            "node_modules",
            _packageName,
          );
          if (!this.fs.exists(installedPackageNodeModulesPath)) {
            this.symlink(actualPackagePath, installedPackageNodeModulesPath);
          }
          if (dependencyInfo.name === _packageName) {
            this.symlinkBinaries(
              dependencyInfo.name,
              dependencyInfo.range,
              concatenatePathSegments(resolvedPackagePath, "node_modules/.bin"),
            );
          }
        }
        let installedPeerDependencies = groupAndValidateNpmPackages(
          packageJsonContent.peerDependencies,
        );
        for (let [
          peerDependencyIdentifier,
          packageInfo,
        ] of convertErrorListenerToPackageInfoArray(
          installedPeerDependencies,
        )) {
          let resolvedPeerDependencyPath = this.findPackage(
            packageInfo.name,
            packageInfo.range,
          );
          if (!resolvedPeerDependencyPath) {
            if (
              !packageJsonContent.peerDependenciesMeta?.[
                peerDependencyIdentifier
              ]?.optional
            ) {
              console.warn(
                '[PackageManager] Failed to symlink a non-optional peer dependency of "%s@%s" from "%s@%s": dependency is not installed',
                peerDependencyIdentifier,
                packageInfo.name !== peerDependencyIdentifier
                  ? packageInfo.name + "@" + packageInfo.range
                  : packageInfo.range,
                packageNameWithVersions,
                packageVersion,
              );
            }
            continue;
          }
          let _resolvedPeerDependencyPath = this.buildPackageActualPath(
            peerDependencyIdentifier,
            resolvedPeerDependencyPath,
          );
          let peerDependencySymlinkDestination = concatenatePathSegments(
            packageVersionEntryPath,
            "node_modules",
            peerDependencyIdentifier,
          );
          this.symlink(
            _resolvedPeerDependencyPath,
            peerDependencySymlinkDestination,
          );
          if (packageInfo.name !== peerDependencyIdentifier) {
            this.symlinkBinaries(
              packageInfo.name,
              packageInfo.range,
              concatenatePathSegments(resolvedPackagePath, "node_modules/.bin"),
            );
          }
        }
      }
    }
  }
  symlinkBinaries(
    symlinkBinariesFromSourceToTarget,
    sourcePackageVersionForBinaries,
    targetBinariesDirectoryPath,
  ) {
    let binariesToSymlink = this.getBinaries(
      symlinkBinariesFromSourceToTarget,
      sourcePackageVersionForBinaries,
    );
    for (let [sourceBinaryName, sourceBinaryPath] of binariesToSymlink) {
      let fullBinaryPathForSource = concatenatePathSegments(
        targetBinariesDirectoryPath,
        sourceBinaryName,
      );
      if (this.fs.exists(fullBinaryPathForSource)) {
        console.warn(
          '[PackageManager] Failed to symlink "%s" ("%s@%s"): target binary already exists at "%s"',
          sourceBinaryName,
          symlinkBinariesFromSourceToTarget,
          sourcePackageVersionForBinaries,
          fullBinaryPathForSource,
        );
        continue;
      }
      this.symlink(sourceBinaryPath, fullBinaryPathForSource);
    }
  }
  symlinkRootDependencies(symlinkRootDependenciesHandler) {
    let dependencyComparisonResult = generatePackageDependencySummary(
      symlinkRootDependenciesHandler,
    );
    let {
      directNpmPackages: directDependencies,
      npmAliases: npmPackageAliases,
    } = dependencyComparisonResult;
    for (let [packageName, ___packageVersion] of Object.entries(
      directDependencies,
    )) {
      if (this.shouldHoistPackage(packageName)) {
        continue;
      }
      let actualPackagePath = this.getPackageActualPath(
        packageName,
        ___packageVersion,
      );
      let packageSymlinkDestination = concatenatePathSegments(
        isAbortSignalProcessed,
        "node_modules",
        packageName,
      );
      this.symlink(actualPackagePath, packageSymlinkDestination);
      let packageBinaryMappings = this.getBinaries(
        packageName,
        ___packageVersion,
      );
      for (let [packageBinaryName, sourceBinaryPath] of packageBinaryMappings) {
        let packageBinarySymlinkPath = concatenatePathSegments(
          isAbortSignalProcessed,
          "node_modules",
          ".bin",
          packageBinaryName,
        );
        if (this.fs.exists(packageBinarySymlinkPath)) {
          console.warn(
            '[PackageManager] Failed to symlink root-level "%s" binary for package "%s@%s": target binary already exists at "%s"',
            packageBinaryName,
            packageName,
            ___packageVersion,
            packageBinarySymlinkPath,
          );
          continue;
        }
        this.symlink(sourceBinaryPath, packageBinarySymlinkPath);
      }
    }
    for (let [alias, aliasResolvedPath] of Object.entries(npmPackageAliases)) {
      let [aliasResolvedPackagePath, resolvedPackagePath] =
        extractErrorDetailsFromLog(aliasResolvedPath);
      let _actualPackagePath = this.getPackageActualPath(
        aliasResolvedPackagePath,
        resolvedPackagePath,
      );
      let nodeModulesSymlinkFilePath = concatenatePathSegments(
        isAbortSignalProcessed,
        "node_modules",
        alias,
      );
      this.symlink(_actualPackagePath, nodeModulesSymlinkFilePath);
    }
  }
  resolveBinaryPath(
    resolveAndCheckBinaryPath,
    resolvedBinaryFilePath,
    binaryFilePath,
  ) {
    let _actualPackagePath = this.getPackageActualPath(
      resolveAndCheckBinaryPath,
      resolvedBinaryFilePath,
    );
    let finalBinaryPath = concatenatePathSegments(
      _actualPackagePath,
      binaryFilePath,
    );
    return [
      finalBinaryPath,
      finalBinaryPath + ".js",
      finalBinaryPath + ".mjs",
    ].find((checkFileExistence) => this.fs.exists(checkFileExistence));
  }
  writePackageTag(_packageIdentifier, versionTag, versionToRegister) {
    let getPackageRegistrationDetails = this.packages.get(_packageIdentifier);
    if (!getPackageRegistrationDetails) {
      throw new Error(
        "Failed to write tag " +
          versionToRegister +
          " for " +
          _packageIdentifier +
          ", package is not installed",
      );
    }
    getPackageRegistrationDetails.registerVersionTag(
      versionToRegister,
      versionTag,
    );
  }
};
var dependencyManagementUtility = readableStreamState;
setPropertyIfSymbolExists(
  dependencyManagementUtility,
  "STORE_PATH",
  concatenatePathSegments(isAbortSignalProcessed, "node_modules", ".store"),
);
var isValidUint8Array = class {
  constructor(userName) {
    this.name = userName;
  }
  versions = new Map();
  tags = new Map();
  addVersion(registerVersionForDependency, dependencyVersionInfo) {
    isWriteOperationAllowed(
      !this.versions.has(registerVersionForDependency),
      'Failed to register version "%s" for store dependency "%s": already exists',
      registerVersionForDependency,
      this.name,
    );
    this.versions.set(registerVersionForDependency, dependencyVersionInfo);
    return this;
  }
  registerVersionTag(registerTagForVersion, versionTag) {
    isWriteOperationAllowed(
      this.versions.has(versionTag),
      'Failed to register tag "%s" for version "%s" for store dependency "%s": version does not exist',
      registerTagForVersion,
      versionTag,
      this.name,
    );
    this.tags.set(registerTagForVersion, versionTag);
    return this;
  }
  findVersion(getVersionByTagOrSemverRange) {
    let resolveVersionFromTagOrRange = this.tags.get(
      getVersionByTagOrSemverRange,
    );
    if (resolveVersionFromTagOrRange) {
      return this.versions.get(resolveVersionFromTagOrRange);
    }
    if (
      getVersionByTagOrSemverRange === "latest" ||
      getVersionByTagOrSemverRange === "*"
    ) {
      let validSortedVersionKeys = Array.from(this.versions.keys());
      let sortedValidSemverKeys =
        fetchValidSemverRangeEventListeners.default.sort(
          validSortedVersionKeys,
        );
      return this.versions.get(sortedValidSemverKeys[0]);
    }
    for (let [___currentVersion, validVersionForCurrent] of this.versions) {
      if (
        fetchValidSemverRangeEventListeners.default.satisfies(
          ___currentVersion,
          getVersionByTagOrSemverRange,
        )
      ) {
        return validVersionForCurrent;
      }
    }
    if (/^\d/.test(getVersionByTagOrSemverRange)) {
      for (let [semverRangeEventListener, getValidVersionRangeCallback] of this
        .versions) {
        if (
          fetchValidSemverRangeEventListeners.default.satisfies(
            semverRangeEventListener,
            "^" + getVersionByTagOrSemverRange,
          )
        ) {
          return getValidVersionRangeCallback;
        }
      }
    }
    for (let [softwareVersion, versionInfo] of this.versions) {
      let parsedSoftwareVersion =
        getFirstNumberFromEncodedData(softwareVersion);
      let taggedReleaseVersion = getFirstNumberFromEncodedData(
        getVersionByTagOrSemverRange,
      );
      if (parsedSoftwareVersion === taggedReleaseVersion) {
        return versionInfo;
      }
    }
  }
};
function truncatePathToParentDirectory(resolvePackageInstallationPath) {
  let packageInstallationPathSegments =
    resolvePackageInstallationPath.split("/");
  packageInstallationPathSegments.pop();
  return packageInstallationPathSegments.join("/");
}
function handleEncodedStringDecoding(
  getDecodedPackageString,
  decodeStringForPackage,
) {
  if (typeof decodeStringForPackage !== "undefined") {
    if (typeof decodeStringForPackage == "string") {
      return {
        [getDecodedPackageString]: decodeStringForPackage,
      };
    } else {
      return decodeStringForPackage;
    }
  }
}
function extractUniqueEncodingCapabilities(isEncodingCapabilitySupported) {
  let uniqueEncodingIdentifierSet = new Set();
  return Object.entries(isEncodingCapabilitySupported)
    .map(([userTextInput, processUserTextInput]) => {
      let [extractErrorNameFromLog, handleErrorExtraction] =
        extractErrorDetailsFromLog(userTextInput);
      return {
        name: extractErrorNameFromLog,
        version: processUserTextInput,
      };
    })
    .filter((isUniqueEncodingAndAddIfNot) => {
      let generateUniqueEncodingKey =
        isUniqueEncodingAndAddIfNot.name +
        "@" +
        isUniqueEncodingAndAddIfNot.version;
      if (uniqueEncodingIdentifierSet.has(generateUniqueEncodingKey)) {
        return false;
      } else {
        uniqueEncodingIdentifierSet.add(generateUniqueEncodingKey);
        return true;
      }
    });
}
function getFirstNumberFromEncodedData(processEncodedFileData) {
  let [extractedFirstDigit] = processEncodedFileData.match(/\d/) || [];
  let firstExtractedNumber = Number(extractedFirstDigit);
  if (isNaN(firstExtractedNumber)) {
    return undefined;
  } else {
    return firstExtractedNumber;
  }
}
var processBufferedDataForFile =
  handleWriteChunk.COPYFILE_EXCL |
  handleWriteChunk.COPYFILE_FICLONE |
  handleWriteChunk.COPYFILE_FICLONE_FORCE;
var isPathExistInStore = concatenatePathSegments(
  isAbortSignalProcessed,
  "package.json",
);
var validateEncodedDataForPackageStore = class {
  core = new checkIfObjectIsInitialized();
  isMain = false;
  _cdnUrl = undefined;
  packageManager = new handleSyncEventUpdate(this);
  isInstallingDependencies = Promise.resolve();
  get cdnUrl() {
    return this._cdnUrl;
  }
  set cdnUrl(updateCdnUrl) {
    this._cdnUrl = updateCdnUrl;
    this.packageManager.cdnUrl = this._cdnUrl;
  }
  readFileAsString(filePathForReading) {
    let fileContents = this.readFileSync(filePathForReading);
    return fetchIntrinsicPropertiesWithValidation
      .from(fileContents)
      .toString("utf-8");
  }
  writeFileSync(saveDataToFileInDirectory, fileContentToWrite) {
    let resolvedDirectoryPath = extractPathSegmentsFromFilePath(
      saveDataToFileInDirectory,
    );
    let finalFileName = resolvedDirectoryPath.pop();
    if (!finalFileName) {
      throw new dataStreamConfiguration("open", saveDataToFileInDirectory);
    }
    let directoryNodeAtResolvedPath = this.core.getDirNodeAtPath(
      resolvedDirectoryPath,
    );
    let fileNode = directoryNodeAtResolvedPath.getChild(finalFileName);
    if (fileNode) {
      if (fileNode instanceof retrievePortDataBasedOnShellId) {
        fileNode.write(fileContentToWrite);
      } else {
        throw new processWritableArray("open", saveDataToFileInDirectory);
      }
    } else {
      let filePortDataForWriting = new retrievePortDataBasedOnShellId(
        finalFileName,
        fileContentToWrite,
        directoryNodeAtResolvedPath,
        this.core,
      );
      directoryNodeAtResolvedPath.addChild(filePortDataForWriting);
    }
  }
  async installDependencies() {
    this.isInstallingDependencies =
      this.packageManager.installAllPackages(isPathExistInStore);
    return this.isInstallingDependencies;
  }
  waitForIdleDependencies() {
    return this.isInstallingDependencies;
  }
  readFileSync(inputFilePath) {
    let resolvedInputFilePath = extractPathSegmentsFromFilePath(inputFilePath);
    let resolvedFileNode = this.core.getNodeAtPath(
      resolvedInputFilePath,
      inputFilePath,
    );
    if (!resolvedFileNode) {
      throw new dataStreamConfiguration("open", inputFilePath);
    }
    if (resolvedFileNode instanceof retrievePortDataBasedOnShellId) {
      return resolvedFileNode.content;
    }
    if (resolvedFileNode instanceof setupVersionComparisonEventHandlers) {
      let _resolvedInputFilePath = this.realpath(inputFilePath);
      return this.readFileSync(_resolvedInputFilePath);
    } else {
      throw new processWritableArray("open", inputFilePath);
    }
  }
  mkdir(createDirectoryPath, functionSettings = {}) {
    let { recursive: allowRecursiveCreation } = functionSettings || {};
    let baseDirectory = this.core.root;
    let resolvedPathSegments =
      extractPathSegmentsFromFilePath(createDirectoryPath);
    if (
      !resolvedPathSegments.length ||
      (resolvedPathSegments.length === 1 && resolvedPathSegments[0] === "")
    ) {
      if (allowRecursiveCreation) {
        return;
      }
      throw new processWritableArray("mkdir", createDirectoryPath);
    }
    for (
      let currentSegmentIndex = 0;
      currentSegmentIndex < resolvedPathSegments.length;
      currentSegmentIndex++
    ) {
      let currentResolvedDirectory = resolvedPathSegments[currentSegmentIndex];
      let resolvedChildDirectory = baseDirectory.getChild(
        currentResolvedDirectory,
      );
      let isCurrentSegmentLastInResolvedPath =
        currentSegmentIndex === resolvedPathSegments.length - 1;
      if (resolvedChildDirectory) {
        if (resolvedChildDirectory instanceof retrieveEditableStateAttributes) {
          if (isCurrentSegmentLastInResolvedPath) {
            if (allowRecursiveCreation) {
              continue;
            }
            throw new validateWritableData("mkdir", createDirectoryPath);
          }
          baseDirectory = resolvedChildDirectory;
        } else if (
          resolvedChildDirectory instanceof
            setupVersionComparisonEventHandlers &&
          !isCurrentSegmentLastInResolvedPath
        ) {
          let resolvedChildDirectory = this.core.resolveSymlink(
            resolvedChildDirectory,
          );
          if (
            resolvedChildDirectory instanceof retrieveEditableStateAttributes
          ) {
            baseDirectory = resolvedChildDirectory;
          } else {
            throw new validateWritableData("mkdir", createDirectoryPath);
          }
        } else {
          throw new validateWritableData("mkdir", createDirectoryPath);
        }
      } else {
        if (!allowRecursiveCreation && !isCurrentSegmentLastInResolvedPath) {
          throw new dataStreamConfiguration("mkdir", createDirectoryPath);
        }
        {
          let editableStateAttributes = new retrieveEditableStateAttributes(
            currentResolvedDirectory,
            baseDirectory,
            this.core,
          );
          baseDirectory.addChild(editableStateAttributes);
          baseDirectory = editableStateAttributes;
        }
      }
    }
  }
  rmdir(deleteDirectory, _userSettings = {}) {
    let resolvedPathSegments = extractPathSegmentsFromFilePath(deleteDirectory);
    let targetDirectoryName = resolvedPathSegments.pop();
    if (!targetDirectoryName) {
      throw new dataStreamConfiguration("rmdir", deleteDirectory);
    }
    let targetDirectoryParentNode =
      this.core.getDirNodeAtPath(resolvedPathSegments);
    let _targetDirectoryNode =
      targetDirectoryParentNode.getChild(targetDirectoryName);
    if (!_targetDirectoryNode) {
      throw new dataStreamConfiguration("rmdir", deleteDirectory);
    }
    if (_targetDirectoryNode instanceof retrieveEditableStateAttributes) {
      if (!_userSettings.recursive && _targetDirectoryNode.children.size > 0) {
        throw new replaceTemplateVariables("rmdir", deleteDirectory);
      }
      targetDirectoryParentNode.removeChild(targetDirectoryName);
    } else {
      throw new replaceVariablesInTemplateStringAndConvertValues(
        "rmdir",
        deleteDirectory,
      );
    }
  }
  readdir(retrieveDirectoryContents, userSettings = {}) {
    let { withFileTypes: includeFileTypeInfo = false } = userSettings || {};
    let resolvedDirectoryPath = extractPathSegmentsFromFilePath(
      retrieveDirectoryContents,
    );
    let _directoryNode = this.core.getDirNodeAtPath(resolvedDirectoryPath);
    if (includeFileTypeInfo) {
      return Array.from(_directoryNode.children.values()).map(
        (fetchCharacterDetails) => ({
          name: fetchCharacterDetails.name,
          type: fetchCharacterDetails.stats.type,
        }),
      );
    } else {
      return Array.from(_directoryNode.children.keys());
    }
  }
  unlink(removeResourceFromDirectory) {
    let _removeResourceFromDirectory = extractPathSegmentsFromFilePath(
      removeResourceFromDirectory,
    );
    let targetResourceId = _removeResourceFromDirectory.pop();
    if (!targetResourceId) {
      throw new dataStreamConfiguration("open", removeResourceFromDirectory);
    }
    let _targetDirectoryNode = this.core.getDirNodeAtPath(
      _removeResourceFromDirectory,
    );
    let targetResourceNode = _targetDirectoryNode.getChild(targetResourceId);
    if (!targetResourceNode) {
      throw new dataStreamConfiguration("unlink", removeResourceFromDirectory);
    }
    if (targetResourceNode instanceof retrieveEditableStateAttributes) {
      throw new processWritableArray("unlink", removeResourceFromDirectory);
    }
    _targetDirectoryNode.removeChild(targetResourceId);
  }
  rename(sourceNodeIdentifier, destinationNodeId) {
    this.core.moveNode(sourceNodeIdentifier, destinationNodeId);
  }
  stat(retrieveNodeStatistics) {
    let resolvedNodePathSegments = extractPathSegmentsFromFilePath(
      retrieveNodeStatistics,
    );
    let retrievedNode = this.core.getNodeAtPath(
      resolvedNodePathSegments,
      retrieveNodeStatistics,
    );
    let failedAttemptCount = 0;
    while (retrievedNode instanceof setupVersionComparisonEventHandlers) {
      if (failedAttemptCount > 10) {
        throw new dataStreamConfiguration("open", retrieveNodeStatistics);
      }
      retrievedNode = this.core.getNodeAtPath(
        extractPathSegmentsFromFilePath(retrievedNode.target),
        retrievedNode.target,
      );
      failedAttemptCount++;
    }
    return retrievedNode.stats;
  }
  lstat(retrieveNodeStatisticsByFilePath) {
    let extractedNodePathSegments = extractPathSegmentsFromFilePath(
      retrieveNodeStatisticsByFilePath,
    );
    return this.core.getNodeAtPath(
      extractedNodePathSegments,
      retrieveNodeStatisticsByFilePath,
    ).stats;
  }
  symlink(resolveAndCreateSymbolicLink, resolvedTargetSymlinkPath) {
    let resolveAndLinkSymbolicPath = extractPathSegmentsFromFilePath(
      resolveAndCreateSymbolicLink,
    );
    let sourceNode = this.core.getNodeAtPath(
      resolveAndLinkSymbolicPath,
      resolveAndCreateSymbolicLink,
    );
    let resolvedTargetLinkDirectoryPath = extractPathSegmentsFromFilePath(
      resolvedTargetSymlinkPath,
    );
    let targetSymbolicLinkName = resolvedTargetLinkDirectoryPath.pop();
    if (!targetSymbolicLinkName) {
      throw new dataStreamConfiguration("symlink", resolvedTargetSymlinkPath);
    }
    let targetDirectoryNode = this.core.getDirNodeAtPath(
      resolvedTargetLinkDirectoryPath,
    );
    if (!targetDirectoryNode) {
      throw new dataStreamConfiguration("symlink", resolvedTargetSymlinkPath);
    }
    if (targetDirectoryNode.getChild(targetSymbolicLinkName)) {
      throw new validateWritableData("symlink", resolvedTargetSymlinkPath);
    }
    let setupSymbolicLinkVersionComparisonHandlers =
      new setupVersionComparisonEventHandlers(
        targetSymbolicLinkName,
        sourceNode.getPath(),
        targetDirectoryNode,
      );
    targetDirectoryNode.addChild(setupSymbolicLinkVersionComparisonHandlers);
  }
  realpath(resolvePathFromNode) {
    let resolvedFilePath = extractPathSegmentsFromFilePath(resolvePathFromNode);
    let resolvedNodeFromPath = this.core.getNodeAtPath(
      resolvedFilePath,
      resolvePathFromNode,
    );
    if (!resolvedNodeFromPath) {
      throw new dataStreamConfiguration("realpath", resolvePathFromNode);
    }
    return (
      resolvedNodeFromPath instanceof setupVersionComparisonEventHandlers
        ? this.core.resolveSymlink(resolvedNodeFromPath)
        : resolvedNodeFromPath
    ).getPath();
  }
  readlink(getResolvedLink) {
    let _resolvedPathSegments =
      extractPathSegmentsFromFilePath(getResolvedLink);
    let _resolvedFileNode = this.core.getNodeAtPath(
      _resolvedPathSegments,
      getResolvedLink,
    );
    if (_resolvedFileNode instanceof setupVersionComparisonEventHandlers) {
      return _resolvedFileNode.target;
    }
    throw new variableFormatter("readlink", getResolvedLink);
  }
  access(retrieveNodeFromFilePath) {
    let ___resolvedPathSegments = extractPathSegmentsFromFilePath(
      retrieveNodeFromFilePath,
    );
    this.core.getNodeAtPath(___resolvedPathSegments, retrieveNodeFromFilePath);
  }
  copyFile(sourceFilePath, targetFilePath, _initialCounterValue = 0) {
    if (!(_initialCounterValue < 0)) {
      _initialCounterValue > processBufferedDataForFile;
    }
    let isCopyExclusive =
      (_initialCounterValue & handleWriteChunk.COPYFILE_EXCL) ===
      handleWriteChunk.COPYFILE_EXCL;
    let resolvedSourceFilePathSegments =
      extractPathSegmentsFromFilePath(sourceFilePath);
    let sourceFileNode = this.core.getNodeAtPath(
      resolvedSourceFilePathSegments,
      sourceFilePath,
    );
    if (!(sourceFileNode instanceof retrievePortDataBasedOnShellId)) {
      throw new handleTemplateVariableProcessing("copyfile", sourceFilePath);
    }
    let resolvedTargetFilePath =
      extractPathSegmentsFromFilePath(targetFilePath);
    let targetFileName = resolvedTargetFilePath.pop();
    if (!targetFileName) {
      throw new dataStreamConfiguration("copyfile", targetFilePath);
    }
    let targetDirectoryNode = this.core.getDirNodeAtPath(
      resolvedTargetFilePath,
    );
    if (targetDirectoryNode.getChild(targetFileName)) {
      if (isCopyExclusive) {
        throw new validateWritableData("copyfile", targetFilePath);
      }
      targetDirectoryNode.removeChild(targetFileName);
    }
    let targetFileHandle = new retrievePortDataBasedOnShellId(
      targetFileName,
      new Uint8Array(sourceFileNode.content),
      targetDirectoryNode,
      this.core,
    );
    targetDirectoryNode.addChild(targetFileHandle);
  }
  exists(doesStatisticsDataExist) {
    try {
      this.stat(doesStatisticsDataExist);
      return true;
    } catch {
      return false;
    }
  }
};
var updateOrResetVersion = new validateEncodedDataForPackageStore();
var incrementAndReturnPreviousVersion = initializeReadabilityState();
incrementAndReturnPreviousVersion.onMessage((handleRouterBroadcastEvent) => {
  if (
    handleRouterBroadcastEvent.$type === "router-broadcast" &&
    handleRouterBroadcastEvent.$origin !== handleByteHeaderProcessing &&
    handleRouterBroadcastEvent.$data.type === "fs-sync"
  ) {
    updateOrResetVersion.core.handleSyncEvent(
      handleRouterBroadcastEvent.$data.event,
    );
  }
});
updateOrResetVersion.core.onFSEvent((broadcastEventIfNotSynced) => {
  if (!broadcastEventIfNotSynced.isSync) {
    incrementAndReturnPreviousVersion.broadcast({
      type: "fs-sync",
      event: broadcastEventIfNotSynced,
    });
  }
});
var retrieveVersionByTagOrRange = class extends Worker {
  isTerminated;
  constructor(...constructorArguments) {
    super(...constructorArguments);
    this.isTerminated = false;
    this.addEventListener("error", (handleMessageTermination) => {
      if (
        handleMessageTermination.message &&
        handleMessageTermination.message.endsWith("closing")
      ) {
        handleMessageTermination.stopImmediatePropagation();
        handleMessageTermination.preventDefault();
        Object.defineProperty(this, "terminated", {
          value: true,
        });
      }
    });
  }
  terminate() {
    this.isTerminated = true;
    super.terminate();
  }
};
async function generateSlugWithResponseHandling() {
  let versionedSlugRetriever = new retrieveVersionByTagOrRange(
    compareAndConvertToFloat(),
    {
      eval: true,
    },
  );
  let slugGenerationDeferredPromise =
    new createStreamReaderAndWriter.DeferredPromise();
  let processSlugGenerationResponse = (processApiResponse) => {
    let apiResponseData = processApiResponse.data;
    if (apiResponseData.$type === "loaded") {
      slugGenerationDeferredPromise.resolve([
        versionedSlugRetriever,
        apiResponseData.$data.id,
      ]);
    } else if (apiResponseData.$type === "init:failed") {
      slugGenerationDeferredPromise.reject(
        initializeReaderAndDispatchEvents(apiResponseData.$data.error),
      );
    }
  };
  let handleSlugGenerationError = (rejectSlugGenerationError) => {
    slugGenerationDeferredPromise.reject(rejectSlugGenerationError.error);
  };
  versionedSlugRetriever.addEventListener(
    "message",
    processSlugGenerationResponse,
  );
  versionedSlugRetriever.addEventListener("error", handleSlugGenerationError);
  return slugGenerationDeferredPromise.finally(() => {
    versionedSlugRetriever.removeEventListener(
      "message",
      processSlugGenerationResponse,
    );
    versionedSlugRetriever.removeEventListener(
      "error",
      handleSlugGenerationError,
    );
  });
}
async function setupDeferredPromiseForFileInitialization(
  initializeDeferredPromiseHandler,
  extractUniqueEncodingFormats,
) {
  let fileInitializationPromise =
    new createStreamReaderAndWriter.DeferredPromise();
  sendFileTreeInitializationMessage(
    initializeDeferredPromiseHandler,
    extractUniqueEncodingFormats.port2,
    {
      isMainThread: true,
    },
  );
  let handleFileInitializationMessage = (handleFileInitialization) => {
    if (handleFileInitialization.data.$type === "ready") {
      fileInitializationPromise.resolve();
    }
  };
  extractUniqueEncodingFormats.port1.addEventListener(
    "message",
    handleFileInitializationMessage,
  );
  extractUniqueEncodingFormats.port1.start();
  return fileInitializationPromise.finally(() => {
    extractUniqueEncodingFormats.port1.removeEventListener(
      "message",
      handleFileInitializationMessage,
    );
  });
}
function sendFileTreeInitializationMessage(
  createDeferredPromiseExecutor,
  createDeferredExecutorForAsyncActions,
  _userSettings = {},
) {
  let fileTreeInitializationPayload = {
    $type: "init",
    $data: {
      ..._userSettings,
      fileTree: updateOrResetVersion.core.serialize(),
    },
  };
  createDeferredPromiseExecutor.postMessage(fileTreeInitializationPayload, [
    createDeferredExecutorForAsyncActions,
  ]);
}
var createDeferredExecutor = handleAndEmitProcessedMessages("runtime:worker");
var _initializeDeferredPromise = class {
  constructor(messagePreviewElement) {
    this.preview = messagePreviewElement;
    this.handleMessage = this.handleMessage.bind(this);
    this.#r.port1.addEventListener("message", this.handleMessage);
  }
  emitter = new shouldAllowMaximumAgeUpdate();
  #e;
  #t = null;
  #a = generateSlugWithResponseHandling();
  #s = null;
  #l = false;
  #r = new MessageChannel();
  #n = new Map();
  #i = new Map();
  #o(isUserAuthenticated = false) {
    if (this.#t) {
      this.#t?.terminate();
      this.#u();
    } else {
      this.#a.then(() => this.#o());
    }
  }
  #u() {
    for (let activeItemToTerminate of this.#n.values()) {
      activeItemToTerminate.terminate();
    }
    for (let terminationPromises of this.#i.values()) {
      terminationPromises.then((_processTerminationHandler) =>
        _processTerminationHandler.terminate(),
      );
    }
  }
  sendInput(inputData) {
    this.#r.port1.postMessage({
      $type: "tty:out",
      $data: {
        fd: 0,
        data: inputData,
      },
    });
  }
  handleMessage(processWorkerMessage) {
    let { data: workerMessageData } = processWorkerMessage;
    switch (workerMessageData.$type) {
      case "started": {
        this.emitter.dispatchEvent(
          new _isMaximumAgeUpdateAllowed("worker/started", {}),
        );
        return;
      }
      case "run:failed": {
        this.emitter.dispatchEvent(
          new _isMaximumAgeUpdateAllowed("worker/error", {
            data: workerMessageData.$data,
          }),
        );
        this.#o();
        return;
      }
      case "exit": {
        this.emitter.dispatchEvent(
          new _isMaximumAgeUpdateAllowed("worker/exit", {
            data: workerMessageData.$data,
          }),
        );
        this.#o();
        return;
      }
      case "tty:out": {
        let messageFromWorker = workerMessageData.$data;
        if (messageFromWorker.fd === 0) {
          break;
        }
        let messageDirection = messageFromWorker.fd === 1 ? "out" : "err";
        let validatedProperties = fetchIntrinsicPropertiesWithValidation
          .from(messageFromWorker.data)
          .toString("utf-8");
        this.emitter.dispatchEvent(
          new _isMaximumAgeUpdateAllowed("worker/tty:out", {
            data: {
              payload: {
                data: validatedProperties,
                type: messageDirection,
              },
            },
          }),
        );
        return;
      }
    }
  }
  stop() {
    if (this.#e) {
      let shellPort = this.preview.getPortFromShellId(this.#e);
      if (shellPort) {
        this.preview.closePort(shellPort);
      }
    }
    this.#o(true);
    this.#r.port1.removeEventListener("message", this.handleMessage);
    this.#r.port1.close();
  }
  #c(_handleChildProcessMessageEvents) {
    _handleChildProcessMessageEvents.addEventListener(
      "message",
      (processChildMessageFromWorker) => {
        let workerMessageData = processChildMessageFromWorker.data;
        switch (workerMessageData.$type) {
          case "child:spawn": {
            console.warn("child:spawn called", workerMessageData);
            let workerProcessId = workerMessageData.$data.id;
            let slugGenerationProcess = generateSlugWithResponseHandling()
              .then(([userSettings, storeUserSettings]) => {
                this.#n.set(workerProcessId, userSettings);
                this.#i.delete(workerProcessId);
                this.#c(userSettings);
                sendFileTreeInitializationMessage(
                  userSettings,
                  processChildMessageFromWorker.ports[0],
                  {
                    isMainThread: false,
                    environmentData: workerMessageData.$data.environmentData,
                    globals: {
                      ...(workerMessageData.$data.globals || {}),
                    },
                  },
                );
                return userSettings;
              })
              .catch((handleChildProcessDeletion) => {
                this.#i.delete(workerProcessId);
                throw handleChildProcessDeletion;
              });
            slugGenerationProcess.catch(console.error);
            this.#i.set(workerProcessId, slugGenerationProcess);
            break;
          }
          case "child:kill": {
            let _workerProcessId = workerMessageData.$data.id;
            let workerProcessController = this.#n.get(_workerProcessId);
            if (workerProcessController) {
              workerProcessController.terminate();
              this.#n.delete(_workerProcessId);
            }
            break;
          }
        }
      },
    );
  }
  async _init() {
    let [initializeWorkerDependencies, workerDependenciesInitialization] =
      await this.#a;
    this.#t = initializeWorkerDependencies;
    this.#e = workerDependenciesInitialization;
    if (typeof window === "undefined") {
      console.error(
        "Tried to start a node worker from outside the main thread.",
      );
    } else {
      this.#c(initializeWorkerDependencies);
    }
    initializeReadabilityState().addEndpoint(
      "node-worker-" + (0, initializeMessageReaderAndEmitEvent.default)(),
      {
        send: (postMessageToPort, postMessageData) =>
          this.#r.port1.postMessage(postMessageToPort, postMessageData),
        onMessage: (addPortMessageListener) => {
          this.#r.port1.addEventListener(
            "message",
            (processPortMessageData) => {
              addPortMessageListener(processPortMessageData.data);
            },
          );
        },
      },
    );
    await setupDeferredPromiseForFileInitialization(
      initializeWorkerDependencies,
      this.#r,
    ).catch((throwNodeWorkerInitializationError) => {
      let throwNodeWorkerInitializationErrorWithCause = new Error(
        "Initializing node worker failed",
      );
      throwNodeWorkerInitializationErrorWithCause.cause =
        throwNodeWorkerInitializationError;
      throw throwNodeWorkerInitializationErrorWithCause;
    });
    this.#l = true;
    return workerDependenciesInitialization;
  }
  init() {
    if (this.#t?.isTerminated) {
      return Promise.reject(new Error("Worker has been terminated"));
    } else {
      this.#s ||= this._init();
      return this.#s;
    }
  }
  runCommand(commandPayload) {
    if (!this.#l) {
      throw new Error("Worker has not finished initialising");
    }
    this.#r.port1.postMessage({
      $type: "run",
      $data: commandPayload,
    });
  }
};
function generateRegexFromWildcardPattern(_computeRemainingValue) {
  return new RegExp(_computeRemainingValue.replace(/\*+/g, ".*"));
}
var ResourceEventListenerManager = class {
  _isClosed = false;
  _disposables = [];
  eventEmitter = new _decodeByteHeaderValue();
  onChange = this.eventEmitter.event;
  constructor(filePathValidationHandler, validateFilePathsAgainstRules) {
    let compiledFilePathRegexHandlers = filePathValidationHandler.map(
      (generateRegexFromWildcard) =>
        generateRegexFromWildcardPattern(generateRegexFromWildcard),
    );
    let validateFilePathAgainstValidations = validateFilePathsAgainstRules.map(
      (_generateRegexFromWildcardPattern) =>
        generateRegexFromWildcardPattern(_generateRegexFromWildcardPattern),
    );
    let isFilePathValid = (_isFilePathValid) => {
      for (let filePathValidationRule of validateFilePathAgainstValidations) {
        if (filePathValidationRule.test(_isFilePathValid)) {
          return false;
        }
      }
      for (let filePathRegexHandler of compiledFilePathRegexHandlers) {
        if (filePathRegexHandler.test(_isFilePathValid)) {
          return true;
        }
      }
    };
    let handleFileSystemEvent = updateOrResetVersion.core.onFSEvent(
      (handleFileOperationEvent) => {
        if (!this._isClosed) {
          switch (handleFileOperationEvent.type) {
            case "create": {
              let createdFilePath = joinPathSegments(
                handleFileOperationEvent.parent,
                handleFileOperationEvent.newNode.name,
              );
              if (isFilePathValid(createdFilePath)) {
                this.eventEmitter.fire({
                  type: "create",
                  path: createdFilePath,
                });
              }
              break;
            }
            case "remove": {
              let _constructedFilePath = joinPathSegments(
                handleFileOperationEvent.parent,
                handleFileOperationEvent.name,
              );
              if (isFilePathValid(_constructedFilePath)) {
                this.eventEmitter.fire({
                  type: "remove",
                  path: _constructedFilePath,
                });
              }
              break;
            }
            case "write": {
              if (isFilePathValid(handleFileOperationEvent.path)) {
                this.eventEmitter.fire({
                  type: "change",
                  path: handleFileOperationEvent.path,
                });
              }
              break;
            }
            case "move": {
              if (isFilePathValid(handleFileOperationEvent.newPath)) {
                this.eventEmitter.fire({
                  type: "rename",
                  oldPath: handleFileOperationEvent.oldPath,
                  newPath: handleFileOperationEvent.newPath,
                });
              }
              break;
            }
          }
        }
      },
    );
    this._disposables.push(handleFileSystemEvent);
  }
  close() {
    this._isClosed = true;
    for (let resourceToDispose of this._disposables) {
      try {
        resourceToDispose.dispose();
      } catch (genericError) {
        console.warn(genericError);
      }
    }
    this.eventEmitter.fire({
      type: "close",
    });
    this.eventEmitter.dispose();
  }
};
var _handleDataEncodingError = class {
  constructor(_inputData) {
    this.data = _inputData;
    this.name = _inputData.name;
    this.type = _inputData.type;
  }
  name;
  type;
  isSymbolicLink() {
    return this.type === 2;
  }
  isSocket() {
    return false;
  }
  isFile() {
    return this.type === 1;
  }
  isFIFO() {
    return false;
  }
  isDirectory() {
    return this.type === 0;
  }
  isCharacterDevice() {
    return false;
  }
  isBlockDevice() {
    return false;
  }
};
var calculateDataEncodingError = /^[0-7]+$/;
function __processDataEncodingError(
  eventListenerHandler,
  copyFileEventListener,
  eventListener,
) {
  eventListenerHandler ??= eventListener;
  if (typeof eventListenerHandler == "string") {
    if (calculateDataEncodingError.exec(eventListenerHandler) === null) {
      throw new Error("invalid mode");
    }
    eventListenerHandler = parseInt(eventListenerHandler, 8);
  }
  __handleDataEncodingError(eventListenerHandler, copyFileEventListener);
  return eventListenerHandler;
}
var attachEventListenersToNodes = class extends Error {};
var dataStreamErrorManager = class extends Error {};
var __handleDataEncodingError = (
  validateIntegerWithinUnsignedIntRange,
  validateUnsignedIntInRange,
  _validateUnsignedIntInRange,
) => {
  if (typeof validateIntegerWithinUnsignedIntRange != "number") {
    throw new attachEventListenersToNodes(
      validateUnsignedIntInRange,
      "number",
      validateIntegerWithinUnsignedIntRange,
    );
  }
  if (!Number.isInteger(validateIntegerWithinUnsignedIntRange)) {
    throw new dataStreamErrorManager(
      validateUnsignedIntInRange,
      "an integer",
      validateIntegerWithinUnsignedIntRange,
    );
  }
  let isMinimumUnsignedIntValue = _validateUnsignedIntInRange ? 1 : 0;
  let maxValidUnsignedInt = 4294967295;
  if (
    validateIntegerWithinUnsignedIntRange < isMinimumUnsignedIntValue ||
    validateIntegerWithinUnsignedIntRange > maxValidUnsignedInt
  ) {
    throw new dataStreamErrorManager(
      validateUnsignedIntInRange,
      ">= " + isMinimumUnsignedIntValue + " && <= " + maxValidUnsignedInt,
      validateIntegerWithinUnsignedIntRange,
    );
  }
};
function determineFileOpenMode(FileSyncHandler, statusFlags = "flags") {
  if (typeof FileSyncHandler == "number") {
    return FileSyncHandler;
  }
  if (FileSyncHandler == null) {
    return handleWriteChunk.O_RDONLY;
  }
  switch (FileSyncHandler) {
    case "r":
      return handleWriteChunk.O_RDONLY;
    case "rs":
    case "sr":
      return handleWriteChunk.O_RDONLY | handleWriteChunk.O_SYNC;
    case "r+":
      return handleWriteChunk.O_RDWR;
    case "rs+":
    case "sr+":
      return handleWriteChunk.O_RDWR | handleWriteChunk.O_SYNC;
    case "w":
      return (
        handleWriteChunk.O_TRUNC |
        handleWriteChunk.O_CREAT |
        handleWriteChunk.O_WRONLY
      );
    case "wx":
    case "xw":
      return (
        handleWriteChunk.O_TRUNC |
        handleWriteChunk.O_CREAT |
        handleWriteChunk.O_WRONLY |
        handleWriteChunk.O_EXCL
      );
    case "w+":
      return (
        handleWriteChunk.O_TRUNC |
        handleWriteChunk.O_CREAT |
        handleWriteChunk.O_RDWR
      );
    case "wx+":
    case "xw+":
      return (
        handleWriteChunk.O_TRUNC |
        handleWriteChunk.O_CREAT |
        handleWriteChunk.O_RDWR |
        handleWriteChunk.O_EXCL
      );
    case "a":
      return (
        handleWriteChunk.O_APPEND |
        handleWriteChunk.O_CREAT |
        handleWriteChunk.O_WRONLY
      );
    case "ax":
    case "xa":
      return (
        handleWriteChunk.O_APPEND |
        handleWriteChunk.O_CREAT |
        handleWriteChunk.O_WRONLY |
        handleWriteChunk.O_EXCL
      );
    case "as":
    case "sa":
      return (
        handleWriteChunk.O_APPEND |
        handleWriteChunk.O_CREAT |
        handleWriteChunk.O_WRONLY |
        handleWriteChunk.O_SYNC
      );
    case "a+":
      return (
        handleWriteChunk.O_APPEND |
        handleWriteChunk.O_CREAT |
        handleWriteChunk.O_RDWR
      );
    case "ax+":
    case "xa+":
      return (
        handleWriteChunk.O_APPEND |
        handleWriteChunk.O_CREAT |
        handleWriteChunk.O_RDWR |
        handleWriteChunk.O_EXCL
      );
    case "as+":
    case "sa+":
      return (
        handleWriteChunk.O_APPEND |
        handleWriteChunk.O_CREAT |
        handleWriteChunk.O_RDWR |
        handleWriteChunk.O_SYNC
      );
  }
  throw new Error("flags invalid");
}
var handleSlugGenerationError = initializeObjectWithProperties(
  validateEncodingIntegrity(),
);
var handleReadyStateMessage = class extends handleSlugGenerationError.Readable {
  _read() {}
};
var ______validateNumberInRange = initializeObjectWithProperties(
  validateEncodingIntegrity(),
);
retrieveAndValidateIntrinsicPropertyValue();
function asyncRangeValidation(validateRangeAndPushToCollection) {
  return function (...rangeValidationArgs) {
    return new Promise(
      (onRangeValidationComplete, handleRangeValidationError) => {
        setTimeout(() => {
          try {
            let rangeValidationOutcome = validateRangeAndPushToCollection(
              ...rangeValidationArgs,
            );
            onRangeValidationComplete(rangeValidationOutcome);
          } catch (validationError) {
            handleRangeValidationError(validationError);
          }
        }, 0);
      },
    );
  };
}
function deferredCallbackExecutor(__initializeDeferredPromise) {
  return function (...executeDeferredWithCallback) {
    let deferredPromiseCallback = executeDeferredWithCallback.pop();
    if (typeof deferredPromiseCallback != "function") {
      throw new Error("No callback provided");
    }
    setTimeout(() => {
      try {
        let deferredPromiseResult = __initializeDeferredPromise(
          ...executeDeferredWithCallback,
        );
        deferredPromiseCallback(null, deferredPromiseResult);
      } catch (_errorHandlingCallback) {
        deferredPromiseCallback(_errorHandlingCallback, null);
      }
    }, 0);
  };
}
function generateAsyncValidationExecutor(
  initializeFileTreeAndSendMessage,
  validateAndExportSettingsAndFileTree,
) {
  return function (...invokeCallbackPostValidation) {
    let postValidationCallback = invokeCallbackPostValidation.pop();
    if (typeof postValidationCallback != "function") {
      throw new Error("No callback provided");
    }
    setTimeout(() => {
      try {
        let fileTreeInitializationResult = initializeFileTreeAndSendMessage(
          ...invokeCallbackPostValidation,
        );
        postValidationCallback(fileTreeInitializationResult);
      } catch {
        postValidationCallback(validateAndExportSettingsAndFileTree);
      }
    }, 0);
  };
}
var __validateAndProcessCacheEntry = asyncRangeValidation(
  handleDataAndSetupEventListener,
);
__validateAndProcessCacheEntry.native = __validateAndProcessCacheEntry;
var ___validateAndProcessCacheEntry = {
  readFile: asyncRangeValidation(initializeAndConvertChunkData),
  writeFile: asyncRangeValidation(handleAndStoreStreamData),
  mkdir: asyncRangeValidation(setupDataStreamEventListener),
  rmdir: asyncRangeValidation(processCacheEntryAndValidateFilePath),
  rm: asyncRangeValidation(___processIncomingMessage),
  readdir: asyncRangeValidation(processFileCacheValidationAndEvents),
  unlink: asyncRangeValidation(checkAndBindCacheEntryValidity),
  rename: asyncRangeValidation(handleStreamValidationAndCaching),
  stat: asyncRangeValidation(fetchDataWithErrorHandling),
  lstat: asyncRangeValidation(validateAndProcessFileSystemEventCacheEntry),
  symlink: asyncRangeValidation(handleFileSystemCacheEntries),
  link: asyncRangeValidation(handleCacheEntryProcessingAndLogging),
  appendFile: asyncRangeValidation(_processIncomingMessageData),
  readlink: asyncRangeValidation(setupErrorHandlingForDataEncoding),
  access: asyncRangeValidation(checkCacheValidityAndSetEventListener),
  copyFile: asyncRangeValidation(validateAndLogCacheEntryForDataEncoding),
  exists: asyncRangeValidation(processCacheEntryForEventListener),
  chown: asyncRangeValidation(processIncomingFileMessage),
  chmod: asyncRangeValidation(handleFileOpenModeFlags),
  createReadStream: validateAndProcessIncomingMessage,
  constants: handleWriteChunk,
  realpath: __validateAndProcessCacheEntry,
};
var dispatchWorkerTtyOutput = initializeObjectWithProperties(
  resetStreamConstructionStates(),
);
var handleWorkerMessageAndDispatchEvent = initializeObjectWithProperties(
  validateEncodingIntegrity(),
);
var handleWorkerMessageProcessing = deferredCallbackExecutor(
  initializeAndConvertChunkData,
);
var handleAndValidateCacheValue = deferredCallbackExecutor(
  handleAndStoreStreamData,
);
var validateAndCacheEntry = deferredCallbackExecutor(
  setupDataStreamEventListener,
);
var handleWebWorkerMessage = deferredCallbackExecutor(
  processCacheEntryAndValidateFilePath,
);
var _handleWebWorkerMessage = deferredCallbackExecutor(
  processFileCacheValidationAndEvents,
);
var handleChildProcessMessageEvents = deferredCallbackExecutor(
  checkAndBindCacheEntryValidity,
);
var handleChildProcessSpawn = deferredCallbackExecutor(
  handleStreamValidationAndCaching,
);
var processAndValidateReadableChunk = deferredCallbackExecutor(
  fetchDataWithErrorHandling,
);
var isSerializedObject = deferredCallbackExecutor(
  validateAndProcessFileSystemEventCacheEntry,
);
var handleWebWorkerMessages = deferredCallbackExecutor(
  handleFileSystemCacheEntries,
);
var processAndHandleChildMessage = deferredCallbackExecutor(
  handleCacheEntryProcessingAndLogging,
);
var processUserPreferences = deferredCallbackExecutor(
  ___processIncomingMessage,
);
var processAndValidateCacheValue = deferredCallbackExecutor(
  setupErrorHandlingForDataEncoding,
);
var handleSlugGenerationProcess = deferredCallbackExecutor(
  checkCacheValidityAndSetEventListener,
);
var generateAndValidateUserPreferencesCache = deferredCallbackExecutor(
  validateAndLogCacheEntryForDataEncoding,
);
var storeAndNotifyUserPreferences = generateAsyncValidationExecutor(
  processCacheEntryForEventListener,
  false,
);
var validateAndInitializeUserPreferences = deferredCallbackExecutor(
  processIncomingMessageData,
);
var handleChildProcessExecution = deferredCallbackExecutor(
  deleteFileAccessModeCacheEntry,
);
var handleChildProcessCommunication = deferredCallbackExecutor(
  validateAndProcessFileStreamData,
);
var handleAndValidateUserInput = deferredCallbackExecutor(
  processIncomingFileMessage,
);
var __processAndValidateReadableChunk = deferredCallbackExecutor(
  handleFileOpenModeFlags,
);
var handleReadableChunkProcess = deferredCallbackExecutor(
  _processIncomingMessageData,
);
var handleChildProcessDeletion = deferredCallbackExecutor(
  handleDataAndSetupEventListener,
);
var convertReadableChunkToString = handleChildProcessDeletion;
convertReadableChunkToString.native = handleChildProcessDeletion;
var serializeReadableChunk = handleDataAndSetupEventListener;
serializeReadableChunk.native = handleDataAndSetupEventListener;
function convertChunkToOutputFormat(
  terminateChildProcessAndCleanup,
  _terminateChildProcessAndCleanup,
) {
  _terminateChildProcessAndCleanup =
    _terminateChildProcessAndCleanup ?? "buffer";
  let validateAndPrepareChunkForOutput = fetchAndValidateIntrinsicProperties(
    terminateChildProcessAndCleanup,
  );
  if (_terminateChildProcessAndCleanup === "buffer") {
    return validateAndPrepareChunkForOutput;
  } else {
    return validateAndPrepareChunkForOutput.toString(
      _terminateChildProcessAndCleanup,
    );
  }
}
function getIdleVersionDependencies() {
  return updateOrResetVersion.waitForIdleDependencies();
}
function initializeAndConvertChunkData(
  initializeAndSetupWorker,
  handleWorkerInitialization,
) {
  let initializedChunkData = updateOrResetVersion.readFileSync(
    initializeEventListenerBasedOnType(initializeAndSetupWorker),
  );
  let getChunkEncoding =
    typeof handleWorkerInitialization == "string"
      ? handleWorkerInitialization
      : handleWorkerInitialization?.encoding;
  return convertChunkToOutputFormat(initializedChunkData, getChunkEncoding);
}
function fetchAndValidateStreamDataWithEncoding(
  __processStreamData,
  initializeAndStoreWorkerState,
) {
  initializeAndStoreWorkerState = initializeAndStoreWorkerState ?? "utf-8";
  return fetchAndValidateReadableStreamProperties(
    __processStreamData,
    initializeAndStoreWorkerState,
  );
}
function handleAndStoreStreamData(
  validateAndProcessStreamData,
  _validateAndProcessStreamData,
  validateFilePathAndCache,
) {
  let processedStreamData = fetchAndValidateStreamDataWithEncoding(
    _validateAndProcessStreamData,
    validateFilePathAndCache,
  );
  updateOrResetVersion.writeFileSync(
    initializeEventListenerBasedOnType(validateAndProcessStreamData),
    processedStreamData,
  );
}
function setupDataStreamEventListener(
  validateFilePathAndHandleEvents,
  validateAndProcessFilePath,
) {
  updateOrResetVersion.mkdir(
    initializeEventListenerBasedOnType(validateFilePathAndHandleEvents),
    validateAndProcessFilePath,
  );
}
function processCacheEntryAndValidateFilePath(
  validateFilePathAgainstValidations,
  handleFilePathValidation,
) {
  updateOrResetVersion.rmdir(
    initializeEventListenerBasedOnType(validateFilePathAgainstValidations),
    handleFilePathValidation,
  );
}
function _validateAndHandleDataEncodingErrors(validateAndProcessFilePathEntry) {
  return validateAndProcessFilePathEntry.map((____handleDataEncodingError) =>
    typeof ____handleDataEncodingError == "string"
      ? ____handleDataEncodingError
      : new _handleDataEncodingError(____handleDataEncodingError),
  );
}
function processFileCacheValidationAndEvents(
  validateAndTriggerEventForFileCreation,
  isFilePathValid,
) {
  let fileCacheEntries = updateOrResetVersion.readdir(
    initializeEventListenerBasedOnType(validateAndTriggerEventForFileCreation),
    isFilePathValid,
  );
  return _validateAndHandleDataEncodingErrors(fileCacheEntries);
}
function checkAndBindCacheEntryValidity(isValidCacheEntry) {
  updateOrResetVersion.unlink(
    initializeEventListenerBasedOnType(isValidCacheEntry),
  );
}
function handleStreamValidationAndCaching(
  validateAndEmitFileEvent,
  validateCacheEntryBasedOnFileOperations,
) {
  updateOrResetVersion.rename(
    initializeEventListenerBasedOnType(validateAndEmitFileEvent),
    validateCacheEntryBasedOnFileOperations,
  );
}
function initializeWritableStreamForFileEvent(processFileOperationEvent) {
  return initializeWritableStreamWithHandleMessage(processFileOperationEvent);
}
function fetchDataWithErrorHandling(
  handleFileOperationError,
  optionsObject = {
    throwIfNoEntry: true,
  },
) {
  try {
    return initializeWritableStreamForFileEvent(
      updateOrResetVersion.stat(
        initializeEventListenerBasedOnType(handleFileOperationError),
      ),
    );
  } catch (fileNotFoundError) {
    if (
      optionsObject.throwIfNoEntry === false &&
      fileNotFoundError.code === "ENOENT"
    ) {
      return;
    }
    throw fileNotFoundError;
  }
}
function validateAndProcessFileSystemEventCacheEntry(
  validateAndHandleFileSystemEvent,
) {
  return initializeWritableStreamForFileEvent(
    updateOrResetVersion.lstat(
      initializeEventListenerBasedOnType(validateAndHandleFileSystemEvent),
    ),
  );
}
function validateAndProcessFileStreamData(handleFileSystemEvent) {
  let { path: fileStreamDataPath } =
    validateAndHandleEncodingErrors[handleFileSystemEvent];
  if (!fileStreamDataPath) {
    throw new Error("Could not find path for fd: " + handleFileSystemEvent);
  }
  return initializeWritableStreamForFileEvent(
    updateOrResetVersion.stat(fileStreamDataPath),
  );
}
function handleFileSystemCacheEntries(
  handleFileSystemError,
  _handleFileSystemError,
) {
  updateOrResetVersion.symlink(
    initializeEventListenerBasedOnType(handleFileSystemError),
    initializeEventListenerBasedOnType(_handleFileSystemError),
  );
}
function handleCacheEntryProcessingAndLogging(
  _handleCacheEntryProcessing,
  ___handleDataEncodingError,
) {
  updateOrResetVersion.symlink(
    initializeEventListenerBasedOnType(_handleCacheEntryProcessing),
    initializeEventListenerBasedOnType(___handleDataEncodingError),
  );
}
function setupErrorHandlingForDataEncoding(processDataEncodingError) {
  return updateOrResetVersion.readlink(
    initializeEventListenerBasedOnType(processDataEncodingError),
  );
}
function checkCacheValidityAndSetEventListener(validateDataEncoding) {
  updateOrResetVersion.access(
    initializeEventListenerBasedOnType(validateDataEncoding),
  );
}
function validateAndLogCacheEntryForDataEncoding(
  validateDataEncodingError,
  cacheEntryValidationLogger,
  _processDataEncodingError,
) {
  updateOrResetVersion.copyFile(
    initializeEventListenerBasedOnType(validateDataEncodingError),
    initializeEventListenerBasedOnType(cacheEntryValidationLogger),
    _processDataEncodingError,
  );
}
function handleDataAndSetupEventListener(handleDataEncodingErrorEvent) {
  return updateOrResetVersion.realpath(
    initializeEventListenerBasedOnType(handleDataEncodingErrorEvent),
  );
}
function processCacheEntryForEventListener(handleDataEncodingErrorInternal) {
  if (handleDataEncodingErrorInternal) {
    return updateOrResetVersion.exists(
      initializeEventListenerBasedOnType(handleDataEncodingErrorInternal),
    );
  } else {
    return false;
  }
}
var validateAndHandleEncodingErrors = {};
function processIncomingMessageData(
  handleDataEncodingErrors,
  processIncomingMessage,
  handleDataEncodingValidationError,
) {
  if (arguments.length < 2) {
    processIncomingMessage = "r";
    handleDataEncodingValidationError = 438;
  } else if (typeof handleDataEncodingValidationError == "function") {
    handleDataEncodingValidationError = 438;
  } else {
    handleDataEncodingValidationError = __processDataEncodingError(
      handleDataEncodingValidationError,
      "mode",
      438,
    );
  }
  let determineFileOpenModeAndFlags =
    determineFileOpenMode(processIncomingMessage) & handleWriteChunk.O_CREAT;
  handleDataEncodingErrors = initializeEventListenerBasedOnType(
    handleDataEncodingErrors,
  );
  try {
    updateOrResetVersion.access(handleDataEncodingErrors);
  } catch (fileOpenError) {
    if (determineFileOpenModeAndFlags) {
      handleAndStoreStreamData(handleDataEncodingErrors, "");
    } else {
      throw fileOpenError;
    }
  }
  let dataCacheIdentifier = Math.floor(Math.random() * 100000);
  validateAndHandleEncodingErrors[dataCacheIdentifier] = {
    path: handleDataEncodingErrors,
    cursor: 0,
  };
  return dataCacheIdentifier;
}
function deleteFileAccessModeCacheEntry(handleFileAccessMode) {
  delete validateAndHandleEncodingErrors[handleFileAccessMode];
}
function validateAndProcessIncomingMessage(handleIncomingMessage) {
  let incomingMessageChunkProcessor = new handleReadyStateMessage();
  setTimeout(() => {
    try {
      let formattedIncomingMessageChunk = initializeAndConvertChunkData(
        handleIncomingMessage,
      );
      incomingMessageChunkProcessor.push(formattedIncomingMessageChunk);
      incomingMessageChunkProcessor.push(null);
    } catch (_processingError) {
      incomingMessageChunkProcessor.destroy(_processingError);
    }
  }, 1);
  return incomingMessageChunkProcessor;
}
function handleFileOpenModeFlags(getFileOpenModeFlags) {
  fetchDataWithErrorHandling(getFileOpenModeFlags);
}
function processIncomingFileMessage(handleFileOpenMode) {
  fetchDataWithErrorHandling(handleFileOpenMode);
}
function ___processIncomingMessage(
  _handleIncomingMessage,
  handleFileModeFlags,
) {
  handleFileModeFlags = handleFileModeFlags || {};
  try {
    if (fetchDataWithErrorHandling(_handleIncomingMessage)?.isDirectory()) {
      return processCacheEntryAndValidateFilePath(
        _handleIncomingMessage,
        handleFileModeFlags,
      );
    } else {
      return checkAndBindCacheEntryValidity(_handleIncomingMessage);
    }
  } catch (fileProcessingError) {
    if (handleFileModeFlags.force) {
      return;
    }
    throw fileProcessingError;
  }
}
function _processIncomingMessageData(
  getFilePermissionFlags,
  getFileModeFlags,
  determineFileOpenFlags,
) {
  let transformedMessage = "";
  try {
    transformedMessage = initializeAndConvertChunkData(
      initializeEventListenerBasedOnType(getFilePermissionFlags),
      determineFileOpenFlags || "utf8",
    );
  } catch (_fileNotFoundError) {
    if (!_fileNotFoundError.message.includes("ENOENT")) {
      throw _fileNotFoundError;
    }
  }
  let finalMessageBuffer =
    typeof getFileModeFlags == "string" && typeof transformedMessage == "string"
      ? transformedMessage + getFileModeFlags
      : Buffer.concat([
          Buffer.isBuffer(transformedMessage)
            ? transformedMessage
            : Buffer.from(transformedMessage),
          Buffer.isBuffer(getFileModeFlags)
            ? getFileModeFlags
            : Buffer.from(getFileModeFlags),
        ]);
  handleAndStoreStreamData(
    getFilePermissionFlags,
    finalMessageBuffer,
    determineFileOpenFlags,
  );
}
globalThis.global = globalThis;
globalThis.originalConsole = console;
var _processAndValidateStreamData = handleAndEmitProcessedMessages("runtime");
async function handleFileSystemEventsForDependencyManagement() {
  let encodedByteLength = ___calculateEncodedByteLength.default.slug();
  let _cleanupPostProcessingHandler = new cleanupPostProcessingHandler(
    encodedByteLength,
  );
  updateOrResetVersion.isMain = true;
  updateOrResetVersion.core.onFSEvent((handleDependencyAction) => {
    if (
      (() => {
        if (handleDependencyAction.type === "create") {
          let _newNodeName = handleDependencyAction.newNode.name;
          if (_newNodeName) {
            return (
              handleDependencyAction.parent + "/" + _newNodeName ===
              isPathExistInStore
            );
          }
        } else if (handleDependencyAction.type === "write") {
          return handleDependencyAction.path === isPathExistInStore;
        }
      })()
    ) {
      updateOrResetVersion
        .installDependencies()
        .catch((handleDependencyReinstallError) => {
          console.error(
            'Failed to re-install dependencies upon "package.json" change.',
          );
          console.error(handleDependencyReinstallError);
        });
    }
  });
  updateOrResetVersion.mkdir("/tmp");
  let cacheEntryValidator = new validateSectionedValueCaching();
  cacheEntryValidator.on("connect", ({ cdnUrl: contentDeliveryNetworkUrl }) => {
    let defaultCdnUrl =
      contentDeliveryNetworkUrl || "https://sandpack-cdn-v2.codesandbox.io";
    isWriteOperationAllowed(
      defaultCdnUrl,
      "Failed to connect to Nodebox: the Sandpack CDN URL is not defined",
    );
    updateOrResetVersion.cdnUrl = defaultCdnUrl;
    cacheEntryValidator.send("runtime/ready");
  });
  updateOrResetVersion.packageManager.addEventListener(
    "progress",
    (handleModuleDownloadProgress) => {
      let {
        name: moduleHandler,
        totalPending: totalPendingDownloads,
        version: moduleDownloadVersion,
      } = handleModuleDownloadProgress.data;
      cacheEntryValidator.send("worker/progress", {
        status: {
          state: "downloaded_module",
          name: moduleHandler,
          totalPending: totalPendingDownloads,
          version: moduleDownloadVersion,
        },
      });
    },
  );
  if (!processCacheEntryForEventListener(isAbortSignalProcessed)) {
    setupDataStreamEventListener(isAbortSignalProcessed);
  }
  cacheEntryValidator.on("fs/init", ({ files: uploadedFiles }) => {
    _processAndValidateStreamData("Handling fs/init");
    Object.entries(uploadedFiles).map(([userAge, validateUserAge]) => {
      let userAgeFilePath = buildFilePathFromSegments(
        concatenatePathSegments(isAbortSignalProcessed, userAge),
      );
      let formattedUserAgeByteLength =
        formatAndFormatByteLength(userAgeFilePath);
      setupDataStreamEventListener(formattedUserAgeByteLength, {
        recursive: true,
      });
      handleAndStoreStreamData(userAgeFilePath, validateUserAge);
    });
  });
  cacheEntryValidator.on(
    "fs/readFile",
    ({ path: configFilePath, encoding: fileEncodingSetting }) => ({
      data: initializeAndConvertChunkData(
        concatenatePathSegments(isAbortSignalProcessed, configFilePath),
        fileEncodingSetting,
      ),
    }),
  );
  cacheEntryValidator.on(
    "fs/writeFile",
    ({
      path: filePathToResource,
      content: resourceFileContent,
      encoding: resourceFileEncoding,
      recursive: isResourceTraversalRecursive,
    }) => {
      let combineFilePathAndProcess = concatenatePathSegments(
        isAbortSignalProcessed,
        filePathToResource,
      );
      if (isResourceTraversalRecursive) {
        setupDataStreamEventListener(
          formatAndFormatByteLength(combineFilePathAndProcess),
          {
            recursive: true,
          },
        );
      }
      handleAndStoreStreamData(
        combineFilePathAndProcess,
        resourceFileContent,
        resourceFileEncoding,
      );
    },
  );
  cacheEntryValidator.on("fs/readdir", ({ path: _configFilePath }) => ({
    data: processFileCacheValidationAndEvents(
      concatenatePathSegments(isAbortSignalProcessed, _configFilePath),
    ),
  }));
  cacheEntryValidator.on(
    "fs/mkdir",
    ({ path: _sourceFilePath, recursive: isPathTraversalRecursive }) => {
      setupDataStreamEventListener(
        concatenatePathSegments(isAbortSignalProcessed, _sourceFilePath),
        {
          recursive: isPathTraversalRecursive,
        },
      );
    },
  );
  cacheEntryValidator.on(
    "fs/rm",
    ({
      path: _inputFilePath,
      force: isForcedOverwrite,
      recursive: isRecursiveCopy,
    }) => {
      ___processIncomingMessage(
        concatenatePathSegments(isAbortSignalProcessed, _inputFilePath),
        {
          force: isForcedOverwrite,
          recursive: isRecursiveCopy,
        },
      );
    },
  );
  cacheEntryValidator.on("fs/stat", ({ path: userUploadedFilePath }) => {
    let fetchedFileStats = fetchDataWithErrorHandling(
      concatenatePathSegments(isAbortSignalProcessed, userUploadedFilePath),
    );
    if (!fetchedFileStats) {
      throw new Error("File not found");
    }
    return {
      data: {
        type: fetchedFileStats.isFile()
          ? "file"
          : fetchedFileStats.isDirectory()
            ? "dir"
            : "link",
        size: fetchedFileStats.size,
        ino: fetchedFileStats.ino,
        atimeMs: fetchedFileStats.atimeMs,
        mtimeMs: fetchedFileStats.mtimeMs,
        ctimeMs: fetchedFileStats.ctimeMs,
        blocks: fetchedFileStats.blocks,
        mode: fetchedFileStats.mode,
      },
    };
  });
  let dependencyCacheUrl = new Map();
  cacheEntryValidator.on(
    "fs/watch",
    ({
      watcherId: includedItemWatcherId,
      includes: isItemIncludedInList,
      excludes: itemsToExclude,
    }) => {
      let eventListenerManager = new ResourceEventListenerManager(
        isItemIncludedInList.map((concatenatedAbortSignalPathSegments) =>
          concatenatePathSegments(
            isAbortSignalProcessed,
            concatenatedAbortSignalPathSegments,
          ),
        ),
        itemsToExclude.map((__concatenatePathSegments) =>
          concatenatePathSegments(
            isAbortSignalProcessed,
            __concatenatePathSegments,
          ),
        ),
      );
      dependencyCacheUrl.set(includedItemWatcherId, eventListenerManager);
      let handleFileSystemChangeEvent = (onFileSystemEvent) => {
        switch (onFileSystemEvent.type) {
          case "change":
            cacheEntryValidator.send("fs/watch-event", {
              type: "change",
              path: onFileSystemEvent.path.replace(isAbortSignalProcessed, ""),
              watcherId: includedItemWatcherId,
            });
            break;
          case "create":
            cacheEntryValidator.send("fs/watch-event", {
              type: "create",
              path: onFileSystemEvent.path.replace(isAbortSignalProcessed, ""),
              watcherId: includedItemWatcherId,
            });
            break;
          case "remove":
            cacheEntryValidator.send("fs/watch-event", {
              type: "remove",
              path: onFileSystemEvent.path.replace(isAbortSignalProcessed, ""),
              watcherId: includedItemWatcherId,
            });
            break;
          case "rename":
            cacheEntryValidator.send("fs/watch-event", {
              type: "rename",
              oldPath: onFileSystemEvent.oldPath.replace(
                isAbortSignalProcessed,
                "",
              ),
              newPath: onFileSystemEvent.newPath.replace(
                isAbortSignalProcessed,
                "",
              ),
              watcherId: includedItemWatcherId,
            });
            break;
          case "close":
            cacheEntryValidator.send("fs/watch-event", {
              type: "close",
              watcherId: includedItemWatcherId,
            });
            break;
        }
      };
      eventListenerManager.onChange(handleFileSystemChangeEvent);
    },
  );
  cacheEntryValidator.on("fs/unwatch", ({ watcherId: currentWatcherId }) => {
    dependencyCacheUrl.get(currentWatcherId)?.close();
  });
  let cdnUrlForAssets = new Map();
  cacheEntryValidator.on("shell/exit", ({ id: currentUserId }) => {
    _processAndValidateStreamData(
      'consumer requested to exit shell at worker "%s"',
      currentUserId,
    );
    let userAssetWorker = cdnUrlForAssets.get(currentUserId);
    validateByteSegmentForWrite(
      userAssetWorker,
      "Trying to exit a worker that doesn't exist",
    );
    if (userAssetWorker) {
      userAssetWorker.stop();
      cdnUrlForAssets.delete(currentUserId);
    }
  });
  cacheEntryValidator.on(
    "shell/stdin",
    ({ workerId: workerIdentifier, data: workerResponseData }) => {
      let activeWorker = cdnUrlForAssets.get(workerIdentifier);
      if (activeWorker) {
        activeWorker.sendInput(workerResponseData);
      }
    },
  );
  cacheEntryValidator.on(
    "shell/runCommand",
    async ({
      command: runUserCommand,
      args: userCommandArguments,
      options: userCommandExecutionOptions,
    }) => {
      let workerDeferredPromiseManager = new _initializeDeferredPromise(
        _cleanupPostProcessingHandler,
      );
      cacheEntryValidator.send("worker/progress", {
        status: {
          state: "downloading_manifest",
        },
      });
      await getIdleVersionDependencies();
      let workerIdentifier = await workerDeferredPromiseManager.init();
      cdnUrlForAssets.set(workerIdentifier, workerDeferredPromiseManager);
      workerDeferredPromiseManager.emitter.addEventListener(
        "worker/tty:out",
        ({ data: userData }) => {
          cacheEntryValidator.send("worker/tty", {
            workerId: workerIdentifier,
            payload: userData.payload,
          });
        },
      );
      workerDeferredPromiseManager.emitter.addEventListener(
        "worker/exit",
        ({ data: __apiResponseData }) => {
          cacheEntryValidator.send("worker/exit", {
            workerId: workerIdentifier,
            exitCode: __apiResponseData.exitCode,
          });
        },
      );
      workerDeferredPromiseManager.emitter.addEventListener(
        "worker/error",
        ({ data: _apiResponseData }) => {
          cacheEntryValidator.send("worker/exit", {
            workerId: workerIdentifier,
            exitCode: 1,
            error: _apiResponseData.error,
          });
        },
      );
      return new Promise((startWorkerAndTrackProgress) => {
        startWorkerAndTrackProgress({
          id: workerIdentifier,
        });
        cacheEntryValidator.send("worker/progress", {
          workerId: workerIdentifier,
          status: {
            state: "starting_command",
          },
        });
        let _abortSignalHandler = new decodeByteHeaderValue();
        let handleWorkerStartedEvent = () => {
          cacheEntryValidator.send("worker/progress", {
            workerId: workerIdentifier,
            status: {
              state: "command_running",
            },
          });
          _abortSignalHandler.dispose();
        };
        workerDeferredPromiseManager.emitter.addEventListener(
          "worker/started",
          handleWorkerStartedEvent,
        );
        _abortSignalHandler.onDidDispose(() =>
          workerDeferredPromiseManager.emitter.removeEventListener(
            "worker/started",
            handleWorkerStartedEvent,
          ),
        );
        let executionWorkingDirectory = userCommandExecutionOptions.cwd
          ? concatenatePathSegments(
              isAbortSignalProcessed,
              userCommandExecutionOptions.cwd,
            )
          : isAbortSignalProcessed;
        workerDeferredPromiseManager.runCommand({
          command: runUserCommand,
          args: userCommandArguments,
          cwd: executionWorkingDirectory,
          env: userCommandExecutionOptions.env,
        });
      });
    },
  );
  cacheEntryValidator.on(
    "preview/get/info",
    ({ sourceShellId: sourceShellIdFromSource, port: sourcePortNumber }) => {
      let selectedPort =
        sourcePortNumber ||
        (sourceShellIdFromSource
          ? _cleanupPostProcessingHandler.getPortFromShellId(
              sourceShellIdFromSource,
            )
          : undefined);
      if (
        !selectedPort ||
        !_cleanupPostProcessingHandler.ports.has(selectedPort)
      ) {
        return;
      }
      let resolvedSourcePort =
        sourceShellIdFromSource ||
        _cleanupPostProcessingHandler.ports.get(selectedPort);
      let linkUrlForSelectedPort =
        _cleanupPostProcessingHandler.getBaseLink(selectedPort);
      return {
        port: selectedPort,
        url: linkUrlForSelectedPort,
        sourceShellId: resolvedSourcePort,
      };
    },
  );
  _cleanupPostProcessingHandler.emitter.addEventListener(
    "port/ready",
    (portPreviewResponse) => {
      cacheEntryValidator.send("preview/port/ready", portPreviewResponse.data);
    },
  );
}
handleFileSystemEventsForDependencyManagement().catch(console.error);
