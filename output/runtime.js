var definePropertyIfExists = (propertyHandler, _propertyKey, propertyValue) =>
  _propertyKey in propertyHandler
    ? Object.defineProperty(propertyHandler, _propertyKey, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: propertyValue,
      })
    : (propertyHandler[_propertyKey] = propertyValue);
var conditionalExecutor = (resetAndUpdateValue, resettableValue) => () => {
  if (resetAndUpdateValue) {
    resettableValue = resetAndUpdateValue((resetAndUpdateValue = 0));
  }
  return resettableValue;
};
var conditionalModuleLoader = (initializeModule, _____moduleExports) => () => {
  if (!_____moduleExports) {
    initializeModule(
      (_____moduleExports = {
        exports: {},
      }).exports,
      _____moduleExports,
    );
  }
  return _____moduleExports.exports;
};
var definePropertiesWithGetters = (
  _definePropertiesFromSource,
  sourceProperties,
) => {
  for (var __propertyKey in sourceProperties) {
    Object.defineProperty(_definePropertiesFromSource, __propertyKey, {
      get: sourceProperties[__propertyKey],
      enumerable: true,
    });
  }
};
var definePropertiesFromSource = (
  definePropertiesIfNotExists,
  sourceObject,
  excludedPropertyName,
  ____propertyDescriptor,
) => {
  if (
    (sourceObject && typeof sourceObject == "object") ||
    typeof sourceObject == "function"
  ) {
    for (let propertyName of Object.getOwnPropertyNames(sourceObject)) {
      if (
        !Object.prototype.hasOwnProperty.call(
          definePropertiesIfNotExists,
          propertyName,
        ) &&
        propertyName !== excludedPropertyName
      ) {
        Object.defineProperty(definePropertiesIfNotExists, propertyName, {
          get: () => sourceObject[propertyName],
          enumerable:
            !(____propertyDescriptor = Object.getOwnPropertyDescriptor(
              sourceObject,
              propertyName,
            )) || ____propertyDescriptor.enumerable,
        });
      }
    }
  }
  return definePropertiesIfNotExists;
};
var copyPropertiesWithDefault = (
  sourcePropertyDefinitions,
  defaultPropertyDefinitions,
  additionalPropertyDefinitions,
) => {
  definePropertiesFromSource(
    sourcePropertyDefinitions,
    defaultPropertyDefinitions,
    "default",
  );
  return (
    additionalPropertyDefinitions &&
    definePropertiesFromSource(
      additionalPropertyDefinitions,
      defaultPropertyDefinitions,
      "default",
    )
  );
};
var defineObjectProperties = (
  _sourceObject,
  sourceObjectProperties,
  createdObject,
) => {
  if (_sourceObject != null) {
    createdObject = Object.create(Object.getPrototypeOf(_sourceObject));
  } else {
    createdObject = {};
  }
  return definePropertiesFromSource(
    sourceObjectProperties || !_sourceObject || !_sourceObject.__esModule
      ? Object.defineProperty(createdObject, "default", {
          value: _sourceObject,
          enumerable: true,
        })
      : createdObject,
    _sourceObject,
  );
};
var createESModule = (__definePropertiesFromSource) =>
  definePropertiesFromSource(
    Object.defineProperty({}, "__esModule", {
      value: true,
    }),
    __definePropertiesFromSource,
  );
var definePropertyIfSymbolExists = (
  defineAndReturnProperty,
  __propertyName,
  __propertyValue,
) => {
  definePropertyIfExists(
    defineAndReturnProperty,
    typeof __propertyName != "symbol" ? __propertyName + "" : __propertyName,
    __propertyValue,
  );
  return __propertyValue;
};
var conditionalModuleLoaderWithSymbolCheck = conditionalModuleLoader(
  (checkSymbolSupport, checkSymbolSupportImplementation) => {
    checkSymbolSupportImplementation.exports = function () {
      if (
        typeof Symbol != "function" ||
        typeof Object.getOwnPropertySymbols != "function"
      ) {
        return false;
      }
      if (typeof Symbol.iterator == "symbol") {
        return true;
      }
      var symbolPropertiesObject = {};
      var testSymbol = Symbol("test");
      var symbolWrapperObject = Object(testSymbol);
      if (
        typeof testSymbol == "string" ||
        Object.prototype.toString.call(testSymbol) !== "[object Symbol]" ||
        Object.prototype.toString.call(symbolWrapperObject) !==
          "[object Symbol]"
      ) {
        return false;
      }
      var symbolValue = 42;
      symbolPropertiesObject[testSymbol] = symbolValue;
      for (testSymbol in symbolPropertiesObject) {
        return false;
      }
      if (
        (typeof Object.keys == "function" &&
          Object.keys(symbolPropertiesObject).length !== 0) ||
        (typeof Object.getOwnPropertyNames == "function" &&
          Object.getOwnPropertyNames(symbolPropertiesObject).length !== 0)
      ) {
        return false;
      }
      var symbolKeys = Object.getOwnPropertySymbols(symbolPropertiesObject);
      if (
        symbolKeys.length !== 1 ||
        symbolKeys[0] !== testSymbol ||
        !Object.prototype.propertyIsEnumerable.call(
          symbolPropertiesObject,
          testSymbol,
        )
      ) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var _______propertyDescriptor = Object.getOwnPropertyDescriptor(
          symbolPropertiesObject,
          testSymbol,
        );
        if (
          _______propertyDescriptor.value !== symbolValue ||
          _______propertyDescriptor.enumerable !== true
        ) {
          return false;
        }
      }
      return true;
    };
  },
);
var _conditionalModuleLoaderWithSymbolCheck = conditionalModuleLoader(
  (checkSymbolToStringTagSupport, isSymbolToStringTagSupported) => {
    var _checkSymbolToStringTagSupport =
      conditionalModuleLoaderWithSymbolCheck();
    isSymbolToStringTagSupported.exports = function () {
      return _checkSymbolToStringTagSupport() && !!Symbol.toStringTag;
    };
  },
);
var __conditionalModuleLoaderWithSymbolCheck = conditionalModuleLoader(
  (validateSymbolSupport, checkSymbolSupportAndLoadModule) => {
    var symbolValidationCheck = typeof Symbol !== "undefined" && Symbol;
    var _conditionalModuleLoaderWithSymbolValidation =
      conditionalModuleLoaderWithSymbolCheck();
    checkSymbolSupportAndLoadModule.exports = function () {
      if (
        typeof symbolValidationCheck != "function" ||
        typeof Symbol != "function" ||
        typeof symbolValidationCheck("foo") != "symbol" ||
        typeof Symbol("bar") != "symbol"
      ) {
        return false;
      } else {
        return _conditionalModuleLoaderWithSymbolValidation();
      }
    };
  },
);
var symbolSupportChecker = conditionalModuleLoader(
  (bindFunctionWithContext, bindFunctionToContext) => {
    var incompatibleFunctionBindMessage =
      "Function.prototype.bind called on incompatible ";
    var arraySlice = Array.prototype.slice;
    var _getObjectType = Object.prototype.toString;
    var functionTypeString = "[object Function]";
    bindFunctionToContext.exports = function (
      conditionalModuleLoaderWithSymbolValidation,
    ) {
      var boundFunction = this;
      if (
        typeof boundFunction != "function" ||
        _getObjectType.call(boundFunction) !== functionTypeString
      ) {
        throw new TypeError(incompatibleFunctionBindMessage + boundFunction);
      }
      var argumentsArray = arraySlice.call(arguments, 1);
      var boundFunctionWrapper;
      function invokeBoundFunctionWithArgs() {
        if (this instanceof boundFunctionWrapper) {
          var resultBoundFunction = boundFunction.apply(
            this,
            argumentsArray.concat(arraySlice.call(arguments)),
          );
          if (Object(resultBoundFunction) === resultBoundFunction) {
            return resultBoundFunction;
          } else {
            return this;
          }
        } else {
          return boundFunction.apply(
            conditionalModuleLoaderWithSymbolValidation,
            argumentsArray.concat(arraySlice.call(arguments)),
          );
        }
      }
      for (
        var argumentsCount = Math.max(
            0,
            boundFunction.length - argumentsArray.length,
          ),
          placeholderArguments = [],
          currentArgumentIndex = 0;
        currentArgumentIndex < argumentsCount;
        currentArgumentIndex++
      ) {
        placeholderArguments.push("$" + currentArgumentIndex);
      }
      boundFunctionWrapper = Function(
        "binder",
        "return function (" +
          placeholderArguments.join(",") +
          "){ return binder.apply(this,arguments); }",
      )(invokeBoundFunctionWithArgs);
      if (boundFunction.prototype) {
        function executeFunction() {}
        executeFunction.prototype = boundFunction.prototype;
        boundFunctionWrapper.prototype = new executeFunction();
        executeFunction.prototype = null;
      }
      return boundFunctionWrapper;
    };
  },
);
var validateAndBindFunction = conditionalModuleLoader(
  (bindFunctionWithFallback, _bindFunctionWithFallback) => {
    var fallbackBindFunction = symbolSupportChecker();
    _bindFunctionWithFallback.exports =
      Function.prototype.bind || fallbackBindFunction;
  },
);
var createConditionalLoader = conditionalModuleLoader(
  (validateHasOwnProperty, hasOwnPropertyExporter) => {
    var validateAndBindHasOwnProperty = validateAndBindFunction();
    hasOwnPropertyExporter.exports = validateAndBindHasOwnProperty.call(
      Function.call,
      Object.prototype.hasOwnProperty,
    );
  },
);
var _validateAndBindFunction = conditionalModuleLoader(
  (handleConditionalModuleLoading, ____conditionalModuleLoader) => {
    var _____conditionalModuleLoader;
    var SyntaxErrorConstructor = SyntaxError;
    var createBoundFunctionFromSource = Function;
    var TypeErrorException = TypeError;
    function getConstructorFromBoundFunction(createAndValidateBoundFunction) {
      try {
        return createBoundFunctionFromSource(
          '"use strict"; return (' +
            createAndValidateBoundFunction +
            ").constructor;",
        )();
      } catch {}
    }
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    if (getOwnPropertyDescriptor) {
      try {
        getOwnPropertyDescriptor({}, "");
      } catch {
        getOwnPropertyDescriptor = null;
      }
    }
    function throwTypeError() {
      throw new TypeErrorException();
    }
    var getCalleeGetter = getOwnPropertyDescriptor
      ? (function () {
          try {
            arguments.callee;
            return throwTypeError;
          } catch {
            try {
              return getOwnPropertyDescriptor(arguments, "callee").get;
            } catch {
              return throwTypeError;
            }
          }
        })()
      : throwTypeError;
    var conditionalModuleLoaderFunction =
      __conditionalModuleLoaderWithSymbolCheck()();
    var ______conditionalModuleLoader =
      Object.getPrototypeOf ||
      function (validateFunctionBinding) {
        return validateFunctionBinding.__proto__;
      };
    var _______conditionalModuleLoader = {};
    var ________conditionalModuleLoader =
      typeof Uint8Array === "undefined"
        ? _____conditionalModuleLoader
        : ______conditionalModuleLoader(Uint8Array);
    var __________conditionalModuleLoader = {
      "%AggregateError%":
        typeof AggregateError === "undefined"
          ? _____conditionalModuleLoader
          : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%":
        typeof ArrayBuffer === "undefined"
          ? _____conditionalModuleLoader
          : ArrayBuffer,
      "%ArrayIteratorPrototype%": conditionalModuleLoaderFunction
        ? ______conditionalModuleLoader([][Symbol.iterator]())
        : _____conditionalModuleLoader,
      "%AsyncFromSyncIteratorPrototype%": _____conditionalModuleLoader,
      "%AsyncFunction%": _______conditionalModuleLoader,
      "%AsyncGenerator%": _______conditionalModuleLoader,
      "%AsyncGeneratorFunction%": _______conditionalModuleLoader,
      "%AsyncIteratorPrototype%": _______conditionalModuleLoader,
      "%Atomics%":
        typeof Atomics === "undefined" ? _____conditionalModuleLoader : Atomics,
      "%BigInt%":
        typeof BigInt === "undefined" ? _____conditionalModuleLoader : BigInt,
      "%Boolean%": Boolean,
      "%DataView%":
        typeof DataView === "undefined"
          ? _____conditionalModuleLoader
          : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%":
        typeof Float32Array === "undefined"
          ? _____conditionalModuleLoader
          : Float32Array,
      "%Float64Array%":
        typeof Float64Array === "undefined"
          ? _____conditionalModuleLoader
          : Float64Array,
      "%FinalizationRegistry%":
        typeof FinalizationRegistry === "undefined"
          ? _____conditionalModuleLoader
          : FinalizationRegistry,
      "%Function%": createBoundFunctionFromSource,
      "%GeneratorFunction%": _______conditionalModuleLoader,
      "%Int8Array%":
        typeof Int8Array === "undefined"
          ? _____conditionalModuleLoader
          : Int8Array,
      "%Int16Array%":
        typeof Int16Array === "undefined"
          ? _____conditionalModuleLoader
          : Int16Array,
      "%Int32Array%":
        typeof Int32Array === "undefined"
          ? _____conditionalModuleLoader
          : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": conditionalModuleLoaderFunction
        ? ______conditionalModuleLoader(
            ______conditionalModuleLoader([][Symbol.iterator]()),
          )
        : _____conditionalModuleLoader,
      "%JSON%": typeof JSON == "object" ? JSON : _____conditionalModuleLoader,
      "%Map%": typeof Map === "undefined" ? _____conditionalModuleLoader : Map,
      "%MapIteratorPrototype%":
        typeof Map === "undefined" || !conditionalModuleLoaderFunction
          ? _____conditionalModuleLoader
          : ______conditionalModuleLoader(new Map()[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%":
        typeof Promise === "undefined" ? _____conditionalModuleLoader : Promise,
      "%Proxy%":
        typeof Proxy === "undefined" ? _____conditionalModuleLoader : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%":
        typeof Reflect === "undefined" ? _____conditionalModuleLoader : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? _____conditionalModuleLoader : Set,
      "%SetIteratorPrototype%":
        typeof Set === "undefined" || !conditionalModuleLoaderFunction
          ? _____conditionalModuleLoader
          : ______conditionalModuleLoader(new Set()[Symbol.iterator]()),
      "%SharedArrayBuffer%":
        typeof SharedArrayBuffer === "undefined"
          ? _____conditionalModuleLoader
          : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": conditionalModuleLoaderFunction
        ? ______conditionalModuleLoader(""[Symbol.iterator]())
        : _____conditionalModuleLoader,
      "%Symbol%": conditionalModuleLoaderFunction
        ? Symbol
        : _____conditionalModuleLoader,
      "%SyntaxError%": SyntaxErrorConstructor,
      "%ThrowTypeError%": getCalleeGetter,
      "%TypedArray%": ________conditionalModuleLoader,
      "%TypeError%": TypeErrorException,
      "%Uint8Array%":
        typeof Uint8Array === "undefined"
          ? _____conditionalModuleLoader
          : Uint8Array,
      "%Uint8ClampedArray%":
        typeof Uint8ClampedArray === "undefined"
          ? _____conditionalModuleLoader
          : Uint8ClampedArray,
      "%Uint16Array%":
        typeof Uint16Array === "undefined"
          ? _____conditionalModuleLoader
          : Uint16Array,
      "%Uint32Array%":
        typeof Uint32Array === "undefined"
          ? _____conditionalModuleLoader
          : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%":
        typeof WeakMap === "undefined" ? _____conditionalModuleLoader : WeakMap,
      "%WeakRef%":
        typeof WeakRef === "undefined" ? _____conditionalModuleLoader : WeakRef,
      "%WeakSet%":
        typeof WeakSet === "undefined" ? _____conditionalModuleLoader : WeakSet,
    };
    var _________________________conditionalModuleLoader =
      function getObjectPrototypeMapping(parseableInteger) {
        var objectPrototype;
        if (parseableInteger === "%AsyncFunction%") {
          objectPrototype = getConstructorFromBoundFunction(
            "async function () {}",
          );
        } else if (parseableInteger === "%GeneratorFunction%") {
          objectPrototype = getConstructorFromBoundFunction("function* () {}");
        } else if (parseableInteger === "%AsyncGeneratorFunction%") {
          objectPrototype = getConstructorFromBoundFunction(
            "async function* () {}",
          );
        } else if (parseableInteger === "%AsyncGenerator%") {
          var asyncGeneratorFunctionPrototype = getObjectPrototypeMapping(
            "%AsyncGeneratorFunction%",
          );
          if (asyncGeneratorFunctionPrototype) {
            objectPrototype = asyncGeneratorFunctionPrototype.prototype;
          }
        } else if (parseableInteger === "%AsyncIteratorPrototype%") {
          var asyncGeneratorPrototypeMapping =
            getObjectPrototypeMapping("%AsyncGenerator%");
          if (asyncGeneratorPrototypeMapping) {
            objectPrototype = ______conditionalModuleLoader(
              asyncGeneratorPrototypeMapping.prototype,
            );
          }
        }
        __________conditionalModuleLoader[parseableInteger] = objectPrototype;
        return objectPrototype;
      };
    var __________________________conditionalModuleLoader = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": [
        "AsyncGeneratorFunction",
        "prototype",
        "prototype",
      ],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"],
    };
    var ___________________________conditionalModuleLoader =
      validateAndBindFunction();
    var _conditionalModuleLoaderFunction = createConditionalLoader();
    var ____________________________conditionalModuleLoader =
      ___________________________conditionalModuleLoader.call(
        Function.call,
        Array.prototype.concat,
      );
    var _____________________________conditionalModuleLoader =
      ___________________________conditionalModuleLoader.call(
        Function.apply,
        Array.prototype.splice,
      );
    var ______________________________conditionalModuleLoader =
      ___________________________conditionalModuleLoader.call(
        Function.call,
        String.prototype.replace,
      );
    var _______________________________conditionalModuleLoader =
      ___________________________conditionalModuleLoader.call(
        Function.call,
        String.prototype.slice,
      );
    var ________________________________conditionalModuleLoader =
      ___________________________conditionalModuleLoader.call(
        Function.call,
        RegExp.prototype.exec,
      );
    var _________________________________conditionalModuleLoader =
      /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var __________________________________conditionalModuleLoader = /\\(\\)?/g;
    function validateAndCheckPrototypes(availablePrototypesMapping) {
      var evaluatePrototypeSyntax =
        _______________________________conditionalModuleLoader(
          availablePrototypesMapping,
          0,
          1,
        );
      var closingBracketEvaluation =
        _______________________________conditionalModuleLoader(
          availablePrototypesMapping,
          -1,
        );
      if (evaluatePrototypeSyntax === "%" && closingBracketEvaluation !== "%") {
        throw new SyntaxErrorConstructor(
          "invalid intrinsic syntax, expected closing `%`",
        );
      }
      if (closingBracketEvaluation === "%" && evaluatePrototypeSyntax !== "%") {
        throw new SyntaxErrorConstructor(
          "invalid intrinsic syntax, expected opening `%`",
        );
      }
      var evaluatedPrototypes = [];
      ______________________________conditionalModuleLoader(
        availablePrototypesMapping,
        _________________________________conditionalModuleLoader,
        function (
          validateAndGetBoundFunction,
          validateAndBindFunctionCall,
          validatedAndBoundFunction,
          __validateAndBindFunction,
        ) {
          if (validatedAndBoundFunction) {
            evaluatedPrototypes[evaluatedPrototypes.length] =
              ______________________________conditionalModuleLoader(
                __validateAndBindFunction,
                __________________________________conditionalModuleLoader,
                "$1",
              );
          } else {
            evaluatedPrototypes[evaluatedPrototypes.length] =
              validateAndBindFunctionCall || validateAndGetBoundFunction;
          }
        },
      );
      return evaluatedPrototypes;
    }
    function validateAndBindIntrinsic(
      validateBindFunction,
      ___validateAndBindFunction,
    ) {
      var bindedValidateFunction = validateBindFunction;
      var conditionalLoaderAlias;
      if (
        _conditionalModuleLoaderFunction(
          __________________________conditionalModuleLoader,
          bindedValidateFunction,
        )
      ) {
        conditionalLoaderAlias =
          __________________________conditionalModuleLoader[
            bindedValidateFunction
          ];
        bindedValidateFunction = "%" + conditionalLoaderAlias[0] + "%";
      }
      if (
        _conditionalModuleLoaderFunction(
          __________conditionalModuleLoader,
          bindedValidateFunction,
        )
      ) {
        var conditionalModule =
          __________conditionalModuleLoader[bindedValidateFunction];
        if (conditionalModule === _______conditionalModuleLoader) {
          conditionalModule = _________________________conditionalModuleLoader(
            bindedValidateFunction,
          );
        }
        if (
          typeof conditionalModule === "undefined" &&
          !___validateAndBindFunction
        ) {
          throw new TypeErrorException(
            "intrinsic " +
              validateBindFunction +
              " exists, but is not available. Please file an issue!",
          );
        }
        return {
          alias: conditionalLoaderAlias,
          name: bindedValidateFunction,
          value: conditionalModule,
        };
      }
      throw new SyntaxErrorConstructor(
        "intrinsic " + validateBindFunction + " does not exist!",
      );
    }
    ____conditionalModuleLoader.exports = function (
      validateAndExtractPrototypes,
      _validateAndGetBoundFunction,
    ) {
      if (
        typeof validateAndExtractPrototypes != "string" ||
        validateAndExtractPrototypes.length === 0
      ) {
        throw new TypeErrorException(
          "intrinsic name must be a non-empty string",
        );
      }
      if (
        arguments.length > 1 &&
        typeof _validateAndGetBoundFunction != "boolean"
      ) {
        throw new TypeErrorException(
          '"allowMissing" argument must be a boolean',
        );
      }
      if (
        ________________________________conditionalModuleLoader(
          /^%?[^%]*%?$/,
          validateAndExtractPrototypes,
        ) === null
      ) {
        throw new SyntaxErrorConstructor(
          "`%` may not be present anywhere but at the beginning and end of the intrinsic name",
        );
      }
      var extractedPrototype = validateAndCheckPrototypes(
        validateAndExtractPrototypes,
      );
      var extractedPrototypeName =
        extractedPrototype.length > 0 ? extractedPrototype[0] : "";
      var boundFunctionInstance = validateAndBindIntrinsic(
        "%" + extractedPrototypeName + "%",
        _validateAndGetBoundFunction,
      );
      var boundFunctionName = boundFunctionInstance.name;
      var boundFunctionObject = boundFunctionInstance.value;
      var __validateAndExtractPrototypes = false;
      var validateAndExtractFunction = boundFunctionInstance.alias;
      if (validateAndExtractFunction) {
        extractedPrototypeName = validateAndExtractFunction[0];
        _____________________________conditionalModuleLoader(
          extractedPrototype,
          ____________________________conditionalModuleLoader(
            [0, 1],
            validateAndExtractFunction,
          ),
        );
      }
      for (
        var __currentIndex = 1, isPrototypeValid = true;
        __currentIndex < extractedPrototype.length;
        __currentIndex += 1
      ) {
        var _extractedPrototypeName = extractedPrototype[__currentIndex];
        var loadConditionalModule =
          _______________________________conditionalModuleLoader(
            _extractedPrototypeName,
            0,
            1,
          );
        var conditionalModuleName =
          _______________________________conditionalModuleLoader(
            _extractedPrototypeName,
            -1,
          );
        if (
          (loadConditionalModule === '"' ||
            loadConditionalModule === "'" ||
            loadConditionalModule === "`" ||
            conditionalModuleName === '"' ||
            conditionalModuleName === "'" ||
            conditionalModuleName === "`") &&
          loadConditionalModule !== conditionalModuleName
        ) {
          throw new SyntaxErrorConstructor(
            "property names with quotes must have matching quotes",
          );
        }
        if (_extractedPrototypeName === "constructor" || !isPrototypeValid) {
          __validateAndExtractPrototypes = true;
        }
        extractedPrototypeName += "." + _extractedPrototypeName;
        boundFunctionName = "%" + extractedPrototypeName + "%";
        if (
          _conditionalModuleLoaderFunction(
            __________conditionalModuleLoader,
            boundFunctionName,
          )
        ) {
          boundFunctionObject =
            __________conditionalModuleLoader[boundFunctionName];
        } else if (boundFunctionObject != null) {
          if (!(_extractedPrototypeName in boundFunctionObject)) {
            if (!_validateAndGetBoundFunction) {
              throw new TypeErrorException(
                "base intrinsic for " +
                  validateAndExtractPrototypes +
                  " exists, but the property is not available.",
              );
            }
            return;
          }
          if (
            getOwnPropertyDescriptor &&
            __currentIndex + 1 >= extractedPrototype.length
          ) {
            var extractedPrototypeDescriptor = getOwnPropertyDescriptor(
              boundFunctionObject,
              _extractedPrototypeName,
            );
            isPrototypeValid = !!extractedPrototypeDescriptor;
            if (
              isPrototypeValid &&
              "get" in extractedPrototypeDescriptor &&
              !("originalValue" in extractedPrototypeDescriptor.get)
            ) {
              boundFunctionObject = extractedPrototypeDescriptor.get;
            } else {
              boundFunctionObject =
                boundFunctionObject[_extractedPrototypeName];
            }
          } else {
            isPrototypeValid = _conditionalModuleLoaderFunction(
              boundFunctionObject,
              _extractedPrototypeName,
            );
            boundFunctionObject = boundFunctionObject[_extractedPrototypeName];
          }
          if (isPrototypeValid && !__validateAndExtractPrototypes) {
            __________conditionalModuleLoader[boundFunctionName] =
              boundFunctionObject;
          }
        }
      }
      return boundFunctionObject;
    };
  },
);
var validateIntrinsicName = conditionalModuleLoader(
  (applyMethodWithValidation, moduleExportsWithPrototypeValidation) => {
    var validatedFunction = validateAndBindFunction();
    var ____validateAndBindFunction = _validateAndBindFunction();
    var getFunctionApplyMethod = ____validateAndBindFunction(
      "%Function.prototype.apply%",
    );
    var functionCallMethod = ____validateAndBindFunction(
      "%Function.prototype.call%",
    );
    var getReflectApplyMethod =
      ____validateAndBindFunction("%Reflect.apply%", true) ||
      validatedFunction.call(functionCallMethod, getFunctionApplyMethod);
    var getObjectPropertyDescriptorMethod = ____validateAndBindFunction(
      "%Object.getOwnPropertyDescriptor%",
      true,
    );
    var defineObjectPropertyMethod = ____validateAndBindFunction(
      "%Object.defineProperty%",
      true,
    );
    var maxFunction = ____validateAndBindFunction("%Math.max%");
    if (defineObjectPropertyMethod) {
      try {
        defineObjectPropertyMethod({}, "a", {
          value: 1,
        });
      } catch {
        defineObjectPropertyMethod = null;
      }
    }
    moduleExportsWithPrototypeValidation.exports = function (
      _validateAndExtractPrototypes,
    ) {
      var appliedFunction = getReflectApplyMethod(
        validatedFunction,
        functionCallMethod,
        arguments,
      );
      if (getObjectPropertyDescriptorMethod && defineObjectPropertyMethod) {
        var lengthPropertyDescriptor = getObjectPropertyDescriptorMethod(
          appliedFunction,
          "length",
        );
        if (lengthPropertyDescriptor.configurable) {
          defineObjectPropertyMethod(appliedFunction, "length", {
            value:
              1 +
              maxFunction(
                0,
                _validateAndExtractPrototypes.length - (arguments.length - 1),
              ),
          });
        }
      }
      return appliedFunction;
    };
    function applyValidatedFunction() {
      return getReflectApplyMethod(
        validatedFunction,
        getFunctionApplyMethod,
        arguments,
      );
    }
    if (defineObjectPropertyMethod) {
      defineObjectPropertyMethod(
        moduleExportsWithPrototypeValidation.exports,
        "apply",
        {
          value: applyValidatedFunction,
        },
      );
    } else {
      moduleExportsWithPrototypeValidation.exports.apply =
        applyValidatedFunction;
    }
  },
);
var propertyAccessCheck = conditionalModuleLoader(
  (handleIntrinsicProperty, exportIntrinsicPropertyFunction) => {
    var validateAndBindStringIndexOf = _validateAndBindFunction();
    var validateIntrinsicNameFunction = validateIntrinsicName();
    var validateStringIndexOfIntrinsic = validateIntrinsicNameFunction(
      validateAndBindStringIndexOf("String.prototype.indexOf"),
    );
    exportIntrinsicPropertyFunction.exports = function (
      getPropertyFromIntrinsic,
      validateAndExtractIntrinsicName,
    ) {
      var validatedStringIndexFunction = validateAndBindStringIndexOf(
        getPropertyFromIntrinsic,
        !!validateAndExtractIntrinsicName,
      );
      if (
        typeof validatedStringIndexFunction == "function" &&
        validateStringIndexOfIntrinsic(
          getPropertyFromIntrinsic,
          ".prototype.",
        ) > -1
      ) {
        return validateIntrinsicNameFunction(validatedStringIndexFunction);
      } else {
        return validatedStringIndexFunction;
      }
    };
  },
);
var validateAndGetIntrinsicProperty = conditionalModuleLoader(
  (isArgumentsLegacy, isArgumentsObject) => {
    var isLegacyArgumentsSupported =
      _conditionalModuleLoaderWithSymbolCheck()();
    var checkIfArguments = propertyAccessCheck();
    var getToStringTag = checkIfArguments("Object.prototype.toString");
    function _isArgumentsObject(_validateIntrinsicName) {
      if (
        isLegacyArgumentsSupported &&
        _validateIntrinsicName &&
        typeof _validateIntrinsicName == "object" &&
        Symbol.toStringTag in _validateIntrinsicName
      ) {
        return false;
      } else {
        return getToStringTag(_validateIntrinsicName) === "[object Arguments]";
      }
    }
    function _validateIntrinsicObject(__validateIntrinsicName) {
      if (_isArgumentsObject(__validateIntrinsicName)) {
        return true;
      } else {
        return (
          __validateIntrinsicName !== null &&
          typeof __validateIntrinsicName == "object" &&
          typeof __validateIntrinsicName.length == "number" &&
          __validateIntrinsicName.length >= 0 &&
          getToStringTag(__validateIntrinsicName) !== "[object Array]" &&
          getToStringTag(__validateIntrinsicName.callee) === "[object Function]"
        );
      }
    }
    var _isValidArgumentsObject = (function () {
      return _isArgumentsObject(arguments);
    })();
    _isArgumentsObject.isLegacyArguments = _validateIntrinsicObject;
    if (_isValidArgumentsObject) {
      isArgumentsObject.exports = _isArgumentsObject;
    } else {
      isArgumentsObject.exports = _validateIntrinsicObject;
    }
  },
);
var initializeConditionalModule = conditionalModuleLoader(
  (_checkIfGeneratorFunction, __isGeneratorFunction) => {
    var toStringMethod = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var generatorFunctionRegex = /^\s*(?:function)?\*/;
    var isGeneratorFunctionSupported =
      _conditionalModuleLoaderWithSymbolCheck()();
    var _getPrototypeOf = Object.getPrototypeOf;
    function isGeneratorFunctionSupportedCheck() {
      if (!isGeneratorFunctionSupported) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch {}
    }
    var ___isGeneratorFunction;
    __isGeneratorFunction.exports = function (definePropertySafe) {
      if (typeof definePropertySafe != "function") {
        return false;
      }
      if (
        generatorFunctionRegex.test(functionToString.call(definePropertySafe))
      ) {
        return true;
      }
      if (!isGeneratorFunctionSupported) {
        var isGeneratorFunctionString = toStringMethod.call(definePropertySafe);
        return isGeneratorFunctionString === "[object GeneratorFunction]";
      }
      if (!_getPrototypeOf) {
        return false;
      }
      if (typeof ___isGeneratorFunction === "undefined") {
        var __isGeneratorFunctionSupported =
          isGeneratorFunctionSupportedCheck();
        if (__isGeneratorFunctionSupported) {
          ___isGeneratorFunction = _getPrototypeOf(
            __isGeneratorFunctionSupported,
          );
        } else {
          ___isGeneratorFunction = false;
        }
      }
      return _getPrototypeOf(definePropertySafe) === ___isGeneratorFunction;
    };
  },
);
var validateAndExtractIntrinsicProperty = conditionalModuleLoader(
  (validateAndRetrieveIntrinsicClass, validateIntrinsicMethod) => {
    var getFunctionStringRepresentation = Function.prototype.toString;
    var isReflectApplySupported =
      typeof Reflect == "object" && Reflect !== null && Reflect.apply;
    var lengthDescriptor;
    var errorPlaceholder;
    if (
      typeof isReflectApplySupported == "function" &&
      typeof Object.defineProperty == "function"
    ) {
      try {
        lengthDescriptor = Object.defineProperty({}, "length", {
          get() {
            throw errorPlaceholder;
          },
        });
        errorPlaceholder = {};
        isReflectApplySupported(
          function () {
            throw 42;
          },
          null,
          lengthDescriptor,
        );
      } catch (__errorCaught) {
        if (__errorCaught !== errorPlaceholder) {
          isReflectApplySupported = null;
        }
      }
    } else {
      isReflectApplySupported = null;
    }
    var classDeclarationRegex = /^\s*class\b/;
    function isValidIntrinsicProperty(validateAndRetrieveIntrinsicProperty) {
      try {
        var __functionStringRepresentation =
          getFunctionStringRepresentation.call(
            validateAndRetrieveIntrinsicProperty,
          );
        return classDeclarationRegex.test(__functionStringRepresentation);
      } catch {
        return false;
      }
    }
    function validateIntrinsicPropertyAndGetFunctionString(
      validateIntrinsicProperty,
    ) {
      try {
        if (isValidIntrinsicProperty(validateIntrinsicProperty)) {
          return false;
        } else {
          getFunctionStringRepresentation.call(validateIntrinsicProperty);
          return true;
        }
      } catch {
        return false;
      }
    }
    var _getFunctionStringRepresentation = Object.prototype.toString;
    var __getFunctionStringRepresentation = "[object Object]";
    var ___getFunctionStringRepresentation = "[object Function]";
    var ____getFunctionStringRepresentation = "[object GeneratorFunction]";
    var _____getFunctionStringRepresentation = "[object HTMLAllCollection]";
    var getClassDefinitionFromFunction = "[object HTML document.all class]";
    var ______getFunctionStringRepresentation = "[object HTMLCollection]";
    var _______getFunctionStringRepresentation =
      typeof Symbol == "function" && !!Symbol.toStringTag;
    var ________getFunctionStringRepresentation = !(0 in [,]);
    function _isValidIntrinsicName() {
      return false;
    }
    if (typeof document == "object") {
      _________getFunctionStringRepresentation = document.all;
      if (
        _getFunctionStringRepresentation.call(
          _________getFunctionStringRepresentation,
        ) === _getFunctionStringRepresentation.call(document.all)
      ) {
        _isValidIntrinsicName = function (___validateIntrinsicName) {
          if (
            (________getFunctionStringRepresentation ||
              !___validateIntrinsicName) &&
            (typeof ___validateIntrinsicName === "undefined" ||
              typeof ___validateIntrinsicName == "object")
          ) {
            try {
              var _functionStringRepresentation =
                _getFunctionStringRepresentation.call(___validateIntrinsicName);
              return (
                (_functionStringRepresentation ===
                  _____getFunctionStringRepresentation ||
                  _functionStringRepresentation ===
                    getClassDefinitionFromFunction ||
                  _functionStringRepresentation ===
                    ______getFunctionStringRepresentation ||
                  _functionStringRepresentation ===
                    __getFunctionStringRepresentation) &&
                ___validateIntrinsicName("") == null
              );
            } catch {}
          }
          return false;
        };
      }
    }
    var _________getFunctionStringRepresentation;
    if (isReflectApplySupported) {
      validateIntrinsicMethod.exports = function (isGeneratorFunction) {
        if (_isValidIntrinsicName(isGeneratorFunction)) {
          return true;
        }
        if (
          !isGeneratorFunction ||
          (typeof isGeneratorFunction != "function" &&
            typeof isGeneratorFunction != "object")
        ) {
          return false;
        }
        try {
          isReflectApplySupported(isGeneratorFunction, null, lengthDescriptor);
        } catch (errorHandling) {
          if (errorHandling !== errorPlaceholder) {
            return false;
          }
        }
        return (
          !isValidIntrinsicProperty(isGeneratorFunction) &&
          validateIntrinsicPropertyAndGetFunctionString(isGeneratorFunction)
        );
      };
    } else {
      validateIntrinsicMethod.exports = function (validateGeneratorFunction) {
        if (_isValidIntrinsicName(validateGeneratorFunction)) {
          return true;
        }
        if (
          !validateGeneratorFunction ||
          (typeof validateGeneratorFunction != "function" &&
            typeof validateGeneratorFunction != "object")
        ) {
          return false;
        }
        if (_______getFunctionStringRepresentation) {
          return validateIntrinsicPropertyAndGetFunctionString(
            validateGeneratorFunction,
          );
        }
        if (isValidIntrinsicProperty(validateGeneratorFunction)) {
          return false;
        }
        var functionStringRepresentation =
          _getFunctionStringRepresentation.call(validateGeneratorFunction);
        if (
          functionStringRepresentation !== ___getFunctionStringRepresentation &&
          functionStringRepresentation !==
            ____getFunctionStringRepresentation &&
          !/^\[object HTML/.test(functionStringRepresentation)
        ) {
          return false;
        } else {
          return validateIntrinsicPropertyAndGetFunctionString(
            validateGeneratorFunction,
          );
        }
      };
    }
  },
);
var isGeneratorFunctionCheck = conditionalModuleLoader(
  (processIntrinsicProperties, ___validateAndProcessIntrinsicProperties) => {
    var extractedIntrinsicProperties = validateAndExtractIntrinsicProperty();
    var getObjectType = Object.prototype.toString;
    var __hasOwnProperty = Object.prototype.hasOwnProperty;
    function _processIntrinsicProperties(
      _validateAndRetrieveIntrinsicProperty,
      __validateAndRetrieveIntrinsicProperty,
      ___validateAndRetrieveIntrinsicProperty,
    ) {
      for (
        var propertyIndex = 0,
          intrinsicPropertyCount = _validateAndRetrieveIntrinsicProperty.length;
        propertyIndex < intrinsicPropertyCount;
        propertyIndex++
      ) {
        if (
          __hasOwnProperty.call(
            _validateAndRetrieveIntrinsicProperty,
            propertyIndex,
          )
        ) {
          if (___validateAndRetrieveIntrinsicProperty == null) {
            __validateAndRetrieveIntrinsicProperty(
              _validateAndRetrieveIntrinsicProperty[propertyIndex],
              propertyIndex,
              _validateAndRetrieveIntrinsicProperty,
            );
          } else {
            __validateAndRetrieveIntrinsicProperty.call(
              ___validateAndRetrieveIntrinsicProperty,
              _validateAndRetrieveIntrinsicProperty[propertyIndex],
              propertyIndex,
              _validateAndRetrieveIntrinsicProperty,
            );
          }
        }
      }
    }
    function validateAndProcessClassInstantiation(
      validateClassInstantiation,
      validateClassStructure,
      ____validateAndRetrieveIntrinsicProperty,
    ) {
      for (
        var _____index = 0,
          totalClassInstantiations = validateClassInstantiation.length;
        _____index < totalClassInstantiations;
        _____index++
      ) {
        if (____validateAndRetrieveIntrinsicProperty == null) {
          validateClassStructure(
            validateClassInstantiation.charAt(_____index),
            _____index,
            validateClassInstantiation,
          );
        } else {
          validateClassStructure.call(
            ____validateAndRetrieveIntrinsicProperty,
            validateClassInstantiation.charAt(_____index),
            _____index,
            validateClassInstantiation,
          );
        }
      }
    }
    function processAndRetrieveProperties(
      validateAndHandleFunction,
      validateAndRetrieveObjectLength,
      _____validateAndRetrieveIntrinsicProperty,
    ) {
      for (var propertyKey in validateAndHandleFunction) {
        if (__hasOwnProperty.call(validateAndHandleFunction, propertyKey)) {
          if (_____validateAndRetrieveIntrinsicProperty == null) {
            validateAndRetrieveObjectLength(
              validateAndHandleFunction[propertyKey],
              propertyKey,
              validateAndHandleFunction,
            );
          } else {
            validateAndRetrieveObjectLength.call(
              _____validateAndRetrieveIntrinsicProperty,
              validateAndHandleFunction[propertyKey],
              propertyKey,
              validateAndHandleFunction,
            );
          }
        }
      }
    }
    function validateAndProcessClassDefinition(
      validateClassString,
      isClassDefinition,
      validateAndDetectIntrinsicProperty,
    ) {
      if (!extractedIntrinsicProperties(isClassDefinition)) {
        throw new TypeError("iterator must be a function");
      }
      var _intrinsicPropertyValidator;
      if (arguments.length >= 3) {
        _intrinsicPropertyValidator = validateAndDetectIntrinsicProperty;
      }
      if (getObjectType.call(validateClassString) === "[object Array]") {
        _processIntrinsicProperties(
          validateClassString,
          isClassDefinition,
          _intrinsicPropertyValidator,
        );
      } else if (typeof validateClassString == "string") {
        validateAndProcessClassInstantiation(
          validateClassString,
          isClassDefinition,
          _intrinsicPropertyValidator,
        );
      } else {
        processAndRetrieveProperties(
          validateClassString,
          isClassDefinition,
          _intrinsicPropertyValidator,
        );
      }
    }
    ___validateAndProcessIntrinsicProperties.exports =
      validateAndProcessClassDefinition;
  },
);
var isIntrinsicObject = conditionalModuleLoader(
  (exportSupportedTypedArrays, getSupportedTypedArrays) => {
    var supportedTypedArrayNames = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray",
    ];
    var __globalContext =
      typeof globalThis === "undefined" ? global : globalThis;
    getSupportedTypedArrays.exports = function () {
      var supportedTypedArrayList = [];
      for (
        var typedArrayCount = 0;
        typedArrayCount < supportedTypedArrayNames.length;
        typedArrayCount++
      ) {
        if (
          typeof __globalContext[supportedTypedArrayNames[typedArrayCount]] ==
          "function"
        ) {
          supportedTypedArrayList[supportedTypedArrayList.length] =
            supportedTypedArrayNames[typedArrayCount];
        }
      }
      return supportedTypedArrayList;
    };
  },
);
var isValidIntrinsicName = conditionalModuleLoader(
  (validateAndGetPropertyDescriptor, exportedPropertyDescriptor) => {
    var _validateAndGetPropertyDescriptor = _validateAndBindFunction();
    var getOwnPropertyDescriptorValidator = _validateAndGetPropertyDescriptor(
      "%Object.getOwnPropertyDescriptor%",
      true,
    );
    if (getOwnPropertyDescriptorValidator) {
      try {
        getOwnPropertyDescriptorValidator([], "length");
      } catch {
        getOwnPropertyDescriptorValidator = null;
      }
    }
    exportedPropertyDescriptor.exports = getOwnPropertyDescriptorValidator;
  },
);
var isValidGeneratorFunction = conditionalModuleLoader(
  (findIndexOfElement, generatorFunctionInstance) => {
    var checkIfGeneratorFunction = isGeneratorFunctionCheck();
    var getIntrinsicObject = isIntrinsicObject();
    var getPropertyAccessFunction = propertyAccessCheck();
    var propertyAccessToString = getPropertyAccessFunction(
      "Object.prototype.toString",
    );
    var ___conditionalModuleLoaderWithSymbolCheck =
      _conditionalModuleLoaderWithSymbolCheck()();
    var globalContext = typeof globalThis === "undefined" ? global : globalThis;
    var getIntrinsicObjectInstance = getIntrinsicObject();
    var findIndexInArray =
      getPropertyAccessFunction("Array.prototype.indexOf", true) ||
      function (_validateGeneratorFunction, _isValidGeneratorFunction) {
        for (
          var indexOfValidFunction = 0;
          indexOfValidFunction < _validateGeneratorFunction.length;
          indexOfValidFunction += 1
        ) {
          if (
            _validateGeneratorFunction[indexOfValidFunction] ===
            _isValidGeneratorFunction
          ) {
            return indexOfValidFunction;
          }
        }
        return -1;
      };
    var stringPrototypeSliceFunction = getPropertyAccessFunction(
      "String.prototype.slice",
    );
    var generatorFunctionState = {};
    var findIndexOfElementInArray = isValidIntrinsicName();
    var findElementIndexInArray = Object.getPrototypeOf;
    if (
      ___conditionalModuleLoaderWithSymbolCheck &&
      findIndexOfElementInArray &&
      findElementIndexInArray
    ) {
      checkIfGeneratorFunction(
        getIntrinsicObjectInstance,
        function (__isValidGeneratorFunction) {
          var _generatorFunctionInstance = new globalContext[
            __isValidGeneratorFunction
          ]();
          if (Symbol.toStringTag in _generatorFunctionInstance) {
            var elementIndexInGeneratorFunction = findElementIndexInArray(
              _generatorFunctionInstance,
            );
            var indexOfToStringTag = findIndexOfElementInArray(
              elementIndexInGeneratorFunction,
              Symbol.toStringTag,
            );
            if (!indexOfToStringTag) {
              var elementIndex = findElementIndexInArray(
                elementIndexInGeneratorFunction,
              );
              indexOfToStringTag = findIndexOfElementInArray(
                elementIndex,
                Symbol.toStringTag,
              );
            }
            generatorFunctionState[__isValidGeneratorFunction] =
              indexOfToStringTag.get;
          }
        },
      );
    }
    function ______validateGeneratorFunction(isGeneratorFunctionValid) {
      var isGeneratorFunctionValidCached = false;
      checkIfGeneratorFunction(
        generatorFunctionState,
        function (_isGeneratorFunctionCheck, __isGeneratorFunctionCheck) {
          if (!isGeneratorFunctionValidCached) {
            try {
              isGeneratorFunctionValidCached =
                _isGeneratorFunctionCheck.call(isGeneratorFunctionValid) ===
                __isGeneratorFunctionCheck;
            } catch {}
          }
        },
      );
      return isGeneratorFunctionValidCached;
    }
    generatorFunctionInstance.exports = function (___isGeneratorFunctionCheck) {
      if (
        !___isGeneratorFunctionCheck ||
        typeof ___isGeneratorFunctionCheck != "object"
      ) {
        return false;
      }
      if (
        !___conditionalModuleLoaderWithSymbolCheck ||
        !(Symbol.toStringTag in ___isGeneratorFunctionCheck)
      ) {
        var generatorFunctionName = stringPrototypeSliceFunction(
          propertyAccessToString(___isGeneratorFunctionCheck),
          8,
          -1,
        );
        return (
          findIndexInArray(getIntrinsicObjectInstance, generatorFunctionName) >
          -1
        );
      }
      if (findIndexOfElementInArray) {
        return ______validateGeneratorFunction(___isGeneratorFunctionCheck);
      } else {
        return false;
      }
    };
  },
);
var validateAndProcessIntrinsicProperty = conditionalModuleLoader(
  (validateAndCreateNewInstance, createInstanceWithValidation) => {
    var generateInstanceWithValidation = isGeneratorFunctionCheck();
    var retrieveIntrinsicObject = isIntrinsicObject();
    var propertyAccessCheckFunction = propertyAccessCheck();
    var propertyToStringCheck = propertyAccessCheckFunction(
      "Object.prototype.toString",
    );
    var ___________________________________conditionalModuleLoader =
      _conditionalModuleLoaderWithSymbolCheck()();
    var globalObjectReference =
      typeof globalThis === "undefined" ? global : globalThis;
    var intrinsicObject = retrieveIntrinsicObject();
    var stringSlicePropertyAccess = propertyAccessCheckFunction(
      "String.prototype.slice",
    );
    var instanceValidationResult = {};
    var isValidIntrinsicNameCheck = isValidIntrinsicName();
    var getPrototypeOf = Object.getPrototypeOf;
    if (
      ___________________________________conditionalModuleLoader &&
      isValidIntrinsicNameCheck &&
      getPrototypeOf
    ) {
      generateInstanceWithValidation(
        intrinsicObject,
        function (validateAndRetrieveClassProperties) {
          if (
            typeof globalObjectReference[validateAndRetrieveClassProperties] ==
            "function"
          ) {
            var validatedClassInstance = new globalObjectReference[
              validateAndRetrieveClassProperties
            ]();
            if (Symbol.toStringTag in validatedClassInstance) {
              var prototypeOfValidatedInstance = getPrototypeOf(
                validatedClassInstance,
              );
              var _isPrototypeValid = isValidIntrinsicNameCheck(
                prototypeOfValidatedInstance,
                Symbol.toStringTag,
              );
              if (!_isPrototypeValid) {
                var validatedInstancePrototype = getPrototypeOf(
                  prototypeOfValidatedInstance,
                );
                _isPrototypeValid = isValidIntrinsicNameCheck(
                  validatedInstancePrototype,
                  Symbol.toStringTag,
                );
              }
              instanceValidationResult[validateAndRetrieveClassProperties] =
                _isPrototypeValid.get;
            }
          }
        },
      );
    }
    function validateAndProcessInstance(validateAndProcessIntrinsicProperties) {
      var isValidationSuccessful = false;
      generateInstanceWithValidation(
        instanceValidationResult,
        function (
          validateAndProcessCharacter,
          _validateAndProcessIntrinsicProperties,
        ) {
          if (!isValidationSuccessful) {
            try {
              var validatedCharacter = validateAndProcessCharacter.call(
                validateAndProcessIntrinsicProperties,
              );
              if (
                validatedCharacter === _validateAndProcessIntrinsicProperties
              ) {
                isValidationSuccessful = validatedCharacter;
              }
            } catch {}
          }
        },
      );
      return isValidationSuccessful;
    }
    var _validateAndCreateNewInstance = isValidGeneratorFunction();
    createInstanceWithValidation.exports = function (
      ______validateAndRetrieveIntrinsicProperty,
    ) {
      if (
        _validateAndCreateNewInstance(
          ______validateAndRetrieveIntrinsicProperty,
        )
      ) {
        if (
          !___________________________________conditionalModuleLoader ||
          !(Symbol.toStringTag in ______validateAndRetrieveIntrinsicProperty)
        ) {
          return stringSlicePropertyAccess(
            propertyToStringCheck(______validateAndRetrieveIntrinsicProperty),
            8,
            -1,
          );
        } else {
          return validateAndProcessInstance(
            ______validateAndRetrieveIntrinsicProperty,
          );
        }
      } else {
        return false;
      }
    };
  },
);
var _______validateAndRetrieveIntrinsicProperty = conditionalModuleLoader(
  (__validateAndProcessIntrinsicProperties) => {
    var _______intrinsicPropertyValue = validateAndGetIntrinsicProperty();
    var _initializeConditionalModule = initializeConditionalModule();
    var validatedIntrinsicProperties = validateAndProcessIntrinsicProperty();
    var _isGeneratorFunctionValid = isValidGeneratorFunction();
    function bindValidationHandlerFunction(_validateAndHandleFunction) {
      return _validateAndHandleFunction.call.bind(_validateAndHandleFunction);
    }
    var isBigIntSupported = typeof BigInt !== "undefined";
    var isSymbolSupported = typeof Symbol !== "undefined";
    var createBoundFunction = bindValidationHandlerFunction(
      Object.prototype.toString,
    );
    var createBoundValueOfFunction = bindValidationHandlerFunction(
      Number.prototype.valueOf,
    );
    var createBoundStringValueFunction = bindValidationHandlerFunction(
      String.prototype.valueOf,
    );
    var createBoundBooleanValueFunction = bindValidationHandlerFunction(
      Boolean.prototype.valueOf,
    );
    if (isBigIntSupported) {
      createBoundBigIntValueFunction = bindValidationHandlerFunction(
        BigInt.prototype.valueOf,
      );
    }
    var createBoundBigIntValueFunction;
    if (isSymbolSupported) {
      ________intrinsicPropertyValue = bindValidationHandlerFunction(
        Symbol.prototype.valueOf,
      );
    }
    var ________intrinsicPropertyValue;
    function __validateIntrinsicObject(
      validateAndDetectIntrinsicObject,
      isIntrinsicObjectLoader,
    ) {
      if (typeof validateAndDetectIntrinsicObject != "object") {
        return false;
      }
      try {
        isIntrinsicObjectLoader(validateAndDetectIntrinsicObject);
        return true;
      } catch {
        return false;
      }
    }
    __validateAndProcessIntrinsicProperties.isArgumentsObject =
      _______intrinsicPropertyValue;
    __validateAndProcessIntrinsicProperties.isGeneratorFunction =
      _initializeConditionalModule;
    __validateAndProcessIntrinsicProperties.isTypedArray =
      _isGeneratorFunctionValid;
    function isPromiseOrThenable(isValidIntrinsicObject) {
      return (
        (typeof Promise !== "undefined" &&
          isValidIntrinsicObject instanceof Promise) ||
        (isValidIntrinsicObject !== null &&
          typeof isValidIntrinsicObject == "object" &&
          typeof isValidIntrinsicObject.then == "function" &&
          typeof isValidIntrinsicObject.catch == "function")
      );
    }
    __validateAndProcessIntrinsicProperties.isPromise = isPromiseOrThenable;
    function __isValidIntrinsicObject(validateIntrinsicObjectFunction) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(validateIntrinsicObjectFunction);
      } else {
        return (
          _isGeneratorFunctionValid(validateIntrinsicObjectFunction) ||
          isDataViewSupported(validateIntrinsicObjectFunction)
        );
      }
    }
    __validateAndProcessIntrinsicProperties.isArrayBufferView =
      __isValidIntrinsicObject;
    function isUint8ArrayIntrinsic(getValidIntrinsicNames) {
      return (
        validatedIntrinsicProperties(getValidIntrinsicNames) === "Uint8Array"
      );
    }
    __validateAndProcessIntrinsicProperties.isUint8Array =
      isUint8ArrayIntrinsic;
    function isValidUint8ClampedArray(collectValidFunctionNames) {
      return (
        validatedIntrinsicProperties(collectValidFunctionNames) ===
        "Uint8ClampedArray"
      );
    }
    __validateAndProcessIntrinsicProperties.isUint8ClampedArray =
      isValidUint8ClampedArray;
    function isValidUint16ArrayIntrinsic(____validateIntrinsicName) {
      return (
        validatedIntrinsicProperties(____validateIntrinsicName) ===
        "Uint16Array"
      );
    }
    __validateAndProcessIntrinsicProperties.isUint16Array =
      isValidUint16ArrayIntrinsic;
    function isValidUint32ArrayCheck(isValidFunctionCheck) {
      return (
        validatedIntrinsicProperties(isValidFunctionCheck) === "Uint32Array"
      );
    }
    __validateAndProcessIntrinsicProperties.isUint32Array =
      isValidUint32ArrayCheck;
    function isInt8Array(__validateGeneratorFunction) {
      return (
        validatedIntrinsicProperties(__validateGeneratorFunction) ===
        "Int8Array"
      );
    }
    __validateAndProcessIntrinsicProperties.isInt8Array = isInt8Array;
    function isInt16ArrayDescriptor(checkObjectPropertyDescriptor) {
      return (
        validatedIntrinsicProperties(checkObjectPropertyDescriptor) ===
        "Int16Array"
      );
    }
    __validateAndProcessIntrinsicProperties.isInt16Array =
      isInt16ArrayDescriptor;
    function isValidInt32Array(handleGeneratorFunctionValidation) {
      return (
        validatedIntrinsicProperties(handleGeneratorFunctionValidation) ===
        "Int32Array"
      );
    }
    __validateAndProcessIntrinsicProperties.isInt32Array = isValidInt32Array;
    function isValidFloat32Array(___isValidGeneratorFunction) {
      return (
        validatedIntrinsicProperties(___isValidGeneratorFunction) ===
        "Float32Array"
      );
    }
    __validateAndProcessIntrinsicProperties.isFloat32Array =
      isValidFloat32Array;
    function isFloat64ArrayValidated(isGeneratorFunctionHandler) {
      return (
        validatedIntrinsicProperties(isGeneratorFunctionHandler) ===
        "Float64Array"
      );
    }
    __validateAndProcessIntrinsicProperties.isFloat64Array =
      isFloat64ArrayValidated;
    function isBigInt64ArrayType(getTypeCheckFunction) {
      return (
        validatedIntrinsicProperties(getTypeCheckFunction) === "BigInt64Array"
      );
    }
    __validateAndProcessIntrinsicProperties.isBigInt64Array =
      isBigInt64ArrayType;
    function isBigUint64Array(getArrayIndexOrDefault) {
      return (
        validatedIntrinsicProperties(getArrayIndexOrDefault) ===
        "BigUint64Array"
      );
    }
    __validateAndProcessIntrinsicProperties.isBigUint64Array = isBigUint64Array;
    function isMapInstance(validateGeneratorFunctionIndex) {
      return (
        createBoundFunction(validateGeneratorFunctionIndex) === "[object Map]"
      );
    }
    isMapInstance.working =
      typeof Map !== "undefined" && isMapInstance(new Map());
    function isGeneratorFunctionIndexValid(isValidGeneratorFunctionIndex) {
      if (typeof Map === "undefined") {
        return false;
      } else if (isMapInstance.working) {
        return isMapInstance(isValidGeneratorFunctionIndex);
      } else {
        return isValidGeneratorFunctionIndex instanceof Map;
      }
    }
    __validateAndProcessIntrinsicProperties.isMap =
      isGeneratorFunctionIndexValid;
    function isValidGeneratorFunctionSet(___validateGeneratorFunction) {
      return (
        createBoundFunction(___validateGeneratorFunction) === "[object Set]"
      );
    }
    isValidGeneratorFunctionSet.working =
      typeof Set !== "undefined" && isValidGeneratorFunctionSet(new Set());
    function ____isValidGeneratorFunction(isGeneratorFunctionValidCheck) {
      if (typeof Set === "undefined") {
        return false;
      } else if (isValidGeneratorFunctionSet.working) {
        return isValidGeneratorFunctionSet(isGeneratorFunctionValidCheck);
      } else {
        return isGeneratorFunctionValidCheck instanceof Set;
      }
    }
    __validateAndProcessIntrinsicProperties.isSet =
      ____isValidGeneratorFunction;
    function isFunctionGeneratorCheck(____isGeneratorFunctionCheck) {
      return (
        createBoundFunction(____isGeneratorFunctionCheck) === "[object WeakMap]"
      );
    }
    isFunctionGeneratorCheck.working =
      typeof WeakMap !== "undefined" && isFunctionGeneratorCheck(new WeakMap());
    function _isGeneratorFunctionSupported(____validateGeneratorFunction) {
      if (typeof WeakMap === "undefined") {
        return false;
      } else if (isFunctionGeneratorCheck.working) {
        return isFunctionGeneratorCheck(____validateGeneratorFunction);
      } else {
        return ____validateGeneratorFunction instanceof WeakMap;
      }
    }
    __validateAndProcessIntrinsicProperties.isWeakMap =
      _isGeneratorFunctionSupported;
    function isValidWeakSet(_____validateGeneratorFunction) {
      return (
        createBoundFunction(_____validateGeneratorFunction) ===
        "[object WeakSet]"
      );
    }
    isValidWeakSet.working =
      typeof WeakSet !== "undefined" && isValidWeakSet(new WeakSet());
    function __isGeneratorFunctionValid(_____isGeneratorFunctionCheck) {
      return isValidWeakSet(_____isGeneratorFunctionCheck);
    }
    __validateAndProcessIntrinsicProperties.isWeakSet =
      __isGeneratorFunctionValid;
    function isArrayBufferType(_validateAndProcessIntrinsicProperty) {
      return (
        createBoundFunction(_validateAndProcessIntrinsicProperty) ===
        "[object ArrayBuffer]"
      );
    }
    isArrayBufferType.working =
      typeof ArrayBuffer !== "undefined" &&
      isArrayBufferType(new ArrayBuffer());
    function validateIntrinsicPropertyIsArrayBuffer(
      __validateAndProcessIntrinsicProperty,
    ) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      } else if (isArrayBufferType.working) {
        return isArrayBufferType(__validateAndProcessIntrinsicProperty);
      } else {
        return __validateAndProcessIntrinsicProperty instanceof ArrayBuffer;
      }
    }
    __validateAndProcessIntrinsicProperties.isArrayBuffer =
      validateIntrinsicPropertyIsArrayBuffer;
    function ____isDataView(validateAndProcessIntrinsicPropertyParameters) {
      return (
        createBoundFunction(validateAndProcessIntrinsicPropertyParameters) ===
        "[object DataView]"
      );
    }
    ____isDataView.working =
      typeof ArrayBuffer !== "undefined" &&
      typeof DataView !== "undefined" &&
      ____isDataView(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataViewSupported(_conditionalModuleLoader) {
      if (typeof DataView === "undefined") {
        return false;
      } else if (____isDataView.working) {
        return ____isDataView(_conditionalModuleLoader);
      } else {
        return _conditionalModuleLoader instanceof DataView;
      }
    }
    __validateAndProcessIntrinsicProperties.isDataView = isDataViewSupported;
    var validateAndGetIntrinsicPropertyValue =
      typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : undefined;
    function isSharedArrayBuffer(_validateAndRetrieveClassProperties) {
      return (
        createBoundFunction(_validateAndRetrieveClassProperties) ===
        "[object SharedArrayBuffer]"
      );
    }
    function ___________________________________________________________________validateAndRetrieveIntrinsicProperty(
      validateAndRetrieveIntrinsicProperties,
    ) {
      if (typeof validateAndGetIntrinsicPropertyValue === "undefined") {
        return false;
      } else {
        if (typeof isSharedArrayBuffer.working === "undefined") {
          isSharedArrayBuffer.working = isSharedArrayBuffer(
            new validateAndGetIntrinsicPropertyValue(),
          );
        }
        if (isSharedArrayBuffer.working) {
          return isSharedArrayBuffer(validateAndRetrieveIntrinsicProperties);
        } else {
          return (
            validateAndRetrieveIntrinsicProperties instanceof
            validateAndGetIntrinsicPropertyValue
          );
        }
      }
    }
    __validateAndProcessIntrinsicProperties.isSharedArrayBuffer =
      ___________________________________________________________________validateAndRetrieveIntrinsicProperty;
    function isAsyncFunction(________validateAndRetrieveIntrinsicProperty) {
      return (
        createBoundFunction(________validateAndRetrieveIntrinsicProperty) ===
        "[object AsyncFunction]"
      );
    }
    __validateAndProcessIntrinsicProperties.isAsyncFunction = isAsyncFunction;
    function isMapIterator(getIntrinsicProperty) {
      return (
        createBoundFunction(getIntrinsicProperty) === "[object Map Iterator]"
      );
    }
    __validateAndProcessIntrinsicProperties.isMapIterator = isMapIterator;
    function isSetIterator(___validateAndProcessIntrinsicProperty) {
      return (
        createBoundFunction(___validateAndProcessIntrinsicProperty) ===
        "[object Set Iterator]"
      );
    }
    __validateAndProcessIntrinsicProperties.isSetIterator = isSetIterator;
    function ____isGeneratorFunction(validateAndProcessProviderFunction) {
      return (
        createBoundFunction(validateAndProcessProviderFunction) ===
        "[object Generator]"
      );
    }
    __validateAndProcessIntrinsicProperties.isGeneratorObject =
      ____isGeneratorFunction;
    function isWebAssemblyModule(
      _________validateAndRetrieveIntrinsicProperty,
    ) {
      return (
        createBoundFunction(_________validateAndRetrieveIntrinsicProperty) ===
        "[object WebAssembly.Module]"
      );
    }
    __validateAndProcessIntrinsicProperties.isWebAssemblyCompiledModule =
      isWebAssemblyModule;
    function ______________________________________________________________________validateAndRetrieveIntrinsicProperty(
      __________validateAndRetrieveIntrinsicProperty,
    ) {
      return __validateIntrinsicObject(
        __________validateAndRetrieveIntrinsicProperty,
        createBoundValueOfFunction,
      );
    }
    __validateAndProcessIntrinsicProperties.isNumberObject =
      ______________________________________________________________________validateAndRetrieveIntrinsicProperty;
    function _______________________________________________________________________validateAndRetrieveIntrinsicProperty(
      ___________validateAndRetrieveIntrinsicProperty,
    ) {
      return __validateIntrinsicObject(
        ___________validateAndRetrieveIntrinsicProperty,
        createBoundStringValueFunction,
      );
    }
    __validateAndProcessIntrinsicProperties.isStringObject =
      _______________________________________________________________________validateAndRetrieveIntrinsicProperty;
    function ________________________________________________________________________validateAndRetrieveIntrinsicProperty(
      ____________validateAndRetrieveIntrinsicProperty,
    ) {
      return __validateIntrinsicObject(
        ____________validateAndRetrieveIntrinsicProperty,
        createBoundBooleanValueFunction,
      );
    }
    __validateAndProcessIntrinsicProperties.isBooleanObject =
      ________________________________________________________________________validateAndRetrieveIntrinsicProperty;
    function validateAndRetrieveBigIntProperty(
      _____________validateAndRetrieveIntrinsicProperty,
    ) {
      return (
        isBigIntSupported &&
        __validateIntrinsicObject(
          _____________validateAndRetrieveIntrinsicProperty,
          createBoundBigIntValueFunction,
        )
      );
    }
    __validateAndProcessIntrinsicProperties.isBigIntObject =
      validateAndRetrieveBigIntProperty;
    function _____________________________________________________________________validateAndRetrieveIntrinsicProperty(
      ______________validateAndRetrieveIntrinsicProperty,
    ) {
      return (
        isSymbolSupported &&
        __validateIntrinsicObject(
          ______________validateAndRetrieveIntrinsicProperty,
          ________intrinsicPropertyValue,
        )
      );
    }
    __validateAndProcessIntrinsicProperties.isSymbolObject =
      _____________________________________________________________________validateAndRetrieveIntrinsicProperty;
    function ____________________________________________________________________validateAndRetrieveIntrinsicProperty(
      _______________validateAndRetrieveIntrinsicProperty,
    ) {
      return (
        ______________________________________________________________________validateAndRetrieveIntrinsicProperty(
          _______________validateAndRetrieveIntrinsicProperty,
        ) ||
        _______________________________________________________________________validateAndRetrieveIntrinsicProperty(
          _______________validateAndRetrieveIntrinsicProperty,
        ) ||
        ________________________________________________________________________validateAndRetrieveIntrinsicProperty(
          _______________validateAndRetrieveIntrinsicProperty,
        ) ||
        validateAndRetrieveBigIntProperty(
          _______________validateAndRetrieveIntrinsicProperty,
        ) ||
        _____________________________________________________________________validateAndRetrieveIntrinsicProperty(
          _______________validateAndRetrieveIntrinsicProperty,
        )
      );
    }
    __validateAndProcessIntrinsicProperties.isBoxedPrimitive =
      ____________________________________________________________________validateAndRetrieveIntrinsicProperty;
    function validateAndRetrieveIntrinsicArrayBuffer(
      ________________validateAndRetrieveIntrinsicProperty,
    ) {
      return (
        typeof Uint8Array !== "undefined" &&
        (validateIntrinsicPropertyIsArrayBuffer(
          ________________validateAndRetrieveIntrinsicProperty,
        ) ||
          ___________________________________________________________________validateAndRetrieveIntrinsicProperty(
            ________________validateAndRetrieveIntrinsicProperty,
          ))
      );
    }
    __validateAndProcessIntrinsicProperties.isAnyArrayBuffer =
      validateAndRetrieveIntrinsicArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(
      function (validateAndLoadModule) {
        Object.defineProperty(
          __validateAndProcessIntrinsicProperties,
          validateAndLoadModule,
          {
            enumerable: false,
            value() {
              throw new Error(
                validateAndLoadModule + " is not supported in userland",
              );
            },
          },
        );
      },
    );
  },
);
var isValidArgumentsObject = conditionalModuleLoader(
  (validateTypedArray, isValidTypedArray) => {
    isValidTypedArray.exports = function (isTypedArrayChecker) {
      return (
        isTypedArrayChecker &&
        typeof isTypedArrayChecker == "object" &&
        typeof isTypedArrayChecker.copy == "function" &&
        typeof isTypedArrayChecker.fill == "function" &&
        typeof isTypedArrayChecker.readUInt8 == "function"
      );
    };
  },
);
var validateAndDetectSpecificTypes = conditionalModuleLoader(
  (setupInheritance, _setupInheritance) => {
    if (typeof Object.create == "function") {
      _setupInheritance.exports = function (
        validateAndDetectType,
        isValidPromise,
      ) {
        if (isValidPromise) {
          validateAndDetectType.super_ = isValidPromise;
          validateAndDetectType.prototype = Object.create(
            isValidPromise.prototype,
            {
              constructor: {
                value: validateAndDetectType,
                enumerable: false,
                writable: true,
                configurable: true,
              },
            },
          );
        }
      };
    } else {
      _setupInheritance.exports = function (
        isTypedArrayView,
        _validateAndDetectIntrinsicObject,
      ) {
        if (_validateAndDetectIntrinsicObject) {
          isTypedArrayView.super_ = _validateAndDetectIntrinsicObject;
          function _initializeComponent() {}
          _initializeComponent.prototype =
            _validateAndDetectIntrinsicObject.prototype;
          isTypedArrayView.prototype = new _initializeComponent();
          isTypedArrayView.prototype.constructor = isTypedArrayView;
        }
      };
    }
  },
);
var _isValidPromise = conditionalModuleLoader((StringFormatter) => {
  var getObjectPropertyDescriptors =
    Object.getOwnPropertyDescriptors ||
    function (validateIntrinsicObject) {
      for (
        var intrinsicObjectPropertyDescriptors = Object.keys(
            validateIntrinsicObject,
          ),
          intrinsicObjectPropertyDescriptorMap = {},
          propertyDescriptorIndex = 0;
        propertyDescriptorIndex < intrinsicObjectPropertyDescriptors.length;
        propertyDescriptorIndex++
      ) {
        intrinsicObjectPropertyDescriptorMap[
          intrinsicObjectPropertyDescriptors[propertyDescriptorIndex]
        ] = Object.getOwnPropertyDescriptor(
          validateIntrinsicObject,
          intrinsicObjectPropertyDescriptors[propertyDescriptorIndex],
        );
      }
      return intrinsicObjectPropertyDescriptorMap;
    };
  var formatSpecifierPattern = /%[sdj%]/g;
  StringFormatter.format = function (__isValidPromise) {
    if (!isStringInput(__isValidPromise)) {
      var inspectedArrayBuffers = [];
      for (var argIndex = 0; argIndex < arguments.length; argIndex++) {
        inspectedArrayBuffers.push(
          configureArrayBufferInspection(arguments[argIndex]),
        );
      }
      return inspectedArrayBuffers.join(" ");
    }
    for (
      var argIndex = 1,
        _argumentsArray = arguments,
        argumentsLength = _argumentsArray.length,
        formattedString = String(__isValidPromise).replace(
          formatSpecifierPattern,
          function (_isValidIntrinsicObject) {
            if (_isValidIntrinsicObject === "%%") {
              return "%";
            }
            if (argIndex >= argumentsLength) {
              return _isValidIntrinsicObject;
            }
            switch (_isValidIntrinsicObject) {
              case "%s":
                return String(_argumentsArray[argIndex++]);
              case "%d":
                return Number(_argumentsArray[argIndex++]);
              case "%j":
                try {
                  return JSON.stringify(_argumentsArray[argIndex++]);
                } catch {
                  return "[Circular]";
                }
              default:
                return _isValidIntrinsicObject;
            }
          },
        ),
        currentArgument = _argumentsArray[argIndex];
      argIndex < argumentsLength;
      currentArgument = _argumentsArray[++argIndex]
    ) {
      if (
        isNullValidateAndFormatPromise(currentArgument) ||
        !isObjectAndNotNull(currentArgument)
      ) {
        formattedString += " " + currentArgument;
      } else {
        formattedString +=
          " " + configureArrayBufferInspection(currentArgument);
      }
    }
    return formattedString;
  };
  StringFormatter.deprecate = function (
    validateArrayType,
    getArrayTypeCheckFunction,
  ) {
    if (typeof process !== "undefined" && process.noDeprecation === true) {
      return validateArrayType;
    }
    if (typeof process === "undefined") {
      return function () {
        return StringFormatter.deprecate(
          validateArrayType,
          getArrayTypeCheckFunction,
        ).apply(this, arguments);
      };
    }
    var hasDeprecationWarningBeenLogged = false;
    function logDeprecationWarningAndValidateArrayType() {
      if (!hasDeprecationWarningBeenLogged) {
        if (process.throwDeprecation) {
          throw new Error(getArrayTypeCheckFunction);
        }
        if (process.traceDeprecation) {
          console.trace(getArrayTypeCheckFunction);
        } else {
          console.error(getArrayTypeCheckFunction);
        }
        hasDeprecationWarningBeenLogged = true;
      }
      return validateArrayType.apply(this, arguments);
    }
    return logDeprecationWarningAndValidateArrayType;
  };
  var _getObjectPropertyDescriptors = {};
  var __getObjectPropertyDescriptors = /^$/;
  ___getObjectPropertyDescriptors = "false";
  ___getObjectPropertyDescriptors = ___getObjectPropertyDescriptors
    .replace(/[|\\{}()[\]^$+?.]/g, "\\$&")
    .replace(/\*/g, ".*")
    .replace(/,/g, "$|^")
    .toUpperCase();
  __getObjectPropertyDescriptors = new RegExp(
    "^" + ___getObjectPropertyDescriptors + "$",
    "i",
  );
  var ___getObjectPropertyDescriptors;
  StringFormatter.debuglog = function (validateSetInstance) {
    validateSetInstance = validateSetInstance.toUpperCase();
    if (!_getObjectPropertyDescriptors[validateSetInstance]) {
      if (__getObjectPropertyDescriptors.test(validateSetInstance)) {
        var currentProcessId = process.pid;
        _getObjectPropertyDescriptors[validateSetInstance] = function () {
          var _formattedString = StringFormatter.format.apply(
            StringFormatter,
            arguments,
          );
          console.error(
            "%s %d: %s",
            validateSetInstance,
            currentProcessId,
            _formattedString,
          );
        };
      } else {
        _getObjectPropertyDescriptors[validateSetInstance] = function () {};
      }
    }
    return _getObjectPropertyDescriptors[validateSetInstance];
  };
  function configureArrayBufferInspection(isValidWeakMap, _isValidWeakMap) {
    var arrayBufferInspectionConfig = {
      seen: [],
      stylize: isDataViewValid,
    };
    if (arguments.length >= 3) {
      arrayBufferInspectionConfig.depth = arguments[2];
    }
    if (arguments.length >= 4) {
      arrayBufferInspectionConfig.colors = arguments[3];
    }
    if (isBoolean(_isValidWeakMap)) {
      arrayBufferInspectionConfig.showHidden = _isValidWeakMap;
    } else if (_isValidWeakMap) {
      StringFormatter._extend(arrayBufferInspectionConfig, _isValidWeakMap);
    }
    if (isFormatStringUndefined(arrayBufferInspectionConfig.showHidden)) {
      arrayBufferInspectionConfig.showHidden = false;
    }
    if (isFormatStringUndefined(arrayBufferInspectionConfig.depth)) {
      arrayBufferInspectionConfig.depth = 2;
    }
    if (isFormatStringUndefined(arrayBufferInspectionConfig.colors)) {
      arrayBufferInspectionConfig.colors = false;
    }
    if (isFormatStringUndefined(arrayBufferInspectionConfig.customInspect)) {
      arrayBufferInspectionConfig.customInspect = true;
    }
    if (arrayBufferInspectionConfig.colors) {
      arrayBufferInspectionConfig.stylize = formatDataViewWithColor;
    }
    return inspectArrayBuffer(
      arrayBufferInspectionConfig,
      isValidWeakMap,
      arrayBufferInspectionConfig.depth,
    );
  }
  StringFormatter.inspect = configureArrayBufferInspection;
  configureArrayBufferInspection.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39],
  };
  configureArrayBufferInspection.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    regexp: "red",
  };
  function formatDataViewWithColor(isDataView, isWeakSet) {
    var colorStyleIndex = configureArrayBufferInspection.styles[isWeakSet];
    if (colorStyleIndex) {
      return (
        "[" +
        configureArrayBufferInspection.colors[colorStyleIndex][0] +
        "m" +
        isDataView +
        "[" +
        configureArrayBufferInspection.colors[colorStyleIndex][1] +
        "m"
      );
    } else {
      return isDataView;
    }
  }
  function isDataViewValid(_isDataView, processArrayBufferValidation) {
    return _isDataView;
  }
  function validateAndProcessBuffers(validateAndCheckArrayBuffer) {
    var validatedArrayBufferMap = {};
    validateAndCheckArrayBuffer.forEach(
      function (validateAndProcessArrayBuffer, __isDataView) {
        validatedArrayBufferMap[validateAndProcessArrayBuffer] = true;
      },
    );
    return validatedArrayBufferMap;
  }
  function inspectArrayBuffer(
    isValidDataView,
    isArrayBufferProperty,
    ___isDataView,
  ) {
    if (
      isValidDataView.customInspect &&
      isArrayBufferProperty &&
      isFunction(isArrayBufferProperty.inspect) &&
      isArrayBufferProperty.inspect !== StringFormatter.inspect &&
      (!isArrayBufferProperty.constructor ||
        isArrayBufferProperty.constructor.prototype !== isArrayBufferProperty)
    ) {
      var __arrayBufferInspectionResult = isArrayBufferProperty.inspect(
        ___isDataView,
        isValidDataView,
      );
      if (!isStringInput(__arrayBufferInspectionResult)) {
        __arrayBufferInspectionResult = inspectArrayBuffer(
          isValidDataView,
          __arrayBufferInspectionResult,
          ___isDataView,
        );
      }
      return __arrayBufferInspectionResult;
    }
    var arrayBufferInspectionResult = stylizeGeneratorObjectType(
      isValidDataView,
      isArrayBufferProperty,
    );
    if (arrayBufferInspectionResult) {
      return arrayBufferInspectionResult;
    }
    var arrayBufferKeys = Object.keys(isArrayBufferProperty);
    var processedArrayBufferKeys = validateAndProcessBuffers(arrayBufferKeys);
    if (isValidDataView.showHidden) {
      arrayBufferKeys = Object.getOwnPropertyNames(isArrayBufferProperty);
    }
    if (
      isFormattedStringErrorCheck(isArrayBufferProperty) &&
      (arrayBufferKeys.indexOf("message") >= 0 ||
        arrayBufferKeys.indexOf("description") >= 0)
    ) {
      return formatErrorToString(isArrayBufferProperty);
    }
    if (arrayBufferKeys.length === 0) {
      if (isFunction(isArrayBufferProperty)) {
        var arrayBufferPropertyName = isArrayBufferProperty.name
          ? ": " + isArrayBufferProperty.name
          : "";
        return isValidDataView.stylize(
          "[Function" + arrayBufferPropertyName + "]",
          "special",
        );
      }
      if (isValidRegExpFormat(isArrayBufferProperty)) {
        return isValidDataView.stylize(
          RegExp.prototype.toString.call(isArrayBufferProperty),
          "regexp",
        );
      }
      if (isValidDateFormat(isArrayBufferProperty)) {
        return isValidDataView.stylize(
          Date.prototype.toString.call(isArrayBufferProperty),
          "date",
        );
      }
      if (isFormattedStringErrorCheck(isArrayBufferProperty)) {
        return formatErrorToString(isArrayBufferProperty);
      }
    }
    var _arrayBufferInspectionResult = "";
    var inspectArrayBufferProperty = false;
    var _inspectArrayBufferProperty = ["{", "}"];
    if (isConditionalModulePromiseLoaderArray(isArrayBufferProperty)) {
      inspectArrayBufferProperty = true;
      _inspectArrayBufferProperty = ["[", "]"];
    }
    if (isFunction(isArrayBufferProperty)) {
      var _arrayBufferPropertyName = isArrayBufferProperty.name
        ? ": " + isArrayBufferProperty.name
        : "";
      _arrayBufferInspectionResult =
        " [Function" + _arrayBufferPropertyName + "]";
    }
    if (isValidRegExpFormat(isArrayBufferProperty)) {
      _arrayBufferInspectionResult =
        " " + RegExp.prototype.toString.call(isArrayBufferProperty);
    }
    if (isValidDateFormat(isArrayBufferProperty)) {
      _arrayBufferInspectionResult =
        " " + Date.prototype.toUTCString.call(isArrayBufferProperty);
    }
    if (isFormattedStringErrorCheck(isArrayBufferProperty)) {
      _arrayBufferInspectionResult =
        " " + formatErrorToString(isArrayBufferProperty);
    }
    if (
      arrayBufferKeys.length === 0 &&
      (!inspectArrayBufferProperty || isArrayBufferProperty.length == 0)
    ) {
      return (
        _inspectArrayBufferProperty[0] +
        _arrayBufferInspectionResult +
        _inspectArrayBufferProperty[1]
      );
    }
    if (___isDataView < 0) {
      if (isValidRegExpFormat(isArrayBufferProperty)) {
        return isValidDataView.stylize(
          RegExp.prototype.toString.call(isArrayBufferProperty),
          "regexp",
        );
      } else {
        return isValidDataView.stylize("[Object]", "special");
      }
    }
    isValidDataView.seen.push(isArrayBufferProperty);
    var inspectArrayBufferKeys;
    if (inspectArrayBufferProperty) {
      inspectArrayBufferKeys = retrievePropertyDescriptors(
        isValidDataView,
        isArrayBufferProperty,
        ___isDataView,
        processedArrayBufferKeys,
        arrayBufferKeys,
      );
    } else {
      inspectArrayBufferKeys = arrayBufferKeys.map(
        function (isSetIteratorFunction) {
          return validateAndRetrievePropertyDescriptor(
            isValidDataView,
            isArrayBufferProperty,
            ___isDataView,
            processedArrayBufferKeys,
            isSetIteratorFunction,
            inspectArrayBufferProperty,
          );
        },
      );
    }
    isValidDataView.seen.pop();
    return validatePromiseConfiguration(
      inspectArrayBufferKeys,
      _arrayBufferInspectionResult,
      _inspectArrayBufferProperty,
    );
  }
  function stylizeGeneratorObjectType(_isGeneratorFunction, isGeneratorObject) {
    if (isFormatStringUndefined(isGeneratorObject)) {
      return _isGeneratorFunction.stylize("undefined", "undefined");
    }
    if (isStringInput(isGeneratorObject)) {
      var serializedIsGeneratorObject =
        "'" +
        JSON.stringify(isGeneratorObject)
          .replace(/^"|"$/g, "")
          .replace(/'/g, "\\'")
          .replace(/\\"/g, '"') +
        "'";
      return _isGeneratorFunction.stylize(
        serializedIsGeneratorObject,
        "string",
      );
    }
    if (isNumberValidationModule(isGeneratorObject)) {
      return _isGeneratorFunction.stylize("" + isGeneratorObject, "number");
    }
    if (isBoolean(isGeneratorObject)) {
      return _isGeneratorFunction.stylize("" + isGeneratorObject, "boolean");
    }
    if (isNullValidateAndFormatPromise(isGeneratorObject)) {
      return _isGeneratorFunction.stylize("null", "null");
    }
  }
  function formatErrorToString(
    _________________validateAndRetrieveIntrinsicProperty,
  ) {
    return (
      "[" +
      Error.prototype.toString.call(
        _________________validateAndRetrieveIntrinsicProperty,
      ) +
      "]"
    );
  }
  function retrievePropertyDescriptors(
    isWrappedPrimitiveObject,
    isBoxedPrimitiveType,
    isBoxedPrimitive,
    _isBoxedPrimitive,
    __isBoxedPrimitive,
  ) {
    var propertyDescriptors = [];
    for (
      var __________currentIndex = 0,
        totalBoxedPrimitiveTypes = isBoxedPrimitiveType.length;
      __________currentIndex < totalBoxedPrimitiveTypes;
      ++__________currentIndex
    ) {
      if (
        isDebugLoggerSet(isBoxedPrimitiveType, String(__________currentIndex))
      ) {
        propertyDescriptors.push(
          validateAndRetrievePropertyDescriptor(
            isWrappedPrimitiveObject,
            isBoxedPrimitiveType,
            isBoxedPrimitive,
            _isBoxedPrimitive,
            String(__________currentIndex),
            true,
          ),
        );
      } else {
        propertyDescriptors.push("");
      }
    }
    __isBoxedPrimitive.forEach(
      function (__________________validateAndRetrieveIntrinsicProperty) {
        if (
          !__________________validateAndRetrieveIntrinsicProperty.match(/^\d+$/)
        ) {
          propertyDescriptors.push(
            validateAndRetrievePropertyDescriptor(
              isWrappedPrimitiveObject,
              isBoxedPrimitiveType,
              isBoxedPrimitive,
              _isBoxedPrimitive,
              __________________validateAndRetrieveIntrinsicProperty,
              true,
            ),
          );
        }
      },
    );
    return propertyDescriptors;
  }
  function validateAndRetrievePropertyDescriptor(
    ___________________validateAndRetrieveIntrinsicProperty,
    ____________________validateAndRetrieveIntrinsicProperty,
    _____________________validateAndRetrieveIntrinsicProperty,
    ______________________validateAndRetrieveIntrinsicProperty,
    _______________________validateAndRetrieveIntrinsicProperty,
    _validateIntrinsicProperty,
  ) {
    var __propertyDescriptor;
    var propertyDescriptorInfo;
    var ___propertyDescriptor;
    ___propertyDescriptor = Object.getOwnPropertyDescriptor(
      ____________________validateAndRetrieveIntrinsicProperty,
      _______________________validateAndRetrieveIntrinsicProperty,
    ) || {
      value:
        ____________________validateAndRetrieveIntrinsicProperty[
          _______________________validateAndRetrieveIntrinsicProperty
        ],
    };
    if (___propertyDescriptor.get) {
      if (___propertyDescriptor.set) {
        propertyDescriptorInfo =
          ___________________validateAndRetrieveIntrinsicProperty.stylize(
            "[Getter/Setter]",
            "special",
          );
      } else {
        propertyDescriptorInfo =
          ___________________validateAndRetrieveIntrinsicProperty.stylize(
            "[Getter]",
            "special",
          );
      }
    } else if (___propertyDescriptor.set) {
      propertyDescriptorInfo =
        ___________________validateAndRetrieveIntrinsicProperty.stylize(
          "[Setter]",
          "special",
        );
    }
    if (
      !isDebugLoggerSet(
        ______________________validateAndRetrieveIntrinsicProperty,
        _______________________validateAndRetrieveIntrinsicProperty,
      )
    ) {
      __propertyDescriptor =
        "[" + _______________________validateAndRetrieveIntrinsicProperty + "]";
    }
    if (!propertyDescriptorInfo) {
      if (
        ___________________validateAndRetrieveIntrinsicProperty.seen.indexOf(
          ___propertyDescriptor.value,
        ) < 0
      ) {
        if (
          isNullValidateAndFormatPromise(
            _____________________validateAndRetrieveIntrinsicProperty,
          )
        ) {
          propertyDescriptorInfo = inspectArrayBuffer(
            ___________________validateAndRetrieveIntrinsicProperty,
            ___propertyDescriptor.value,
            null,
          );
        } else {
          propertyDescriptorInfo = inspectArrayBuffer(
            ___________________validateAndRetrieveIntrinsicProperty,
            ___propertyDescriptor.value,
            _____________________validateAndRetrieveIntrinsicProperty - 1,
          );
        }
        if (propertyDescriptorInfo.indexOf("\n") > -1) {
          if (_validateIntrinsicProperty) {
            propertyDescriptorInfo = propertyDescriptorInfo
              .split("\n")
              .map(function (__conditionalModuleLoader) {
                return "  " + __conditionalModuleLoader;
              })
              .join("\n")
              .substr(2);
          } else {
            propertyDescriptorInfo =
              "\n" +
              propertyDescriptorInfo
                .split("\n")
                .map(function (_validateAndDetectType) {
                  return "   " + _validateAndDetectType;
                })
                .join("\n");
          }
        }
      } else {
        propertyDescriptorInfo =
          ___________________validateAndRetrieveIntrinsicProperty.stylize(
            "[Circular]",
            "special",
          );
      }
    }
    if (isFormatStringUndefined(__propertyDescriptor)) {
      if (
        _validateIntrinsicProperty &&
        _______________________validateAndRetrieveIntrinsicProperty.match(
          /^\d+$/,
        )
      ) {
        return propertyDescriptorInfo;
      }
      __propertyDescriptor = JSON.stringify(
        "" + _______________________validateAndRetrieveIntrinsicProperty,
      );
      if (__propertyDescriptor.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        __propertyDescriptor = __propertyDescriptor.substr(
          1,
          __propertyDescriptor.length - 2,
        );
        __propertyDescriptor =
          ___________________validateAndRetrieveIntrinsicProperty.stylize(
            __propertyDescriptor,
            "name",
          );
      } else {
        __propertyDescriptor = __propertyDescriptor
          .replace(/'/g, "\\'")
          .replace(/\\"/g, '"')
          .replace(/(^"|"$)/g, "'");
        __propertyDescriptor =
          ___________________validateAndRetrieveIntrinsicProperty.stylize(
            __propertyDescriptor,
            "string",
          );
      }
    }
    return __propertyDescriptor + ": " + propertyDescriptorInfo;
  }
  function validatePromiseConfiguration(
    configurePromiseValidation,
    conditionalPromiseValidator,
    __validateAndDetectIntrinsicObject,
  ) {
    var lineCount = 0;
    var totalCharacterCount = configurePromiseValidation.reduce(function (
      validateAndDetectTypedArrayView,
      isValidTypedArrayView,
    ) {
      lineCount++;
      if (isValidTypedArrayView.indexOf("\n") >= 0) {
        lineCount++;
      }
      return (
        validateAndDetectTypedArrayView +
        isValidTypedArrayView.replace(/\u001b\[\d\d?m/g, "").length +
        1
      );
    }, 0);
    if (totalCharacterCount > 60) {
      return (
        __validateAndDetectIntrinsicObject[0] +
        (conditionalPromiseValidator === ""
          ? ""
          : conditionalPromiseValidator + "\n ") +
        " " +
        configurePromiseValidation.join(",\n  ") +
        " " +
        __validateAndDetectIntrinsicObject[1]
      );
    } else {
      return (
        __validateAndDetectIntrinsicObject[0] +
        conditionalPromiseValidator +
        " " +
        configurePromiseValidation.join(", ") +
        " " +
        __validateAndDetectIntrinsicObject[1]
      );
    }
  }
  StringFormatter.types = _______validateAndRetrieveIntrinsicProperty();
  function isConditionalModulePromiseLoaderArray(
    conditionalModulePromiseLoader,
  ) {
    return Array.isArray(conditionalModulePromiseLoader);
  }
  StringFormatter.isArray = isConditionalModulePromiseLoaderArray;
  function isBoolean(conditionalPromiseValidation) {
    return typeof conditionalPromiseValidation == "boolean";
  }
  StringFormatter.isBoolean = isBoolean;
  function isNullValidateAndFormatPromise(validateAndFormatPromise) {
    return validateAndFormatPromise === null;
  }
  StringFormatter.isNull = isNullValidateAndFormatPromise;
  function _isPromiseValidationFormatterNull(promiseValidationFormatter) {
    return promiseValidationFormatter == null;
  }
  StringFormatter.isNullOrUndefined = _isPromiseValidationFormatterNull;
  function isNumberValidationModule(promiseValidationModule) {
    return typeof promiseValidationModule == "number";
  }
  StringFormatter.isNumber = isNumberValidationModule;
  function isStringInput(getPropertyDescriptorsAndFormat) {
    return typeof getPropertyDescriptorsAndFormat == "string";
  }
  StringFormatter.isString = isStringInput;
  function isSymbolType(getPropertyDescriptors) {
    return typeof getPropertyDescriptors == "symbol";
  }
  StringFormatter.isSymbol = isSymbolType;
  function isFormatStringUndefined(formatStringWithArguments) {
    return formatStringWithArguments === undefined;
  }
  StringFormatter.isUndefined = isFormatStringUndefined;
  function isValidRegExpFormat(formatStringWithArgs) {
    return (
      isObjectAndNotNull(formatStringWithArgs) &&
      getObjectTypeString(formatStringWithArgs) === "[object RegExp]"
    );
  }
  StringFormatter.isRegExp = isValidRegExpFormat;
  StringFormatter.types.isRegExp = isValidRegExpFormat;
  function isObjectAndNotNull(generateFormattedString) {
    return (
      typeof generateFormattedString == "object" &&
      generateFormattedString !== null
    );
  }
  StringFormatter.isObject = isObjectAndNotNull;
  function isValidDateFormat(_formatStringWithArguments) {
    return (
      isObjectAndNotNull(_formatStringWithArguments) &&
      getObjectTypeString(_formatStringWithArguments) === "[object Date]"
    );
  }
  StringFormatter.isDate = isValidDateFormat;
  StringFormatter.types.isDate = isValidDateFormat;
  function isFormattedStringErrorCheck(_generateFormattedString) {
    return (
      isObjectAndNotNull(_generateFormattedString) &&
      (getObjectTypeString(_generateFormattedString) === "[object Error]" ||
        _generateFormattedString instanceof Error)
    );
  }
  StringFormatter.isError = isFormattedStringErrorCheck;
  StringFormatter.types.isNativeError = isFormattedStringErrorCheck;
  function isFunction(formatAndValidateArguments) {
    return typeof formatAndValidateArguments == "function";
  }
  StringFormatter.isFunction = isFunction;
  function isPrimitive(formatArgumentsAndHandleTypes) {
    return (
      formatArgumentsAndHandleTypes === null ||
      typeof formatArgumentsAndHandleTypes == "boolean" ||
      typeof formatArgumentsAndHandleTypes == "number" ||
      typeof formatArgumentsAndHandleTypes == "string" ||
      typeof formatArgumentsAndHandleTypes == "symbol" ||
      typeof formatArgumentsAndHandleTypes === "undefined"
    );
  }
  StringFormatter.isPrimitive = isPrimitive;
  StringFormatter.isBuffer = isValidArgumentsObject();
  function getObjectTypeString(deprecateValidation) {
    return Object.prototype.toString.call(deprecateValidation);
  }
  function formatArrayTypeValidator(deprecatedArrayTypeValidator) {
    if (deprecatedArrayTypeValidator < 10) {
      return "0" + deprecatedArrayTypeValidator.toString(10);
    } else {
      return deprecatedArrayTypeValidator.toString(10);
    }
  }
  var ____getObjectPropertyDescriptors = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
  ];
  function formatCurrentDateTime() {
    var currentDateTime = new Date();
    var formattedTime = [
      formatArrayTypeValidator(currentDateTime.getHours()),
      formatArrayTypeValidator(currentDateTime.getMinutes()),
      formatArrayTypeValidator(currentDateTime.getSeconds()),
    ].join(":");
    return [
      currentDateTime.getDate(),
      ____getObjectPropertyDescriptors[currentDateTime.getMonth()],
      formattedTime,
    ].join(" ");
  }
  StringFormatter.log = function () {
    console.log(
      "%s - %s",
      formatCurrentDateTime(),
      StringFormatter.format.apply(StringFormatter, arguments),
    );
  };
  StringFormatter.inherits = validateAndDetectSpecificTypes();
  StringFormatter._extend = function (
    getArrayTypeValidationFunction,
    deprecateTypeValidation,
  ) {
    if (
      !deprecateTypeValidation ||
      !isObjectAndNotNull(deprecateTypeValidation)
    ) {
      return getArrayTypeValidationFunction;
    }
    var deprecatedValidationKeys = Object.keys(deprecateTypeValidation);
    for (
      var validationKeyIndex = deprecatedValidationKeys.length;
      validationKeyIndex--;

    ) {
      getArrayTypeValidationFunction[
        deprecatedValidationKeys[validationKeyIndex]
      ] = deprecateTypeValidation[deprecatedValidationKeys[validationKeyIndex]];
    }
    return getArrayTypeValidationFunction;
  };
  function isDebugLoggerSet(logDebugMessageForSetInstance, createDebugLogger) {
    return Object.prototype.hasOwnProperty.call(
      logDebugMessageForSetInstance,
      createDebugLogger,
    );
  }
  var objectPropertyDescriptorGetter =
    typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : undefined;
  StringFormatter.promisify = function (debugLogForInstance) {
    if (typeof debugLogForInstance != "function") {
      throw new TypeError('The "original" argument must be of type Function');
    }
    if (
      objectPropertyDescriptorGetter &&
      debugLogForInstance[objectPropertyDescriptorGetter]
    ) {
      var logWithCompletionCallback =
        debugLogForInstance[objectPropertyDescriptorGetter];
      if (typeof logWithCompletionCallback != "function") {
        throw new TypeError(
          'The "util.promisify.custom" argument must be of type Function',
        );
      }
      Object.defineProperty(
        logWithCompletionCallback,
        objectPropertyDescriptorGetter,
        {
          value: logWithCompletionCallback,
          enumerable: false,
          writable: false,
          configurable: true,
        },
      );
      return logWithCompletionCallback;
    }
    function logWithCompletionCallback() {
      var resolveLogCallback;
      var errorCallbackFunction;
      var logPromise = new Promise(function (
        logValidatedSetInstance,
        validateSetInstanceLogger,
      ) {
        resolveLogCallback = logValidatedSetInstance;
        errorCallbackFunction = validateSetInstanceLogger;
      });
      var argumentsArrayForLogging = [];
      for (
        var ___argumentIndex = 0;
        ___argumentIndex < arguments.length;
        ___argumentIndex++
      ) {
        argumentsArrayForLogging.push(arguments[___argumentIndex]);
      }
      argumentsArrayForLogging.push(
        function (validateAndInspectWeakMap, inspectObject) {
          if (validateAndInspectWeakMap) {
            errorCallbackFunction(validateAndInspectWeakMap);
          } else {
            resolveLogCallback(inspectObject);
          }
        },
      );
      try {
        debugLogForInstance.apply(this, argumentsArrayForLogging);
      } catch (errorObject) {
        errorCallbackFunction(errorObject);
      }
      return logPromise;
    }
    Object.setPrototypeOf(
      logWithCompletionCallback,
      Object.getPrototypeOf(debugLogForInstance),
    );
    if (objectPropertyDescriptorGetter) {
      Object.defineProperty(
        logWithCompletionCallback,
        objectPropertyDescriptorGetter,
        {
          value: logWithCompletionCallback,
          enumerable: false,
          writable: false,
          configurable: true,
        },
      );
    }
    return Object.defineProperties(
      logWithCompletionCallback,
      getObjectPropertyDescriptors(debugLogForInstance),
    );
  };
  StringFormatter.promisify.custom = objectPropertyDescriptorGetter;
  function handleCustomStyle(inspectCustomStyle, customStylizeFunction) {
    if (!inspectCustomStyle) {
      var rejectionError = new Error("Promise was rejected with a falsy value");
      rejectionError.reason = inspectCustomStyle;
      inspectCustomStyle = rejectionError;
    }
    return customStylizeFunction(inspectCustomStyle);
  }
  function createStyledOutputHandler(getStyledOutput) {
    if (typeof getStyledOutput != "function") {
      throw new TypeError('The "original" argument must be of type Function');
    }
    function executeWithStyledOutput() {
      var __argumentsArray = [];
      for (
        var ___argumentsCount = 0;
        ___argumentsCount < arguments.length;
        ___argumentsCount++
      ) {
        __argumentsArray.push(arguments[___argumentsCount]);
      }
      var __callbackFunction = __argumentsArray.pop();
      if (typeof __callbackFunction != "function") {
        throw new TypeError("The last argument must be of type Function");
      }
      var ___context = this;
      function invokeCallbackFunction() {
        return __callbackFunction.apply(___context, arguments);
      }
      getStyledOutput.apply(this, __argumentsArray).then(
        function (getStyledString) {
          process.nextTick(
            invokeCallbackFunction.bind(null, null, getStyledString),
          );
        },
        function (inspectDataView) {
          process.nextTick(
            handleCustomStyle.bind(
              null,
              inspectDataView,
              invokeCallbackFunction,
            ),
          );
        },
      );
    }
    Object.setPrototypeOf(
      executeWithStyledOutput,
      Object.getPrototypeOf(getStyledOutput),
    );
    Object.defineProperties(
      executeWithStyledOutput,
      getObjectPropertyDescriptors(getStyledOutput),
    );
    return executeWithStyledOutput;
  }
  StringFormatter.callbackify = createStyledOutputHandler;
});
var processArrayBufferKeys = conditionalModuleLoader(
  (validateAndExtractArrayBuffer, getValidatedArrayBuffer) => {
    getValidatedArrayBuffer.exports = function (
      _processArrayBufferValidation,
      isArrayBufferValid,
    ) {
      var paddedArrayBuffer = "000000000" + _processArrayBufferValidation;
      return paddedArrayBuffer.substr(
        paddedArrayBuffer.length - isArrayBufferValid,
      );
    };
  },
);
var validateAndInspectDataView = conditionalModuleLoader(
  (_________processData, processMimeTypeLengthAndUserAgent) => {
    var ___globalContext =
      typeof ___globalContext === "undefined" ? globalThis : ___globalContext;
    var generateEncodedKey = processArrayBufferKeys();
    var ____globalContext =
      typeof ___globalContext == "object" ? ___globalContext : self;
    var globalObjectKeysCount = Object.keys(____globalContext).length;
    var _mimeTypesCount = navigator.mimeTypes ? navigator.mimeTypes.length : 0;
    var generateEncodedKeyByUserAgentAndMimeTypes = generateEncodedKey(
      (_mimeTypesCount + navigator.userAgent.length).toString(36) +
        globalObjectKeysCount.toString(36),
      4,
    );
    processMimeTypeLengthAndUserAgent.exports = function () {
      return generateEncodedKeyByUserAgentAndMimeTypes;
    };
  },
);
var isArrayBufferPropertyDescription = conditionalModuleLoader(
  (_generateRandomValue, __generateRandomValue) => {
    var randomValueGenerator =
      typeof randomValueGenerator === "undefined"
        ? globalThis
        : randomValueGenerator;
    var generateRandomNumber;
    var isCryptoSupported =
      (typeof randomValueGenerator !== "undefined" &&
        (randomValueGenerator.crypto || randomValueGenerator.msCrypto)) ||
      (typeof self !== "undefined" && self.crypto);
    if (isCryptoSupported) {
      _maxRandomValue = Math.pow(2, 32) - 1;
      generateRandomNumber = function () {
        return Math.abs(
          isCryptoSupported.getRandomValues(new Uint32Array(1))[0] /
            _maxRandomValue,
        );
      };
    } else {
      generateRandomNumber = Math.random;
    }
    var _maxRandomValue;
    __generateRandomValue.exports = generateRandomNumber;
  },
);
var getStylizedRepresentation = conditionalModuleLoader(
  (generateUniqueSlug, generateUniqueSlugWithTimestamp) => {
    var validateAndGenerateUniqueSlug = validateAndInspectDataView();
    var processSlugGeneration = processArrayBufferKeys();
    var isArrayBufferDescription = isArrayBufferPropertyDescription();
    var currentSlugIndex = 0;
    var maxSlugLength = 4;
    var _base36 = 36;
    var maxSlugIndex = Math.pow(_base36, maxSlugLength);
    function generateSlugFromBuffer() {
      return processSlugGeneration(
        ((isArrayBufferDescription() * maxSlugIndex) << 0).toString(_base36),
        maxSlugLength,
      );
    }
    function getNextSlugIndex() {
      if (currentSlugIndex < maxSlugIndex) {
        currentSlugIndex = currentSlugIndex;
      } else {
        currentSlugIndex = 0;
      }
      currentSlugIndex++;
      return currentSlugIndex - 1;
    }
    function _generateUniqueSlug() {
      var slugIdentifier = "c";
      var uniqueTimestamp = new Date().getTime().toString(_base36);
      var generatedUniqueSlug = processSlugGeneration(
        getNextSlugIndex().toString(_base36),
        maxSlugLength,
      );
      var uniqueSlugValidation = validateAndGenerateUniqueSlug();
      var combinedHash = generateSlugFromBuffer() + generateSlugFromBuffer();
      return (
        slugIdentifier +
        uniqueTimestamp +
        generatedUniqueSlug +
        uniqueSlugValidation +
        combinedHash
      );
    }
    _generateUniqueSlug.slug = function () {
      var timestampSlugPart = new Date().getTime().toString(36);
      var _uniqueIdentifierPart = getNextSlugIndex().toString(36).slice(-4);
      var uniqueSlugCharacterPart =
        validateAndGenerateUniqueSlug().slice(0, 1) +
        validateAndGenerateUniqueSlug().slice(-1);
      var lastTwoCharacters = generateSlugFromBuffer().slice(-2);
      return (
        timestampSlugPart.slice(-2) +
        _uniqueIdentifierPart +
        uniqueSlugCharacterPart +
        lastTwoCharacters
      );
    };
    _generateUniqueSlug.isCuid = function (_isArrayBufferProperty) {
      if (typeof _isArrayBufferProperty != "string") {
        return false;
      } else {
        return !!_isArrayBufferProperty.startsWith("c");
      }
    };
    _generateUniqueSlug.isSlug = function (isValidDataViewFormatter) {
      if (typeof isValidDataViewFormatter != "string") {
        return false;
      }
      var dataFormatterLength = isValidDataViewFormatter.length;
      return dataFormatterLength >= 7 && dataFormatterLength <= 10;
    };
    _generateUniqueSlug.fingerprint = validateAndGenerateUniqueSlug;
    generateUniqueSlugWithTimestamp.exports = _generateUniqueSlug;
  },
);
var generateDataViewRepresentation = conditionalModuleLoader(
  (Base64Handler) => {
    Base64Handler.byteLength = calculateBase64Output;
    Base64Handler.toByteArray = decodeBase64ToTypedArray;
    Base64Handler.fromByteArray = base64EncodeChunked;
    var base64CharacterSet = [];
    var base64DecodeTable = [];
    var TypedArray = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var _base64CharacterSet =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    base64CharacterIndex = 0;
    base64CharacterSetLength = _base64CharacterSet.length;
    for (
      ;
      base64CharacterIndex < base64CharacterSetLength;
      ++base64CharacterIndex
    ) {
      base64CharacterSet[base64CharacterIndex] =
        _base64CharacterSet[base64CharacterIndex];
      base64DecodeTable[_base64CharacterSet.charCodeAt(base64CharacterIndex)] =
        base64CharacterIndex;
    }
    var base64CharacterIndex;
    var base64CharacterSetLength;
    base64DecodeTable["-".charCodeAt(0)] = 62;
    base64DecodeTable["_".charCodeAt(0)] = 63;
    function validateBase64Length(processDataView) {
      var processDataViewLength = processDataView.length;
      if (processDataViewLength % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var lastEqualSignIndex = processDataView.indexOf("=");
      if (lastEqualSignIndex === -1) {
        lastEqualSignIndex = processDataViewLength;
      }
      var _paddingNeeded =
        lastEqualSignIndex === processDataViewLength
          ? 0
          : 4 - (lastEqualSignIndex % 4);
      return [lastEqualSignIndex, _paddingNeeded];
    }
    function calculateBase64Output(
      ________________________validateAndRetrieveIntrinsicProperty,
    ) {
      var base64Output = validateBase64Length(
        ________________________validateAndRetrieveIntrinsicProperty,
      );
      var base64ValidLength = base64Output[0];
      var base64DecodedData = base64Output[1];
      return (
        ((base64ValidLength + base64DecodedData) * 3) / 4 - base64DecodedData
      );
    }
    function calculateGeneratorWeights(
      validateAndFormatGeneratorObject,
      _validateAndFormatGeneratorObject,
      validateAndStylizeGeneratorObject,
    ) {
      return (
        ((_validateAndFormatGeneratorObject +
          validateAndStylizeGeneratorObject) *
          3) /
          4 -
        validateAndStylizeGeneratorObject
      );
    }
    function decodeBase64ToTypedArray(
      _________________________validateAndRetrieveIntrinsicProperty,
    ) {
      var decodedByte;
      var decodedByteArray = validateBase64Length(
        _________________________validateAndRetrieveIntrinsicProperty,
      );
      var decodedByteCount = decodedByteArray[0];
      var decodedByteLength = decodedByteArray[1];
      var typedArrayFromDecodedBase64 = new TypedArray(
        calculateGeneratorWeights(
          _________________________validateAndRetrieveIntrinsicProperty,
          decodedByteCount,
          decodedByteLength,
        ),
      );
      var currentByteIndex = 0;
      var decodedByteCountLimit =
        decodedByteLength > 0 ? decodedByteCount - 4 : decodedByteCount;
      var currentBase64Index;
      for (
        currentBase64Index = 0;
        currentBase64Index < decodedByteCountLimit;
        currentBase64Index += 4
      ) {
        decodedByte =
          (base64DecodeTable[
            _________________________validateAndRetrieveIntrinsicProperty.charCodeAt(
              currentBase64Index,
            )
          ] <<
            18) |
          (base64DecodeTable[
            _________________________validateAndRetrieveIntrinsicProperty.charCodeAt(
              currentBase64Index + 1,
            )
          ] <<
            12) |
          (base64DecodeTable[
            _________________________validateAndRetrieveIntrinsicProperty.charCodeAt(
              currentBase64Index + 2,
            )
          ] <<
            6) |
          base64DecodeTable[
            _________________________validateAndRetrieveIntrinsicProperty.charCodeAt(
              currentBase64Index + 3,
            )
          ];
        typedArrayFromDecodedBase64[currentByteIndex++] =
          (decodedByte >> 16) & 255;
        typedArrayFromDecodedBase64[currentByteIndex++] =
          (decodedByte >> 8) & 255;
        typedArrayFromDecodedBase64[currentByteIndex++] = decodedByte & 255;
      }
      if (decodedByteLength === 2) {
        decodedByte =
          (base64DecodeTable[
            _________________________validateAndRetrieveIntrinsicProperty.charCodeAt(
              currentBase64Index,
            )
          ] <<
            2) |
          (base64DecodeTable[
            _________________________validateAndRetrieveIntrinsicProperty.charCodeAt(
              currentBase64Index + 1,
            )
          ] >>
            4);
        typedArrayFromDecodedBase64[currentByteIndex++] = decodedByte & 255;
      }
      if (decodedByteLength === 1) {
        decodedByte =
          (base64DecodeTable[
            _________________________validateAndRetrieveIntrinsicProperty.charCodeAt(
              currentBase64Index,
            )
          ] <<
            10) |
          (base64DecodeTable[
            _________________________validateAndRetrieveIntrinsicProperty.charCodeAt(
              currentBase64Index + 1,
            )
          ] <<
            4) |
          (base64DecodeTable[
            _________________________validateAndRetrieveIntrinsicProperty.charCodeAt(
              currentBase64Index + 2,
            )
          ] >>
            2);
        typedArrayFromDecodedBase64[currentByteIndex++] =
          (decodedByte >> 8) & 255;
        typedArrayFromDecodedBase64[currentByteIndex++] = decodedByte & 255;
      }
      return typedArrayFromDecodedBase64;
    }
    function _convertToBase64(_validateAndRetrieveIntrinsicProperties) {
      return (
        base64CharacterSet[
          (_validateAndRetrieveIntrinsicProperties >> 18) & 63
        ] +
        base64CharacterSet[
          (_validateAndRetrieveIntrinsicProperties >> 12) & 63
        ] +
        base64CharacterSet[
          (_validateAndRetrieveIntrinsicProperties >> 6) & 63
        ] +
        base64CharacterSet[_validateAndRetrieveIntrinsicProperties & 63]
      );
    }
    function extractAndTransformColorValues(
      __________________________validateAndRetrieveIntrinsicProperty,
      ___________________________validateAndRetrieveIntrinsicProperty,
      ____________________________validateAndRetrieveIntrinsicProperty,
    ) {
      var hexColorValue;
      var hexColorResults = [];
      for (
        var colorChannelIndex =
          ___________________________validateAndRetrieveIntrinsicProperty;
        colorChannelIndex <
        ____________________________validateAndRetrieveIntrinsicProperty;
        colorChannelIndex += 3
      ) {
        hexColorValue =
          ((__________________________validateAndRetrieveIntrinsicProperty[
            colorChannelIndex
          ] <<
            16) &
            16711680) +
          ((__________________________validateAndRetrieveIntrinsicProperty[
            colorChannelIndex + 1
          ] <<
            8) &
            65280) +
          (__________________________validateAndRetrieveIntrinsicProperty[
            colorChannelIndex + 2
          ] &
            255);
        hexColorResults.push(_convertToBase64(hexColorValue));
      }
      return hexColorResults.join("");
    }
    function base64EncodeChunked(
      _____________________________validateAndRetrieveIntrinsicProperty,
    ) {
      var lastChunkValue;
      var inputDataLength =
        _____________________________validateAndRetrieveIntrinsicProperty.length;
      var remainingBytesInInput = inputDataLength % 3;
      var encodedChunks = [];
      for (
        var chunkSize = 16383,
          currentByteOffset = 0,
          maxByteOffset = inputDataLength - remainingBytesInInput;
        currentByteOffset < maxByteOffset;
        currentByteOffset += chunkSize
      ) {
        encodedChunks.push(
          extractAndTransformColorValues(
            _____________________________validateAndRetrieveIntrinsicProperty,
            currentByteOffset,
            currentByteOffset + chunkSize > maxByteOffset
              ? maxByteOffset
              : currentByteOffset + chunkSize,
          ),
        );
      }
      if (remainingBytesInInput === 1) {
        lastChunkValue =
          _____________________________validateAndRetrieveIntrinsicProperty[
            inputDataLength - 1
          ];
        encodedChunks.push(
          base64CharacterSet[lastChunkValue >> 2] +
            base64CharacterSet[(lastChunkValue << 4) & 63] +
            "==",
        );
      } else if (remainingBytesInInput === 2) {
        lastChunkValue =
          (_____________________________validateAndRetrieveIntrinsicProperty[
            inputDataLength - 2
          ] <<
            8) +
          _____________________________validateAndRetrieveIntrinsicProperty[
            inputDataLength - 1
          ];
        encodedChunks.push(
          base64CharacterSet[lastChunkValue >> 10] +
            base64CharacterSet[(lastChunkValue >> 4) & 63] +
            base64CharacterSet[(lastChunkValue << 2) & 63] +
            "=",
        );
      }
      return encodedChunks.join("");
    }
  },
);
var intrinsicPropertyDescriptor = conditionalModuleLoader(
  (readIntrinsicProperty) => {
    readIntrinsicProperty.read = function (
      _intrinsicPropertyDescriptor,
      descriptorForIntrinsicProperty,
      validateAndRetrieveIntrinsicPropertyDescriptor,
      propertyDescriptor,
      _propertyDescriptor,
    ) {
      var decodedIntrinsicPropertyValue;
      var decodedIntrinsicPropertyValueLastByte;
      var bitOffsetForPropertyDescriptor =
        _propertyDescriptor * 8 - propertyDescriptor - 1;
      var maxBitMaskForPropertyDescriptor =
        (1 << bitOffsetForPropertyDescriptor) - 1;
      var maxBitMaskShifted = maxBitMaskForPropertyDescriptor >> 1;
      var bitShiftOffset = -7;
      var previousPropertyDescriptorIndex =
        validateAndRetrieveIntrinsicPropertyDescriptor
          ? _propertyDescriptor - 1
          : 0;
      var adjustedPropertyDescriptorIndex =
        validateAndRetrieveIntrinsicPropertyDescriptor ? -1 : 1;
      var __________intrinsicPropertyValue =
        _intrinsicPropertyDescriptor[
          descriptorForIntrinsicProperty + previousPropertyDescriptorIndex
        ];
      previousPropertyDescriptorIndex += adjustedPropertyDescriptorIndex;
      decodedIntrinsicPropertyValue =
        __________intrinsicPropertyValue & ((1 << -bitShiftOffset) - 1);
      __________intrinsicPropertyValue >>= -bitShiftOffset;
      bitShiftOffset += bitOffsetForPropertyDescriptor;
      for (; bitShiftOffset > 0; bitShiftOffset -= 8) {
        decodedIntrinsicPropertyValue =
          decodedIntrinsicPropertyValue * 256 +
          _intrinsicPropertyDescriptor[
            descriptorForIntrinsicProperty + previousPropertyDescriptorIndex
          ];
        previousPropertyDescriptorIndex += adjustedPropertyDescriptorIndex;
      }
      decodedIntrinsicPropertyValueLastByte =
        decodedIntrinsicPropertyValue & ((1 << -bitShiftOffset) - 1);
      decodedIntrinsicPropertyValue >>= -bitShiftOffset;
      bitShiftOffset += propertyDescriptor;
      for (; bitShiftOffset > 0; bitShiftOffset -= 8) {
        decodedIntrinsicPropertyValueLastByte =
          decodedIntrinsicPropertyValueLastByte * 256 +
          _intrinsicPropertyDescriptor[
            descriptorForIntrinsicProperty + previousPropertyDescriptorIndex
          ];
        previousPropertyDescriptorIndex += adjustedPropertyDescriptorIndex;
      }
      if (decodedIntrinsicPropertyValue === 0) {
        decodedIntrinsicPropertyValue = 1 - maxBitMaskShifted;
      } else {
        if (decodedIntrinsicPropertyValue === maxBitMaskForPropertyDescriptor) {
          if (decodedIntrinsicPropertyValueLastByte) {
            return NaN;
          } else {
            return (__________intrinsicPropertyValue ? -1 : 1) * Infinity;
          }
        }
        decodedIntrinsicPropertyValueLastByte =
          decodedIntrinsicPropertyValueLastByte +
          Math.pow(2, propertyDescriptor);
        decodedIntrinsicPropertyValue =
          decodedIntrinsicPropertyValue - maxBitMaskShifted;
      }
      return (
        (__________intrinsicPropertyValue ? -1 : 1) *
        decodedIntrinsicPropertyValueLastByte *
        Math.pow(2, decodedIntrinsicPropertyValue - propertyDescriptor)
      );
    };
    readIntrinsicProperty.write = function (
      ______________________________validateAndRetrieveIntrinsicProperty,
      _______________________________validateAndRetrieveIntrinsicProperty,
      ________________________________validateAndRetrieveIntrinsicProperty,
      __validateIntrinsicProperty,
      validateAndFormatIntrinsicProperty,
      _________________________________validateAndRetrieveIntrinsicProperty,
    ) {
      var _________intrinsicPropertyValue;
      var intrinsicPropertyBase;
      var intrinsicPropertyAdjustmentFactor;
      var computedPropertyAdjustment =
        _________________________________validateAndRetrieveIntrinsicProperty *
          8 -
        validateAndFormatIntrinsicProperty -
        1;
      var maxIntrinsicPropertyValue = (1 << computedPropertyAdjustment) - 1;
      var maxIntrinsicPropertyValueHalf = maxIntrinsicPropertyValue >> 1;
      var intrinsicPropertyAdjustment =
        validateAndFormatIntrinsicProperty === 23
          ? Math.pow(2, -24) - Math.pow(2, -77)
          : 0;
      var intrinsicPropertyStartValue = __validateIntrinsicProperty
        ? 0
        : _________________________________validateAndRetrieveIntrinsicProperty -
          1;
      var validateAndRetrieveIntrinsicPropertyValues =
        __validateIntrinsicProperty ? 1 : -1;
      var __calculateIntrinsicProperty =
        _______________________________validateAndRetrieveIntrinsicProperty <
          0 ||
        (_______________________________validateAndRetrieveIntrinsicProperty ===
          0 &&
          1 /
            _______________________________validateAndRetrieveIntrinsicProperty <
            0)
          ? 1
          : 0;
      _______________________________validateAndRetrieveIntrinsicProperty =
        Math.abs(
          _______________________________validateAndRetrieveIntrinsicProperty,
        );
      if (
        isNaN(
          _______________________________validateAndRetrieveIntrinsicProperty,
        ) ||
        _______________________________validateAndRetrieveIntrinsicProperty ===
          Infinity
      ) {
        if (
          isNaN(
            _______________________________validateAndRetrieveIntrinsicProperty,
          )
        ) {
          intrinsicPropertyBase = 1;
        } else {
          intrinsicPropertyBase = 0;
        }
        _________intrinsicPropertyValue = maxIntrinsicPropertyValue;
      } else {
        _________intrinsicPropertyValue = Math.floor(
          Math.log(
            _______________________________validateAndRetrieveIntrinsicProperty,
          ) / Math.LN2,
        );
        if (
          _______________________________validateAndRetrieveIntrinsicProperty *
            (intrinsicPropertyAdjustmentFactor = Math.pow(
              2,
              -_________intrinsicPropertyValue,
            )) <
          1
        ) {
          _________intrinsicPropertyValue--;
          intrinsicPropertyAdjustmentFactor *= 2;
        }
        if (
          _________intrinsicPropertyValue + maxIntrinsicPropertyValueHalf >=
          1
        ) {
          _______________________________validateAndRetrieveIntrinsicProperty +=
            intrinsicPropertyAdjustment / intrinsicPropertyAdjustmentFactor;
        } else {
          _______________________________validateAndRetrieveIntrinsicProperty +=
            intrinsicPropertyAdjustment *
            Math.pow(2, 1 - maxIntrinsicPropertyValueHalf);
        }
        if (
          _______________________________validateAndRetrieveIntrinsicProperty *
            intrinsicPropertyAdjustmentFactor >=
          2
        ) {
          _________intrinsicPropertyValue++;
          intrinsicPropertyAdjustmentFactor /= 2;
        }
        if (
          _________intrinsicPropertyValue + maxIntrinsicPropertyValueHalf >=
          maxIntrinsicPropertyValue
        ) {
          intrinsicPropertyBase = 0;
          _________intrinsicPropertyValue = maxIntrinsicPropertyValue;
        } else if (
          _________intrinsicPropertyValue + maxIntrinsicPropertyValueHalf >=
          1
        ) {
          intrinsicPropertyBase =
            (_______________________________validateAndRetrieveIntrinsicProperty *
              intrinsicPropertyAdjustmentFactor -
              1) *
            Math.pow(2, validateAndFormatIntrinsicProperty);
          _________intrinsicPropertyValue =
            _________intrinsicPropertyValue + maxIntrinsicPropertyValueHalf;
        } else {
          intrinsicPropertyBase =
            _______________________________validateAndRetrieveIntrinsicProperty *
            Math.pow(2, maxIntrinsicPropertyValueHalf - 1) *
            Math.pow(2, validateAndFormatIntrinsicProperty);
          _________intrinsicPropertyValue = 0;
        }
      }
      for (
        ;
        validateAndFormatIntrinsicProperty >= 8;
        validateAndFormatIntrinsicProperty -= 8
      ) {
        ______________________________validateAndRetrieveIntrinsicProperty[
          ________________________________validateAndRetrieveIntrinsicProperty +
            intrinsicPropertyStartValue
        ] = intrinsicPropertyBase & 255;
        intrinsicPropertyStartValue +=
          validateAndRetrieveIntrinsicPropertyValues;
        intrinsicPropertyBase /= 256;
      }
      _________intrinsicPropertyValue =
        (_________intrinsicPropertyValue <<
          validateAndFormatIntrinsicProperty) |
        intrinsicPropertyBase;
      computedPropertyAdjustment += validateAndFormatIntrinsicProperty;
      for (; computedPropertyAdjustment > 0; computedPropertyAdjustment -= 8) {
        ______________________________validateAndRetrieveIntrinsicProperty[
          ________________________________validateAndRetrieveIntrinsicProperty +
            intrinsicPropertyStartValue
        ] = _________intrinsicPropertyValue & 255;
        intrinsicPropertyStartValue +=
          validateAndRetrieveIntrinsicPropertyValues;
        _________intrinsicPropertyValue /= 256;
      }
      ______________________________validateAndRetrieveIntrinsicProperty[
        ________________________________validateAndRetrieveIntrinsicProperty +
          intrinsicPropertyStartValue -
          validateAndRetrieveIntrinsicPropertyValues
      ] |= __calculateIntrinsicProperty * 128;
    };
  },
);
var formattedValidationMessage = conditionalModuleLoader((BufferUtilities) => {
  var generateDataView = generateDataViewRepresentation();
  var getIntrinsicPropertyDescriptor = intrinsicPropertyDescriptor();
  var symbolForNodejsInspectCustom =
    typeof Symbol == "function" && typeof Symbol.for == "function"
      ? Symbol.for("nodejs.util.inspect.custom")
      : null;
  BufferUtilities.Buffer = validatePromiseInput;
  BufferUtilities.SlowBuffer = allocateDebugLogInstance;
  BufferUtilities.INSPECT_MAX_BYTES = 50;
  var kMaxBufferSize = 2147483647;
  BufferUtilities.kMaxLength = kMaxBufferSize;
  validatePromiseInput.TYPED_ARRAY_SUPPORT = checkUint8ArrayFooMethod();
  if (
    !validatePromiseInput.TYPED_ARRAY_SUPPORT &&
    typeof console !== "undefined" &&
    typeof console.error == "function"
  ) {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.",
    );
  }
  function checkUint8ArrayFooMethod() {
    try {
      let typedArrayWithFooMethod = new Uint8Array(1);
      let typedArrayWithFooPrototype = {
        foo() {
          return 42;
        },
      };
      Object.setPrototypeOf(typedArrayWithFooPrototype, Uint8Array.prototype);
      Object.setPrototypeOf(
        typedArrayWithFooMethod,
        typedArrayWithFooPrototype,
      );
      return typedArrayWithFooMethod.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(validatePromiseInput.prototype, "parent", {
    enumerable: true,
    get() {
      if (validatePromiseInput.isBuffer(this)) {
        return this.buffer;
      }
    },
  });
  Object.defineProperty(validatePromiseInput.prototype, "offset", {
    enumerable: true,
    get() {
      if (validatePromiseInput.isBuffer(this)) {
        return this.byteOffset;
      }
    },
  });
  function createUint8ArrayWithValidation(isRegexp) {
    if (isRegexp > kMaxBufferSize) {
      throw new RangeError(
        'The value "' + isRegexp + '" is invalid for option "size"',
      );
    }
    let uint8ArrayWithValidation = new Uint8Array(isRegexp);
    Object.setPrototypeOf(
      uint8ArrayWithValidation,
      validatePromiseInput.prototype,
    );
    return uint8ArrayWithValidation;
  }
  function validatePromiseInput(
    isPromiseValidationFormatterNull,
    isPromiseValidationNull,
    _isPromiseValidationNull,
  ) {
    if (typeof isPromiseValidationFormatterNull == "number") {
      if (typeof isPromiseValidationNull == "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number',
        );
      }
      return processAndCreateUint8Array(isPromiseValidationFormatterNull);
    }
    return processInputType(
      isPromiseValidationFormatterNull,
      isPromiseValidationNull,
      _isPromiseValidationNull,
    );
  }
  validatePromiseInput.poolSize = 8192;
  function processInputType(isObjectType, isErrorType, isError) {
    if (typeof isObjectType == "string") {
      return writeAndValidateBuffer(isObjectType, isErrorType);
    }
    if (ArrayBuffer.isView(isObjectType)) {
      return convertToUint8Array(isObjectType);
    }
    if (isObjectType == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof isObjectType,
      );
    }
    if (
      isInstanceOfOrHasSameConstructorName(isObjectType, ArrayBuffer) ||
      (isObjectType &&
        isInstanceOfOrHasSameConstructorName(
          isObjectType.buffer,
          ArrayBuffer,
        )) ||
      (typeof SharedArrayBuffer !== "undefined" &&
        (isInstanceOfOrHasSameConstructorName(
          isObjectType,
          SharedArrayBuffer,
        ) ||
          (isObjectType &&
            isInstanceOfOrHasSameConstructorName(
              isObjectType.buffer,
              SharedArrayBuffer,
            ))))
    ) {
      return _createUint8ArrayFromBuffer(isObjectType, isErrorType, isError);
    }
    if (typeof isObjectType == "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number',
      );
    }
    let ____inputValue = isObjectType.valueOf && isObjectType.valueOf();
    if (____inputValue != null && ____inputValue !== isObjectType) {
      return validatePromiseInput.from(____inputValue, isErrorType, isError);
    }
    let __processInput = processLoggingHandle(isObjectType);
    if (__processInput) {
      return __processInput;
    }
    if (
      typeof Symbol !== "undefined" &&
      Symbol.toPrimitive != null &&
      typeof isObjectType[Symbol.toPrimitive] == "function"
    ) {
      return validatePromiseInput.from(
        isObjectType[Symbol.toPrimitive]("string"),
        isErrorType,
        isError,
      );
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
        typeof isObjectType,
    );
  }
  validatePromiseInput.from = function (
    logDateWithFormattedTimestamp,
    logFormattedDate,
    logCurrentDateAndTime,
  ) {
    return processInputType(
      logDateWithFormattedTimestamp,
      logFormattedDate,
      logCurrentDateAndTime,
    );
  };
  Object.setPrototypeOf(validatePromiseInput.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(validatePromiseInput, Uint8Array);
  function _validateSizeArgument(isFormatArgumentsUndefined) {
    if (typeof isFormatArgumentsUndefined != "number") {
      throw new TypeError('"size" argument must be of type number');
    }
    if (isFormatArgumentsUndefined < 0) {
      throw new RangeError(
        'The value "' +
          isFormatArgumentsUndefined +
          '" is invalid for option "size"',
      );
    }
  }
  function processAndValidateTimeArray(
    formatTimeWithLeadingZero,
    _validateArrayType,
    arrayTypeValidationFunction,
  ) {
    _validateSizeArgument(formatTimeWithLeadingZero);
    if (formatTimeWithLeadingZero <= 0) {
      return createUint8ArrayWithValidation(formatTimeWithLeadingZero);
    } else if (_validateArrayType !== undefined) {
      if (typeof arrayTypeValidationFunction == "string") {
        return createUint8ArrayWithValidation(formatTimeWithLeadingZero).fill(
          _validateArrayType,
          arrayTypeValidationFunction,
        );
      } else {
        return createUint8ArrayWithValidation(formatTimeWithLeadingZero).fill(
          _validateArrayType,
        );
      }
    } else {
      return createUint8ArrayWithValidation(formatTimeWithLeadingZero);
    }
  }
  validatePromiseInput.alloc = function (
    logCurrentTime,
    logFormattedMessage,
    logDebugMessage,
  ) {
    return processAndValidateTimeArray(
      logCurrentTime,
      logFormattedMessage,
      logDebugMessage,
    );
  };
  function processAndCreateUint8Array(utilityModule) {
    _validateSizeArgument(utilityModule);
    return createUint8ArrayWithValidation(
      utilityModule < 0 ? 0 : _validateBufferSize(utilityModule) | 0,
    );
  }
  validatePromiseInput.allocUnsafe = function (_logDebugMessage) {
    return processAndCreateUint8Array(_logDebugMessage);
  };
  validatePromiseInput.allocUnsafeSlow = function (promisifyDebugLogger) {
    return processAndCreateUint8Array(promisifyDebugLogger);
  };
  function writeAndValidateBuffer(
    promisifyCustomSymbol,
    validateAndExtendArrayTypeValidation,
  ) {
    if (
      typeof validateAndExtendArrayTypeValidation != "string" ||
      validateAndExtendArrayTypeValidation === ""
    ) {
      validateAndExtendArrayTypeValidation = "utf8";
    }
    if (
      !validatePromiseInput.isEncoding(validateAndExtendArrayTypeValidation)
    ) {
      throw new TypeError(
        "Unknown encoding: " + validateAndExtendArrayTypeValidation,
      );
    }
    let __bufferLength =
      getBufferOrArrayBufferLength(
        promisifyCustomSymbol,
        validateAndExtendArrayTypeValidation,
      ) | 0;
    let _buffer = createUint8ArrayWithValidation(__bufferLength);
    let bytesWritten = _buffer.write(
      promisifyCustomSymbol,
      validateAndExtendArrayTypeValidation,
    );
    if (bytesWritten !== __bufferLength) {
      _buffer = _buffer.slice(0, bytesWritten);
    }
    return _buffer;
  }
  function convertFunctionToByteArray(promisifyFunction) {
    let functionLengthInBytes =
      promisifyFunction.length < 0
        ? 0
        : _validateBufferSize(promisifyFunction.length) | 0;
    let functionByteArray = createUint8ArrayWithValidation(
      functionLengthInBytes,
    );
    for (
      let ___byteIndex = 0;
      ___byteIndex < functionLengthInBytes;
      ___byteIndex += 1
    ) {
      functionByteArray[___byteIndex] = promisifyFunction[___byteIndex] & 255;
    }
    return functionByteArray;
  }
  function convertToUint8Array(promisifyUtilFunction) {
    if (
      isInstanceOfOrHasSameConstructorName(promisifyUtilFunction, Uint8Array)
    ) {
      let promisifiedUint8Array = new Uint8Array(promisifyUtilFunction);
      return _createUint8ArrayFromBuffer(
        promisifiedUint8Array.buffer,
        promisifiedUint8Array.byteOffset,
        promisifiedUint8Array.byteLength,
      );
    }
    return convertFunctionToByteArray(promisifyUtilFunction);
  }
  function _createUint8ArrayFromBuffer(
    validateAndLogInstance,
    logPromiseWithCallback,
    _validateAndLogInstance,
  ) {
    if (
      logPromiseWithCallback < 0 ||
      validateAndLogInstance.byteLength < logPromiseWithCallback
    ) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (
      validateAndLogInstance.byteLength <
      logPromiseWithCallback + (_validateAndLogInstance || 0)
    ) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let uint8Array;
    if (
      logPromiseWithCallback === undefined &&
      _validateAndLogInstance === undefined
    ) {
      uint8Array = new Uint8Array(validateAndLogInstance);
    } else if (_validateAndLogInstance === undefined) {
      uint8Array = new Uint8Array(
        validateAndLogInstance,
        logPromiseWithCallback,
      );
    } else {
      uint8Array = new Uint8Array(
        validateAndLogInstance,
        logPromiseWithCallback,
        _validateAndLogInstance,
      );
    }
    Object.setPrototypeOf(uint8Array, validatePromiseInput.prototype);
    return uint8Array;
  }
  function processLoggingHandle(handleLoggingProcess) {
    if (validatePromiseInput.isBuffer(handleLoggingProcess)) {
      let validatedBufferSize =
        _validateBufferSize(handleLoggingProcess.length) | 0;
      let validatedLoggingBuffer =
        createUint8ArrayWithValidation(validatedBufferSize);
      if (validatedLoggingBuffer.length !== 0) {
        handleLoggingProcess.copy(
          validatedLoggingBuffer,
          0,
          0,
          validatedBufferSize,
        );
      }
      return validatedLoggingBuffer;
    }
    if (handleLoggingProcess.length !== undefined) {
      if (
        typeof handleLoggingProcess.length != "number" ||
        isIntrinsicPropertyValid(handleLoggingProcess.length)
      ) {
        return createUint8ArrayWithValidation(0);
      } else {
        return convertFunctionToByteArray(handleLoggingProcess);
      }
    }
    if (
      handleLoggingProcess.type === "Buffer" &&
      Array.isArray(handleLoggingProcess.data)
    ) {
      return convertFunctionToByteArray(handleLoggingProcess.data);
    }
  }
  function _validateBufferSize(debugLogForInstanceHandler) {
    if (debugLogForInstanceHandler >= kMaxBufferSize) {
      throw new RangeError(
        "Attempt to allocate Buffer larger than maximum size: 0x" +
          kMaxBufferSize.toString(16) +
          " bytes",
      );
    }
    return debugLogForInstanceHandler | 0;
  }
  function allocateDebugLogInstance(_debugLogForInstance) {
    if (+_debugLogForInstance != _debugLogForInstance) {
      _debugLogForInstance = 0;
    }
    return validatePromiseInput.alloc(+_debugLogForInstance);
  }
  validatePromiseInput.isBuffer = function (promisifyCustomFunction) {
    return (
      promisifyCustomFunction != null &&
      promisifyCustomFunction._isBuffer === true &&
      promisifyCustomFunction !== validatePromiseInput.prototype
    );
  };
  validatePromiseInput.compare = function (
    handlePromiseRejection,
    styledOutputPromise,
  ) {
    if (
      isInstanceOfOrHasSameConstructorName(handlePromiseRejection, Uint8Array)
    ) {
      handlePromiseRejection = validatePromiseInput.from(
        handlePromiseRejection,
        handlePromiseRejection.offset,
        handlePromiseRejection.byteLength,
      );
    }
    if (isInstanceOfOrHasSameConstructorName(styledOutputPromise, Uint8Array)) {
      styledOutputPromise = validatePromiseInput.from(
        styledOutputPromise,
        styledOutputPromise.offset,
        styledOutputPromise.byteLength,
      );
    }
    if (
      !validatePromiseInput.isBuffer(handlePromiseRejection) ||
      !validatePromiseInput.isBuffer(styledOutputPromise)
    ) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array',
      );
    }
    if (handlePromiseRejection === styledOutputPromise) {
      return 0;
    }
    let handlePromiseRejectionLength = handlePromiseRejection.length;
    let styledOutputLength = styledOutputPromise.length;
    for (
      let ______index = 0,
        minLengthToCompare = Math.min(
          handlePromiseRejectionLength,
          styledOutputLength,
        );
      ______index < minLengthToCompare;
      ++______index
    ) {
      if (
        handlePromiseRejection[______index] !== styledOutputPromise[______index]
      ) {
        handlePromiseRejectionLength = handlePromiseRejection[______index];
        styledOutputLength = styledOutputPromise[______index];
        break;
      }
    }
    if (handlePromiseRejectionLength < styledOutputLength) {
      return -1;
    } else if (styledOutputLength < handlePromiseRejectionLength) {
      return 1;
    } else {
      return 0;
    }
  };
  validatePromiseInput.isEncoding = function (_processArrayBufferKeys) {
    switch (String(_processArrayBufferKeys).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  validatePromiseInput.concat = function (
    validateAndInspectArrayBuffer,
    getValidatedDataViewLength,
  ) {
    if (!Array.isArray(validateAndInspectArrayBuffer)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (validateAndInspectArrayBuffer.length === 0) {
      return validatePromiseInput.alloc(0);
    }
    let ___currentIndex;
    if (getValidatedDataViewLength === undefined) {
      getValidatedDataViewLength = 0;
      ___currentIndex = 0;
      for (
        ;
        ___currentIndex < validateAndInspectArrayBuffer.length;
        ++___currentIndex
      ) {
        getValidatedDataViewLength +=
          validateAndInspectArrayBuffer[___currentIndex].length;
      }
    }
    let bufferDataView = validatePromiseInput.allocUnsafe(
      getValidatedDataViewLength,
    );
    let currentBufferLength = 0;
    for (
      ___currentIndex = 0;
      ___currentIndex < validateAndInspectArrayBuffer.length;
      ++___currentIndex
    ) {
      let currentArrayBuffer = validateAndInspectArrayBuffer[___currentIndex];
      if (
        isInstanceOfOrHasSameConstructorName(currentArrayBuffer, Uint8Array)
      ) {
        if (
          currentBufferLength + currentArrayBuffer.length >
          bufferDataView.length
        ) {
          if (!validatePromiseInput.isBuffer(currentArrayBuffer)) {
            currentArrayBuffer = validatePromiseInput.from(currentArrayBuffer);
          }
          currentArrayBuffer.copy(bufferDataView, currentBufferLength);
        } else {
          Uint8Array.prototype.set.call(
            bufferDataView,
            currentArrayBuffer,
            currentBufferLength,
          );
        }
      } else if (validatePromiseInput.isBuffer(currentArrayBuffer)) {
        currentArrayBuffer.copy(bufferDataView, currentBufferLength);
      } else {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      currentBufferLength += currentArrayBuffer.length;
    }
    return bufferDataView;
  };
  function getBufferOrArrayBufferLength(
    exportedRandomValueGenerator,
    generateRandomValue,
  ) {
    if (validatePromiseInput.isBuffer(exportedRandomValueGenerator)) {
      return exportedRandomValueGenerator.length;
    }
    if (
      ArrayBuffer.isView(exportedRandomValueGenerator) ||
      isInstanceOfOrHasSameConstructorName(
        exportedRandomValueGenerator,
        ArrayBuffer,
      )
    ) {
      return exportedRandomValueGenerator.byteLength;
    }
    if (typeof exportedRandomValueGenerator != "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
          typeof exportedRandomValueGenerator,
      );
    }
    let stringLength = exportedRandomValueGenerator.length;
    let isSpecialCondition = arguments.length > 2 && arguments[2] === true;
    if (!isSpecialCondition && stringLength === 0) {
      return 0;
    }
    let isValidLength = false;
    while (true) {
      switch (generateRandomValue) {
        case "ascii":
        case "latin1":
        case "binary":
          return stringLength;
        case "utf8":
        case "utf-8":
          return validateAndRetrieveUnicodeProperty(
            exportedRandomValueGenerator,
          ).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return stringLength * 2;
        case "hex":
          return stringLength >>> 1;
        case "base64":
          return convertAndStoreIntrinsicValue(exportedRandomValueGenerator)
            .length;
        default:
          if (isValidLength) {
            if (isSpecialCondition) {
              return -1;
            } else {
              return validateAndRetrieveUnicodeProperty(
                exportedRandomValueGenerator,
              ).length;
            }
          }
          generateRandomValue = ("" + generateRandomValue).toLowerCase();
          isValidLength = true;
      }
    }
  }
  validatePromiseInput.byteLength = getBufferOrArrayBufferLength;
  function generateStringSlice(
    generateIdentifier,
    generateUniqueIdentifier,
    generateUniqueId,
  ) {
    let isSliceValid = false;
    if (
      generateUniqueIdentifier === undefined ||
      generateUniqueIdentifier < 0
    ) {
      generateUniqueIdentifier = 0;
    }
    if (
      generateUniqueIdentifier > this.length ||
      ((generateUniqueId === undefined || generateUniqueId > this.length) &&
        (generateUniqueId = this.length),
      generateUniqueId <= 0) ||
      ((generateUniqueId >>>= 0),
      (generateUniqueIdentifier >>>= 0),
      generateUniqueId <= generateUniqueIdentifier)
    ) {
      return "";
    }
    for (generateIdentifier ||= "utf8"; ; ) {
      switch (generateIdentifier) {
        case "hex":
          return processTypedArrayConversion(
            this,
            generateUniqueIdentifier,
            generateUniqueId,
          );
        case "utf8":
        case "utf-8":
          return processTypedArrayValidation(
            this,
            generateUniqueIdentifier,
            generateUniqueId,
          );
        case "ascii":
          return extractValidPromiseTypeChars(
            this,
            generateUniqueIdentifier,
            generateUniqueId,
          );
        case "latin1":
        case "binary":
          return extractCharactersFromInput(
            this,
            generateUniqueIdentifier,
            generateUniqueId,
          );
        case "base64":
          return createDataViewFromByteArray(
            this,
            generateUniqueIdentifier,
            generateUniqueId,
          );
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return processInputValues(
            this,
            generateUniqueIdentifier,
            generateUniqueId,
          );
        default:
          if (isSliceValid) {
            throw new TypeError("Unknown encoding: " + generateIdentifier);
          }
          generateIdentifier = (generateIdentifier + "").toLowerCase();
          isSliceValid = true;
      }
    }
  }
  validatePromiseInput.prototype._isBuffer = true;
  function swapCharacterData(
    processAndMapCharacterData,
    processDataLength,
    validateAndRetrieveData,
  ) {
    let tempCharacterData = processAndMapCharacterData[processDataLength];
    processAndMapCharacterData[processDataLength] =
      processAndMapCharacterData[validateAndRetrieveData];
    processAndMapCharacterData[validateAndRetrieveData] = tempCharacterData;
  }
  validatePromiseInput.prototype.swap16 = function () {
    let ______bufferLength = this.length;
    if (______bufferLength % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (
      let ____________currentIndex = 0;
      ____________currentIndex < ______bufferLength;
      ____________currentIndex += 2
    ) {
      swapCharacterData(
        this,
        ____________currentIndex,
        ____________currentIndex + 1,
      );
    }
    return this;
  };
  validatePromiseInput.prototype.swap32 = function () {
    let _____bufferLength = this.length;
    if (_____bufferLength % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (
      let __bufferIndex = 0;
      __bufferIndex < _____bufferLength;
      __bufferIndex += 4
    ) {
      swapCharacterData(this, __bufferIndex, __bufferIndex + 3);
      swapCharacterData(this, __bufferIndex + 1, __bufferIndex + 2);
    }
    return this;
  };
  validatePromiseInput.prototype.swap64 = function () {
    let ___bufferLength = this.length;
    if (___bufferLength % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (
      let _bufferIndex = 0;
      _bufferIndex < ___bufferLength;
      _bufferIndex += 8
    ) {
      swapCharacterData(this, _bufferIndex, _bufferIndex + 7);
      swapCharacterData(this, _bufferIndex + 1, _bufferIndex + 6);
      swapCharacterData(this, _bufferIndex + 2, _bufferIndex + 5);
      swapCharacterData(this, _bufferIndex + 3, _bufferIndex + 4);
    }
    return this;
  };
  validatePromiseInput.prototype.toString = function () {
    let lengthOfInputArray = this.length;
    if (lengthOfInputArray === 0) {
      return "";
    } else if (arguments.length === 0) {
      return processTypedArrayValidation(this, 0, lengthOfInputArray);
    } else {
      return generateStringSlice.apply(this, arguments);
    }
  };
  validatePromiseInput.prototype.toLocaleString =
    validatePromiseInput.prototype.toString;
  validatePromiseInput.prototype.equals = function (decodeBase64String) {
    if (!validatePromiseInput.isBuffer(decodeBase64String)) {
      throw new TypeError("Argument must be a Buffer");
    }
    if (this === decodeBase64String) {
      return true;
    } else {
      return validatePromiseInput.compare(this, decodeBase64String) === 0;
    }
  };
  validatePromiseInput.prototype.inspect = function () {
    let bufferHexString = "";
    let maxBytesForBufferInspection = BufferUtilities.INSPECT_MAX_BYTES;
    bufferHexString = this.toString("hex", 0, maxBytesForBufferInspection)
      .replace(/(.{2})/g, "$1 ")
      .trim();
    if (this.length > maxBytesForBufferInspection) {
      bufferHexString += " ... ";
    }
    return "<Buffer " + bufferHexString + ">";
  };
  if (symbolForNodejsInspectCustom) {
    validatePromiseInput.prototype[symbolForNodejsInspectCustom] =
      validatePromiseInput.prototype.inspect;
  }
  validatePromiseInput.prototype.compare = function (
    processData,
    validateAndRetrievePropertyValue,
    extractAndProcessEncodedData,
    processAndOutputEncodedData,
    charCodeAtValue,
  ) {
    if (isInstanceOfOrHasSameConstructorName(processData, Uint8Array)) {
      processData = validatePromiseInput.from(
        processData,
        processData.offset,
        processData.byteLength,
      );
    }
    if (!validatePromiseInput.isBuffer(processData)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
          typeof processData,
      );
    }
    if (validateAndRetrievePropertyValue === undefined) {
      validateAndRetrievePropertyValue = 0;
    }
    if (extractAndProcessEncodedData === undefined) {
      if (processData) {
        extractAndProcessEncodedData = processData.length;
      } else {
        extractAndProcessEncodedData = 0;
      }
    }
    if (processAndOutputEncodedData === undefined) {
      processAndOutputEncodedData = 0;
    }
    if (charCodeAtValue === undefined) {
      charCodeAtValue = this.length;
    }
    if (
      validateAndRetrievePropertyValue < 0 ||
      extractAndProcessEncodedData > processData.length ||
      processAndOutputEncodedData < 0 ||
      charCodeAtValue > this.length
    ) {
      throw new RangeError("out of range index");
    }
    if (
      processAndOutputEncodedData >= charCodeAtValue &&
      validateAndRetrievePropertyValue >= extractAndProcessEncodedData
    ) {
      return 0;
    }
    if (processAndOutputEncodedData >= charCodeAtValue) {
      return -1;
    }
    if (validateAndRetrievePropertyValue >= extractAndProcessEncodedData) {
      return 1;
    }
    validateAndRetrievePropertyValue >>>= 0;
    extractAndProcessEncodedData >>>= 0;
    processAndOutputEncodedData >>>= 0;
    charCodeAtValue >>>= 0;
    if (this === processData) {
      return 0;
    }
    let validateIndexAndBounds = charCodeAtValue - processAndOutputEncodedData;
    let validateIndexAndProcessData =
      extractAndProcessEncodedData - validateAndRetrievePropertyValue;
    let validateIndexAndSetDefaults = Math.min(
      validateIndexAndBounds,
      validateIndexAndProcessData,
    );
    let processInputData = this.slice(
      processAndOutputEncodedData,
      charCodeAtValue,
    );
    let validateInputParameters = processData.slice(
      validateAndRetrievePropertyValue,
      extractAndProcessEncodedData,
    );
    for (
      let inputIndex = 0;
      inputIndex < validateIndexAndSetDefaults;
      ++inputIndex
    ) {
      if (
        processInputData[inputIndex] !== validateInputParameters[inputIndex]
      ) {
        validateIndexAndBounds = processInputData[inputIndex];
        validateIndexAndProcessData = validateInputParameters[inputIndex];
        break;
      }
    }
    if (validateIndexAndBounds < validateIndexAndProcessData) {
      return -1;
    } else if (validateIndexAndProcessData < validateIndexAndBounds) {
      return 1;
    } else {
      return 0;
    }
  };
  function validateAndGetPropertySegment(
    __________________________________validateAndRetrieveIntrinsicProperty,
    ___________________________________validateAndRetrieveIntrinsicProperty,
    retrievePropertySegment,
    retrieveAndProcessIntrinsicProperties,
    retrieveIntrinsicPropertiesFromArray,
  ) {
    if (
      __________________________________validateAndRetrieveIntrinsicProperty.length ===
      0
    ) {
      return -1;
    }
    if (typeof retrievePropertySegment == "string") {
      retrieveAndProcessIntrinsicProperties = retrievePropertySegment;
      retrievePropertySegment = 0;
    } else if (retrievePropertySegment > 2147483647) {
      retrievePropertySegment = 2147483647;
    } else if (retrievePropertySegment < -2147483648) {
      retrievePropertySegment = -2147483648;
    }
    retrievePropertySegment = +retrievePropertySegment;
    if (isIntrinsicPropertyValid(retrievePropertySegment)) {
      if (retrieveIntrinsicPropertiesFromArray) {
        retrievePropertySegment = 0;
      } else {
        retrievePropertySegment =
          __________________________________validateAndRetrieveIntrinsicProperty.length -
          1;
      }
    }
    if (retrievePropertySegment < 0) {
      retrievePropertySegment =
        __________________________________validateAndRetrieveIntrinsicProperty.length +
        retrievePropertySegment;
    }
    if (
      retrievePropertySegment >=
      __________________________________validateAndRetrieveIntrinsicProperty.length
    ) {
      if (retrieveIntrinsicPropertiesFromArray) {
        return -1;
      }
      retrievePropertySegment =
        __________________________________validateAndRetrieveIntrinsicProperty.length -
        1;
    } else if (retrievePropertySegment < 0) {
      if (retrieveIntrinsicPropertiesFromArray) {
        retrievePropertySegment = 0;
      } else {
        return -1;
      }
    }
    if (
      typeof ___________________________________validateAndRetrieveIntrinsicProperty ==
      "string"
    ) {
      ___________________________________validateAndRetrieveIntrinsicProperty =
        validatePromiseInput.from(
          ___________________________________validateAndRetrieveIntrinsicProperty,
          retrieveAndProcessIntrinsicProperties,
        );
    }
    if (
      validatePromiseInput.isBuffer(
        ___________________________________validateAndRetrieveIntrinsicProperty,
      )
    ) {
      if (
        ___________________________________validateAndRetrieveIntrinsicProperty.length ===
        0
      ) {
        return -1;
      } else {
        return calculateAndValidateProperties(
          __________________________________validateAndRetrieveIntrinsicProperty,
          ___________________________________validateAndRetrieveIntrinsicProperty,
          retrievePropertySegment,
          retrieveAndProcessIntrinsicProperties,
          retrieveIntrinsicPropertiesFromArray,
        );
      }
    }
    if (
      typeof ___________________________________validateAndRetrieveIntrinsicProperty ==
      "number"
    ) {
      ___________________________________validateAndRetrieveIntrinsicProperty =
        ___________________________________validateAndRetrieveIntrinsicProperty &
        255;
      if (typeof Uint8Array.prototype.indexOf == "function") {
        if (retrieveIntrinsicPropertiesFromArray) {
          return Uint8Array.prototype.indexOf.call(
            __________________________________validateAndRetrieveIntrinsicProperty,
            ___________________________________validateAndRetrieveIntrinsicProperty,
            retrievePropertySegment,
          );
        } else {
          return Uint8Array.prototype.lastIndexOf.call(
            __________________________________validateAndRetrieveIntrinsicProperty,
            ___________________________________validateAndRetrieveIntrinsicProperty,
            retrievePropertySegment,
          );
        }
      } else {
        return calculateAndValidateProperties(
          __________________________________validateAndRetrieveIntrinsicProperty,
          [
            ___________________________________validateAndRetrieveIntrinsicProperty,
          ],
          retrievePropertySegment,
          retrieveAndProcessIntrinsicProperties,
          retrieveIntrinsicPropertiesFromArray,
        );
      }
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function calculateAndValidateProperties(
    calculateIntrinsicPropertyValues,
    calculatePropertyValue,
    calculatePropertyDescriptorValues,
    calculateIntrinsicProperty,
    calculateIntrinsicPropertyValue,
  ) {
    let minimumPropertyCount = 1;
    let calculatedIntrinsicPropertyValuesCount =
      calculateIntrinsicPropertyValues.length;
    let calculatedPropertyValueCount = calculatePropertyValue.length;
    if (
      calculateIntrinsicProperty !== undefined &&
      ((calculateIntrinsicProperty = String(
        calculateIntrinsicProperty,
      ).toLowerCase()),
      calculateIntrinsicProperty === "ucs2" ||
        calculateIntrinsicProperty === "ucs-2" ||
        calculateIntrinsicProperty === "utf16le" ||
        calculateIntrinsicProperty === "utf-16le")
    ) {
      if (
        calculateIntrinsicPropertyValues.length < 2 ||
        calculatePropertyValue.length < 2
      ) {
        return -1;
      }
      minimumPropertyCount = 2;
      calculatedIntrinsicPropertyValuesCount /= 2;
      calculatedPropertyValueCount /= 2;
      calculatePropertyDescriptorValues /= 2;
    }
    function getPropertyValue(
      validateAndCalculateProperty,
      _calculateIntrinsicPropertyValue,
    ) {
      if (minimumPropertyCount === 1) {
        return validateAndCalculateProperty[_calculateIntrinsicPropertyValue];
      } else {
        return validateAndCalculateProperty.readUInt16BE(
          _calculateIntrinsicPropertyValue * minimumPropertyCount,
        );
      }
    }
    let validateAndCalculatePropertyValues;
    if (calculateIntrinsicPropertyValue) {
      let firstMatchingIndex = -1;
      for (
        validateAndCalculatePropertyValues = calculatePropertyDescriptorValues;
        validateAndCalculatePropertyValues <
        calculatedIntrinsicPropertyValuesCount;
        validateAndCalculatePropertyValues++
      ) {
        if (
          getPropertyValue(
            calculateIntrinsicPropertyValues,
            validateAndCalculatePropertyValues,
          ) ===
          getPropertyValue(
            calculatePropertyValue,
            firstMatchingIndex === -1
              ? 0
              : validateAndCalculatePropertyValues - firstMatchingIndex,
          )
        ) {
          if (firstMatchingIndex === -1) {
            firstMatchingIndex = validateAndCalculatePropertyValues;
          }
          if (
            validateAndCalculatePropertyValues - firstMatchingIndex + 1 ===
            calculatedPropertyValueCount
          ) {
            return firstMatchingIndex * minimumPropertyCount;
          }
        } else {
          if (firstMatchingIndex !== -1) {
            validateAndCalculatePropertyValues -=
              validateAndCalculatePropertyValues - firstMatchingIndex;
          }
          firstMatchingIndex = -1;
        }
      }
    } else {
      if (
        calculatePropertyDescriptorValues + calculatedPropertyValueCount >
        calculatedIntrinsicPropertyValuesCount
      ) {
        calculatePropertyDescriptorValues =
          calculatedIntrinsicPropertyValuesCount - calculatedPropertyValueCount;
      }
      validateAndCalculatePropertyValues = calculatePropertyDescriptorValues;
      for (
        ;
        validateAndCalculatePropertyValues >= 0;
        validateAndCalculatePropertyValues--
      ) {
        let isPropertiesValid = true;
        for (
          let _propertyIndex = 0;
          _propertyIndex < calculatedPropertyValueCount;
          _propertyIndex++
        ) {
          if (
            getPropertyValue(
              calculateIntrinsicPropertyValues,
              validateAndCalculatePropertyValues + _propertyIndex,
            ) !== getPropertyValue(calculatePropertyValue, _propertyIndex)
          ) {
            isPropertiesValid = false;
            break;
          }
        }
        if (isPropertiesValid) {
          return validateAndCalculatePropertyValues;
        }
      }
    }
    return -1;
  }
  validatePromiseInput.prototype.includes = function (
    ____________________________________validateAndRetrieveIntrinsicProperty,
    intrinsicPropertyValidator,
    _____________________________________validateAndRetrieveIntrinsicProperty,
  ) {
    return (
      this.indexOf(
        ____________________________________validateAndRetrieveIntrinsicProperty,
        intrinsicPropertyValidator,
        _____________________________________validateAndRetrieveIntrinsicProperty,
      ) !== -1
    );
  };
  validatePromiseInput.prototype.indexOf = function (
    intrinsicPropertyValue,
    validateAndRetrieveIntrinsicValue,
    ______________________________________validateAndRetrieveIntrinsicProperty,
  ) {
    return validateAndGetPropertySegment(
      this,
      intrinsicPropertyValue,
      validateAndRetrieveIntrinsicValue,
      ______________________________________validateAndRetrieveIntrinsicProperty,
      true,
    );
  };
  validatePromiseInput.prototype.lastIndexOf = function (
    _intrinsicPropertyValue,
    __intrinsicPropertyValue,
    ___intrinsicPropertyValue,
  ) {
    return validateAndGetPropertySegment(
      this,
      _intrinsicPropertyValue,
      __intrinsicPropertyValue,
      ___intrinsicPropertyValue,
      false,
    );
  };
  function calculateAdjustedIntrinsicProperty(
    validateAndRetrieveProperty,
    _______________________________________validateAndRetrieveIntrinsicProperty,
    ____intrinsicPropertyValue,
    _calculateIntrinsicProperty,
  ) {
    ____intrinsicPropertyValue = Number(____intrinsicPropertyValue) || 0;
    let remainingPropertyLength =
      validateAndRetrieveProperty.length - ____intrinsicPropertyValue;
    if (_calculateIntrinsicProperty) {
      _calculateIntrinsicProperty = Number(_calculateIntrinsicProperty);
      if (_calculateIntrinsicProperty > remainingPropertyLength) {
        _calculateIntrinsicProperty = remainingPropertyLength;
      }
    } else {
      _calculateIntrinsicProperty = remainingPropertyLength;
    }
    let totalIntrinsicProperties =
      _______________________________________validateAndRetrieveIntrinsicProperty.length;
    if (_calculateIntrinsicProperty > totalIntrinsicProperties / 2) {
      _calculateIntrinsicProperty = totalIntrinsicProperties / 2;
    }
    let currentIntrinsicPropertyIndex;
    for (
      currentIntrinsicPropertyIndex = 0;
      currentIntrinsicPropertyIndex < _calculateIntrinsicProperty;
      ++currentIntrinsicPropertyIndex
    ) {
      let parseHexToInt = parseInt(
        _______________________________________validateAndRetrieveIntrinsicProperty.substr(
          currentIntrinsicPropertyIndex * 2,
          2,
        ),
        16,
      );
      if (isIntrinsicPropertyValid(parseHexToInt)) {
        return currentIntrinsicPropertyIndex;
      }
      validateAndRetrieveProperty[
        ____intrinsicPropertyValue + currentIntrinsicPropertyIndex
      ] = parseHexToInt;
    }
    return currentIntrinsicPropertyIndex;
  }
  function validateAndCopyIntrinsicValues(
    ________________________________________validateAndRetrieveIntrinsicProperty,
    _validateAndRetrieveIntrinsicValue,
    _________________________________________validateAndRetrieveIntrinsicProperty,
    _validateAndRetrievePropertyValue,
  ) {
    return copyIntrinsicValues(
      validateAndRetrieveUnicodeProperty(
        _validateAndRetrieveIntrinsicValue,
        ________________________________________validateAndRetrieveIntrinsicProperty.length -
          _________________________________________validateAndRetrieveIntrinsicProperty,
      ),
      ________________________________________validateAndRetrieveIntrinsicProperty,
      _________________________________________validateAndRetrieveIntrinsicProperty,
      _validateAndRetrievePropertyValue,
    );
  }
  function copyAndValidateIntrinsicValues(
    _____intrinsicPropertyValue,
    __validateAndRetrieveIntrinsicValue,
    validatedIntrinsicValue,
    __________________________________________validateAndRetrieveIntrinsicProperty,
  ) {
    return copyIntrinsicValues(
      convertStringToCharCodeArray(__validateAndRetrieveIntrinsicValue),
      _____intrinsicPropertyValue,
      validatedIntrinsicValue,
      __________________________________________validateAndRetrieveIntrinsicProperty,
    );
  }
  function __validateAndCopyIntrinsicValues(
    ___________________________________________validateAndRetrieveIntrinsicProperty,
    ___validateAndRetrieveIntrinsicValue,
    validateAndRetrieveIntrinsicNumber,
    ____validateAndRetrieveIntrinsicValue,
  ) {
    return copyIntrinsicValues(
      convertAndStoreIntrinsicValue(___validateAndRetrieveIntrinsicValue),
      ___________________________________________validateAndRetrieveIntrinsicProperty,
      validateAndRetrieveIntrinsicNumber,
      ____validateAndRetrieveIntrinsicValue,
    );
  }
  function _validateAndCopyIntrinsicValues(
    intrinsicProperty,
    ____________________________________________validateAndRetrieveIntrinsicProperty,
    _____validateAndRetrieveIntrinsicValue,
    _____________________________________________validateAndRetrieveIntrinsicProperty,
  ) {
    return copyIntrinsicValues(
      extractIntrinsicPropertyValues(
        ____________________________________________validateAndRetrieveIntrinsicProperty,
        intrinsicProperty.length - _____validateAndRetrieveIntrinsicValue,
      ),
      intrinsicProperty,
      _____validateAndRetrieveIntrinsicValue,
      _____________________________________________validateAndRetrieveIntrinsicProperty,
    );
  }
  validatePromiseInput.prototype.write = function (
    ______________________________________________validateAndRetrieveIntrinsicProperty,
    _______________________________________________validateAndRetrieveIntrinsicProperty,
    ________________________________________________validateAndRetrieveIntrinsicProperty,
    _________________________________________________validateAndRetrieveIntrinsicProperty,
  ) {
    if (
      _______________________________________________validateAndRetrieveIntrinsicProperty ===
      undefined
    ) {
      _________________________________________________validateAndRetrieveIntrinsicProperty =
        "utf8";
      ________________________________________________validateAndRetrieveIntrinsicProperty =
        this.length;
      _______________________________________________validateAndRetrieveIntrinsicProperty = 0;
    } else if (
      ________________________________________________validateAndRetrieveIntrinsicProperty ===
        undefined &&
      typeof _______________________________________________validateAndRetrieveIntrinsicProperty ==
        "string"
    ) {
      _________________________________________________validateAndRetrieveIntrinsicProperty =
        _______________________________________________validateAndRetrieveIntrinsicProperty;
      ________________________________________________validateAndRetrieveIntrinsicProperty =
        this.length;
      _______________________________________________validateAndRetrieveIntrinsicProperty = 0;
    } else if (
      isFinite(
        _______________________________________________validateAndRetrieveIntrinsicProperty,
      )
    ) {
      _______________________________________________validateAndRetrieveIntrinsicProperty =
        _______________________________________________validateAndRetrieveIntrinsicProperty >>>
        0;
      if (
        isFinite(
          ________________________________________________validateAndRetrieveIntrinsicProperty,
        )
      ) {
        ________________________________________________validateAndRetrieveIntrinsicProperty =
          ________________________________________________validateAndRetrieveIntrinsicProperty >>>
          0;
        if (
          _________________________________________________validateAndRetrieveIntrinsicProperty ===
          undefined
        ) {
          _________________________________________________validateAndRetrieveIntrinsicProperty =
            "utf8";
        }
      } else {
        _________________________________________________validateAndRetrieveIntrinsicProperty =
          ________________________________________________validateAndRetrieveIntrinsicProperty;
        ________________________________________________validateAndRetrieveIntrinsicProperty =
          undefined;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported",
      );
    }
    let __________________________________________validateAndRetrieveIntrinsicProperties =
      this.length -
      _______________________________________________validateAndRetrieveIntrinsicProperty;
    if (
      ________________________________________________validateAndRetrieveIntrinsicProperty ===
        undefined ||
      ________________________________________________validateAndRetrieveIntrinsicProperty >
        __________________________________________validateAndRetrieveIntrinsicProperties
    ) {
      ________________________________________________validateAndRetrieveIntrinsicProperty =
        __________________________________________validateAndRetrieveIntrinsicProperties;
    }
    if (
      (______________________________________________validateAndRetrieveIntrinsicProperty.length >
        0 &&
        (________________________________________________validateAndRetrieveIntrinsicProperty <
          0 ||
          _______________________________________________validateAndRetrieveIntrinsicProperty <
            0)) ||
      _______________________________________________validateAndRetrieveIntrinsicProperty >
        this.length
    ) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    _________________________________________________validateAndRetrieveIntrinsicProperty ||=
      "utf8";
    let __________________________________________________________________validateAndRetrieveIntrinsicProperty = false;
    while (true) {
      switch (
        _________________________________________________validateAndRetrieveIntrinsicProperty
      ) {
        case "hex":
          return calculateAdjustedIntrinsicProperty(
            this,
            ______________________________________________validateAndRetrieveIntrinsicProperty,
            _______________________________________________validateAndRetrieveIntrinsicProperty,
            ________________________________________________validateAndRetrieveIntrinsicProperty,
          );
        case "utf8":
        case "utf-8":
          return validateAndCopyIntrinsicValues(
            this,
            ______________________________________________validateAndRetrieveIntrinsicProperty,
            _______________________________________________validateAndRetrieveIntrinsicProperty,
            ________________________________________________validateAndRetrieveIntrinsicProperty,
          );
        case "ascii":
        case "latin1":
        case "binary":
          return copyAndValidateIntrinsicValues(
            this,
            ______________________________________________validateAndRetrieveIntrinsicProperty,
            _______________________________________________validateAndRetrieveIntrinsicProperty,
            ________________________________________________validateAndRetrieveIntrinsicProperty,
          );
        case "base64":
          return __validateAndCopyIntrinsicValues(
            this,
            ______________________________________________validateAndRetrieveIntrinsicProperty,
            _______________________________________________validateAndRetrieveIntrinsicProperty,
            ________________________________________________validateAndRetrieveIntrinsicProperty,
          );
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return _validateAndCopyIntrinsicValues(
            this,
            ______________________________________________validateAndRetrieveIntrinsicProperty,
            _______________________________________________validateAndRetrieveIntrinsicProperty,
            ________________________________________________validateAndRetrieveIntrinsicProperty,
          );
        default:
          if (
            __________________________________________________________________validateAndRetrieveIntrinsicProperty
          ) {
            throw new TypeError(
              "Unknown encoding: " +
                _________________________________________________validateAndRetrieveIntrinsicProperty,
            );
          }
          _________________________________________________validateAndRetrieveIntrinsicProperty =
            (
              "" +
              _________________________________________________validateAndRetrieveIntrinsicProperty
            ).toLowerCase();
          __________________________________________________________________validateAndRetrieveIntrinsicProperty = true;
      }
    }
  };
  validatePromiseInput.prototype.toJSON = function () {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0),
    };
  };
  function createDataViewFromByteArray(
    _validateAndRetrieveProperty,
    __________________________________________________validateAndRetrieveIntrinsicProperty,
    _validateAndRetrieveIntrinsicPropertyDescriptor,
  ) {
    if (
      __________________________________________________validateAndRetrieveIntrinsicProperty ===
        0 &&
      _validateAndRetrieveIntrinsicPropertyDescriptor ===
        _validateAndRetrieveProperty.length
    ) {
      return generateDataView.fromByteArray(_validateAndRetrieveProperty);
    } else {
      return generateDataView.fromByteArray(
        _validateAndRetrieveProperty.slice(
          __________________________________________________validateAndRetrieveIntrinsicProperty,
          _validateAndRetrieveIntrinsicPropertyDescriptor,
        ),
      );
    }
  }
  function processTypedArrayValidation(
    __validateAndRetrieveIntrinsicProperties,
    ___________________________________________________validateAndRetrieveIntrinsicProperty,
    validateAndRetrieveTypedArraySupport,
  ) {
    validateAndRetrieveTypedArraySupport = Math.min(
      __validateAndRetrieveIntrinsicProperties.length,
      validateAndRetrieveTypedArraySupport,
    );
    let typedArrayBuffer = [];
    let _currentIndex =
      ___________________________________________________validateAndRetrieveIntrinsicProperty;
    while (_currentIndex < validateAndRetrieveTypedArraySupport) {
      let firstByteValue =
        __validateAndRetrieveIntrinsicProperties[_currentIndex];
      let decodedUnicodeValue = null;
      let byteCount =
        firstByteValue > 239
          ? 4
          : firstByteValue > 223
            ? 3
            : firstByteValue > 191
              ? 2
              : 1;
      if (_currentIndex + byteCount <= validateAndRetrieveTypedArraySupport) {
        let nextByteValue;
        let thirdByteValue;
        let decodedUnicodeValueFromBytes;
        let _decodedUnicodeValue;
        switch (byteCount) {
          case 1:
            if (firstByteValue < 128) {
              decodedUnicodeValue = firstByteValue;
            }
            break;
          case 2:
            nextByteValue =
              __validateAndRetrieveIntrinsicProperties[_currentIndex + 1];
            if ((nextByteValue & 192) === 128) {
              _decodedUnicodeValue =
                ((firstByteValue & 31) << 6) | (nextByteValue & 63);
              if (_decodedUnicodeValue > 127) {
                decodedUnicodeValue = _decodedUnicodeValue;
              }
            }
            break;
          case 3:
            nextByteValue =
              __validateAndRetrieveIntrinsicProperties[_currentIndex + 1];
            thirdByteValue =
              __validateAndRetrieveIntrinsicProperties[_currentIndex + 2];
            if (
              (nextByteValue & 192) === 128 &&
              (thirdByteValue & 192) === 128
            ) {
              _decodedUnicodeValue =
                ((firstByteValue & 15) << 12) |
                ((nextByteValue & 63) << 6) |
                (thirdByteValue & 63);
              if (
                _decodedUnicodeValue > 2047 &&
                (_decodedUnicodeValue < 55296 || _decodedUnicodeValue > 57343)
              ) {
                decodedUnicodeValue = _decodedUnicodeValue;
              }
            }
            break;
          case 4:
            nextByteValue =
              __validateAndRetrieveIntrinsicProperties[_currentIndex + 1];
            thirdByteValue =
              __validateAndRetrieveIntrinsicProperties[_currentIndex + 2];
            decodedUnicodeValueFromBytes =
              __validateAndRetrieveIntrinsicProperties[_currentIndex + 3];
            if (
              (nextByteValue & 192) === 128 &&
              (thirdByteValue & 192) === 128 &&
              (decodedUnicodeValueFromBytes & 192) === 128
            ) {
              _decodedUnicodeValue =
                ((firstByteValue & 15) << 18) |
                ((nextByteValue & 63) << 12) |
                ((thirdByteValue & 63) << 6) |
                (decodedUnicodeValueFromBytes & 63);
              if (
                _decodedUnicodeValue > 65535 &&
                _decodedUnicodeValue < 1114112
              ) {
                decodedUnicodeValue = _decodedUnicodeValue;
              }
            }
        }
      }
      if (decodedUnicodeValue === null) {
        decodedUnicodeValue = 65533;
        byteCount = 1;
      } else if (decodedUnicodeValue > 65535) {
        decodedUnicodeValue -= 65536;
        typedArrayBuffer.push(((decodedUnicodeValue >>> 10) & 1023) | 55296);
        decodedUnicodeValue = (decodedUnicodeValue & 1023) | 56320;
      }
      typedArrayBuffer.push(decodedUnicodeValue);
      _currentIndex += byteCount;
    }
    return convertValidatePromiseToString(typedArrayBuffer);
  }
  var createUint8ArraySupportCheck = 4096;
  function convertValidatePromiseToString(validatePromiseFormat) {
    let validatePromiseLength = validatePromiseFormat.length;
    if (validatePromiseLength <= createUint8ArraySupportCheck) {
      return String.fromCharCode.apply(String, validatePromiseFormat);
    }
    let convertedString = "";
    let _________currentIndex = 0;
    while (_________currentIndex < validatePromiseLength) {
      convertedString += String.fromCharCode.apply(
        String,
        validatePromiseFormat.slice(
          _________currentIndex,
          (_________currentIndex += createUint8ArraySupportCheck),
        ),
      );
    }
    return convertedString;
  }
  function extractValidPromiseTypeChars(
    validatePromiseTypes,
    _validatePromiseFormat,
    __validatePromiseFormat,
  ) {
    let validPromiseTypeChars = "";
    __validatePromiseFormat = Math.min(
      validatePromiseTypes.length,
      __validatePromiseFormat,
    );
    for (
      let currentPromiseTypeIndex = _validatePromiseFormat;
      currentPromiseTypeIndex < __validatePromiseFormat;
      ++currentPromiseTypeIndex
    ) {
      validPromiseTypeChars += String.fromCharCode(
        validatePromiseTypes[currentPromiseTypeIndex] & 127,
      );
    }
    return validPromiseTypeChars;
  }
  function extractCharactersFromInput(
    processInput,
    validateInputType,
    validateInputObjectType,
  ) {
    let extractedCharacters = "";
    validateInputObjectType = Math.min(
      processInput.length,
      validateInputObjectType,
    );
    for (
      let inputCharacterIndex = validateInputType;
      inputCharacterIndex < validateInputObjectType;
      ++inputCharacterIndex
    ) {
      extractedCharacters += String.fromCharCode(
        processInput[inputCharacterIndex],
      );
    }
    return extractedCharacters;
  }
  function processTypedArrayConversion(
    checkObjectTypeAndConvert,
    validateAndConvertObjectType,
    _validateInputObjectType,
  ) {
    let typedArrayLength = checkObjectTypeAndConvert.length;
    if (!validateAndConvertObjectType || validateAndConvertObjectType < 0) {
      validateAndConvertObjectType = 0;
    }
    if (
      !_validateInputObjectType ||
      _validateInputObjectType < 0 ||
      _validateInputObjectType > typedArrayLength
    ) {
      _validateInputObjectType = typedArrayLength;
    }
    let concatenatedTypedArraySupport = "";
    for (
      let objectTypeValidator = validateAndConvertObjectType;
      objectTypeValidator < _validateInputObjectType;
      ++objectTypeValidator
    ) {
      concatenatedTypedArraySupport +=
        checkTypedArraySupport[checkObjectTypeAndConvert[objectTypeValidator]];
    }
    return concatenatedTypedArraySupport;
  }
  function processInputValues(
    inputValueHandler,
    _validateInputType,
    _validateAndConvertObjectType,
  ) {
    let extractedCharCodes = inputValueHandler.slice(
      _validateInputType,
      _validateAndConvertObjectType,
    );
    let _decodedString = "";
    for (
      let _charCodeIndex = 0;
      _charCodeIndex < extractedCharCodes.length - 1;
      _charCodeIndex += 2
    ) {
      _decodedString += String.fromCharCode(
        extractedCharCodes[_charCodeIndex] +
          extractedCharCodes[_charCodeIndex + 1] * 256,
      );
    }
    return _decodedString;
  }
  validatePromiseInput.prototype.slice = function (
    processObject,
    getObjectTypeValue,
  ) {
    let arrayLength = this.length;
    processObject = ~~processObject;
    if (getObjectTypeValue === undefined) {
      getObjectTypeValue = arrayLength;
    } else {
      getObjectTypeValue = ~~getObjectTypeValue;
    }
    if (processObject < 0) {
      processObject += arrayLength;
      if (processObject < 0) {
        processObject = 0;
      }
    } else if (processObject > arrayLength) {
      processObject = arrayLength;
    }
    if (getObjectTypeValue < 0) {
      getObjectTypeValue += arrayLength;
      if (getObjectTypeValue < 0) {
        getObjectTypeValue = 0;
      }
    } else if (getObjectTypeValue > arrayLength) {
      getObjectTypeValue = arrayLength;
    }
    if (getObjectTypeValue < processObject) {
      getObjectTypeValue = processObject;
    }
    let subArraySlice = this.subarray(processObject, getObjectTypeValue);
    Object.setPrototypeOf(subArraySlice, validatePromiseInput.prototype);
    return subArraySlice;
  };
  function validateBufferSize(
    validateArraySize,
    _validateArraySize,
    validateAndThrowSizeError,
  ) {
    if (validateArraySize % 1 !== 0 || validateArraySize < 0) {
      throw new RangeError("offset is not uint");
    }
    if (validateArraySize + _validateArraySize > validateAndThrowSizeError) {
      throw new RangeError("Trying to access beyond buffer length");
    }
  }
  validatePromiseInput.prototype.readUintLE =
    validatePromiseInput.prototype.readUIntLE = function (
      validateSizeArgument,
      allocateBuffer,
      _allocateBuffer,
    ) {
      validateSizeArgument = validateSizeArgument >>> 0;
      allocateBuffer = allocateBuffer >>> 0;
      if (!_allocateBuffer) {
        validateBufferSize(validateSizeArgument, allocateBuffer, this.length);
      }
      let bufferValue = this[validateSizeArgument];
      let multiplicativeFactor = 1;
      let bufferAccumulator = 0;
      while (
        ++bufferAccumulator < allocateBuffer &&
        (multiplicativeFactor *= 256)
      ) {
        bufferValue +=
          this[validateSizeArgument + bufferAccumulator] * multiplicativeFactor;
      }
      return bufferValue;
    };
  validatePromiseInput.prototype.readUintBE =
    validatePromiseInput.prototype.readUIntBE = function (
      allocateArrayWithLeadingZero,
      allocateMemoryWithValidation,
      __allocateBuffer,
    ) {
      allocateArrayWithLeadingZero = allocateArrayWithLeadingZero >>> 0;
      allocateMemoryWithValidation = allocateMemoryWithValidation >>> 0;
      if (!__allocateBuffer) {
        validateBufferSize(
          allocateArrayWithLeadingZero,
          allocateMemoryWithValidation,
          this.length,
        );
      }
      let allocatedValue =
        this[allocateArrayWithLeadingZero + --allocateMemoryWithValidation];
      let multiplierForAllocation = 1;
      while (
        allocateMemoryWithValidation > 0 &&
        (multiplierForAllocation *= 256)
      ) {
        allocatedValue +=
          this[allocateArrayWithLeadingZero + --allocateMemoryWithValidation] *
          multiplierForAllocation;
      }
      return allocatedValue;
    };
  validatePromiseInput.prototype.readUint8 =
    validatePromiseInput.prototype.readUInt8 = function (
      validateAndFillArrayType,
      validateAndExtendArrayType,
    ) {
      validateAndFillArrayType = validateAndFillArrayType >>> 0;
      if (!validateAndExtendArrayType) {
        validateBufferSize(validateAndFillArrayType, 1, this.length);
      }
      return this[validateAndFillArrayType];
    };
  validatePromiseInput.prototype.readUint16LE =
    validatePromiseInput.prototype.readUInt16LE = function (
      logUtil_allocate,
      initializeDebugLogger,
    ) {
      logUtil_allocate = logUtil_allocate >>> 0;
      if (!initializeDebugLogger) {
        validateBufferSize(logUtil_allocate, 2, this.length);
      }
      return this[logUtil_allocate] | (this[logUtil_allocate + 1] << 8);
    };
  validatePromiseInput.prototype.readUint16BE =
    validatePromiseInput.prototype.readUInt16BE = function (
      validateAndProcessBuffer,
      validateAndExtendEncoding,
    ) {
      validateAndProcessBuffer = validateAndProcessBuffer >>> 0;
      if (!validateAndExtendEncoding) {
        validateBufferSize(validateAndProcessBuffer, 2, this.length);
      }
      return (
        (this[validateAndProcessBuffer] << 8) |
        this[validateAndProcessBuffer + 1]
      );
    };
  validatePromiseInput.prototype.readUint32LE =
    validatePromiseInput.prototype.readUInt32LE = function (
      processDebugLogging,
      allocateBufferForDebugLogger,
    ) {
      processDebugLogging = processDebugLogging >>> 0;
      if (!allocateBufferForDebugLogger) {
        validateBufferSize(processDebugLogging, 4, this.length);
      }
      return (
        (this[processDebugLogging] |
          (this[processDebugLogging + 1] << 8) |
          (this[processDebugLogging + 2] << 16)) +
        this[processDebugLogging + 3] * 16777216
      );
    };
  validatePromiseInput.prototype.readUint32BE =
    validatePromiseInput.prototype.readUInt32BE = function (
      validateAndExtendArrayEncoding,
      _validateAndExtendEncoding,
    ) {
      validateAndExtendArrayEncoding = validateAndExtendArrayEncoding >>> 0;
      if (!_validateAndExtendEncoding) {
        validateBufferSize(validateAndExtendArrayEncoding, 4, this.length);
      }
      return (
        this[validateAndExtendArrayEncoding] * 16777216 +
        ((this[validateAndExtendArrayEncoding + 1] << 16) |
          (this[validateAndExtendArrayEncoding + 2] << 8) |
          this[validateAndExtendArrayEncoding + 3])
      );
    };
  validatePromiseInput.prototype.readBigUInt64LE = getIntrinsicValueOrFallback(
    function (validateAndLogPromisifiedFunction) {
      validateAndLogPromisifiedFunction =
        validateAndLogPromisifiedFunction >>> 0;
      validateAndCheckLastMatchingIndex(
        validateAndLogPromisifiedFunction,
        "offset",
      );
      let currentValue = this[validateAndLogPromisifiedFunction];
      let offsetValue = this[validateAndLogPromisifiedFunction + 7];
      if (currentValue === undefined || offsetValue === undefined) {
        validateBufferOffsetAndBounds(
          validateAndLogPromisifiedFunction,
          this.length - 8,
        );
      }
      let compositeValue =
        currentValue +
        this[++validateAndLogPromisifiedFunction] * 256 +
        this[++validateAndLogPromisifiedFunction] * 65536 +
        this[++validateAndLogPromisifiedFunction] * 16777216;
      let combinedValue =
        this[++validateAndLogPromisifiedFunction] +
        this[++validateAndLogPromisifiedFunction] * 256 +
        this[++validateAndLogPromisifiedFunction] * 65536 +
        offsetValue * 16777216;
      return BigInt(compositeValue) + (BigInt(combinedValue) << BigInt(32));
    },
  );
  validatePromiseInput.prototype.readBigUInt64BE = getIntrinsicValueOrFallback(
    function (validateBufferAndLog) {
      validateBufferAndLog = validateBufferAndLog >>> 0;
      validateAndCheckLastMatchingIndex(validateBufferAndLog, "offset");
      let bufferValueAtOffset = this[validateBufferAndLog];
      let bufferValueNextToOffset = this[validateBufferAndLog + 7];
      if (
        bufferValueAtOffset === undefined ||
        bufferValueNextToOffset === undefined
      ) {
        validateBufferOffsetAndBounds(validateBufferAndLog, this.length - 8);
      }
      let combinedBufferValue =
        bufferValueAtOffset * 16777216 +
        this[++validateBufferAndLog] * 65536 +
        this[++validateBufferAndLog] * 256 +
        this[++validateBufferAndLog];
      let nextBufferValue =
        this[++validateBufferAndLog] * 16777216 +
        this[++validateBufferAndLog] * 65536 +
        this[++validateBufferAndLog] * 256 +
        bufferValueNextToOffset;
      return (
        (BigInt(combinedBufferValue) << BigInt(32)) + BigInt(nextBufferValue)
      );
    },
  );
  validatePromiseInput.prototype.readIntLE = function (
    getByteArrayFromBuffer,
    createUint8ArrayFromBuffer,
    createTypedArrayFromBuffer,
  ) {
    getByteArrayFromBuffer = getByteArrayFromBuffer >>> 0;
    createUint8ArrayFromBuffer = createUint8ArrayFromBuffer >>> 0;
    if (!createTypedArrayFromBuffer) {
      validateBufferSize(
        getByteArrayFromBuffer,
        createUint8ArrayFromBuffer,
        this.length,
      );
    }
    let ___decodedValue = this[getByteArrayFromBuffer];
    let multiplier = 1;
    let __byteIndex = 0;
    while (++__byteIndex < createUint8ArrayFromBuffer && (multiplier *= 256)) {
      ___decodedValue +=
        this[getByteArrayFromBuffer + __byteIndex] * multiplier;
    }
    multiplier *= 128;
    if (___decodedValue >= multiplier) {
      ___decodedValue -= Math.pow(2, createUint8ArrayFromBuffer * 8);
    }
    return ___decodedValue;
  };
  validatePromiseInput.prototype.readIntBE = function (
    createUint8ArrayFromLoggingInstance,
    createBufferFromLoggingProcess,
    initializeAndLogBuffer,
  ) {
    createUint8ArrayFromLoggingInstance =
      createUint8ArrayFromLoggingInstance >>> 0;
    createBufferFromLoggingProcess = createBufferFromLoggingProcess >>> 0;
    if (!initializeAndLogBuffer) {
      validateBufferSize(
        createUint8ArrayFromLoggingInstance,
        createBufferFromLoggingProcess,
        this.length,
      );
    }
    let remainingBytes = createBufferFromLoggingProcess;
    let multiplierForEncoding = 1;
    let __decodedValue =
      this[createUint8ArrayFromLoggingInstance + --remainingBytes];
    while (remainingBytes > 0 && (multiplierForEncoding *= 256)) {
      __decodedValue +=
        this[createUint8ArrayFromLoggingInstance + --remainingBytes] *
        multiplierForEncoding;
    }
    multiplierForEncoding *= 128;
    if (__decodedValue >= multiplierForEncoding) {
      __decodedValue -= Math.pow(2, createBufferFromLoggingProcess * 8);
    }
    return __decodedValue;
  };
  validatePromiseInput.prototype.readInt8 = function (
    _debugLogForInstanceHandler,
    processLoggingData,
  ) {
    _debugLogForInstanceHandler = _debugLogForInstanceHandler >>> 0;
    if (!processLoggingData) {
      validateBufferSize(_debugLogForInstanceHandler, 1, this.length);
    }
    if (this[_debugLogForInstanceHandler] & 128) {
      return (255 - this[_debugLogForInstanceHandler] + 1) * -1;
    } else {
      return this[_debugLogForInstanceHandler];
    }
  };
  validatePromiseInput.prototype.readInt16LE = function (
    _handleLoggingProcess,
    __handleLoggingProcess,
  ) {
    _handleLoggingProcess = _handleLoggingProcess >>> 0;
    if (!__handleLoggingProcess) {
      validateBufferSize(_handleLoggingProcess, 2, this.length);
    }
    let combinedLoggingProcessValue =
      this[_handleLoggingProcess] | (this[_handleLoggingProcess + 1] << 8);
    if (combinedLoggingProcessValue & 32768) {
      return combinedLoggingProcessValue | 4294901760;
    } else {
      return combinedLoggingProcessValue;
    }
  };
  validatePromiseInput.prototype.readInt16BE = function (
    handleLoggingProcessData,
    validateDebugLogSize,
  ) {
    handleLoggingProcessData = handleLoggingProcessData >>> 0;
    if (!validateDebugLogSize) {
      validateBufferSize(handleLoggingProcessData, 2, this.length);
    }
    let combinedLogData =
      this[handleLoggingProcessData + 1] |
      (this[handleLoggingProcessData] << 8);
    if (combinedLogData & 32768) {
      return combinedLogData | 4294901760;
    } else {
      return combinedLogData;
    }
  };
  validatePromiseInput.prototype.readInt32LE = function (
    __debugLogForInstance,
    __debugLogForInstanceHandler,
  ) {
    __debugLogForInstance = __debugLogForInstance >>> 0;
    if (!__debugLogForInstanceHandler) {
      validateBufferSize(__debugLogForInstance, 4, this.length);
    }
    return (
      this[__debugLogForInstance] |
      (this[__debugLogForInstance + 1] << 8) |
      (this[__debugLogForInstance + 2] << 16) |
      (this[__debugLogForInstance + 3] << 24)
    );
  };
  validatePromiseInput.prototype.readInt32BE = function (
    compareBuffers,
    _compareBuffers,
  ) {
    compareBuffers = compareBuffers >>> 0;
    if (!_compareBuffers) {
      validateBufferSize(compareBuffers, 4, this.length);
    }
    return (
      (this[compareBuffers] << 24) |
      (this[compareBuffers + 1] << 16) |
      (this[compareBuffers + 2] << 8) |
      this[compareBuffers + 3]
    );
  };
  validatePromiseInput.prototype.readBigInt64LE = getIntrinsicValueOrFallback(
    function (__compareBuffers) {
      __compareBuffers = __compareBuffers >>> 0;
      validateAndCheckLastMatchingIndex(__compareBuffers, "offset");
      let currentBufferValue = this[__compareBuffers];
      let _nextBufferValue = this[__compareBuffers + 7];
      if (currentBufferValue === undefined || _nextBufferValue === undefined) {
        validateBufferOffsetAndBounds(__compareBuffers, this.length - 8);
      }
      let _combinedBufferValue =
        this[__compareBuffers + 4] +
        this[__compareBuffers + 5] * 256 +
        this[__compareBuffers + 6] * 65536 +
        (_nextBufferValue << 24);
      return (
        (BigInt(_combinedBufferValue) << BigInt(32)) +
        BigInt(
          currentBufferValue +
            this[++__compareBuffers] * 256 +
            this[++__compareBuffers] * 65536 +
            this[++__compareBuffers] * 16777216,
        )
      );
    },
  );
  validatePromiseInput.prototype.readBigInt64BE = getIntrinsicValueOrFallback(
    function (compareBuffersAndReturnOrder) {
      compareBuffersAndReturnOrder = compareBuffersAndReturnOrder >>> 0;
      validateAndCheckLastMatchingIndex(compareBuffersAndReturnOrder, "offset");
      let _currentBufferValue = this[compareBuffersAndReturnOrder];
      let __nextBufferValue = this[compareBuffersAndReturnOrder + 7];
      if (
        _currentBufferValue === undefined ||
        __nextBufferValue === undefined
      ) {
        validateBufferOffsetAndBounds(
          compareBuffersAndReturnOrder,
          this.length - 8,
        );
      }
      let __combinedBufferValue =
        (_currentBufferValue << 24) +
        this[++compareBuffersAndReturnOrder] * 65536 +
        this[++compareBuffersAndReturnOrder] * 256 +
        this[++compareBuffersAndReturnOrder];
      return (
        (BigInt(__combinedBufferValue) << BigInt(32)) +
        BigInt(
          this[++compareBuffersAndReturnOrder] * 16777216 +
            this[++compareBuffersAndReturnOrder] * 65536 +
            this[++compareBuffersAndReturnOrder] * 256 +
            __nextBufferValue,
        )
      );
    },
  );
  validatePromiseInput.prototype.readFloatLE = function (
    compareEncodedValues,
    getBufferComparisonResult,
  ) {
    compareEncodedValues = compareEncodedValues >>> 0;
    if (!getBufferComparisonResult) {
      validateBufferSize(compareEncodedValues, 4, this.length);
    }
    return getIntrinsicPropertyDescriptor.read(
      this,
      compareEncodedValues,
      true,
      23,
      4,
    );
  };
  validatePromiseInput.prototype.readFloatBE = function (
    bufferConcat,
    validateAndConcatBufferList,
  ) {
    bufferConcat = bufferConcat >>> 0;
    if (!validateAndConcatBufferList) {
      validateBufferSize(bufferConcat, 4, this.length);
    }
    return getIntrinsicPropertyDescriptor.read(
      this,
      bufferConcat,
      false,
      23,
      4,
    );
  };
  validatePromiseInput.prototype.readDoubleLE = function (
    concatArrayBuffers,
    validateAndInspectBufferConcat,
  ) {
    concatArrayBuffers = concatArrayBuffers >>> 0;
    if (!validateAndInspectBufferConcat) {
      validateBufferSize(concatArrayBuffers, 8, this.length);
    }
    return getIntrinsicPropertyDescriptor.read(
      this,
      concatArrayBuffers,
      true,
      52,
      8,
    );
  };
  validatePromiseInput.prototype.readDoubleBE = function (
    validateAndConcatenateBufferArrays,
    _concatArrayBuffers,
  ) {
    validateAndConcatenateBufferArrays =
      validateAndConcatenateBufferArrays >>> 0;
    if (!_concatArrayBuffers) {
      validateBufferSize(validateAndConcatenateBufferArrays, 8, this.length);
    }
    return getIntrinsicPropertyDescriptor.read(
      this,
      validateAndConcatenateBufferArrays,
      false,
      52,
      8,
    );
  };
  function validateAndProcessBufferArguments(
    validateAndConcatenateBuffers,
    validateAndMergeArrayBuffers,
    validateAndCombineArrayBuffers,
    validateAndConcatArrayBuffers,
    _validateAndProcessArrayBuffer,
    validateAndConcatBuffers,
  ) {
    if (!validatePromiseInput.isBuffer(validateAndConcatenateBuffers)) {
      throw new TypeError('"buffer" argument must be a Buffer instance');
    }
    if (
      validateAndMergeArrayBuffers > _validateAndProcessArrayBuffer ||
      validateAndMergeArrayBuffers < validateAndConcatBuffers
    ) {
      throw new RangeError('"value" argument is out of bounds');
    }
    if (
      validateAndCombineArrayBuffers + validateAndConcatArrayBuffers >
      validateAndConcatenateBuffers.length
    ) {
      throw new RangeError("Index out of range");
    }
  }
  validatePromiseInput.prototype.writeUintLE =
    validatePromiseInput.prototype.writeUIntLE = function (
      bufferDataLength,
      copyAndValidateArrayBuffer,
      bufferCapacity,
      arrayBufferIndex,
    ) {
      bufferDataLength = +bufferDataLength;
      copyAndValidateArrayBuffer = copyAndValidateArrayBuffer >>> 0;
      bufferCapacity = bufferCapacity >>> 0;
      if (!arrayBufferIndex) {
        let maxBufferIndex = Math.pow(2, bufferCapacity * 8) - 1;
        validateAndProcessBufferArguments(
          this,
          bufferDataLength,
          copyAndValidateArrayBuffer,
          bufferCapacity,
          maxBufferIndex,
          0,
        );
      }
      let dataScalingFactor = 1;
      let index = 0;
      for (
        this[copyAndValidateArrayBuffer] = bufferDataLength & 255;
        ++index < bufferCapacity && (dataScalingFactor *= 256);

      ) {
        this[copyAndValidateArrayBuffer + index] =
          (bufferDataLength / dataScalingFactor) & 255;
      }
      return copyAndValidateArrayBuffer + bufferCapacity;
    };
  validatePromiseInput.prototype.writeUintBE =
    validatePromiseInput.prototype.writeUIntBE = function (
      copyBuffersAndUpdateOffset,
      _bufferConcat,
      isBufferOrArrayBuffer,
      bufferLengthCheck,
    ) {
      copyBuffersAndUpdateOffset = +copyBuffersAndUpdateOffset;
      _bufferConcat = _bufferConcat >>> 0;
      isBufferOrArrayBuffer = isBufferOrArrayBuffer >>> 0;
      if (!bufferLengthCheck) {
        let maxBufferValue = Math.pow(2, isBufferOrArrayBuffer * 8) - 1;
        validateAndProcessBufferArguments(
          this,
          copyBuffersAndUpdateOffset,
          _bufferConcat,
          isBufferOrArrayBuffer,
          maxBufferValue,
          0,
        );
      }
      let bufferOffset = isBufferOrArrayBuffer - 1;
      let bufferMultiplier = 1;
      for (
        this[_bufferConcat + bufferOffset] = copyBuffersAndUpdateOffset & 255;
        --bufferOffset >= 0 && (bufferMultiplier *= 256);

      ) {
        this[_bufferConcat + bufferOffset] =
          (copyBuffersAndUpdateOffset / bufferMultiplier) & 255;
      }
      return _bufferConcat + isBufferOrArrayBuffer;
    };
  validatePromiseInput.prototype.writeUint8 =
    validatePromiseInput.prototype.writeUInt8 = function (
      exportedRandomValueLength,
      _exportedRandomValueLength,
      getRandomValueLength,
    ) {
      exportedRandomValueLength = +exportedRandomValueLength;
      _exportedRandomValueLength = _exportedRandomValueLength >>> 0;
      if (!getRandomValueLength) {
        validateAndProcessBufferArguments(
          this,
          exportedRandomValueLength,
          _exportedRandomValueLength,
          1,
          255,
          0,
        );
      }
      this[_exportedRandomValueLength] = exportedRandomValueLength & 255;
      return _exportedRandomValueLength + 1;
    };
  validatePromiseInput.prototype.writeUint16LE =
    validatePromiseInput.prototype.writeUInt16LE = function (
      checkRandomValueType,
      getEncodedValueLength,
      getExportedRandomValueLength,
    ) {
      checkRandomValueType = +checkRandomValueType;
      getEncodedValueLength = getEncodedValueLength >>> 0;
      if (!getExportedRandomValueLength) {
        validateAndProcessBufferArguments(
          this,
          checkRandomValueType,
          getEncodedValueLength,
          2,
          65535,
          0,
        );
      }
      this[getEncodedValueLength] = checkRandomValueType & 255;
      this[getEncodedValueLength + 1] = checkRandomValueType >>> 8;
      return getEncodedValueLength + 2;
    };
  validatePromiseInput.prototype.writeUint16BE =
    validatePromiseInput.prototype.writeUInt16BE = function (
      calculateByteLengthBasedOnEncoding,
      getByteLengthBasedOnEncoding,
      shouldReturnZeroIfConditionsNotMet,
    ) {
      calculateByteLengthBasedOnEncoding = +calculateByteLengthBasedOnEncoding;
      getByteLengthBasedOnEncoding = getByteLengthBasedOnEncoding >>> 0;
      if (!shouldReturnZeroIfConditionsNotMet) {
        validateAndProcessBufferArguments(
          this,
          calculateByteLengthBasedOnEncoding,
          getByteLengthBasedOnEncoding,
          2,
          65535,
          0,
        );
      }
      this[getByteLengthBasedOnEncoding] =
        calculateByteLengthBasedOnEncoding >>> 8;
      this[getByteLengthBasedOnEncoding + 1] =
        calculateByteLengthBasedOnEncoding & 255;
      return getByteLengthBasedOnEncoding + 2;
    };
  validatePromiseInput.prototype.writeUint32LE =
    validatePromiseInput.prototype.writeUInt32LE = function (
      _getExportedRandomValueLength,
      getEncodedByteLength,
      randomValueLengthCalculator,
    ) {
      _getExportedRandomValueLength = +_getExportedRandomValueLength;
      getEncodedByteLength = getEncodedByteLength >>> 0;
      if (!randomValueLengthCalculator) {
        validateAndProcessBufferArguments(
          this,
          _getExportedRandomValueLength,
          getEncodedByteLength,
          4,
          4294967295,
          0,
        );
      }
      this[getEncodedByteLength + 3] = _getExportedRandomValueLength >>> 24;
      this[getEncodedByteLength + 2] = _getExportedRandomValueLength >>> 16;
      this[getEncodedByteLength + 1] = _getExportedRandomValueLength >>> 8;
      this[getEncodedByteLength] = _getExportedRandomValueLength & 255;
      return getEncodedByteLength + 4;
    };
  validatePromiseInput.prototype.writeUint32BE =
    validatePromiseInput.prototype.writeUInt32BE = function (
      generateRandomValueLength,
      _generateUniqueIdentifier,
      getSubStringWithEncoding,
    ) {
      generateRandomValueLength = +generateRandomValueLength;
      _generateUniqueIdentifier = _generateUniqueIdentifier >>> 0;
      if (!getSubStringWithEncoding) {
        validateAndProcessBufferArguments(
          this,
          generateRandomValueLength,
          _generateUniqueIdentifier,
          4,
          4294967295,
          0,
        );
      }
      this[_generateUniqueIdentifier] = generateRandomValueLength >>> 24;
      this[_generateUniqueIdentifier + 1] = generateRandomValueLength >>> 16;
      this[_generateUniqueIdentifier + 2] = generateRandomValueLength >>> 8;
      this[_generateUniqueIdentifier + 3] = generateRandomValueLength & 255;
      return _generateUniqueIdentifier + 4;
    };
  function processAndStoreEncodingData(
    lengthCheckStart,
    getSubstringWithEncoding,
    generateUniqueIdentifierAndIdWithFormat,
    generateStringFromIdentifier,
    generateUniqueSubstring,
  ) {
    validateAndDescribePropertyRange(
      getSubstringWithEncoding,
      generateStringFromIdentifier,
      generateUniqueSubstring,
      lengthCheckStart,
      generateUniqueIdentifierAndIdWithFormat,
      7,
    );
    let _decodedValue = Number(getSubstringWithEncoding & BigInt(4294967295));
    lengthCheckStart[generateUniqueIdentifierAndIdWithFormat++] = _decodedValue;
    _decodedValue = _decodedValue >> 8;
    lengthCheckStart[generateUniqueIdentifierAndIdWithFormat++] = _decodedValue;
    _decodedValue = _decodedValue >> 8;
    lengthCheckStart[generateUniqueIdentifierAndIdWithFormat++] = _decodedValue;
    _decodedValue = _decodedValue >> 8;
    lengthCheckStart[generateUniqueIdentifierAndIdWithFormat++] = _decodedValue;
    let highOrderDecodedValue = Number(
      (getSubstringWithEncoding >> BigInt(32)) & BigInt(4294967295),
    );
    lengthCheckStart[generateUniqueIdentifierAndIdWithFormat++] =
      highOrderDecodedValue;
    highOrderDecodedValue = highOrderDecodedValue >> 8;
    lengthCheckStart[generateUniqueIdentifierAndIdWithFormat++] =
      highOrderDecodedValue;
    highOrderDecodedValue = highOrderDecodedValue >> 8;
    lengthCheckStart[generateUniqueIdentifierAndIdWithFormat++] =
      highOrderDecodedValue;
    highOrderDecodedValue = highOrderDecodedValue >> 8;
    lengthCheckStart[generateUniqueIdentifierAndIdWithFormat++] =
      highOrderDecodedValue;
    return generateUniqueIdentifierAndIdWithFormat;
  }
  function processAndEncodeDataBuffer(
    processAndEncodeData,
    processDataByEncoding,
    _processAndMapCharacterData,
    processAndTransformCharacterData,
    processCharacterDataAndRetrieve,
  ) {
    validateAndDescribePropertyRange(
      processDataByEncoding,
      processAndTransformCharacterData,
      processCharacterDataAndRetrieve,
      processAndEncodeData,
      _processAndMapCharacterData,
      7,
    );
    let encodedLower32Bit = Number(processDataByEncoding & BigInt(4294967295));
    processAndEncodeData[_processAndMapCharacterData + 7] = encodedLower32Bit;
    encodedLower32Bit = encodedLower32Bit >> 8;
    processAndEncodeData[_processAndMapCharacterData + 6] = encodedLower32Bit;
    encodedLower32Bit = encodedLower32Bit >> 8;
    processAndEncodeData[_processAndMapCharacterData + 5] = encodedLower32Bit;
    encodedLower32Bit = encodedLower32Bit >> 8;
    processAndEncodeData[_processAndMapCharacterData + 4] = encodedLower32Bit;
    let encodedUpper32Bit = Number(
      (processDataByEncoding >> BigInt(32)) & BigInt(4294967295),
    );
    processAndEncodeData[_processAndMapCharacterData + 3] = encodedUpper32Bit;
    encodedUpper32Bit = encodedUpper32Bit >> 8;
    processAndEncodeData[_processAndMapCharacterData + 2] = encodedUpper32Bit;
    encodedUpper32Bit = encodedUpper32Bit >> 8;
    processAndEncodeData[_processAndMapCharacterData + 1] = encodedUpper32Bit;
    encodedUpper32Bit = encodedUpper32Bit >> 8;
    processAndEncodeData[_processAndMapCharacterData] = encodedUpper32Bit;
    return _processAndMapCharacterData + 8;
  }
  validatePromiseInput.prototype.writeBigUInt64LE = getIntrinsicValueOrFallback(
    function (swapBufferEndian, ___initialValue = 0) {
      return processAndStoreEncodingData(
        this,
        swapBufferEndian,
        ___initialValue,
        BigInt(0),
        BigInt("0xffffffffffffffff"),
      );
    },
  );
  validatePromiseInput.prototype.writeBigUInt64BE = getIntrinsicValueOrFallback(
    function (swapBufferEndianness, ____initialValue = 0) {
      return processAndEncodeDataBuffer(
        this,
        swapBufferEndianness,
        ____initialValue,
        BigInt(0),
        BigInt("0xffffffffffffffff"),
      );
    },
  );
  validatePromiseInput.prototype.writeIntLE = function (
    swapBufferElements,
    swapBufferBytes,
    _swapBufferElements,
    swapBuffer,
  ) {
    swapBufferElements = +swapBufferElements;
    swapBufferBytes = swapBufferBytes >>> 0;
    if (!swapBuffer) {
      let maxBufferThreshold = Math.pow(2, _swapBufferElements * 8 - 1);
      validateAndProcessBufferArguments(
        this,
        swapBufferElements,
        swapBufferBytes,
        _swapBufferElements,
        maxBufferThreshold - 1,
        -maxBufferThreshold,
      );
    }
    let _byteIndex = 0;
    let _byteMultiplier = 1;
    let isNegativeFlag = 0;
    for (
      this[swapBufferBytes] = swapBufferElements & 255;
      ++_byteIndex < _swapBufferElements && (_byteMultiplier *= 256);

    ) {
      if (
        swapBufferElements < 0 &&
        isNegativeFlag === 0 &&
        this[swapBufferBytes + _byteIndex - 1] !== 0
      ) {
        isNegativeFlag = 1;
      }
      this[swapBufferBytes + _byteIndex] =
        (((swapBufferElements / _byteMultiplier) >> 0) - isNegativeFlag) & 255;
    }
    return swapBufferBytes + _swapBufferElements;
  };
  validatePromiseInput.prototype.writeIntBE = function (
    swapBytes32,
    swapBufferEndianess,
    swap32,
    bufferValidator,
  ) {
    swapBytes32 = +swapBytes32;
    swapBufferEndianess = swapBufferEndianess >>> 0;
    if (!bufferValidator) {
      let maxPowerOfTwo = Math.pow(2, swap32 * 8 - 1);
      validateAndProcessBufferArguments(
        this,
        swapBytes32,
        swapBufferEndianess,
        swap32,
        maxPowerOfTwo - 1,
        -maxPowerOfTwo,
      );
    }
    let swappedByteIndex = swap32 - 1;
    let byteMultiplier = 1;
    let negativeByteAdjustmentFlag = 0;
    for (
      this[swapBufferEndianess + swappedByteIndex] = swapBytes32 & 255;
      --swappedByteIndex >= 0 && (byteMultiplier *= 256);

    ) {
      if (
        swapBytes32 < 0 &&
        negativeByteAdjustmentFlag === 0 &&
        this[swapBufferEndianess + swappedByteIndex + 1] !== 0
      ) {
        negativeByteAdjustmentFlag = 1;
      }
      this[swapBufferEndianess + swappedByteIndex] =
        (((swapBytes32 / byteMultiplier) >> 0) - negativeByteAdjustmentFlag) &
        255;
    }
    return swapBufferEndianess + swap32;
  };
  validatePromiseInput.prototype.writeInt8 = function (
    processBufferData,
    inspectBuffer,
    getBufferHexRepresentation,
  ) {
    processBufferData = +processBufferData;
    inspectBuffer = inspectBuffer >>> 0;
    if (!getBufferHexRepresentation) {
      validateAndProcessBufferArguments(
        this,
        processBufferData,
        inspectBuffer,
        1,
        127,
        -128,
      );
    }
    if (processBufferData < 0) {
      processBufferData = 255 + processBufferData + 1;
    }
    this[inspectBuffer] = processBufferData & 255;
    return inspectBuffer + 1;
  };
  validatePromiseInput.prototype.writeInt16LE = function (
    ___compareBuffers,
    ____compareBuffers,
    _____compareBuffers,
  ) {
    ___compareBuffers = +___compareBuffers;
    ____compareBuffers = ____compareBuffers >>> 0;
    if (!_____compareBuffers) {
      validateAndProcessBufferArguments(
        this,
        ___compareBuffers,
        ____compareBuffers,
        2,
        32767,
        -32768,
      );
    }
    this[____compareBuffers] = ___compareBuffers & 255;
    this[____compareBuffers + 1] = ___compareBuffers >>> 8;
    return ____compareBuffers + 2;
  };
  validatePromiseInput.prototype.writeInt16BE = function (
    isBufferAndCompare,
    bufferComparisonFunction,
    bufferComparison,
  ) {
    isBufferAndCompare = +isBufferAndCompare;
    bufferComparisonFunction = bufferComparisonFunction >>> 0;
    if (!bufferComparison) {
      validateAndProcessBufferArguments(
        this,
        isBufferAndCompare,
        bufferComparisonFunction,
        2,
        32767,
        -32768,
      );
    }
    this[bufferComparisonFunction] = isBufferAndCompare >>> 8;
    this[bufferComparisonFunction + 1] = isBufferAndCompare & 255;
    return bufferComparisonFunction + 2;
  };
  validatePromiseInput.prototype.writeInt32LE = function (
    compareBufferData,
    MAX_BUFFER_BYTES,
    _inspectBuffer,
  ) {
    compareBufferData = +compareBufferData;
    MAX_BUFFER_BYTES = MAX_BUFFER_BYTES >>> 0;
    if (!_inspectBuffer) {
      validateAndProcessBufferArguments(
        this,
        compareBufferData,
        MAX_BUFFER_BYTES,
        4,
        2147483647,
        -2147483648,
      );
    }
    this[MAX_BUFFER_BYTES] = compareBufferData & 255;
    this[MAX_BUFFER_BYTES + 1] = compareBufferData >>> 8;
    this[MAX_BUFFER_BYTES + 2] = compareBufferData >>> 16;
    this[MAX_BUFFER_BYTES + 3] = compareBufferData >>> 24;
    return MAX_BUFFER_BYTES + 4;
  };
  validatePromiseInput.prototype.writeInt32BE = function (
    processDataBufferHandler,
    processEncodedData,
    bufferProcessingFunction,
  ) {
    processDataBufferHandler = +processDataBufferHandler;
    processEncodedData = processEncodedData >>> 0;
    if (!bufferProcessingFunction) {
      validateAndProcessBufferArguments(
        this,
        processDataBufferHandler,
        processEncodedData,
        4,
        2147483647,
        -2147483648,
      );
    }
    if (processDataBufferHandler < 0) {
      processDataBufferHandler = 4294967295 + processDataBufferHandler + 1;
    }
    this[processEncodedData] = processDataBufferHandler >>> 24;
    this[processEncodedData + 1] = processDataBufferHandler >>> 16;
    this[processEncodedData + 2] = processDataBufferHandler >>> 8;
    this[processEncodedData + 3] = processDataBufferHandler & 255;
    return processEncodedData + 4;
  };
  validatePromiseInput.prototype.writeBigInt64LE = getIntrinsicValueOrFallback(
    function (_processData, _____initialValue = 0) {
      return processAndStoreEncodingData(
        this,
        _processData,
        _____initialValue,
        -BigInt("0x8000000000000000"),
        BigInt("0x7fffffffffffffff"),
      );
    },
  );
  validatePromiseInput.prototype.writeBigInt64BE = getIntrinsicValueOrFallback(
    function (validateAndRetrieveEncodedData, initialPrice = 0) {
      return processAndEncodeDataBuffer(
        this,
        validateAndRetrieveEncodedData,
        initialPrice,
        -BigInt("0x8000000000000000"),
        BigInt("0x7fffffffffffffff"),
      );
    },
  );
  function validateIndexBounds(
    getDataByIndex,
    outputIndexComparison,
    calculateIndexComparisonResult,
    checkAndProcessEncodedData,
    compareCharCodeAndExtractedData,
    charCodeIndex,
  ) {
    if (
      calculateIndexComparisonResult + checkAndProcessEncodedData >
      getDataByIndex.length
    ) {
      throw new RangeError("Index out of range");
    }
    if (calculateIndexComparisonResult < 0) {
      throw new RangeError("Index out of range");
    }
  }
  function validateAndCompareFunction(
    validateAndCompareProperties,
    validateDataIndices,
    compareValuesAndSliceData,
    indexValidatorAndRetriever,
    validateAndCompareEncodedDataIndices,
  ) {
    validateDataIndices = +validateDataIndices;
    compareValuesAndSliceData = compareValuesAndSliceData >>> 0;
    if (!validateAndCompareEncodedDataIndices) {
      validateIndexBounds(
        validateAndCompareProperties,
        validateDataIndices,
        compareValuesAndSliceData,
        4,
        3.4028234663852886e38,
        -3.4028234663852886e38,
      );
    }
    getIntrinsicPropertyDescriptor.write(
      validateAndCompareProperties,
      validateDataIndices,
      compareValuesAndSliceData,
      indexValidatorAndRetriever,
      23,
      4,
    );
    return compareValuesAndSliceData + 4;
  }
  validatePromiseInput.prototype.writeFloatLE = function (
    validateAndExtractData,
    compareEncodedDataRanges,
    compareEncodedDataSegments,
  ) {
    return validateAndCompareFunction(
      this,
      validateAndExtractData,
      compareEncodedDataRanges,
      true,
      compareEncodedDataSegments,
    );
  };
  validatePromiseInput.prototype.writeFloatBE = function (
    _compareEncodedDataSegments,
    __compareEncodedDataSegments,
    compareEncodedData,
  ) {
    return validateAndCompareFunction(
      this,
      _compareEncodedDataSegments,
      __compareEncodedDataSegments,
      false,
      compareEncodedData,
    );
  };
  function _processEncodedDataComparison(
    compareStringSegments,
    compareEncodedDataSections,
    extractAndProcessData,
    _processEncodedData,
    validateAndCompareEncodedData,
  ) {
    compareEncodedDataSections = +compareEncodedDataSections;
    extractAndProcessData = extractAndProcessData >>> 0;
    if (!validateAndCompareEncodedData) {
      validateIndexBounds(
        compareStringSegments,
        compareEncodedDataSections,
        extractAndProcessData,
        8,
        1.7976931348623157e308,
        -1.7976931348623157e308,
      );
    }
    getIntrinsicPropertyDescriptor.write(
      compareStringSegments,
      compareEncodedDataSections,
      extractAndProcessData,
      _processEncodedData,
      52,
      8,
    );
    return extractAndProcessData + 8;
  }
  validatePromiseInput.prototype.writeDoubleLE = function (
    processAndCompareEncodedData,
    processEncodedDataComparison,
    ___compareEncodedDataSegments,
  ) {
    return _processEncodedDataComparison(
      this,
      processAndCompareEncodedData,
      processEncodedDataComparison,
      true,
      ___compareEncodedDataSegments,
    );
  };
  validatePromiseInput.prototype.writeDoubleBE = function (
    _compareEncodedData,
    ____compareEncodedDataSegments,
    compareEncodedDataValues,
  ) {
    return _processEncodedDataComparison(
      this,
      _compareEncodedData,
      ____compareEncodedDataSegments,
      false,
      compareEncodedDataValues,
    );
  };
  validatePromiseInput.prototype.copy = function (
    compareProcessedDataSegments,
    __compareEncodedData,
    compareProcessedData,
    compareTwoArrays,
  ) {
    if (!validatePromiseInput.isBuffer(compareProcessedDataSegments)) {
      throw new TypeError("argument should be a Buffer");
    }
    compareProcessedData ||= 0;
    if (!compareTwoArrays && compareTwoArrays !== 0) {
      compareTwoArrays = this.length;
    }
    if (__compareEncodedData >= compareProcessedDataSegments.length) {
      __compareEncodedData = compareProcessedDataSegments.length;
    }
    __compareEncodedData ||= 0;
    if (compareTwoArrays > 0 && compareTwoArrays < compareProcessedData) {
      compareTwoArrays = compareProcessedData;
    }
    if (
      compareTwoArrays === compareProcessedData ||
      compareProcessedDataSegments.length === 0 ||
      this.length === 0
    ) {
      return 0;
    }
    if (__compareEncodedData < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (compareProcessedData < 0 || compareProcessedData >= this.length) {
      throw new RangeError("Index out of range");
    }
    if (compareTwoArrays < 0) {
      throw new RangeError("sourceEnd out of bounds");
    }
    if (compareTwoArrays > this.length) {
      compareTwoArrays = this.length;
    }
    if (
      compareProcessedDataSegments.length - __compareEncodedData <
      compareTwoArrays - compareProcessedData
    ) {
      compareTwoArrays =
        compareProcessedDataSegments.length -
        __compareEncodedData +
        compareProcessedData;
    }
    let getValidCompareIndex = compareTwoArrays - compareProcessedData;
    if (
      this === compareProcessedDataSegments &&
      typeof Uint8Array.prototype.copyWithin == "function"
    ) {
      this.copyWithin(
        __compareEncodedData,
        compareProcessedData,
        compareTwoArrays,
      );
    } else {
      Uint8Array.prototype.set.call(
        compareProcessedDataSegments,
        this.subarray(compareProcessedData, compareTwoArrays),
        __compareEncodedData,
      );
    }
    return getValidCompareIndex;
  };
  validatePromiseInput.prototype.fill = function (
    validatedSegmentIndex,
    propertySegmentIndex,
    _retrievePropertySegment,
    validatedPropertySegment,
  ) {
    if (typeof validatedSegmentIndex == "string") {
      if (typeof propertySegmentIndex == "string") {
        validatedPropertySegment = propertySegmentIndex;
        propertySegmentIndex = 0;
        _retrievePropertySegment = this.length;
      } else if (typeof _retrievePropertySegment == "string") {
        validatedPropertySegment = _retrievePropertySegment;
        _retrievePropertySegment = this.length;
      }
      if (
        validatedPropertySegment !== undefined &&
        typeof validatedPropertySegment != "string"
      ) {
        throw new TypeError("encoding must be a string");
      }
      if (
        typeof validatedPropertySegment == "string" &&
        !validatePromiseInput.isEncoding(validatedPropertySegment)
      ) {
        throw new TypeError("Unknown encoding: " + validatedPropertySegment);
      }
      if (validatedSegmentIndex.length === 1) {
        let segmentCharCode = validatedSegmentIndex.charCodeAt(0);
        if (
          (validatedPropertySegment === "utf8" && segmentCharCode < 128) ||
          validatedPropertySegment === "latin1"
        ) {
          validatedSegmentIndex = segmentCharCode;
        }
      }
    } else if (typeof validatedSegmentIndex == "number") {
      validatedSegmentIndex = validatedSegmentIndex & 255;
    } else if (typeof validatedSegmentIndex == "boolean") {
      validatedSegmentIndex = Number(validatedSegmentIndex);
    }
    if (
      propertySegmentIndex < 0 ||
      this.length < propertySegmentIndex ||
      this.length < _retrievePropertySegment
    ) {
      throw new RangeError("Out of range index");
    }
    if (_retrievePropertySegment <= propertySegmentIndex) {
      return this;
    }
    propertySegmentIndex = propertySegmentIndex >>> 0;
    if (_retrievePropertySegment === undefined) {
      _retrievePropertySegment = this.length;
    } else {
      _retrievePropertySegment = _retrievePropertySegment >>> 0;
    }
    validatedSegmentIndex ||= 0;
    let charCodeValidatedIndex;
    if (typeof validatedSegmentIndex == "number") {
      for (
        charCodeValidatedIndex = propertySegmentIndex;
        charCodeValidatedIndex < _retrievePropertySegment;
        ++charCodeValidatedIndex
      ) {
        this[charCodeValidatedIndex] = validatedSegmentIndex;
      }
    } else {
      let validatedBuffer = validatePromiseInput.isBuffer(validatedSegmentIndex)
        ? validatedSegmentIndex
        : validatePromiseInput.from(
            validatedSegmentIndex,
            validatedPropertySegment,
          );
      let validatedBufferLength = validatedBuffer.length;
      if (validatedBufferLength === 0) {
        throw new TypeError(
          'The value "' +
            validatedSegmentIndex +
            '" is invalid for argument "value"',
        );
      }
      for (
        charCodeValidatedIndex = 0;
        charCodeValidatedIndex <
        _retrievePropertySegment - propertySegmentIndex;
        ++charCodeValidatedIndex
      ) {
        this[charCodeValidatedIndex + propertySegmentIndex] =
          validatedBuffer[charCodeValidatedIndex % validatedBufferLength];
      }
    }
    return this;
  };
  var createTypedArraySupportCheck = {};
  function createIntrinsicPropertyError(
    ____________________________________________________validateAndRetrieveIntrinsicProperty,
    _____________________________________________________validateAndRetrieveIntrinsicProperty,
    ______intrinsicPropertyValue,
  ) {
    createTypedArraySupportCheck[
      ____________________________________________________validateAndRetrieveIntrinsicProperty
    ] = class extends ______intrinsicPropertyValue {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value:
            _____________________________________________________validateAndRetrieveIntrinsicProperty.apply(
              this,
              arguments,
            ),
          writable: true,
          configurable: true,
        });
        this.name =
          this.name +
          " [" +
          ____________________________________________________validateAndRetrieveIntrinsicProperty +
          "]";
        this.stack;
        delete this.name;
      }
      get code() {
        return ____________________________________________________validateAndRetrieveIntrinsicProperty;
      }
      set code(setCode) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: setCode,
          writable: true,
        });
      }
      toString() {
        return (
          this.name +
          " [" +
          ____________________________________________________validateAndRetrieveIntrinsicProperty +
          "]: " +
          this.message
        );
      }
    };
  }
  createIntrinsicPropertyError(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function (calculateAndRetrieveIntrinsicProperty) {
      if (calculateAndRetrieveIntrinsicProperty) {
        return (
          calculateAndRetrieveIntrinsicProperty + " is outside of buffer bounds"
        );
      } else {
        return "Attempt to access memory outside buffer bounds";
      }
    },
    RangeError,
  );
  createIntrinsicPropertyError(
    "ERR_INVALID_ARG_TYPE",
    function (
      validateAndProcessPropertyValues,
      calculateAndRetrieveProperties,
    ) {
      return (
        'The "' +
        validateAndProcessPropertyValues +
        '" argument must be of type number. Received type ' +
        typeof calculateAndRetrieveProperties
      );
    },
    TypeError,
  );
  createIntrinsicPropertyError(
    "ERR_OUT_OF_RANGE",
    function (
      calculateAndRetrieveIntrinsicPropertyValues,
      calculateAndRetrieveIntrinsicProperties,
      _calculateIntrinsicPropertyValues,
    ) {
      let errorMessageOutOfRange =
        'The value of "' +
        calculateAndRetrieveIntrinsicPropertyValues +
        '" is out of range.';
      let ___________intrinsicPropertyValue = _calculateIntrinsicPropertyValues;
      if (
        Number.isInteger(_calculateIntrinsicPropertyValues) &&
        Math.abs(_calculateIntrinsicPropertyValues) > 4294967296
      ) {
        ___________intrinsicPropertyValue = formatPropertyString(
          String(_calculateIntrinsicPropertyValues),
        );
      } else if (typeof _calculateIntrinsicPropertyValues == "bigint") {
        ___________intrinsicPropertyValue = String(
          _calculateIntrinsicPropertyValues,
        );
        if (
          _calculateIntrinsicPropertyValues > BigInt(2) ** BigInt(32) ||
          _calculateIntrinsicPropertyValues < -(BigInt(2) ** BigInt(32))
        ) {
          ___________intrinsicPropertyValue = formatPropertyString(
            ___________intrinsicPropertyValue,
          );
        }
        ___________intrinsicPropertyValue += "n";
      }
      errorMessageOutOfRange +=
        " It must be " +
        calculateAndRetrieveIntrinsicProperties +
        ". Received " +
        ___________intrinsicPropertyValue;
      return errorMessageOutOfRange;
    },
    RangeError,
  );
  function formatPropertyString(calculateAndValidateProperty) {
    let formattedPropertyString = "";
    let propertyStringLength = calculateAndValidateProperty.length;
    let isNegativeProperty = calculateAndValidateProperty[0] === "-" ? 1 : 0;
    for (
      ;
      propertyStringLength >= isNegativeProperty + 4;
      propertyStringLength -= 3
    ) {
      formattedPropertyString =
        "_" +
        calculateAndValidateProperty.slice(
          propertyStringLength - 3,
          propertyStringLength,
        ) +
        formattedPropertyString;
    }
    return (
      "" +
      calculateAndValidateProperty.slice(0, propertyStringLength) +
      formattedPropertyString
    );
  }
  function validatePropertyRangeAndDescriptor(
    calculateMatchingPropertyRange,
    calculatePropertyUsingDescriptor,
    computeMatchingPropertyDescriptors,
  ) {
    validateAndCheckLastMatchingIndex(
      calculatePropertyUsingDescriptor,
      "offset",
    );
    if (
      calculateMatchingPropertyRange[calculatePropertyUsingDescriptor] ===
        undefined ||
      calculateMatchingPropertyRange[
        calculatePropertyUsingDescriptor + computeMatchingPropertyDescriptors
      ] === undefined
    ) {
      validateBufferOffsetAndBounds(
        calculatePropertyUsingDescriptor,
        calculateMatchingPropertyRange.length -
          (computeMatchingPropertyDescriptors + 1),
      );
    }
  }
  function validateAndDescribePropertyRange(
    getMatchingPropertyIndex,
    calculateAndValidateIntrinsicPropertyValue,
    calculateMatchingPropertyDescriptor,
    _calculatePropertyDescriptorValues,
    calculateAndValidatePropertyValue,
    _calculateAndValidateProperty,
  ) {
    if (
      getMatchingPropertyIndex > calculateMatchingPropertyDescriptor ||
      getMatchingPropertyIndex < calculateAndValidateIntrinsicPropertyValue
    ) {
      let intrinsicPropertyTypeSuffix =
        typeof calculateAndValidateIntrinsicPropertyValue == "bigint"
          ? "n"
          : "";
      let valueRangeDescription;
      if (_calculateAndValidateProperty > 3) {
        if (
          calculateAndValidateIntrinsicPropertyValue === 0 ||
          calculateAndValidateIntrinsicPropertyValue === BigInt(0)
        ) {
          valueRangeDescription =
            ">= 0" +
            intrinsicPropertyTypeSuffix +
            " and < 2" +
            intrinsicPropertyTypeSuffix +
            " ** " +
            (_calculateAndValidateProperty + 1) * 8 +
            intrinsicPropertyTypeSuffix;
        } else {
          valueRangeDescription =
            ">= -(2" +
            intrinsicPropertyTypeSuffix +
            " ** " +
            ((_calculateAndValidateProperty + 1) * 8 - 1) +
            intrinsicPropertyTypeSuffix +
            ") and < 2 ** " +
            ((_calculateAndValidateProperty + 1) * 8 - 1) +
            intrinsicPropertyTypeSuffix;
        }
      } else {
        valueRangeDescription =
          ">= " +
          calculateAndValidateIntrinsicPropertyValue +
          intrinsicPropertyTypeSuffix +
          " and <= " +
          calculateMatchingPropertyDescriptor +
          intrinsicPropertyTypeSuffix;
      }
      throw new createTypedArraySupportCheck.ERR_OUT_OF_RANGE(
        "value",
        valueRangeDescription,
        getMatchingPropertyIndex,
      );
    }
    validatePropertyRangeAndDescriptor(
      _calculatePropertyDescriptorValues,
      calculateAndValidatePropertyValue,
      _calculateAndValidateProperty,
    );
  }
  function validateAndCheckLastMatchingIndex(
    findLastMatchingIndex,
    __validateAndRetrievePropertyValue,
  ) {
    if (typeof findLastMatchingIndex != "number") {
      throw new createTypedArraySupportCheck.ERR_INVALID_ARG_TYPE(
        __validateAndRetrievePropertyValue,
        "number",
        findLastMatchingIndex,
      );
    }
  }
  function validateBufferOffsetAndBounds(
    calculateIndexOfMatchingProperty,
    retrieveIntrinsicPropertyIndex,
    findMatchingIndex,
  ) {
    throw Math.floor(calculateIndexOfMatchingProperty) !==
      calculateIndexOfMatchingProperty
      ? (validateAndCheckLastMatchingIndex(
          calculateIndexOfMatchingProperty,
          findMatchingIndex,
        ),
        new createTypedArraySupportCheck.ERR_OUT_OF_RANGE(
          findMatchingIndex || "offset",
          "an integer",
          calculateIndexOfMatchingProperty,
        ))
      : retrieveIntrinsicPropertyIndex < 0
        ? new createTypedArraySupportCheck.ERR_BUFFER_OUT_OF_BOUNDS()
        : new createTypedArraySupportCheck.ERR_OUT_OF_RANGE(
            findMatchingIndex || "offset",
            ">= " +
              (findMatchingIndex ? 1 : 0) +
              " and <= " +
              retrieveIntrinsicPropertyIndex,
            calculateIndexOfMatchingProperty,
          );
  }
  var createUint8ArraySupport = /[^+/0-9A-Za-z-_]/g;
  function normalizeAndPadBase64String(findMatchingIntrinsicPropertyIndex) {
    findMatchingIntrinsicPropertyIndex =
      findMatchingIntrinsicPropertyIndex.split("=")[0];
    findMatchingIntrinsicPropertyIndex = findMatchingIntrinsicPropertyIndex
      .trim()
      .replace(createUint8ArraySupport, "");
    if (findMatchingIntrinsicPropertyIndex.length < 2) {
      return "";
    }
    while (findMatchingIntrinsicPropertyIndex.length % 4 !== 0) {
      findMatchingIntrinsicPropertyIndex =
        findMatchingIntrinsicPropertyIndex + "=";
    }
    return findMatchingIntrinsicPropertyIndex;
  }
  function validateAndRetrieveUnicodeProperty(
    __validateAndRetrieveProperty,
    ______________________________________________________validateAndRetrieveIntrinsicProperty,
  ) {
    ______________________________________________________validateAndRetrieveIntrinsicProperty =
      ______________________________________________________validateAndRetrieveIntrinsicProperty ||
      Infinity;
    let unicodeCharacterCode;
    let inputStringLength = __validateAndRetrieveProperty.length;
    let isValidCharacter = null;
    let byteOrderMarkBuffer = [];
    for (
      let characterIndex = 0;
      characterIndex < inputStringLength;
      ++characterIndex
    ) {
      unicodeCharacterCode =
        __validateAndRetrieveProperty.charCodeAt(characterIndex);
      if (unicodeCharacterCode > 55295 && unicodeCharacterCode < 57344) {
        if (!isValidCharacter) {
          if (unicodeCharacterCode > 56319) {
            if (
              (______________________________________________________validateAndRetrieveIntrinsicProperty -= 3) >
              -1
            ) {
              byteOrderMarkBuffer.push(239, 191, 189);
            }
            continue;
          } else if (characterIndex + 1 === inputStringLength) {
            if (
              (______________________________________________________validateAndRetrieveIntrinsicProperty -= 3) >
              -1
            ) {
              byteOrderMarkBuffer.push(239, 191, 189);
            }
            continue;
          }
          isValidCharacter = unicodeCharacterCode;
          continue;
        }
        if (unicodeCharacterCode < 56320) {
          if (
            (______________________________________________________validateAndRetrieveIntrinsicProperty -= 3) >
            -1
          ) {
            byteOrderMarkBuffer.push(239, 191, 189);
          }
          isValidCharacter = unicodeCharacterCode;
          continue;
        }
        unicodeCharacterCode =
          (((isValidCharacter - 55296) << 10) |
            (unicodeCharacterCode - 56320)) +
          65536;
      } else if (
        isValidCharacter &&
        (______________________________________________________validateAndRetrieveIntrinsicProperty -= 3) >
          -1
      ) {
        byteOrderMarkBuffer.push(239, 191, 189);
      }
      isValidCharacter = null;
      if (unicodeCharacterCode < 128) {
        if (
          (______________________________________________________validateAndRetrieveIntrinsicProperty -= 1) <
          0
        ) {
          break;
        }
        byteOrderMarkBuffer.push(unicodeCharacterCode);
      } else if (unicodeCharacterCode < 2048) {
        if (
          (______________________________________________________validateAndRetrieveIntrinsicProperty -= 2) <
          0
        ) {
          break;
        }
        byteOrderMarkBuffer.push(
          (unicodeCharacterCode >> 6) | 192,
          (unicodeCharacterCode & 63) | 128,
        );
      } else if (unicodeCharacterCode < 65536) {
        if (
          (______________________________________________________validateAndRetrieveIntrinsicProperty -= 3) <
          0
        ) {
          break;
        }
        byteOrderMarkBuffer.push(
          (unicodeCharacterCode >> 12) | 224,
          ((unicodeCharacterCode >> 6) & 63) | 128,
          (unicodeCharacterCode & 63) | 128,
        );
      } else if (unicodeCharacterCode < 1114112) {
        if (
          (______________________________________________________validateAndRetrieveIntrinsicProperty -= 4) <
          0
        ) {
          break;
        }
        byteOrderMarkBuffer.push(
          (unicodeCharacterCode >> 18) | 240,
          ((unicodeCharacterCode >> 12) & 63) | 128,
          ((unicodeCharacterCode >> 6) & 63) | 128,
          (unicodeCharacterCode & 63) | 128,
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return byteOrderMarkBuffer;
  }
  function convertStringToCharCodeArray(calculateMaxProperties) {
    let charCodeArray = [];
    for (
      let indexForCharCode = 0;
      indexForCharCode < calculateMaxProperties.length;
      ++indexForCharCode
    ) {
      charCodeArray.push(
        calculateMaxProperties.charCodeAt(indexForCharCode) & 255,
      );
    }
    return charCodeArray;
  }
  function extractIntrinsicPropertyValues(
    maxAllowedIntrinsicProperty,
    calculateHalfIntrinsicProperty,
  ) {
    let ____________intrinsicPropertyValue;
    let highOrderIntrinsicValue;
    let lowOrderIntrinsicValue;
    let _intrinsicPropertyValues = [];
    for (
      let ____index = 0;
      ____index < maxAllowedIntrinsicProperty.length &&
      !((calculateHalfIntrinsicProperty -= 2) < 0);
      ++____index
    ) {
      ____________intrinsicPropertyValue =
        maxAllowedIntrinsicProperty.charCodeAt(____index);
      highOrderIntrinsicValue = ____________intrinsicPropertyValue >> 8;
      lowOrderIntrinsicValue = ____________intrinsicPropertyValue % 256;
      _intrinsicPropertyValues.push(lowOrderIntrinsicValue);
      _intrinsicPropertyValues.push(highOrderIntrinsicValue);
    }
    return _intrinsicPropertyValues;
  }
  function convertAndStoreIntrinsicValue(validateAndStoreIntrinsicValue) {
    return generateDataView.toByteArray(
      normalizeAndPadBase64String(validateAndStoreIntrinsicValue),
    );
  }
  function copyIntrinsicValues(
    parseAndRetrieveIntrinsicValue,
    parseAndValidateIntrinsicValue,
    _parseAndRetrieveIntrinsicValue,
    __parseAndRetrieveIntrinsicValue,
  ) {
    let __index;
    for (
      __index = 0;
      __index < __parseAndRetrieveIntrinsicValue &&
      !(
        __index + _parseAndRetrieveIntrinsicValue >=
        parseAndValidateIntrinsicValue.length
      ) &&
      !(__index >= parseAndRetrieveIntrinsicValue.length);
      ++__index
    ) {
      parseAndValidateIntrinsicValue[
        __index + _parseAndRetrieveIntrinsicValue
      ] = parseAndRetrieveIntrinsicValue[__index];
    }
    return __index;
  }
  function isInstanceOfOrHasSameConstructorName(
    ___validateAndRetrieveIntrinsicProperties,
    _______________________________________________________validateAndRetrieveIntrinsicProperty,
  ) {
    return (
      ___validateAndRetrieveIntrinsicProperties instanceof
        _______________________________________________________validateAndRetrieveIntrinsicProperty ||
      (___validateAndRetrieveIntrinsicProperties != null &&
        ___validateAndRetrieveIntrinsicProperties.constructor != null &&
        ___validateAndRetrieveIntrinsicProperties.constructor.name != null &&
        ___validateAndRetrieveIntrinsicProperties.constructor.name ===
          _______________________________________________________validateAndRetrieveIntrinsicProperty.name)
    );
  }
  function isIntrinsicPropertyValid(retrieveAndValidateIntrinsicProperty) {
    return (
      retrieveAndValidateIntrinsicProperty !==
      retrieveAndValidateIntrinsicProperty
    );
  }
  var checkTypedArraySupport = (function () {
    let hexCharacters = "0123456789abcdef";
    let hexColorCodes = new Array(256);
    for (let outerLoopIndex = 0; outerLoopIndex < 16; ++outerLoopIndex) {
      let colorCodeIndex = outerLoopIndex * 16;
      for (
        let hexColorCodeGenerator = 0;
        hexColorCodeGenerator < 16;
        ++hexColorCodeGenerator
      ) {
        hexColorCodes[colorCodeIndex + hexColorCodeGenerator] =
          hexCharacters[outerLoopIndex] + hexCharacters[hexColorCodeGenerator];
      }
    }
    return hexColorCodes;
  })();
  function getIntrinsicValueOrFallback(retrieveAndValidateIntrinsicValue) {
    if (typeof BigInt === "undefined") {
      return throwBigIntNotSupportedError;
    } else {
      return retrieveAndValidateIntrinsicValue;
    }
  }
  function throwBigIntNotSupportedError() {
    throw new Error("BigInt not supported");
  }
});
var _retrieveAndValidateIntrinsicProperty = {};
definePropertiesWithGetters(_retrieveAndValidateIntrinsicProperty, {
  Buffer: () => ____validateAndRetrieveIntrinsicProperties,
  constants: () => validateAndRetrieveIntrinsicPropertyValue,
  default: () =>
    _________________________________________________________validateAndRetrieveIntrinsicProperty,
});
var ________________________________________________________validateAndRetrieveIntrinsicProperty;
var ____validateAndRetrieveIntrinsicProperties;
var validateAndRetrieveIntrinsicPropertyValue;
var _________________________________________________________validateAndRetrieveIntrinsicProperty;
var _validateAndRetrieveIntrinsicPropertyValue = conditionalExecutor(() => {
  ________________________________________________________validateAndRetrieveIntrinsicProperty =
    defineObjectProperties(formattedValidationMessage());
  copyPropertiesWithDefault(
    _retrieveAndValidateIntrinsicProperty,
    defineObjectProperties(formattedValidationMessage()),
  );
  ____validateAndRetrieveIntrinsicProperties =
    ________________________________________________________validateAndRetrieveIntrinsicProperty.Buffer;
  ____validateAndRetrieveIntrinsicProperties.prototype.copy = function (
    validateAndRetrieveIntrinsicValues,
    ______validateAndRetrieveIntrinsicValue,
    _______validateAndRetrieveIntrinsicValue,
    ________validateAndRetrieveIntrinsicValue,
  ) {
    if (!(validateAndRetrieveIntrinsicValues instanceof Uint8Array)) {
      throw new TypeError("argument should be a Buffer");
    }
    _______validateAndRetrieveIntrinsicValue ||= 0;
    if (
      !________validateAndRetrieveIntrinsicValue &&
      ________validateAndRetrieveIntrinsicValue !== 0
    ) {
      ________validateAndRetrieveIntrinsicValue = this.length;
    }
    if (
      ______validateAndRetrieveIntrinsicValue >=
      validateAndRetrieveIntrinsicValues.length
    ) {
      ______validateAndRetrieveIntrinsicValue =
        validateAndRetrieveIntrinsicValues.length;
    }
    ______validateAndRetrieveIntrinsicValue ||= 0;
    if (
      ________validateAndRetrieveIntrinsicValue > 0 &&
      ________validateAndRetrieveIntrinsicValue <
        _______validateAndRetrieveIntrinsicValue
    ) {
      ________validateAndRetrieveIntrinsicValue =
        _______validateAndRetrieveIntrinsicValue;
    }
    if (
      ________validateAndRetrieveIntrinsicValue ===
        _______validateAndRetrieveIntrinsicValue ||
      validateAndRetrieveIntrinsicValues.length === 0 ||
      this.length === 0
    ) {
      return 0;
    }
    if (______validateAndRetrieveIntrinsicValue < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (
      _______validateAndRetrieveIntrinsicValue < 0 ||
      _______validateAndRetrieveIntrinsicValue >= this.length
    ) {
      throw new RangeError("Index out of range");
    }
    if (________validateAndRetrieveIntrinsicValue < 0) {
      throw new RangeError("sourceEnd out of bounds");
    }
    if (________validateAndRetrieveIntrinsicValue > this.length) {
      ________validateAndRetrieveIntrinsicValue = this.length;
    }
    if (
      validateAndRetrieveIntrinsicValues.length -
        ______validateAndRetrieveIntrinsicValue <
      ________validateAndRetrieveIntrinsicValue -
        _______validateAndRetrieveIntrinsicValue
    ) {
      ________validateAndRetrieveIntrinsicValue =
        validateAndRetrieveIntrinsicValues.length -
        ______validateAndRetrieveIntrinsicValue +
        _______validateAndRetrieveIntrinsicValue;
    }
    let bufferInput =
      ________validateAndRetrieveIntrinsicValue -
      _______validateAndRetrieveIntrinsicValue;
    if (
      this === validateAndRetrieveIntrinsicValues &&
      typeof Uint8Array.prototype.copyWithin == "function"
    ) {
      this.copyWithin(
        ______validateAndRetrieveIntrinsicValue,
        _______validateAndRetrieveIntrinsicValue,
        ________validateAndRetrieveIntrinsicValue,
      );
    } else {
      Uint8Array.prototype.set.call(
        validateAndRetrieveIntrinsicValues,
        this.subarray(
          _______validateAndRetrieveIntrinsicValue,
          ________validateAndRetrieveIntrinsicValue,
        ),
        ______validateAndRetrieveIntrinsicValue,
      );
    }
    return bufferInput;
  };
  Object.defineProperties(____validateAndRetrieveIntrinsicProperties, {
    TextEncoder: {
      value: self.TextEncoder,
    },
    TextDecoder: {
      value: self.TextDecoder,
    },
  });
  validateAndRetrieveIntrinsicPropertyValue = {
    MAX_LENGTH: 4294967296,
    MAX_STRING_LENGTH: 536870888,
  };
  Object.defineProperties(
    ________________________________________________________validateAndRetrieveIntrinsicProperty,
    {
      constants: {
        value: validateAndRetrieveIntrinsicPropertyValue,
      },
    },
  );
  _________________________________________________________validateAndRetrieveIntrinsicProperty =
    ________________________________________________________validateAndRetrieveIntrinsicProperty;
});
var validateAndRetrieveStringLength = conditionalModuleLoader(
  (DeferredExecutorModule) => {
    Object.defineProperty(DeferredExecutorModule, "__esModule", {
      value: true,
    });
    DeferredExecutorModule.createDeferredExecutor = undefined;
    function createPromiseHandler() {
      let createCustomPromiseHandler = (
        customPromiseHandlerCreator,
        __handlePromiseRejection,
      ) => {
        createCustomPromiseHandler.state = "pending";
        createCustomPromiseHandler.resolve = (handlePendingPromise) => {
          if (createCustomPromiseHandler.state !== "pending") {
            return;
          }
          createCustomPromiseHandler.result = handlePendingPromise;
          let resolvePendingPromise = (getFulfilledPromiseState) => {
            createCustomPromiseHandler.state = "fulfilled";
            return getFulfilledPromiseState;
          };
          return customPromiseHandlerCreator(
            handlePendingPromise instanceof Promise
              ? handlePendingPromise
              : Promise.resolve(handlePendingPromise).then(
                  resolvePendingPromise,
                ),
          );
        };
        createCustomPromiseHandler.reject = (_handlePendingPromise) => {
          if (createCustomPromiseHandler.state === "pending") {
            queueMicrotask(() => {
              createCustomPromiseHandler.state = "rejected";
            });
            return __handlePromiseRejection(
              (createCustomPromiseHandler.rejectionReason =
                _handlePendingPromise),
            );
          }
        };
      };
      return createCustomPromiseHandler;
    }
    DeferredExecutorModule.createDeferredExecutor = createPromiseHandler;
  },
);
var ___validateAndRetrieveProperty = conditionalModuleLoader(
  (DeferredPromiseExecutor) => {
    Object.defineProperty(DeferredPromiseExecutor, "__esModule", {
      value: true,
    });
    DeferredPromiseExecutor.DeferredPromise = undefined;
    var _deferredExecutor = validateAndRetrieveStringLength();
    var _DeferredPromise = class extends Promise {
      #e;
      resolve;
      reject;
      constructor(initialValue = null) {
        let ___deferredExecutor = (0,
        _deferredExecutor.createDeferredExecutor)();
        super((deferredExecutorFunction, ____deferredExecutor) => {
          ___deferredExecutor(deferredExecutorFunction, ____deferredExecutor);
          initialValue?.(
            ___deferredExecutor.resolve,
            ___deferredExecutor.reject,
          );
        });
        this.#e = ___deferredExecutor;
        this.resolve = this.#e.resolve;
        this.reject = this.#e.reject;
      }
      get state() {
        return this.#e.state;
      }
      get rejectionReason() {
        return this.#e.rejectionReason;
      }
      then(processResult, __________processData) {
        return this.#t(super.then(processResult, __________processData));
      }
      catch(______errorHandler) {
        return this.#t(super.catch(______errorHandler));
      }
      finally(finalPromiseHandler) {
        return this.#t(super.finally(finalPromiseHandler));
      }
      #t(definePromiseHandlers) {
        return Object.defineProperties(definePromiseHandlers, {
          resolve: {
            configurable: true,
            value: this.resolve,
          },
          reject: {
            configurable: true,
            value: this.reject,
          },
        });
      }
    };
    DeferredPromiseExecutor.DeferredPromise = _DeferredPromise;
  },
);
var bufferCapacityValidation = conditionalModuleLoader((___createBinding) => {
  var ____createBinding =
    (___createBinding && ___createBinding.__createBinding) ||
    (Object.create
      ? function (
          __________________________________________________________validateAndRetrieveIntrinsicProperty,
          validateAndRetrieveIntrinsicPropertyLimit,
          validateAndRetrieveLogicalLength,
          _validateAndRetrieveLogicalLength = validateAndRetrieveLogicalLength,
        ) {
          var ______propertyDescriptor = Object.getOwnPropertyDescriptor(
            validateAndRetrieveIntrinsicPropertyLimit,
            validateAndRetrieveLogicalLength,
          );
          if (
            !______propertyDescriptor ||
            ("get" in ______propertyDescriptor
              ? !validateAndRetrieveIntrinsicPropertyLimit.__esModule
              : ______propertyDescriptor.writable ||
                ______propertyDescriptor.configurable)
          ) {
            ______propertyDescriptor = {
              enumerable: true,
              get() {
                return validateAndRetrieveIntrinsicPropertyLimit[
                  validateAndRetrieveLogicalLength
                ];
              },
            };
          }
          Object.defineProperty(
            __________________________________________________________validateAndRetrieveIntrinsicProperty,
            _validateAndRetrieveLogicalLength,
            ______propertyDescriptor,
          );
        }
      : function (
          validateAndRetrieveBufferEncoding,
          ___________________________________________________________validateAndRetrieveIntrinsicProperty,
          validateAndRetrieveEncoding,
          ___validateAndRetrieveEncoding = validateAndRetrieveEncoding,
        ) {
          validateAndRetrieveBufferEncoding[___validateAndRetrieveEncoding] =
            ___________________________________________________________validateAndRetrieveIntrinsicProperty[
              validateAndRetrieveEncoding
            ];
        });
  var definePropertyWithDescriptor =
    (___createBinding && ___createBinding.__exportStar) ||
    function (
      validateAndRetrieveBufferProperties,
      _validateAndRetrieveBufferProperties,
    ) {
      for (var _propertyName in validateAndRetrieveBufferProperties) {
        if (
          _propertyName !== "default" &&
          !Object.prototype.hasOwnProperty.call(
            _validateAndRetrieveBufferProperties,
            _propertyName,
          )
        ) {
          ____createBinding(
            _validateAndRetrieveBufferProperties,
            validateAndRetrieveBufferProperties,
            _propertyName,
          );
        }
      }
    };
  Object.defineProperty(___createBinding, "__esModule", {
    value: true,
  });
  definePropertyWithDescriptor(
    validateAndRetrieveStringLength(),
    ___createBinding,
  );
  definePropertyWithDescriptor(
    ___validateAndRetrieveProperty(),
    ___createBinding,
  );
});
var _validateAndRetrieveEncoding = conditionalModuleLoader(
  (defineSemverConstants, semverConstantsExporter) => {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var _MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var _MAX_SAFE_COMPONENT_LENGTH = 16;
    semverConstantsExporter.exports = {
      SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION,
      MAX_LENGTH: MAX_LENGTH,
      MAX_SAFE_INTEGER: _MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH: _MAX_SAFE_COMPONENT_LENGTH,
    };
  },
);
var validateAndProcessEncoding = conditionalModuleLoader(
  (logSemverError, logSemverErrorHandler) => {
    var semverErrorLogger =
      typeof process == "object" &&
      process.env &&
      "false" &&
      /\bsemver\b/i.test("false")
        ? (...logSemverErrors) => console.error("SEMVER", ...logSemverErrors)
        : () => {};
    logSemverErrorHandler.exports = semverErrorLogger;
  },
);
var ____________________________________________________________validateAndRetrieveIntrinsicProperty =
  conditionalModuleLoader(
    (encodingPatternRegistry, encodingPatternExporter) => {
      var { MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH } =
        _validateAndRetrieveEncoding();
      var _validateAndProcessEncoding = validateAndProcessEncoding();
      encodingPatternRegistry = encodingPatternExporter.exports = {};
      var encodingPatterns = (encodingPatternRegistry.re = []);
      var encodingPatternArray = (encodingPatternRegistry.src = []);
      var encodingPatternMap = (encodingPatternRegistry.t = {});
      var encodingPatternIndex = 0;
      var addEncodingPattern = (
        processEncodingPattern,
        encodingPatternRegex,
        isGlobalFlag,
      ) => {
        let _encodingPatternIndex = encodingPatternIndex++;
        _validateAndProcessEncoding(
          processEncodingPattern,
          _encodingPatternIndex,
          encodingPatternRegex,
        );
        encodingPatternMap[processEncodingPattern] = _encodingPatternIndex;
        encodingPatternArray[_encodingPatternIndex] = encodingPatternRegex;
        encodingPatterns[_encodingPatternIndex] = new RegExp(
          encodingPatternRegex,
          isGlobalFlag ? "g" : undefined,
        );
      };
      addEncodingPattern("NUMERICIDENTIFIER", "0|[1-9]\\d*");
      addEncodingPattern("NUMERICIDENTIFIERLOOSE", "[0-9]+");
      addEncodingPattern("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
      addEncodingPattern(
        "MAINVERSION",
        "(" +
          encodingPatternArray[encodingPatternMap.NUMERICIDENTIFIER] +
          ")\\.(" +
          encodingPatternArray[encodingPatternMap.NUMERICIDENTIFIER] +
          ")\\.(" +
          encodingPatternArray[encodingPatternMap.NUMERICIDENTIFIER] +
          ")",
      );
      addEncodingPattern(
        "MAINVERSIONLOOSE",
        "(" +
          encodingPatternArray[encodingPatternMap.NUMERICIDENTIFIERLOOSE] +
          ")\\.(" +
          encodingPatternArray[encodingPatternMap.NUMERICIDENTIFIERLOOSE] +
          ")\\.(" +
          encodingPatternArray[encodingPatternMap.NUMERICIDENTIFIERLOOSE] +
          ")",
      );
      addEncodingPattern(
        "PRERELEASEIDENTIFIER",
        "(?:" +
          encodingPatternArray[encodingPatternMap.NUMERICIDENTIFIER] +
          "|" +
          encodingPatternArray[encodingPatternMap.NONNUMERICIDENTIFIER] +
          ")",
      );
      addEncodingPattern(
        "PRERELEASEIDENTIFIERLOOSE",
        "(?:" +
          encodingPatternArray[encodingPatternMap.NUMERICIDENTIFIERLOOSE] +
          "|" +
          encodingPatternArray[encodingPatternMap.NONNUMERICIDENTIFIER] +
          ")",
      );
      addEncodingPattern(
        "PRERELEASE",
        "(?:-(" +
          encodingPatternArray[encodingPatternMap.PRERELEASEIDENTIFIER] +
          "(?:\\." +
          encodingPatternArray[encodingPatternMap.PRERELEASEIDENTIFIER] +
          ")*))",
      );
      addEncodingPattern(
        "PRERELEASELOOSE",
        "(?:-?(" +
          encodingPatternArray[encodingPatternMap.PRERELEASEIDENTIFIERLOOSE] +
          "(?:\\." +
          encodingPatternArray[encodingPatternMap.PRERELEASEIDENTIFIERLOOSE] +
          ")*))",
      );
      addEncodingPattern("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
      addEncodingPattern(
        "BUILD",
        "(?:\\+(" +
          encodingPatternArray[encodingPatternMap.BUILDIDENTIFIER] +
          "(?:\\." +
          encodingPatternArray[encodingPatternMap.BUILDIDENTIFIER] +
          ")*))",
      );
      addEncodingPattern(
        "FULLPLAIN",
        "v?" +
          encodingPatternArray[encodingPatternMap.MAINVERSION] +
          encodingPatternArray[encodingPatternMap.PRERELEASE] +
          "?" +
          encodingPatternArray[encodingPatternMap.BUILD] +
          "?",
      );
      addEncodingPattern(
        "FULL",
        "^" + encodingPatternArray[encodingPatternMap.FULLPLAIN] + "$",
      );
      addEncodingPattern(
        "LOOSEPLAIN",
        "[v=\\s]*" +
          encodingPatternArray[encodingPatternMap.MAINVERSIONLOOSE] +
          encodingPatternArray[encodingPatternMap.PRERELEASELOOSE] +
          "?" +
          encodingPatternArray[encodingPatternMap.BUILD] +
          "?",
      );
      addEncodingPattern(
        "LOOSE",
        "^" + encodingPatternArray[encodingPatternMap.LOOSEPLAIN] + "$",
      );
      addEncodingPattern("GTLT", "((?:<|>)?=?)");
      addEncodingPattern(
        "XRANGEIDENTIFIERLOOSE",
        encodingPatternArray[encodingPatternMap.NUMERICIDENTIFIERLOOSE] +
          "|x|X|\\*",
      );
      addEncodingPattern(
        "XRANGEIDENTIFIER",
        encodingPatternArray[encodingPatternMap.NUMERICIDENTIFIER] + "|x|X|\\*",
      );
      addEncodingPattern(
        "XRANGEPLAIN",
        "[v=\\s]*(" +
          encodingPatternArray[encodingPatternMap.XRANGEIDENTIFIER] +
          ")(?:\\.(" +
          encodingPatternArray[encodingPatternMap.XRANGEIDENTIFIER] +
          ")(?:\\.(" +
          encodingPatternArray[encodingPatternMap.XRANGEIDENTIFIER] +
          ")(?:" +
          encodingPatternArray[encodingPatternMap.PRERELEASE] +
          ")?" +
          encodingPatternArray[encodingPatternMap.BUILD] +
          "?)?)?",
      );
      addEncodingPattern(
        "XRANGEPLAINLOOSE",
        "[v=\\s]*(" +
          encodingPatternArray[encodingPatternMap.XRANGEIDENTIFIERLOOSE] +
          ")(?:\\.(" +
          encodingPatternArray[encodingPatternMap.XRANGEIDENTIFIERLOOSE] +
          ")(?:\\.(" +
          encodingPatternArray[encodingPatternMap.XRANGEIDENTIFIERLOOSE] +
          ")(?:" +
          encodingPatternArray[encodingPatternMap.PRERELEASELOOSE] +
          ")?" +
          encodingPatternArray[encodingPatternMap.BUILD] +
          "?)?)?",
      );
      addEncodingPattern(
        "XRANGE",
        "^" +
          encodingPatternArray[encodingPatternMap.GTLT] +
          "\\s*" +
          encodingPatternArray[encodingPatternMap.XRANGEPLAIN] +
          "$",
      );
      addEncodingPattern(
        "XRANGELOOSE",
        "^" +
          encodingPatternArray[encodingPatternMap.GTLT] +
          "\\s*" +
          encodingPatternArray[encodingPatternMap.XRANGEPLAINLOOSE] +
          "$",
      );
      addEncodingPattern(
        "COERCE",
        "(^|[^\\d])(\\d{1," +
          MAX_SAFE_COMPONENT_LENGTH +
          "})(?:\\.(\\d{1," +
          MAX_SAFE_COMPONENT_LENGTH +
          "}))?(?:\\.(\\d{1," +
          MAX_SAFE_COMPONENT_LENGTH +
          "}))?(?:$|[^\\d])",
      );
      addEncodingPattern(
        "COERCERTL",
        encodingPatternArray[encodingPatternMap.COERCE],
        true,
      );
      addEncodingPattern("LONETILDE", "(?:~>?)");
      addEncodingPattern(
        "TILDETRIM",
        "(\\s*)" + encodingPatternArray[encodingPatternMap.LONETILDE] + "\\s+",
        true,
      );
      encodingPatternRegistry.tildeTrimReplace = "$1~";
      addEncodingPattern(
        "TILDE",
        "^" +
          encodingPatternArray[encodingPatternMap.LONETILDE] +
          encodingPatternArray[encodingPatternMap.XRANGEPLAIN] +
          "$",
      );
      addEncodingPattern(
        "TILDELOOSE",
        "^" +
          encodingPatternArray[encodingPatternMap.LONETILDE] +
          encodingPatternArray[encodingPatternMap.XRANGEPLAINLOOSE] +
          "$",
      );
      addEncodingPattern("LONECARET", "(?:\\^)");
      addEncodingPattern(
        "CARETTRIM",
        "(\\s*)" + encodingPatternArray[encodingPatternMap.LONECARET] + "\\s+",
        true,
      );
      encodingPatternRegistry.caretTrimReplace = "$1^";
      addEncodingPattern(
        "CARET",
        "^" +
          encodingPatternArray[encodingPatternMap.LONECARET] +
          encodingPatternArray[encodingPatternMap.XRANGEPLAIN] +
          "$",
      );
      addEncodingPattern(
        "CARETLOOSE",
        "^" +
          encodingPatternArray[encodingPatternMap.LONECARET] +
          encodingPatternArray[encodingPatternMap.XRANGEPLAINLOOSE] +
          "$",
      );
      addEncodingPattern(
        "COMPARATORLOOSE",
        "^" +
          encodingPatternArray[encodingPatternMap.GTLT] +
          "\\s*(" +
          encodingPatternArray[encodingPatternMap.LOOSEPLAIN] +
          ")$|^$",
      );
      addEncodingPattern(
        "COMPARATOR",
        "^" +
          encodingPatternArray[encodingPatternMap.GTLT] +
          "\\s*(" +
          encodingPatternArray[encodingPatternMap.FULLPLAIN] +
          ")$|^$",
      );
      addEncodingPattern(
        "COMPARATORTRIM",
        "(\\s*)" +
          encodingPatternArray[encodingPatternMap.GTLT] +
          "\\s*(" +
          encodingPatternArray[encodingPatternMap.LOOSEPLAIN] +
          "|" +
          encodingPatternArray[encodingPatternMap.XRANGEPLAIN] +
          ")",
        true,
      );
      encodingPatternRegistry.comparatorTrimReplace = "$1$2$3";
      addEncodingPattern(
        "HYPHENRANGE",
        "^\\s*(" +
          encodingPatternArray[encodingPatternMap.XRANGEPLAIN] +
          ")\\s+-\\s+(" +
          encodingPatternArray[encodingPatternMap.XRANGEPLAIN] +
          ")\\s*$",
      );
      addEncodingPattern(
        "HYPHENRANGELOOSE",
        "^\\s*(" +
          encodingPatternArray[encodingPatternMap.XRANGEPLAINLOOSE] +
          ")\\s+-\\s+(" +
          encodingPatternArray[encodingPatternMap.XRANGEPLAINLOOSE] +
          ")\\s*$",
      );
      addEncodingPattern("STAR", "(<|>)?=?\\s*\\*");
      addEncodingPattern("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
      addEncodingPattern("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    },
  );
var decodedCharacter = conditionalModuleLoader(
  (createOptionsFilter, createOptionFilter) => {
    var optionsFilterKeys = ["includePrerelease", "loose", "rtl"];
    var _createOptionsFilter = (isLooseOrFilteredOptions) =>
      isLooseOrFilteredOptions
        ? typeof isLooseOrFilteredOptions != "object"
          ? {
              loose: true,
            }
          : optionsFilterKeys
              .filter(
                (_isLooseOrFilteredOptions) =>
                  isLooseOrFilteredOptions[_isLooseOrFilteredOptions],
              )
              .reduce((setPropertyToTrue, setPropertyToTrueWithKey) => {
                setPropertyToTrue[setPropertyToTrueWithKey] = true;
                return setPropertyToTrue;
              }, {})
        : {};
    createOptionFilter.exports = _createOptionsFilter;
  },
);
var intrinsicPropertiesArray = conditionalModuleLoader(
  (compareAndSortNumericStrings, ____moduleExports) => {
    var numericStringPattern = /^[0-9]+$/;
    var __compareNumericStrings = (
      ___compareNumericStrings,
      ____compareNumericStrings,
    ) => {
      let isNumericString1 = numericStringPattern.test(
        ___compareNumericStrings,
      );
      let isNumericString2 = numericStringPattern.test(
        ____compareNumericStrings,
      );
      if (isNumericString1 && isNumericString2) {
        ___compareNumericStrings = +___compareNumericStrings;
        ____compareNumericStrings = +____compareNumericStrings;
      }
      if (___compareNumericStrings === ____compareNumericStrings) {
        return 0;
      } else if (isNumericString1 && !isNumericString2) {
        return -1;
      } else if (isNumericString2 && !isNumericString1) {
        return 1;
      } else if (___compareNumericStrings < ____compareNumericStrings) {
        return -1;
      } else {
        return 1;
      }
    };
    var reverseCompareNumericStrings = (
      _compareAndSortNumericStrings,
      numericStringComparator,
    ) =>
      __compareNumericStrings(
        numericStringComparator,
        _compareAndSortNumericStrings,
      );
    ____moduleExports.exports = {
      compareIdentifiers: __compareNumericStrings,
      rcompareIdentifiers: reverseCompareNumericStrings,
    };
  },
);
var processCharacterEncoding = conditionalModuleLoader(
  (createVersionObject, processVersion) => {
    var validateAndProcessVersionEncoding = validateAndProcessEncoding();
    var { MAX_LENGTH: maxVersionLength, MAX_SAFE_INTEGER: maxSafeInteger } =
      _validateAndRetrieveEncoding();
    var { re: versionRegex, t: parsedVersion } =
      ____________________________________________________________validateAndRetrieveIntrinsicProperty();
    var decodeCharacter = decodedCharacter();
    var { compareIdentifiers: _compareVersionIdentifiers } =
      intrinsicPropertiesArray();
    var VersionParser = class {
      constructor(versionInput, decodedOptions) {
        decodedOptions = decodeCharacter(decodedOptions);
        if (versionInput instanceof VersionParser) {
          if (
            versionInput.loose === !!decodedOptions.loose &&
            versionInput.includePrerelease ===
              !!decodedOptions.includePrerelease
          ) {
            return versionInput;
          }
          versionInput = versionInput.version;
        } else if (typeof versionInput != "string") {
          throw new TypeError("Invalid Version: " + versionInput);
        }
        if (versionInput.length > maxVersionLength) {
          throw new TypeError(
            "version is longer than " + maxVersionLength + " characters",
          );
        }
        validateAndProcessVersionEncoding(
          "SemVer",
          versionInput,
          decodedOptions,
        );
        this.options = decodedOptions;
        this.loose = !!decodedOptions.loose;
        this.includePrerelease = !!decodedOptions.includePrerelease;
        let matchedVersionComponents = versionInput
          .trim()
          .match(
            decodedOptions.loose
              ? versionRegex[parsedVersion.LOOSE]
              : versionRegex[parsedVersion.FULL],
          );
        if (!matchedVersionComponents) {
          throw new TypeError("Invalid Version: " + versionInput);
        }
        this.raw = versionInput;
        this.major = +matchedVersionComponents[1];
        this.minor = +matchedVersionComponents[2];
        this.patch = +matchedVersionComponents[3];
        if (this.major > maxSafeInteger || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > maxSafeInteger || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > maxSafeInteger || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (matchedVersionComponents[4]) {
          this.prerelease = matchedVersionComponents[4]
            .split(".")
            .map((validateAndConvertToInteger) => {
              if (/^[0-9]+$/.test(validateAndConvertToInteger)) {
                let validatedInteger = +validateAndConvertToInteger;
                if (
                  validatedInteger >= 0 &&
                  validatedInteger < maxSafeInteger
                ) {
                  return validatedInteger;
                }
              }
              return validateAndConvertToInteger;
            });
        } else {
          this.prerelease = [];
        }
        if (matchedVersionComponents[5]) {
          this.build = matchedVersionComponents[5].split(".");
        } else {
          this.build = [];
        }
        this.format();
      }
      format() {
        this.version = this.major + "." + this.minor + "." + this.patch;
        if (this.prerelease.length) {
          this.version += "-" + this.prerelease.join(".");
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(comparisonTarget) {
        validateAndProcessVersionEncoding(
          "SemVer.compare",
          this.version,
          this.options,
          comparisonTarget,
        );
        if (!(comparisonTarget instanceof VersionParser)) {
          if (
            typeof comparisonTarget == "string" &&
            comparisonTarget === this.version
          ) {
            return 0;
          }
          comparisonTarget = new VersionParser(comparisonTarget, this.options);
        }
        if (comparisonTarget.version === this.version) {
          return 0;
        } else {
          return (
            this.compareMain(comparisonTarget) ||
            this.comparePre(comparisonTarget)
          );
        }
      }
      compareMain(_versionToCompare) {
        if (!(_versionToCompare instanceof VersionParser)) {
          _versionToCompare = new VersionParser(
            _versionToCompare,
            this.options,
          );
        }
        return (
          _compareVersionIdentifiers(this.major, _versionToCompare.major) ||
          _compareVersionIdentifiers(this.minor, _versionToCompare.minor) ||
          _compareVersionIdentifiers(this.patch, _versionToCompare.patch)
        );
      }
      comparePre(comparePreReleaseVersions) {
        if (!(comparePreReleaseVersions instanceof VersionParser)) {
          comparePreReleaseVersions = new VersionParser(
            comparePreReleaseVersions,
            this.options,
          );
        }
        if (
          this.prerelease.length &&
          !comparePreReleaseVersions.prerelease.length
        ) {
          return -1;
        }
        if (
          !this.prerelease.length &&
          comparePreReleaseVersions.prerelease.length
        ) {
          return 1;
        }
        if (
          !this.prerelease.length &&
          !comparePreReleaseVersions.prerelease.length
        ) {
          return 0;
        }
        let prereleaseIndex = 0;
        do {
          let currentPrereleaseVersion = this.prerelease[prereleaseIndex];
          let comparisonPrereleaseVersion =
            comparePreReleaseVersions.prerelease[prereleaseIndex];
          validateAndProcessVersionEncoding(
            "prerelease compare",
            prereleaseIndex,
            currentPrereleaseVersion,
            comparisonPrereleaseVersion,
          );
          if (
            currentPrereleaseVersion === undefined &&
            comparisonPrereleaseVersion === undefined
          ) {
            return 0;
          }
          if (comparisonPrereleaseVersion === undefined) {
            return 1;
          }
          if (currentPrereleaseVersion === undefined) {
            return -1;
          }
          if (currentPrereleaseVersion === comparisonPrereleaseVersion) {
            continue;
          }
          return _compareVersionIdentifiers(
            currentPrereleaseVersion,
            comparisonPrereleaseVersion,
          );
        } while (++prereleaseIndex);
      }
      compareBuild(compareBuildWithVersion) {
        if (!(compareBuildWithVersion instanceof VersionParser)) {
          compareBuildWithVersion = new VersionParser(
            compareBuildWithVersion,
            this.options,
          );
        }
        let currentBuildIndex = 0;
        do {
          let currentBuild = this.build[currentBuildIndex];
          let comparisonBuild =
            compareBuildWithVersion.build[currentBuildIndex];
          validateAndProcessVersionEncoding(
            "prerelease compare",
            currentBuildIndex,
            currentBuild,
            comparisonBuild,
          );
          if (currentBuild === undefined && comparisonBuild === undefined) {
            return 0;
          }
          if (comparisonBuild === undefined) {
            return 1;
          }
          if (currentBuild === undefined) {
            return -1;
          }
          if (currentBuild === comparisonBuild) {
            continue;
          }
          return _compareVersionIdentifiers(currentBuild, comparisonBuild);
        } while (++currentBuildIndex);
      }
      inc(versionIncrementType, incrementValue) {
        switch (versionIncrementType) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", incrementValue);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", incrementValue);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", incrementValue);
            this.inc("pre", incrementValue);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", incrementValue);
            }
            this.inc("pre", incrementValue);
            break;
          case "major":
            if (
              this.minor !== 0 ||
              this.patch !== 0 ||
              this.prerelease.length === 0
            ) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let prereleaseCount = this.prerelease.length;
              while (--prereleaseCount >= 0) {
                if (typeof this.prerelease[prereleaseCount] == "number") {
                  this.prerelease[prereleaseCount]++;
                  prereleaseCount = -2;
                }
              }
              if (prereleaseCount === -1) {
                this.prerelease.push(0);
              }
            }
            if (incrementValue) {
              if (
                _compareVersionIdentifiers(
                  this.prerelease[0],
                  incrementValue,
                ) === 0
              ) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [incrementValue, 0];
                }
              } else {
                this.prerelease = [incrementValue, 0];
              }
            }
            break;
          default:
            throw new Error(
              "invalid increment argument: " + versionIncrementType,
            );
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    processVersion.exports = VersionParser;
  },
);
var readBufferBigUInt64LE = conditionalModuleLoader(
  (_____validateCharacterEncoding, validateAndExportCharacterEncoding) => {
    var { MAX_LENGTH: MAX_CHARACTER_ENCODING_LENGTH } =
      _validateAndRetrieveEncoding();
    var { re: encodingValidationRegex, t: encodingValidationOptions } =
      ____________________________________________________________validateAndRetrieveIntrinsicProperty();
    var _CharacterEncodingProcessor = processCharacterEncoding();
    var characterEncodingDecoder = decodedCharacter();
    var validateCharacterEncodingInput = (
      createCharacterEncodingProcessor,
      decodedInput,
    ) => {
      decodedInput = characterEncodingDecoder(decodedInput);
      if (
        createCharacterEncodingProcessor instanceof _CharacterEncodingProcessor
      ) {
        return createCharacterEncodingProcessor;
      }
      if (
        typeof createCharacterEncodingProcessor != "string" ||
        createCharacterEncodingProcessor.length >
          MAX_CHARACTER_ENCODING_LENGTH ||
        !(
          decodedInput.loose
            ? encodingValidationRegex[encodingValidationOptions.LOOSE]
            : encodingValidationRegex[encodingValidationOptions.FULL]
        ).test(createCharacterEncodingProcessor)
      ) {
        return null;
      }
      try {
        return new _CharacterEncodingProcessor(
          createCharacterEncodingProcessor,
          decodedInput,
        );
      } catch {
        return null;
      }
    };
    validateAndExportCharacterEncoding.exports = validateCharacterEncodingInput;
  },
);
var readBigUInt64Buffer = conditionalModuleLoader(
  (getVersionFromBuffer, getVersionFromBufferAndExport) => {
    var ____currentVersion = readBufferBigUInt64LE();
    var extractVersionFromBuffer = (getCurrentVersion, _versionData) => {
      let _____currentVersion = ____currentVersion(
        getCurrentVersion,
        _versionData,
      );
      if (_____currentVersion) {
        return _____currentVersion.version;
      } else {
        return null;
      }
    };
    getVersionFromBufferAndExport.exports = extractVersionFromBuffer;
  },
);
var readBigUInt64FromBuffer = conditionalModuleLoader(
  (processVersionMapping, getVersionFromTrimmedInput) => {
    var readAndProcessVersion = readBufferBigUInt64LE();
    var retrieveVersionFromInput = (processVersionInput, processedVersion) => {
      let processedVersionData = readAndProcessVersion(
        processVersionInput.trim().replace(/^[=v]+/, ""),
        processedVersion,
      );
      if (processedVersionData) {
        return processedVersionData.version;
      } else {
        return null;
      }
    };
    getVersionFromTrimmedInput.exports = retrieveVersionFromInput;
  },
);
var calculateBigIntFromBuffer = conditionalModuleLoader(
  (processCharacterEncodingAndVersion, exportedVersionIncrementer) => {
    var __CharacterEncodingProcessor = processCharacterEncoding();
    var incrementCharacterEncodingVersion = (
      __createCharacterEncodingProcessor,
      inputStringOrUndefined,
      inputEncoding,
      encodingType,
    ) => {
      if (typeof inputEncoding == "string") {
        encodingType = inputEncoding;
        inputEncoding = undefined;
      }
      try {
        return new __CharacterEncodingProcessor(
          __createCharacterEncodingProcessor instanceof
          __CharacterEncodingProcessor
            ? __createCharacterEncodingProcessor.version
            : __createCharacterEncodingProcessor,
          inputEncoding,
        ).inc(inputStringOrUndefined, encodingType).version;
      } catch {
        return null;
      }
    };
    exportedVersionIncrementer.exports = incrementCharacterEncodingVersion;
  },
);
var calculateBigInt = conditionalModuleLoader(
  (compareCharactersByEncoding, compareCharactersByEncodingAndType) => {
    var createAndCompareCharacterEncoding = processCharacterEncoding();
    var __compareCharacterEncodings = (
      _createAndCompareCharacterEncoding,
      characterEncodingInstance,
      sourceEncodingInstance,
    ) =>
      new createAndCompareCharacterEncoding(
        _createAndCompareCharacterEncoding,
        sourceEncodingInstance,
      ).compare(
        new createAndCompareCharacterEncoding(
          characterEncodingInstance,
          sourceEncodingInstance,
        ),
      );
    compareCharactersByEncodingAndType.exports = __compareCharacterEncodings;
  },
);
var readIntegerFromBuffer = conditionalModuleLoader(
  (areValuesEqualToZero, _areValuesEqualToZero) => {
    var isResultEqualToZero = calculateBigInt();
    var areCalculatedValuesZero = (
      inputValueOne,
      calculateDifference,
      isDifferenceEqualToZero,
    ) =>
      isResultEqualToZero(
        inputValueOne,
        calculateDifference,
        isDifferenceEqualToZero,
      ) === 0;
    _areValuesEqualToZero.exports = areCalculatedValuesZero;
  },
);
var byteArray = conditionalModuleLoader(
  (compareVersionPrerelease, ___comparePrereleaseVersions) => {
    var _readBigUInt64Value = readBufferBigUInt64LE();
    var readIntegerVersion = readIntegerFromBuffer();
    var ____comparePrereleaseVersions = (
      comparePackageVersions,
      compareWithPackageVersion,
    ) => {
      if (
        readIntegerVersion(comparePackageVersions, compareWithPackageVersion)
      ) {
        return null;
      }
      {
        let packageVersionComparison = _readBigUInt64Value(
          comparePackageVersions,
        );
        let compareAgainstPackageVersion = _readBigUInt64Value(
          compareWithPackageVersion,
        );
        let hasPrereleaseVersion =
          packageVersionComparison.prerelease.length ||
          compareAgainstPackageVersion.prerelease.length;
        let versionPrefix = hasPrereleaseVersion ? "pre" : "";
        let prereleaseVersionIndicator = hasPrereleaseVersion
          ? "prerelease"
          : "";
        for (let versionType in packageVersionComparison) {
          if (
            (versionType === "major" ||
              versionType === "minor" ||
              versionType === "patch") &&
            packageVersionComparison[versionType] !==
              compareAgainstPackageVersion[versionType]
          ) {
            return versionPrefix + versionType;
          }
        }
        return prereleaseVersionIndicator;
      }
    };
    ___comparePrereleaseVersions.exports = ____comparePrereleaseVersions;
  },
);
var bufferLength = conditionalModuleLoader(
  (createMajorFromCharacterEncoding, exportMajorCharacterEncoding) => {
    var _createMajorFromCharacterEncoding = processCharacterEncoding();
    var createMajorFromEncoding = (
      __createMajorFromCharacterEncoding,
      createMajorFromCharEncoding,
    ) =>
      new _createMajorFromCharacterEncoding(
        __createMajorFromCharacterEncoding,
        createMajorFromCharEncoding,
      ).major;
    exportMajorCharacterEncoding.exports = createMajorFromEncoding;
  },
);
var bufferSize = conditionalModuleLoader(
  (createMinorFromCharacterEncoding, exportMinorCreationFunction) => {
    var processCharacterEncodingInstance = processCharacterEncoding();
    var createMinorFromEncoding = (
      createCharacterEncodingProcess,
      characterEncodingProcess,
    ) =>
      new processCharacterEncodingInstance(
        createCharacterEncodingProcess,
        characterEncodingProcess,
      ).minor;
    exportMinorCreationFunction.exports = createMinorFromEncoding;
  },
);
var readInt16LittleEndian = conditionalModuleLoader(
  (createCharacterPatch, exportCharacterPatchFunction) => {
    var processCharacterPatch = processCharacterEncoding();
    var createAndExportCharacterPatch = (
      _createCharacterPatch,
      createAndProcessCharacterPatch,
    ) =>
      new processCharacterPatch(
        _createCharacterPatch,
        createAndProcessCharacterPatch,
      ).patch;
    exportCharacterPatchFunction.exports = createAndExportCharacterPatch;
  },
);
var calculateSigned16BitInteger = conditionalModuleLoader(
  (getPrereleaseVersions, exportGetPrereleaseVersions) => {
    var getPrereleaseVersionFromBuffer = readBufferBigUInt64LE();
    var getPrereleaseVersionsFromBuffer = (
      getPrereleaseArrayFromBuffer,
      prereleaseBuffer,
    ) => {
      let __prereleaseVersion = getPrereleaseVersionFromBuffer(
        getPrereleaseArrayFromBuffer,
        prereleaseBuffer,
      );
      if (__prereleaseVersion && __prereleaseVersion.prerelease.length) {
        return __prereleaseVersion.prerelease;
      } else {
        return null;
      }
    };
    exportGetPrereleaseVersions.exports = getPrereleaseVersionsFromBuffer;
  },
);
var readInt16FromBuffer = conditionalModuleLoader(
  (calculateBigIntAndExport, exportBigIntCalculation) => {
    var calculateAndExportBigInt = calculateBigInt();
    var calculateAndExportWithArguments = (
      calculateAndExportBigIntWithParams,
      _bigIntValue,
      exportBigIntWithParams,
    ) =>
      calculateAndExportBigInt(
        _bigIntValue,
        calculateAndExportBigIntWithParams,
        exportBigIntWithParams,
      );
    exportBigIntCalculation.exports = calculateAndExportWithArguments;
  },
);
var logDataHandler = conditionalModuleLoader(
  (_calculateAndExportBigInt, exportCalculateBigInt) => {
    var calculateBigIntWithExport = calculateBigInt();
    var calculateAndExportBigIntWithPrecision = (
      _firstBigIntValue,
      isExportActive,
    ) => calculateBigIntWithExport(_firstBigIntValue, isExportActive, true);
    exportCalculateBigInt.exports = calculateAndExportBigIntWithPrecision;
  },
);
var logProcessIndex = conditionalModuleLoader(
  (compareCharacterEncodings, _compareCharacterEncodings) => {
    var createCharacterEncodingComparer = processCharacterEncoding();
    var compareCharacterEncodingsByEncoding = (
      createEncodingComparerAndCompare,
      referenceCharacterEncodingComparer,
      characterEncodingComparer,
    ) => {
      let characterEncodingComparerInstance =
        new createCharacterEncodingComparer(
          createEncodingComparerAndCompare,
          characterEncodingComparer,
        );
      let referenceCharacterEncodingComparerInstance =
        new createCharacterEncodingComparer(
          referenceCharacterEncodingComparer,
          characterEncodingComparer,
        );
      return (
        characterEncodingComparerInstance.compare(
          referenceCharacterEncodingComparerInstance,
        ) ||
        characterEncodingComparerInstance.compareBuild(
          referenceCharacterEncodingComparerInstance,
        )
      );
    };
    _compareCharacterEncodings.exports = compareCharacterEncodingsByEncoding;
  },
);
var __processData = conditionalModuleLoader(
  (sortByLogProcessIndex, _sortByLogProcessIndex) => {
    var sortLogProcessByIndex = logProcessIndex();
    var sortLogProcessesByIndex = (sortProcessesByIndex, processSortingIndex) =>
      sortProcessesByIndex.sort((logProcess1, _processSortingIndex) =>
        sortLogProcessByIndex(
          logProcess1,
          _processSortingIndex,
          processSortingIndex,
        ),
      );
    _sortByLogProcessIndex.exports = sortLogProcessesByIndex;
  },
);
var _processLoggingData = conditionalModuleLoader(
  (sortProcessLogByIndex, _sortProcessLogByIndex) => {
    var sortLogByProcessIndex = logProcessIndex();
    var sortProcessEntriesByIndex = (
      processLogsSortFunction,
      logSortingProcessIndex,
    ) =>
      processLogsSortFunction.sort((sortLogByProcessIndexAndLog, logEntries) =>
        sortLogByProcessIndex(
          logEntries,
          sortLogByProcessIndexAndLog,
          logSortingProcessIndex,
        ),
      );
    _sortProcessLogByIndex.exports = sortProcessEntriesByIndex;
  },
);
var readInt16WithSignExtension = conditionalModuleLoader(
  (isBigIntGreaterThanZero, _isBigIntGreaterThanZero) => {
    var calculateAndCheckIfBigIntGreaterThanZero = calculateBigInt();
    var __isBigIntGreaterThanZero = (
      _calculateAndCheckIfBigIntGreaterThanZero,
      _valueToCheck,
      result,
    ) =>
      calculateAndCheckIfBigIntGreaterThanZero(
        _calculateAndCheckIfBigIntGreaterThanZero,
        _valueToCheck,
        result,
      ) > 0;
    _isBigIntGreaterThanZero.exports = __isBigIntGreaterThanZero;
  },
);
var applyBitwiseOrToMask = conditionalModuleLoader(
  (isBigIntNegative, isBigIntNegativeComparison) => {
    var calculateIfBigIntIsNegative = calculateBigInt();
    var isBigIntNegativeCalculation = (
      firstBigIntValue,
      firstBigIntValueComparison,
      _comparisonResult,
    ) =>
      calculateIfBigIntIsNegative(
        firstBigIntValue,
        firstBigIntValueComparison,
        _comparisonResult,
      ) < 0;
    isBigIntNegativeComparison.exports = isBigIntNegativeCalculation;
  },
);
var logForInstanceHandler = conditionalModuleLoader(
  (isBigIntNonZero, isBigIntNonZeroCheck) => {
    var _isBigIntNonZero = calculateBigInt();
    var _isBigIntNonZeroCheck = (
      isNonZeroBigIntValue,
      bigIntCheckValue,
      isValidNonZeroBigInt,
    ) =>
      _isBigIntNonZero(
        isNonZeroBigIntValue,
        bigIntCheckValue,
        isValidNonZeroBigInt,
      ) !== 0;
    isBigIntNonZeroCheck.exports = _isBigIntNonZeroCheck;
  },
);
var readBigInt64LE = conditionalModuleLoader(
  (isBigIntPositive, isBigIntNonNegative) => {
    var calculateAndCheckBigIntNonNegative = calculateBigInt();
    var _isBigIntNonNegative = (
      inputBigIntsForNonNegativeCheck,
      bigIntChecker,
      resultOfBigIntNonNegativeCheck,
    ) =>
      calculateAndCheckBigIntNonNegative(
        inputBigIntsForNonNegativeCheck,
        bigIntChecker,
        resultOfBigIntNonNegativeCheck,
      ) >= 0;
    isBigIntNonNegative.exports = _isBigIntNonNegative;
  },
);
var _readBigInt64LE = conditionalModuleLoader(
  (isResultLessThanOrEqualToZero, isBigIntLessThanOrEqualToZero) => {
    var calculateIfBigIntIsNonPositive = calculateBigInt();
    var isBigIntNonPositive = (
      isNonPositiveBigInt,
      bigIntValue,
      thresholdValue,
    ) =>
      calculateIfBigIntIsNonPositive(
        isNonPositiveBigInt,
        bigIntValue,
        thresholdValue,
      ) <= 0;
    isBigIntLessThanOrEqualToZero.exports = isBigIntNonPositive;
  },
);
var compareBufferOffset = conditionalModuleLoader(
  (__compareValues, compareValuesStrictly) => {
    var _readIntegerFromBuffer = readIntegerFromBuffer();
    var logForInstance = logForInstanceHandler();
    var readSignedInt16Value = readInt16WithSignExtension();
    var _readBigInt64Value = readBigInt64LE();
    var _applyBitwiseOrToMask = applyBitwiseOrToMask();
    var lastReadBigIntValue = _readBigInt64LE();
    var ___compareValues = (
      compareValuesUsingOperator,
      ___comparisonOperator,
      valueToCompare,
      bufferPosition,
    ) => {
      switch (___comparisonOperator) {
        case "===":
          if (typeof compareValuesUsingOperator == "object") {
            compareValuesUsingOperator = compareValuesUsingOperator.version;
          }
          if (typeof valueToCompare == "object") {
            valueToCompare = valueToCompare.version;
          }
          return compareValuesUsingOperator === valueToCompare;
        case "!==":
          if (typeof compareValuesUsingOperator == "object") {
            compareValuesUsingOperator = compareValuesUsingOperator.version;
          }
          if (typeof valueToCompare == "object") {
            valueToCompare = valueToCompare.version;
          }
          return compareValuesUsingOperator !== valueToCompare;
        case "":
        case "=":
        case "==":
          return _readIntegerFromBuffer(
            compareValuesUsingOperator,
            valueToCompare,
            bufferPosition,
          );
        case "!=":
          return logForInstance(
            compareValuesUsingOperator,
            valueToCompare,
            bufferPosition,
          );
        case ">":
          return readSignedInt16Value(
            compareValuesUsingOperator,
            valueToCompare,
            bufferPosition,
          );
        case ">=":
          return _readBigInt64Value(
            compareValuesUsingOperator,
            valueToCompare,
            bufferPosition,
          );
        case "<":
          return _applyBitwiseOrToMask(
            compareValuesUsingOperator,
            valueToCompare,
            bufferPosition,
          );
        case "<=":
          return lastReadBigIntValue(
            compareValuesUsingOperator,
            valueToCompare,
            bufferPosition,
          );
        default:
          throw new TypeError("Invalid operator: " + ___comparisonOperator);
      }
    };
    compareValuesStrictly.exports = ___compareValues;
  },
);
var compareAndReadFloatFromBuffer = conditionalModuleLoader(
  (validateAndCoerceValue, coerceAndRetrieveValue) => {
    var _processedCharacterEncoding = processCharacterEncoding();
    var bigUInt64Value = readBufferBigUInt64LE();
    var { re: regexPatterns, t: _intrinsicProperty } =
      ____________________________________________________________validateAndRetrieveIntrinsicProperty();
    var coerceAndValidateInput = (
      ______processCharacterEncoding,
      characterEncodingOptions,
    ) => {
      if (
        ______processCharacterEncoding instanceof _processedCharacterEncoding
      ) {
        return ______processCharacterEncoding;
      }
      if (typeof ______processCharacterEncoding == "number") {
        ______processCharacterEncoding = String(______processCharacterEncoding);
      }
      if (typeof ______processCharacterEncoding != "string") {
        return null;
      }
      characterEncodingOptions = characterEncodingOptions || {};
      let matchedCharacterEncoding = null;
      if (!characterEncodingOptions.rtl) {
        matchedCharacterEncoding = ______processCharacterEncoding.match(
          regexPatterns[_intrinsicProperty.COERCE],
        );
      } else {
        let currentMatch;
        while (
          (currentMatch = regexPatterns[_intrinsicProperty.COERCERTL].exec(
            ______processCharacterEncoding,
          )) &&
          (!matchedCharacterEncoding ||
            matchedCharacterEncoding.index +
              matchedCharacterEncoding[0].length !==
              ______processCharacterEncoding.length)
        ) {
          if (
            !matchedCharacterEncoding ||
            currentMatch.index + currentMatch[0].length !==
              matchedCharacterEncoding.index +
                matchedCharacterEncoding[0].length
          ) {
            matchedCharacterEncoding = currentMatch;
          }
          regexPatterns[_intrinsicProperty.COERCERTL].lastIndex =
            currentMatch.index +
            currentMatch[1].length +
            currentMatch[2].length;
        }
        regexPatterns[_intrinsicProperty.COERCERTL].lastIndex = -1;
      }
      if (matchedCharacterEncoding === null) {
        return null;
      } else {
        return bigUInt64Value(
          matchedCharacterEncoding[2] +
            "." +
            (matchedCharacterEncoding[3] || "0") +
            "." +
            (matchedCharacterEncoding[4] || "0"),
          characterEncodingOptions,
        );
      }
    };
    coerceAndRetrieveValue.exports = coerceAndValidateInput;
  },
);
var concatAndValidateBuffer = conditionalModuleLoader(
  (bufferArrayIterator, _bufferArrayIterator) => {
    _bufferArrayIterator.exports = function (
      _validateAndConcatenateBufferArrays,
    ) {
      _validateAndConcatenateBufferArrays.prototype[Symbol.iterator] =
        function* () {
          for (
            let ______________currentNode = this.head;
            ______________currentNode;
            ______________currentNode = ______________currentNode.next
          ) {
            yield ______________currentNode.value;
          }
        };
    };
  },
);
var readDoubleBigEndian = conditionalModuleLoader(
  (initializeBufferList, bufferListInitializer) => {
    bufferListInitializer.exports = BufferConcatenator;
    BufferConcatenator.Node = BigUInt64LinkedList;
    BufferConcatenator.create = BufferConcatenator;
    function BufferConcatenator(validateAndConcatenateBuffer) {
      var bufferConcatenatorContext = this;
      if (!(bufferConcatenatorContext instanceof BufferConcatenator)) {
        bufferConcatenatorContext = new BufferConcatenator();
      }
      bufferConcatenatorContext.tail = null;
      bufferConcatenatorContext.head = null;
      bufferConcatenatorContext.length = 0;
      if (
        validateAndConcatenateBuffer &&
        typeof validateAndConcatenateBuffer.forEach == "function"
      ) {
        validateAndConcatenateBuffer.forEach(
          function (_validateAndProcessBuffer) {
            bufferConcatenatorContext.push(_validateAndProcessBuffer);
          },
        );
      } else if (arguments.length > 0) {
        for (
          var argumentIndex = 0, _argumentsCount = arguments.length;
          argumentIndex < _argumentsCount;
          argumentIndex++
        ) {
          bufferConcatenatorContext.push(arguments[argumentIndex]);
        }
      }
      return bufferConcatenatorContext;
    }
    BufferConcatenator.prototype.removeNode = function (
      __validateAndProcessArrayBuffer,
    ) {
      if (__validateAndProcessArrayBuffer.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var nextNode = __validateAndProcessArrayBuffer.next;
      var previousNode = __validateAndProcessArrayBuffer.prev;
      if (nextNode) {
        nextNode.prev = previousNode;
      }
      if (previousNode) {
        previousNode.next = nextNode;
      }
      if (__validateAndProcessArrayBuffer === this.head) {
        this.head = nextNode;
      }
      if (__validateAndProcessArrayBuffer === this.tail) {
        this.tail = previousNode;
      }
      __validateAndProcessArrayBuffer.list.length--;
      __validateAndProcessArrayBuffer.next = null;
      __validateAndProcessArrayBuffer.prev = null;
      __validateAndProcessArrayBuffer.list = null;
      return nextNode;
    };
    BufferConcatenator.prototype.unshiftNode = function (initializeBufferData) {
      if (initializeBufferData !== this.head) {
        if (initializeBufferData.list) {
          initializeBufferData.list.removeNode(initializeBufferData);
        }
        var previousHeadNode = this.head;
        initializeBufferData.list = this;
        initializeBufferData.next = previousHeadNode;
        if (previousHeadNode) {
          previousHeadNode.prev = initializeBufferData;
        }
        this.head = initializeBufferData;
        this.tail ||= initializeBufferData;
        this.length++;
      }
    };
    BufferConcatenator.prototype.pushNode = function (
      copyAndValidateBufferLength,
    ) {
      if (copyAndValidateBufferLength !== this.tail) {
        if (copyAndValidateBufferLength.list) {
          copyAndValidateBufferLength.list.removeNode(
            copyAndValidateBufferLength,
          );
        }
        var previousTailNode = this.tail;
        copyAndValidateBufferLength.list = this;
        copyAndValidateBufferLength.prev = previousTailNode;
        if (previousTailNode) {
          previousTailNode.next = copyAndValidateBufferLength;
        }
        this.tail = copyAndValidateBufferLength;
        this.head ||= copyAndValidateBufferLength;
        this.length++;
      }
    };
    BufferConcatenator.prototype.push = function () {
      for (
        var _argumentIndex = 0, _argumentsLength = arguments.length;
        _argumentIndex < _argumentsLength;
        _argumentIndex++
      ) {
        __processAndEncodeCharacterData(this, arguments[_argumentIndex]);
      }
      return this.length;
    };
    BufferConcatenator.prototype.unshift = function () {
      for (
        var __argumentIndex = 0, __argumentsCount = arguments.length;
        __argumentIndex < __argumentsCount;
        __argumentIndex++
      ) {
        addCharacterDataToMapping(this, arguments[__argumentIndex]);
      }
      return this.length;
    };
    BufferConcatenator.prototype.pop = function () {
      if (this.tail) {
        var removedTailValue = this.tail.value;
        this.tail = this.tail.prev;
        if (this.tail) {
          this.tail.next = null;
        } else {
          this.head = null;
        }
        this.length--;
        return removedTailValue;
      }
    };
    BufferConcatenator.prototype.shift = function () {
      if (this.head) {
        var removedHeadValue = this.head.value;
        this.head = this.head.next;
        if (this.head) {
          this.head.prev = null;
        } else {
          this.tail = null;
        }
        this.length--;
        return removedHeadValue;
      }
    };
    BufferConcatenator.prototype.forEach = function (
      writeUint16BigEndian,
      writeUInt8AndCheckBounds,
    ) {
      writeUInt8AndCheckBounds = writeUInt8AndCheckBounds || this;
      for (
        var ______currentNode = this.head, __________index = 0;
        ______currentNode !== null;
        __________index++
      ) {
        writeUint16BigEndian.call(
          writeUInt8AndCheckBounds,
          ______currentNode.value,
          __________index,
          this,
        );
        ______currentNode = ______currentNode.next;
      }
    };
    BufferConcatenator.prototype.forEachReverse = function (
      __exportedRandomValueLength,
      writeUint16LittleEndian,
    ) {
      writeUint16LittleEndian = writeUint16LittleEndian || this;
      for (
        var currentTailNode = this.tail, _______index = this.length - 1;
        currentTailNode !== null;
        _______index--
      ) {
        __exportedRandomValueLength.call(
          writeUint16LittleEndian,
          currentTailNode.value,
          _______index,
          this,
        );
        currentTailNode = currentTailNode.prev;
      }
    };
    BufferConcatenator.prototype.get = function (writeUInt16LE) {
      for (
        var iterationCount = 0, __________currentNode = this.head;
        __________currentNode !== null && iterationCount < writeUInt16LE;
        iterationCount++
      ) {
        __________currentNode = __________currentNode.next;
      }
      if (iterationCount === writeUInt16LE && __________currentNode !== null) {
        return __________currentNode.value;
      }
    };
    BufferConcatenator.prototype.getReverse = function (
      writeUnsignedInt16BigEndian,
    ) {
      for (
        var traverseTailToHead = 0, ___________currentNode = this.tail;
        ___________currentNode !== null &&
        traverseTailToHead < writeUnsignedInt16BigEndian;
        traverseTailToHead++
      ) {
        ___________currentNode = ___________currentNode.prev;
      }
      if (
        traverseTailToHead === writeUnsignedInt16BigEndian &&
        ___________currentNode !== null
      ) {
        return ___________currentNode.value;
      }
    };
    BufferConcatenator.prototype.map = function (
      writeUint32LE,
      calculateAndWriteUint16BE,
    ) {
      calculateAndWriteUint16BE = calculateAndWriteUint16BE || this;
      var bufferConcatenator = new BufferConcatenator();
      for (var _______currentNode = this.head; _______currentNode !== null; ) {
        bufferConcatenator.push(
          writeUint32LE.call(
            calculateAndWriteUint16BE,
            _______currentNode.value,
            this,
          ),
        );
        _______currentNode = _______currentNode.next;
      }
      return bufferConcatenator;
    };
    BufferConcatenator.prototype.mapReverse = function (
      _getEncodedByteLength,
      __getEncodedByteLength,
    ) {
      __getEncodedByteLength = __getEncodedByteLength || this;
      var _bufferConcatenator = new BufferConcatenator();
      for (
        var ________currentNode = this.tail;
        ________currentNode !== null;

      ) {
        _bufferConcatenator.push(
          _getEncodedByteLength.call(
            __getEncodedByteLength,
            ________currentNode.value,
            this,
          ),
        );
        ________currentNode = ________currentNode.prev;
      }
      return _bufferConcatenator;
    };
    BufferConcatenator.prototype.reduce = function (
      writeExportedRandomValueLength,
      calculateByteLengthBasedOnEncodingValue,
    ) {
      var initialValueOrLength;
      var _currentNode = this.head;
      if (arguments.length > 1) {
        initialValueOrLength = calculateByteLengthBasedOnEncodingValue;
      } else if (this.head) {
        _currentNode = this.head.next;
        initialValueOrLength = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (
        var randomValueLengthCounter = 0;
        _currentNode !== null;
        randomValueLengthCounter++
      ) {
        initialValueOrLength = writeExportedRandomValueLength(
          initialValueOrLength,
          _currentNode.value,
          randomValueLengthCounter,
        );
        _currentNode = _currentNode.next;
      }
      return initialValueOrLength;
    };
    BufferConcatenator.prototype.reduceReverse = function (
      randomValueLength,
      _generateRandomValueLength,
    ) {
      var initialValueOrGeneratedValue;
      var _previousNode = this.tail;
      if (arguments.length > 1) {
        initialValueOrGeneratedValue = _generateRandomValueLength;
      } else if (this.tail) {
        _previousNode = this.tail.prev;
        initialValueOrGeneratedValue = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (
        var currentNodeIndex = this.length - 1;
        _previousNode !== null;
        currentNodeIndex--
      ) {
        initialValueOrGeneratedValue = randomValueLength(
          initialValueOrGeneratedValue,
          _previousNode.value,
          currentNodeIndex,
        );
        _previousNode = _previousNode.prev;
      }
      return initialValueOrGeneratedValue;
    };
    BufferConcatenator.prototype.toArray = function () {
      var valuesArray = new Array(this.length);
      for (
        var ___________index = 0, _________currentNode = this.head;
        _________currentNode !== null;
        ___________index++
      ) {
        valuesArray[___________index] = _________currentNode.value;
        _________currentNode = _________currentNode.next;
      }
      return valuesArray;
    };
    BufferConcatenator.prototype.toArrayReverse = function () {
      var arrayOfTailValues = new Array(this.length);
      for (
        var tailValuesCount = 0, _currentTailNode = this.tail;
        _currentTailNode !== null;
        tailValuesCount++
      ) {
        arrayOfTailValues[tailValuesCount] = _currentTailNode.value;
        _currentTailNode = _currentTailNode.prev;
      }
      return arrayOfTailValues;
    };
    BufferConcatenator.prototype.slice = function (
      __generateUniqueIdentifier,
      generateUniqueIdentifierSegments,
    ) {
      generateUniqueIdentifierSegments =
        generateUniqueIdentifierSegments || this.length;
      if (generateUniqueIdentifierSegments < 0) {
        generateUniqueIdentifierSegments += this.length;
      }
      __generateUniqueIdentifier = __generateUniqueIdentifier || 0;
      if (__generateUniqueIdentifier < 0) {
        __generateUniqueIdentifier += this.length;
      }
      var uniqueIdentifier = new BufferConcatenator();
      if (
        generateUniqueIdentifierSegments < __generateUniqueIdentifier ||
        generateUniqueIdentifierSegments < 0
      ) {
        return uniqueIdentifier;
      }
      if (__generateUniqueIdentifier < 0) {
        __generateUniqueIdentifier = 0;
      }
      if (generateUniqueIdentifierSegments > this.length) {
        generateUniqueIdentifierSegments = this.length;
      }
      for (
        var _______currentIndex = 0, ____________currentNode = this.head;
        ____________currentNode !== null &&
        _______currentIndex < __generateUniqueIdentifier;
        _______currentIndex++
      ) {
        ____________currentNode = ____________currentNode.next;
      }
      _______currentIndex++;
      for (
        ;
        ____________currentNode !== null &&
        _______currentIndex < generateUniqueIdentifierSegments;
        ____________currentNode = ____________currentNode.next
      ) {
        uniqueIdentifier.push(____________currentNode.value);
      }
      return uniqueIdentifier;
    };
    BufferConcatenator.prototype.sliceReverse = function (
      extractAndStoreEncodedValues,
      _processAndEncodeData,
    ) {
      _processAndEncodeData = _processAndEncodeData || this.length;
      if (_processAndEncodeData < 0) {
        _processAndEncodeData += this.length;
      }
      extractAndStoreEncodedValues = extractAndStoreEncodedValues || 0;
      if (extractAndStoreEncodedValues < 0) {
        extractAndStoreEncodedValues += this.length;
      }
      var encodedValuesAccumulator = new BufferConcatenator();
      if (
        _processAndEncodeData < extractAndStoreEncodedValues ||
        _processAndEncodeData < 0
      ) {
        return encodedValuesAccumulator;
      }
      if (extractAndStoreEncodedValues < 0) {
        extractAndStoreEncodedValues = 0;
      }
      if (_processAndEncodeData > this.length) {
        _processAndEncodeData = this.length;
      }
      for (
        var ______currentIndex = this.length, __currentTailNode = this.tail;
        __currentTailNode !== null &&
        ______currentIndex > _processAndEncodeData;
        ______currentIndex--
      ) {
        __currentTailNode = __currentTailNode.prev;
      }
      ______currentIndex--;
      for (
        ;
        __currentTailNode !== null &&
        ______currentIndex > extractAndStoreEncodedValues;
        __currentTailNode = __currentTailNode.prev
      ) {
        encodedValuesAccumulator.push(__currentTailNode.value);
      }
      return encodedValuesAccumulator;
    };
    BufferConcatenator.prototype.splice = function (
      processAndStoreEncodedNumbers,
      generateAndEncodeUniqueId,
      ...additionalEncodedValues
    ) {
      if (processAndStoreEncodedNumbers > this.length) {
        processAndStoreEncodedNumbers = this.length - 1;
      }
      if (processAndStoreEncodedNumbers < 0) {
        processAndStoreEncodedNumbers =
          this.length + processAndStoreEncodedNumbers;
      }
      for (
        var uniqueIdCounter = 0, _____________currentNode = this.head;
        _____________currentNode !== null &&
        uniqueIdCounter < processAndStoreEncodedNumbers;
        uniqueIdCounter++
      ) {
        _____________currentNode = _____________currentNode.next;
      }
      var collectedValues = [];
      for (
        var uniqueIdCounter = 0;
        _____________currentNode && uniqueIdCounter < generateAndEncodeUniqueId;
        uniqueIdCounter++
      ) {
        collectedValues.push(_____________currentNode.value);
        _____________currentNode = this.removeNode(_____________currentNode);
      }
      if (_____________currentNode === null) {
        _____________currentNode = this.tail;
      }
      if (
        _____________currentNode !== this.head &&
        _____________currentNode !== this.tail
      ) {
        _____________currentNode = _____________currentNode.prev;
      }
      for (
        var uniqueIdCounter = 0;
        uniqueIdCounter < additionalEncodedValues.length;
        uniqueIdCounter++
      ) {
        _____________currentNode = processAndLinkCharacterData(
          this,
          _____________currentNode,
          additionalEncodedValues[uniqueIdCounter],
        );
      }
      return collectedValues;
    };
    BufferConcatenator.prototype.reverse = function () {
      var ___currentNode = this.head;
      var prevTail = this.tail;
      for (
        var _____currentNode = ___currentNode;
        _____currentNode !== null;
        _____currentNode = _____currentNode.prev
      ) {
        var __previousNode = _____currentNode.prev;
        _____currentNode.prev = _____currentNode.next;
        _____currentNode.next = __previousNode;
      }
      this.head = prevTail;
      this.tail = ___currentNode;
      return this;
    };
    function processAndLinkCharacterData(
      __processAndMapCharacterData,
      processDataAndStoreEncodedCharacters,
      processAndEncodeCharacterData,
    ) {
      var newCharacterDataNode =
        processDataAndStoreEncodedCharacters ===
        __processAndMapCharacterData.head
          ? new BigUInt64LinkedList(
              processAndEncodeCharacterData,
              null,
              processDataAndStoreEncodedCharacters,
              __processAndMapCharacterData,
            )
          : new BigUInt64LinkedList(
              processAndEncodeCharacterData,
              processDataAndStoreEncodedCharacters,
              processDataAndStoreEncodedCharacters.next,
              __processAndMapCharacterData,
            );
      if (newCharacterDataNode.next === null) {
        __processAndMapCharacterData.tail = newCharacterDataNode;
      }
      if (newCharacterDataNode.prev === null) {
        __processAndMapCharacterData.head = newCharacterDataNode;
      }
      __processAndMapCharacterData.length++;
      return newCharacterDataNode;
    }
    function __processAndEncodeCharacterData(
      _processAndEncodeCharacterData,
      writeNormalizedBigUInt64,
    ) {
      _processAndEncodeCharacterData.tail = new BigUInt64LinkedList(
        writeNormalizedBigUInt64,
        _processAndEncodeCharacterData.tail,
        null,
        _processAndEncodeCharacterData,
      );
      _processAndEncodeCharacterData.head ||=
        _processAndEncodeCharacterData.tail;
      _processAndEncodeCharacterData.length++;
    }
    function addCharacterDataToMapping(
      processDataAndMapCharacter,
      processCharacterData,
    ) {
      processDataAndMapCharacter.head = new BigUInt64LinkedList(
        processCharacterData,
        null,
        processDataAndMapCharacter.head,
        processDataAndMapCharacter,
      );
      processDataAndMapCharacter.tail ||= processDataAndMapCharacter.head;
      processDataAndMapCharacter.length++;
    }
    function BigUInt64LinkedList(
      writeBigUInt64LE,
      _writeBigUInt64LE,
      calculateBigUInt64LE,
      writeIntLittleEndian,
    ) {
      if (!(this instanceof BigUInt64LinkedList)) {
        return new BigUInt64LinkedList(
          writeBigUInt64LE,
          _writeBigUInt64LE,
          calculateBigUInt64LE,
          writeIntLittleEndian,
        );
      }
      this.list = writeIntLittleEndian;
      this.value = writeBigUInt64LE;
      if (_writeBigUInt64LE) {
        _writeBigUInt64LE.next = this;
        this.prev = _writeBigUInt64LE;
      } else {
        this.prev = null;
      }
      if (calculateBigUInt64LE) {
        calculateBigUInt64LE.prev = this;
        this.next = calculateBigUInt64LE;
      } else {
        this.next = null;
      }
    }
    try {
      concatAndValidateBuffer()(BufferConcatenator);
    } catch {}
  },
);
var calculateSwappedBufferElements = conditionalModuleLoader(
  (createCacheWithMaxLength, createCacheWithSize) => {
    var cacheMaxLength = readDoubleBigEndian();
    var maxSymbol = Symbol("max");
    var lengthSymbol = Symbol("length");
    var _lengthCalculator = Symbol("lengthCalculator");
    var allowStaleSymbol = Symbol("allowStale");
    var maxAgeSymbol = Symbol("maxAge");
    var disposeSymbol = Symbol("dispose");
    var noDisposeOnSetSymbol = Symbol("noDisposeOnSet");
    var lruCacheList = Symbol("lruList");
    var cacheSymbol = Symbol("cache");
    var updateAgeOnGetSymbol = Symbol("updateAgeOnGet");
    var defaultLengthCalculator = () => 1;
    var CacheWithMaxLength = class {
      constructor(_options) {
        if (typeof _options == "number") {
          _options = {
            max: _options,
          };
        }
        _options ||= {};
        if (
          _options.max &&
          (typeof _options.max != "number" || _options.max < 0)
        ) {
          throw new TypeError("max must be a non-negative number");
        }
        let maxLimit = (this[maxSymbol] = _options.max || Infinity);
        let __lengthCalculator = _options.length || defaultLengthCalculator;
        if (typeof __lengthCalculator != "function") {
          this[_lengthCalculator] = defaultLengthCalculator;
        } else {
          this[_lengthCalculator] = __lengthCalculator;
        }
        this[allowStaleSymbol] = _options.stale || false;
        if (_options.maxAge && typeof _options.maxAge != "number") {
          throw new TypeError("maxAge must be a number");
        }
        this[maxAgeSymbol] = _options.maxAge || 0;
        this[disposeSymbol] = _options.dispose;
        this[noDisposeOnSetSymbol] = _options.noDisposeOnSet || false;
        this[updateAgeOnGetSymbol] = _options.updateAgeOnGet || false;
        this.reset();
      }
      set max(setMaxSize) {
        if (typeof setMaxSize != "number" || setMaxSize < 0) {
          throw new TypeError("max must be a non-negative number");
        }
        this[maxSymbol] = setMaxSize || Infinity;
        cacheMaxSize(this);
      }
      get max() {
        return this[maxSymbol];
      }
      set allowStale(setAllowStale) {
        this[allowStaleSymbol] = !!setAllowStale;
      }
      get allowStale() {
        return this[allowStaleSymbol];
      }
      set maxAge(setMaxAgeValue) {
        if (typeof setMaxAgeValue != "number") {
          throw new TypeError("maxAge must be a non-negative number");
        }
        this[maxAgeSymbol] = setMaxAgeValue;
        cacheMaxSize(this);
      }
      get maxAge() {
        return this[maxAgeSymbol];
      }
      set lengthCalculator(lengthCalculatorFunction) {
        if (typeof lengthCalculatorFunction != "function") {
          lengthCalculatorFunction = defaultLengthCalculator;
        }
        if (lengthCalculatorFunction !== this[_lengthCalculator]) {
          this[_lengthCalculator] = lengthCalculatorFunction;
          this[lengthSymbol] = 0;
          this[lruCacheList].forEach((calculatorResult) => {
            calculatorResult.length = this[_lengthCalculator](
              calculatorResult.value,
              calculatorResult.key,
            );
            this[lengthSymbol] += calculatorResult.length;
          });
        }
        cacheMaxSize(this);
      }
      get lengthCalculator() {
        return this[_lengthCalculator];
      }
      get length() {
        return this[lengthSymbol];
      }
      get itemCount() {
        return this[lruCacheList].length;
      }
      rforEach(cacheEvictionCallback, cacheEvictionContext) {
        cacheEvictionContext = cacheEvictionContext || this;
        for (
          let currentCacheItem = this[lruCacheList].tail;
          currentCacheItem !== null;

        ) {
          let previousCacheItem = currentCacheItem.prev;
          ___maxCacheLength(
            this,
            cacheEvictionCallback,
            currentCacheItem,
            cacheEvictionContext,
          );
          currentCacheItem = previousCacheItem;
        }
      }
      forEach(processCacheEntries, cacheProcessor) {
        cacheProcessor = cacheProcessor || this;
        for (
          let currentCacheEntry = this[lruCacheList].head;
          currentCacheEntry !== null;

        ) {
          let nextCacheEntry = currentCacheEntry.next;
          ___maxCacheLength(
            this,
            processCacheEntries,
            currentCacheEntry,
            cacheProcessor,
          );
          currentCacheEntry = nextCacheEntry;
        }
      }
      keys() {
        return this[lruCacheList].toArray().map((p801Key) => p801Key.key);
      }
      values() {
        return this[lruCacheList].toArray().map((p802Value) => p802Value.value);
      }
      reset() {
        if (
          this[disposeSymbol] &&
          this[lruCacheList] &&
          this[lruCacheList].length
        ) {
          this[lruCacheList].forEach((disposeResource) =>
            this[disposeSymbol](disposeResource.key, disposeResource.value),
          );
        }
        this[cacheSymbol] = new Map();
        this[lruCacheList] = new cacheMaxLength();
        this[lengthSymbol] = 0;
      }
      dump() {
        return this[lruCacheList]
          .map((____cacheEntry) =>
            _maxCacheLength(this, ____cacheEntry)
              ? false
              : {
                  k: ____cacheEntry.key,
                  v: ____cacheEntry.value,
                  e: ____cacheEntry.now + (____cacheEntry.maxAge || 0),
                },
          )
          .toArray()
          .filter((processTransaction) => processTransaction);
      }
      dumpLru() {
        return this[lruCacheList];
      }
      set(setCacheItem, valueToCache, maxCacheDuration) {
        maxCacheDuration = maxCacheDuration || this[maxAgeSymbol];
        if (maxCacheDuration && typeof maxCacheDuration != "number") {
          throw new TypeError("maxAge must be a number");
        }
        let cacheTimestamp = maxCacheDuration ? Date.now() : 0;
        let calculatedValueLength = this[_lengthCalculator](
          valueToCache,
          setCacheItem,
        );
        if (this[cacheSymbol].has(setCacheItem)) {
          if (calculatedValueLength > this[maxSymbol]) {
            maxCacheSize(this, this[cacheSymbol].get(setCacheItem));
            return false;
          }
          let _cachedItem = this[cacheSymbol].get(setCacheItem).value;
          if (this[disposeSymbol]) {
            if (!this[noDisposeOnSetSymbol]) {
              this[disposeSymbol](setCacheItem, _cachedItem.value);
            }
          }
          _cachedItem.now = cacheTimestamp;
          _cachedItem.maxAge = maxCacheDuration;
          _cachedItem.value = valueToCache;
          this[lengthSymbol] += calculatedValueLength - _cachedItem.length;
          _cachedItem.length = calculatedValueLength;
          this.get(setCacheItem);
          cacheMaxSize(this);
          return true;
        }
        let cachedItem = new __maxCacheLength(
          setCacheItem,
          valueToCache,
          calculatedValueLength,
          cacheTimestamp,
          maxCacheDuration,
        );
        if (cachedItem.length > this[maxSymbol]) {
          if (this[disposeSymbol]) {
            this[disposeSymbol](setCacheItem, valueToCache);
          }
          return false;
        } else {
          this[lengthSymbol] += cachedItem.length;
          this[lruCacheList].unshift(cachedItem);
          this[cacheSymbol].set(setCacheItem, this[lruCacheList].head);
          cacheMaxSize(this);
          return true;
        }
      }
      has(checkIfCached) {
        if (!this[cacheSymbol].has(checkIfCached)) {
          return false;
        }
        let _cachedValue = this[cacheSymbol].get(checkIfCached).value;
        return !_maxCacheLength(this, _cachedValue);
      }
      get(_cacheMaxLength) {
        return maxCacheLength(this, _cacheMaxLength, true);
      }
      peek(cacheLength) {
        return maxCacheLength(this, cacheLength, false);
      }
      pop() {
        let tailNode = this[lruCacheList].tail;
        if (tailNode) {
          maxCacheSize(this, tailNode);
          return tailNode.value;
        } else {
          return null;
        }
      }
      del(_____cacheEntry) {
        maxCacheSize(this, this[cacheSymbol].get(_____cacheEntry));
      }
      load(loadItemsBasedOnTimestamp) {
        this.reset();
        let currentTimestamp = Date.now();
        for (
          let itemIndex = loadItemsBasedOnTimestamp.length - 1;
          itemIndex >= 0;
          itemIndex--
        ) {
          let itemBasedOnTimestamp = loadItemsBasedOnTimestamp[itemIndex];
          let expirationTime = itemBasedOnTimestamp.e || 0;
          if (expirationTime === 0) {
            this.set(itemBasedOnTimestamp.k, itemBasedOnTimestamp.v);
          } else {
            let timeUntilExpiration = expirationTime - currentTimestamp;
            if (timeUntilExpiration > 0) {
              this.set(
                itemBasedOnTimestamp.k,
                itemBasedOnTimestamp.v,
                timeUntilExpiration,
              );
            }
          }
        }
      }
      prune() {
        this[cacheSymbol].forEach((calculateMaxCacheLength, useDefaultCache) =>
          maxCacheLength(this, useDefaultCache, false),
        );
      }
    };
    var maxCacheLength = (getCachedValue, cacheKey, isCacheOutOfDate) => {
      let cachedValue = getCachedValue[cacheSymbol].get(cacheKey);
      if (cachedValue) {
        let cachedValueReference = cachedValue.value;
        if (_maxCacheLength(getCachedValue, cachedValueReference)) {
          maxCacheSize(getCachedValue, cachedValue);
          if (!getCachedValue[allowStaleSymbol]) {
            return;
          }
        } else if (isCacheOutOfDate) {
          if (getCachedValue[updateAgeOnGetSymbol]) {
            cachedValue.value.now = Date.now();
          }
          getCachedValue[lruCacheList].unshiftNode(cachedValue);
        }
        return cachedValueReference.value;
      }
    };
    var _maxCacheLength = (isExpired, expirationData) => {
      if (
        !expirationData ||
        (!expirationData.maxAge && !isExpired[maxAgeSymbol])
      ) {
        return false;
      }
      let elapsedTimeSinceCreation = Date.now() - expirationData.now;
      if (expirationData.maxAge) {
        return elapsedTimeSinceCreation > expirationData.maxAge;
      } else {
        return (
          isExpired[maxAgeSymbol] &&
          elapsedTimeSinceCreation > isExpired[maxAgeSymbol]
        );
      }
    };
    var cacheMaxSize = (manageCacheSize) => {
      if (manageCacheSize[lengthSymbol] > manageCacheSize[maxSymbol]) {
        for (
          let currentCacheNode = manageCacheSize[lruCacheList].tail;
          manageCacheSize[lengthSymbol] > manageCacheSize[maxSymbol] &&
          currentCacheNode !== null;

        ) {
          let previousCacheNode = currentCacheNode.prev;
          maxCacheSize(manageCacheSize, currentCacheNode);
          currentCacheNode = previousCacheNode;
        }
      }
    };
    var maxCacheSize = (disposeCacheAndUpdate, cacheItem) => {
      if (cacheItem) {
        let __cachedItem = cacheItem.value;
        if (disposeCacheAndUpdate[disposeSymbol]) {
          disposeCacheAndUpdate[disposeSymbol](
            __cachedItem.key,
            __cachedItem.value,
          );
        }
        disposeCacheAndUpdate[lengthSymbol] -= __cachedItem.length;
        disposeCacheAndUpdate[cacheSymbol].delete(__cachedItem.key);
        disposeCacheAndUpdate[lruCacheList].removeNode(cacheItem);
      }
    };
    var __maxCacheLength = class {
      constructor(
        keyValuePair,
        value,
        lengthInSeconds,
        _currentTimestamp,
        maxAge,
      ) {
        this.key = keyValuePair;
        this.value = value;
        this.length = lengthInSeconds;
        this.now = _currentTimestamp;
        this.maxAge = maxAge || 0;
      }
    };
    var ___maxCacheLength = (
      cacheHandler,
      cacheHandlerCallback,
      ___cacheEntry,
      ____context,
    ) => {
      let cacheEntryValue = ___cacheEntry.value;
      if (_maxCacheLength(cacheHandler, cacheEntryValue)) {
        maxCacheSize(cacheHandler, ___cacheEntry);
        if (!cacheHandler[allowStaleSymbol]) {
          cacheEntryValue = undefined;
        }
      }
      if (cacheEntryValue) {
        cacheHandlerCallback.call(
          ____context,
          cacheEntryValue.value,
          cacheEntryValue.key,
          cacheHandler,
        );
      }
    };
    createCacheWithSize.exports = CacheWithMaxLength;
  },
);
var getCompareSegmentBounds = conditionalModuleLoader(
  (createSemanticVersionRange, createSemanticVersionRangeFunction) => {
    var SemanticVersionRange = class {
      constructor(rawVersionOrRange, versionOptions) {
        versionOptions = validateVersionOptions(versionOptions);
        if (rawVersionOrRange instanceof SemanticVersionRange) {
          if (
            rawVersionOrRange.loose === !!versionOptions.loose &&
            rawVersionOrRange.includePrerelease ===
              !!versionOptions.includePrerelease
          ) {
            return rawVersionOrRange;
          } else {
            return new SemanticVersionRange(
              rawVersionOrRange.raw,
              versionOptions,
            );
          }
        }
        if (rawVersionOrRange instanceof Version) {
          this.raw = rawVersionOrRange.value;
          this.set = [[rawVersionOrRange]];
          this.format();
          return this;
        }
        this.options = versionOptions;
        this.loose = !!versionOptions.loose;
        this.includePrerelease = !!versionOptions.includePrerelease;
        this.raw = rawVersionOrRange;
        this.set = rawVersionOrRange
          .split("||")
          .map((parseRangeString) => this.parseRange(parseRangeString.trim()))
          .filter((getLengthOfArray) => getLengthOfArray.length);
        if (!this.set.length) {
          throw new TypeError("Invalid SemVer Range: " + rawVersionOrRange);
        }
        if (this.set.length > 1) {
          let firstSetElement = this.set[0];
          this.set = this.set.filter(
            (isInvalidVersionRange) =>
              !__semanticVersionRange(isInvalidVersionRange[0]),
          );
          if (this.set.length === 0) {
            this.set = [firstSetElement];
          } else if (this.set.length > 1) {
            for (let __versionRange of this.set) {
              if (
                __versionRange.length === 1 &&
                _______SemanticVersionRange(__versionRange[0])
              ) {
                this.set = [__versionRange];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set
          .map((joinAndTrimStringArray) =>
            joinAndTrimStringArray.join(" ").trim(),
          )
          .join("||")
          .trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(versionRangeString) {
        versionRangeString = versionRangeString.trim();
        let logParseRangeParameters =
          "parseRange:" +
          Object.keys(this.options).join(",") +
          ":" +
          versionRangeString;
        let cachedParsedVersionRange = _semanticVersionRange.get(
          logParseRangeParameters,
        );
        if (cachedParsedVersionRange) {
          return cachedParsedVersionRange;
        }
        let isLooseVersion = this.options.loose;
        let hyphenRangePattern = isLooseVersion
          ? ObjectSemanticVersionRange[___SemanticVersionRange.HYPHENRANGELOOSE]
          : ObjectSemanticVersionRange[___SemanticVersionRange.HYPHENRANGE];
        versionRangeString = versionRangeString.replace(
          hyphenRangePattern,
          ________________SemanticVersionRange(this.options.includePrerelease),
        );
        _SemanticVersionRange("hyphen replace", versionRangeString);
        versionRangeString = versionRangeString.replace(
          ObjectSemanticVersionRange[___SemanticVersionRange.COMPARATORTRIM],
          ____SemanticVersionRange,
        );
        _SemanticVersionRange("comparator trim", versionRangeString);
        versionRangeString = versionRangeString.replace(
          ObjectSemanticVersionRange[___SemanticVersionRange.TILDETRIM],
          _____SemanticVersionRange,
        );
        versionRangeString = versionRangeString.replace(
          ObjectSemanticVersionRange[___SemanticVersionRange.CARETTRIM],
          ______SemanticVersionRange,
        );
        versionRangeString = versionRangeString.split(/\s+/).join(" ");
        let ____parseVersionRange = versionRangeString
          .split(" ")
          .map((__createSemanticVersionRange) =>
            SemanticVersionRangeConstructor(
              __createSemanticVersionRange,
              this.options,
            ),
          )
          .join(" ")
          .split(/\s+/)
          .map((parseSemanticVersionRange) =>
            _______________SemanticVersionRange(
              parseSemanticVersionRange,
              this.options,
            ),
          );
        if (isLooseVersion) {
          ____parseVersionRange = ____parseVersionRange.filter(
            (looseInvalidFilterCheck) => {
              _SemanticVersionRange(
                "loose invalid filter",
                looseInvalidFilterCheck,
                this.options,
              );
              return !!looseInvalidFilterCheck.match(
                ObjectSemanticVersionRange[
                  ___SemanticVersionRange.COMPARATORLOOSE
                ],
              );
            },
          );
        }
        _SemanticVersionRange("range list", ____parseVersionRange);
        let _____parseVersionRange = new Map();
        let ______parseVersionRange = ____parseVersionRange.map(
          (______currentVersion) =>
            new Version(______currentVersion, this.options),
        );
        for (let versionRangeItem of ______parseVersionRange) {
          if (__semanticVersionRange(versionRangeItem)) {
            return [versionRangeItem];
          }
          _____parseVersionRange.set(versionRangeItem.value, versionRangeItem);
        }
        if (_____parseVersionRange.size > 1 && _____parseVersionRange.has("")) {
          _____parseVersionRange.delete("");
        }
        let _____parseVersion = [..._____parseVersionRange.values()];
        _semanticVersionRange.set(logParseRangeParameters, _____parseVersion);
        return _____parseVersion;
      }
      intersects(semanticVersionRangeIntersects, targetSemanticVersion) {
        if (!(semanticVersionRangeIntersects instanceof SemanticVersionRange)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some(
          (isSemanticVersionRangeCompatible) =>
            ___semanticVersionRange(
              isSemanticVersionRangeCompatible,
              targetSemanticVersion,
            ) &&
            semanticVersionRangeIntersects.set.some(
              (isVersionCompatible) =>
                ___semanticVersionRange(
                  isVersionCompatible,
                  targetSemanticVersion,
                ) &&
                isSemanticVersionRangeCompatible.every(
                  (isVersionCompatibleWithTarget) =>
                    isVersionCompatible.every((_targetSemanticVersion) =>
                      isVersionCompatibleWithTarget.intersects(
                        _targetSemanticVersion,
                        targetSemanticVersion,
                      ),
                    ),
                ),
            ),
        );
      }
      test(_versionRange) {
        if (!_versionRange) {
          return false;
        }
        if (typeof _versionRange == "string") {
          try {
            _versionRange = new __SemanticVersionRange(
              _versionRange,
              this.options,
            );
          } catch {
            return false;
          }
        }
        for (
          let _currentVersionIndex = 0;
          _currentVersionIndex < this.set.length;
          _currentVersionIndex++
        ) {
          if (
            _________________SemanticVersionRange(
              this.set[_currentVersionIndex],
              _versionRange,
              this.options,
            )
          ) {
            return true;
          }
        }
        return false;
      }
    };
    createSemanticVersionRangeFunction.exports = SemanticVersionRange;
    var semanticVersionRange = calculateSwappedBufferElements();
    var _semanticVersionRange = new semanticVersionRange({
      max: 1000,
    });
    var validateVersionOptions = decodedCharacter();
    var Version = processCharacterOrCodePoint();
    var _SemanticVersionRange = validateAndProcessEncoding();
    var __SemanticVersionRange = processCharacterEncoding();
    var {
      re: ObjectSemanticVersionRange,
      t: ___SemanticVersionRange,
      comparatorTrimReplace: ____SemanticVersionRange,
      tildeTrimReplace: _____SemanticVersionRange,
      caretTrimReplace: ______SemanticVersionRange,
    } = ____________________________________________________________validateAndRetrieveIntrinsicProperty();
    var __semanticVersionRange = (isVersionLessThanZero) =>
      isVersionLessThanZero.value === "<0.0.0-0";
    var _______SemanticVersionRange = (isInputValueEmpty) =>
      isInputValueEmpty.value === "";
    var ___semanticVersionRange = (
      areAllElementsIntersecting,
      intersectionChecker,
    ) => {
      let areAllIntersectionsValid = true;
      let previousElement = areAllElementsIntersecting.slice();
      let currentElementForIntersectionCheck = previousElement.pop();
      while (areAllIntersectionsValid && previousElement.length) {
        areAllIntersectionsValid = previousElement.every(
          (elementToCheckForIntersection) =>
            currentElementForIntersectionCheck.intersects(
              elementToCheckForIntersection,
              intersectionChecker,
            ),
        );
        currentElementForIntersectionCheck = previousElement.pop();
      }
      return areAllIntersectionsValid;
    };
    var SemanticVersionRangeConstructor = (
      baseVersionRange,
      _versionComparison,
    ) => {
      _SemanticVersionRange("comp", baseVersionRange, _versionComparison);
      baseVersionRange = ___________SemanticVersionRange(
        baseVersionRange,
        _versionComparison,
      );
      _SemanticVersionRange("caret", baseVersionRange);
      baseVersionRange = _________SemanticVersionRange(
        baseVersionRange,
        _versionComparison,
      );
      _SemanticVersionRange("tildes", baseVersionRange);
      baseVersionRange = _____________SemanticVersionRange(
        baseVersionRange,
        _versionComparison,
      );
      _SemanticVersionRange("xrange", baseVersionRange);
      baseVersionRange = semverRange(baseVersionRange, _versionComparison);
      _SemanticVersionRange("stars", baseVersionRange);
      return baseVersionRange;
    };
    var ________SemanticVersionRange = (isValidInput) =>
      !isValidInput ||
      isValidInput.toLowerCase() === "x" ||
      isValidInput === "*";
    var _________SemanticVersionRange = (
      semanticVersionProcessor,
      _________semanticVersionRange,
    ) =>
      semanticVersionProcessor
        .trim()
        .split(/\s+/)
        .map((checkSemanticVersionRange) =>
          __________SemanticVersionRange(
            checkSemanticVersionRange,
            _________semanticVersionRange,
          ),
        )
        .join(" ");
    var __________SemanticVersionRange = (
      replaceTildeInSemanticVersion,
      _______semanticVersionRange,
    ) => {
      let tildeSemanticVersionObject = _______semanticVersionRange.loose
        ? ObjectSemanticVersionRange[___SemanticVersionRange.TILDELOOSE]
        : ObjectSemanticVersionRange[___SemanticVersionRange.TILDE];
      return replaceTildeInSemanticVersion.replace(
        tildeSemanticVersionObject,
        (
          _generateSemanticVersionRange,
          majorVersion,
          __minorVersion,
          _patchVersion,
          preReleaseIdentifier,
        ) => {
          _SemanticVersionRange(
            "tilde",
            replaceTildeInSemanticVersion,
            _generateSemanticVersionRange,
            majorVersion,
            __minorVersion,
            _patchVersion,
            preReleaseIdentifier,
          );
          let ________semanticVersionRange;
          if (________SemanticVersionRange(majorVersion)) {
            ________semanticVersionRange = "";
          } else if (________SemanticVersionRange(__minorVersion)) {
            ________semanticVersionRange =
              ">=" + majorVersion + ".0.0 <" + (+majorVersion + 1) + ".0.0-0";
          } else if (________SemanticVersionRange(_patchVersion)) {
            ________semanticVersionRange =
              ">=" +
              majorVersion +
              "." +
              __minorVersion +
              ".0 <" +
              majorVersion +
              "." +
              (+__minorVersion + 1) +
              ".0-0";
          } else if (preReleaseIdentifier) {
            _SemanticVersionRange("replaceTilde pr", preReleaseIdentifier);
            ________semanticVersionRange =
              ">=" +
              majorVersion +
              "." +
              __minorVersion +
              "." +
              _patchVersion +
              "-" +
              preReleaseIdentifier +
              " <" +
              majorVersion +
              "." +
              (+__minorVersion + 1) +
              ".0-0";
          } else {
            ________semanticVersionRange =
              ">=" +
              majorVersion +
              "." +
              __minorVersion +
              "." +
              _patchVersion +
              " <" +
              majorVersion +
              "." +
              (+__minorVersion + 1) +
              ".0-0";
          }
          _SemanticVersionRange("tilde return", ________semanticVersionRange);
          return ________semanticVersionRange;
        },
      );
    };
    var ___________SemanticVersionRange = (
      parseAndTransformVersionRange,
      ____comparisonOperator,
    ) =>
      parseAndTransformVersionRange
        .trim()
        .split(/\s+/)
        .map((isVersionWithinRange) =>
          ____________SemanticVersionRange(
            isVersionWithinRange,
            ____comparisonOperator,
          ),
        )
        .join(" ");
    var ____________SemanticVersionRange = (
      sourceVersion,
      versionRangeOptions,
    ) => {
      _SemanticVersionRange("caret", sourceVersion, versionRangeOptions);
      let parsedVersionRange = versionRangeOptions.loose
        ? ObjectSemanticVersionRange[___SemanticVersionRange.CARETLOOSE]
        : ObjectSemanticVersionRange[___SemanticVersionRange.CARET];
      let prereleaseSuffix = versionRangeOptions.includePrerelease ? "-0" : "";
      return sourceVersion.replace(
        parsedVersionRange,
        (
          _sourceVersion,
          _minorVersion,
          _prereleaseSuffix,
          prereleaseVersion,
          isPrereleaseArgument,
        ) => {
          _SemanticVersionRange(
            "caret",
            sourceVersion,
            _sourceVersion,
            _minorVersion,
            _prereleaseSuffix,
            prereleaseVersion,
            isPrereleaseArgument,
          );
          let _versionRangeCondition;
          if (________SemanticVersionRange(_minorVersion)) {
            _versionRangeCondition = "";
          } else if (________SemanticVersionRange(_prereleaseSuffix)) {
            _versionRangeCondition =
              ">=" +
              _minorVersion +
              ".0.0" +
              prereleaseSuffix +
              " <" +
              (+_minorVersion + 1) +
              ".0.0-0";
          } else if (________SemanticVersionRange(prereleaseVersion)) {
            if (_minorVersion === "0") {
              _versionRangeCondition =
                ">=" +
                _minorVersion +
                "." +
                _prereleaseSuffix +
                ".0" +
                prereleaseSuffix +
                " <" +
                _minorVersion +
                "." +
                (+_prereleaseSuffix + 1) +
                ".0-0";
            } else {
              _versionRangeCondition =
                ">=" +
                _minorVersion +
                "." +
                _prereleaseSuffix +
                ".0" +
                prereleaseSuffix +
                " <" +
                (+_minorVersion + 1) +
                ".0.0-0";
            }
          } else if (isPrereleaseArgument) {
            _SemanticVersionRange("replaceCaret pr", isPrereleaseArgument);
            if (_minorVersion === "0") {
              if (_prereleaseSuffix === "0") {
                _versionRangeCondition =
                  ">=" +
                  _minorVersion +
                  "." +
                  _prereleaseSuffix +
                  "." +
                  prereleaseVersion +
                  "-" +
                  isPrereleaseArgument +
                  " <" +
                  _minorVersion +
                  "." +
                  _prereleaseSuffix +
                  "." +
                  (+prereleaseVersion + 1) +
                  "-0";
              } else {
                _versionRangeCondition =
                  ">=" +
                  _minorVersion +
                  "." +
                  _prereleaseSuffix +
                  "." +
                  prereleaseVersion +
                  "-" +
                  isPrereleaseArgument +
                  " <" +
                  _minorVersion +
                  "." +
                  (+_prereleaseSuffix + 1) +
                  ".0-0";
              }
            } else {
              _versionRangeCondition =
                ">=" +
                _minorVersion +
                "." +
                _prereleaseSuffix +
                "." +
                prereleaseVersion +
                "-" +
                isPrereleaseArgument +
                " <" +
                (+_minorVersion + 1) +
                ".0.0-0";
            }
          } else {
            _SemanticVersionRange("no pr");
            if (_minorVersion === "0") {
              if (_prereleaseSuffix === "0") {
                _versionRangeCondition =
                  ">=" +
                  _minorVersion +
                  "." +
                  _prereleaseSuffix +
                  "." +
                  prereleaseVersion +
                  prereleaseSuffix +
                  " <" +
                  _minorVersion +
                  "." +
                  _prereleaseSuffix +
                  "." +
                  (+prereleaseVersion + 1) +
                  "-0";
              } else {
                _versionRangeCondition =
                  ">=" +
                  _minorVersion +
                  "." +
                  _prereleaseSuffix +
                  "." +
                  prereleaseVersion +
                  prereleaseSuffix +
                  " <" +
                  _minorVersion +
                  "." +
                  (+_prereleaseSuffix + 1) +
                  ".0-0";
              }
            } else {
              _versionRangeCondition =
                ">=" +
                _minorVersion +
                "." +
                _prereleaseSuffix +
                "." +
                prereleaseVersion +
                " <" +
                (+_minorVersion + 1) +
                ".0.0-0";
            }
          }
          _SemanticVersionRange("caret return", _versionRangeCondition);
          return _versionRangeCondition;
        },
      );
    };
    var _____________SemanticVersionRange = (
      sourceVersionRange,
      replacementVersionRange,
    ) => {
      _SemanticVersionRange(
        "replaceXRanges",
        sourceVersionRange,
        replacementVersionRange,
      );
      return sourceVersionRange
        .split(/\s+/)
        .map((__________semanticVersionRange) =>
          ______________SemanticVersionRange(
            __________semanticVersionRange,
            replacementVersionRange,
          ),
        )
        .join(" ");
    };
    var ______________SemanticVersionRange = (
      _versionString,
      semanticVersionOptions,
    ) => {
      _versionString = _versionString.trim();
      let ____semanticVersionRange = semanticVersionOptions.loose
        ? ObjectSemanticVersionRange[___SemanticVersionRange.XRANGELOOSE]
        : ObjectSemanticVersionRange[___SemanticVersionRange.XRANGE];
      return _versionString.replace(
        ____semanticVersionRange,
        (
          semanticVersionMajorPart,
          _comparisonOperator,
          previousVersionRange,
          currentVersionRange,
          standardVersion,
          __prereleaseSuffix,
        ) => {
          _SemanticVersionRange(
            "xRange",
            _versionString,
            semanticVersionMajorPart,
            _comparisonOperator,
            previousVersionRange,
            currentVersionRange,
            standardVersion,
            __prereleaseSuffix,
          );
          let parsedPreviousVersionRange =
            ________SemanticVersionRange(previousVersionRange);
          let _parsedVersionRange =
            parsedPreviousVersionRange ||
            ________SemanticVersionRange(currentVersionRange);
          let _parsedVersion =
            _parsedVersionRange ||
            ________SemanticVersionRange(standardVersion);
          let __parsedVersion = _parsedVersion;
          if (_comparisonOperator === "=" && __parsedVersion) {
            _comparisonOperator = "";
          }
          if (semanticVersionOptions.includePrerelease) {
            __prereleaseSuffix = "-0";
          } else {
            __prereleaseSuffix = "";
          }
          if (parsedPreviousVersionRange) {
            if (_comparisonOperator === ">" || _comparisonOperator === "<") {
              semanticVersionMajorPart = "<0.0.0-0";
            } else {
              semanticVersionMajorPart = "*";
            }
          } else if (_comparisonOperator && __parsedVersion) {
            if (_parsedVersionRange) {
              currentVersionRange = 0;
            }
            standardVersion = 0;
            if (_comparisonOperator === ">") {
              _comparisonOperator = ">=";
              if (_parsedVersionRange) {
                previousVersionRange = +previousVersionRange + 1;
                currentVersionRange = 0;
                standardVersion = 0;
              } else {
                currentVersionRange = +currentVersionRange + 1;
                standardVersion = 0;
              }
            } else if (_comparisonOperator === "<=") {
              _comparisonOperator = "<";
              if (_parsedVersionRange) {
                previousVersionRange = +previousVersionRange + 1;
              } else {
                currentVersionRange = +currentVersionRange + 1;
              }
            }
            if (_comparisonOperator === "<") {
              __prereleaseSuffix = "-0";
            }
            semanticVersionMajorPart =
              _comparisonOperator +
              previousVersionRange +
              "." +
              currentVersionRange +
              "." +
              standardVersion +
              __prereleaseSuffix;
          } else if (_parsedVersionRange) {
            semanticVersionMajorPart =
              ">=" +
              previousVersionRange +
              ".0.0" +
              __prereleaseSuffix +
              " <" +
              (+previousVersionRange + 1) +
              ".0.0-0";
          } else if (_parsedVersion) {
            semanticVersionMajorPart =
              ">=" +
              previousVersionRange +
              "." +
              currentVersionRange +
              ".0" +
              __prereleaseSuffix +
              " <" +
              previousVersionRange +
              "." +
              (+currentVersionRange + 1) +
              ".0-0";
          }
          _SemanticVersionRange("xRange return", semanticVersionMajorPart);
          return semanticVersionMajorPart;
        },
      );
    };
    var semverRange = (versionRangeInput, replaceStarsWithActualVersions) => {
      _SemanticVersionRange(
        "replaceStars",
        versionRangeInput,
        replaceStarsWithActualVersions,
      );
      return versionRangeInput
        .trim()
        .replace(ObjectSemanticVersionRange[___SemanticVersionRange.STAR], "");
    };
    var _______________SemanticVersionRange = (
      semanticVersionRangeString,
      includePrereleaseFlag,
    ) => {
      _SemanticVersionRange(
        "replaceGTE0",
        semanticVersionRangeString,
        includePrereleaseFlag,
      );
      return semanticVersionRangeString
        .trim()
        .replace(
          ObjectSemanticVersionRange[
            includePrereleaseFlag.includePrerelease
              ? ___SemanticVersionRange.GTE0PRE
              : ___SemanticVersionRange.GTE0
          ],
          "",
        );
    };
    var ________________SemanticVersionRange =
      (_createSemanticVersionRange) =>
      (
        generateSemanticVersionRange,
        _____semanticVersionRange,
        baseVersion,
        minimumPatchVersionRange,
        minimumPatchVersion,
        isBaseVersionDefined,
        ______semanticVersionRange,
        currentMinimumSemanticVersionRange,
        minimumVersionThreshold,
        calculateSemanticVersionRange,
        currentSemanticVersionRange,
        currentPatchVersionRange,
        minimumSupportedVersionRange,
      ) => {
        if (________SemanticVersionRange(baseVersion)) {
          _____semanticVersionRange = "";
        } else if (________SemanticVersionRange(minimumPatchVersionRange)) {
          _____semanticVersionRange =
            ">=" +
            baseVersion +
            ".0.0" +
            (_createSemanticVersionRange ? "-0" : "");
        } else if (________SemanticVersionRange(minimumPatchVersion)) {
          _____semanticVersionRange =
            ">=" +
            baseVersion +
            "." +
            minimumPatchVersionRange +
            ".0" +
            (_createSemanticVersionRange ? "-0" : "");
        } else if (isBaseVersionDefined) {
          _____semanticVersionRange = ">=" + _____semanticVersionRange;
        } else {
          _____semanticVersionRange =
            ">=" +
            _____semanticVersionRange +
            (_createSemanticVersionRange ? "-0" : "");
        }
        if (________SemanticVersionRange(minimumVersionThreshold)) {
          currentMinimumSemanticVersionRange = "";
        } else if (
          ________SemanticVersionRange(calculateSemanticVersionRange)
        ) {
          currentMinimumSemanticVersionRange =
            "<" + (+minimumVersionThreshold + 1) + ".0.0-0";
        } else if (________SemanticVersionRange(currentSemanticVersionRange)) {
          currentMinimumSemanticVersionRange =
            "<" +
            minimumVersionThreshold +
            "." +
            (+calculateSemanticVersionRange + 1) +
            ".0-0";
        } else if (currentPatchVersionRange) {
          currentMinimumSemanticVersionRange =
            "<=" +
            minimumVersionThreshold +
            "." +
            calculateSemanticVersionRange +
            "." +
            currentSemanticVersionRange +
            "-" +
            currentPatchVersionRange;
        } else if (_createSemanticVersionRange) {
          currentMinimumSemanticVersionRange =
            "<" +
            minimumVersionThreshold +
            "." +
            calculateSemanticVersionRange +
            "." +
            (+currentSemanticVersionRange + 1) +
            "-0";
        } else {
          currentMinimumSemanticVersionRange =
            "<=" + currentMinimumSemanticVersionRange;
        }
        return (
          _____semanticVersionRange +
          " " +
          currentMinimumSemanticVersionRange
        ).trim();
      };
    var _________________SemanticVersionRange = (
      validateSemverCompatibility,
      semanticVersion,
      allowPrereleaseVersions,
    ) => {
      for (
        let ____________index = 0;
        ____________index < validateSemverCompatibility.length;
        ____________index++
      ) {
        if (
          !validateSemverCompatibility[____________index].test(semanticVersion)
        ) {
          return false;
        }
      }
      if (
        semanticVersion.prerelease.length &&
        !allowPrereleaseVersions.includePrerelease
      ) {
        for (
          let _index = 0;
          _index < validateSemverCompatibility.length;
          _index++
        ) {
          _SemanticVersionRange(validateSemverCompatibility[_index].semver);
          if (
            validateSemverCompatibility[_index].semver !== Version.ANY &&
            validateSemverCompatibility[_index].semver.prerelease.length > 0
          ) {
            let semverVersion = validateSemverCompatibility[_index].semver;
            if (
              semverVersion.major === semanticVersion.major &&
              semverVersion.minor === semanticVersion.minor &&
              semverVersion.patch === semanticVersion.patch
            ) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  },
);
var processCharacterOrCodePoint = conditionalModuleLoader(
  (createComparator, createComparatorFunction) => {
    var SemVerAnySymbol = Symbol("SemVer ANY");
    var SemVerComparator = class {
      static get ANY() {
        return SemVerAnySymbol;
      }
      constructor(comparatorString, comparatorOptions) {
        comparatorOptions = validateComparatorOptions(comparatorOptions);
        if (comparatorString instanceof SemVerComparator) {
          if (comparatorString.loose === !!comparatorOptions.loose) {
            return comparatorString;
          }
          comparatorString = comparatorString.value;
        }
        _logComparatorCreation(
          "comparator",
          comparatorString,
          comparatorOptions,
        );
        this.options = comparatorOptions;
        this.loose = !!comparatorOptions.loose;
        this.parse(comparatorString);
        if (this.semver === SemVerAnySymbol) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        _logComparatorCreation("comp", this);
      }
      parse(__parseComparator) {
        let comparatorPatternRegex = this.options.loose
          ? comparatorPatterns[comparatorPattern.COMPARATORLOOSE]
          : comparatorPatterns[comparatorPattern.COMPARATOR];
        let parsedComparator = __parseComparator.match(comparatorPatternRegex);
        if (!parsedComparator) {
          throw new TypeError("Invalid comparator: " + __parseComparator);
        }
        if (parsedComparator[1] !== undefined) {
          this.operator = parsedComparator[1];
        } else {
          this.operator = "";
        }
        if (this.operator === "=") {
          this.operator = "";
        }
        if (parsedComparator[2]) {
          this.semver = new _SemVerComparator(
            parsedComparator[2],
            this.options.loose,
          );
        } else {
          this.semver = SemVerAnySymbol;
        }
      }
      toString() {
        return this.value;
      }
      test(comparatorVersion) {
        _logComparatorCreation(
          "Comparator.test",
          comparatorVersion,
          this.options.loose,
        );
        if (
          this.semver === SemVerAnySymbol ||
          comparatorVersion === SemVerAnySymbol
        ) {
          return true;
        }
        if (typeof comparatorVersion == "string") {
          try {
            comparatorVersion = new _SemVerComparator(
              comparatorVersion,
              this.options,
            );
          } catch {
            return false;
          }
        }
        return logComparatorCreation(
          comparatorVersion,
          this.operator,
          this.semver,
          this.options,
        );
      }
      intersects(comparatorA, options) {
        if (!(comparatorA instanceof SemVerComparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options || typeof options != "object") {
          options = {
            loose: !!options,
            includePrerelease: false,
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          } else {
            return new createSemVerComparator(comparatorA.value, options).test(
              this.value,
            );
          }
        }
        if (comparatorA.operator === "") {
          if (comparatorA.value === "") {
            return true;
          } else {
            return new createSemVerComparator(this.value, options).test(
              comparatorA.semver,
            );
          }
        }
        let isCompatible =
          (this.operator === ">=" || this.operator === ">") &&
          (comparatorA.operator === ">=" || comparatorA.operator === ">");
        let isLessOrEqualComparison =
          (this.operator === "<=" || this.operator === "<") &&
          (comparatorA.operator === "<=" || comparatorA.operator === "<");
        let isVersionEqual = this.semver.version === comparatorA.semver.version;
        let checkCompatibilityWithComparator =
          (this.operator === ">=" || this.operator === "<=") &&
          (comparatorA.operator === ">=" || comparatorA.operator === "<=");
        let checkSemanticVersionCompatibility =
          logComparatorCreation(
            this.semver,
            "<",
            comparatorA.semver,
            options,
          ) &&
          (this.operator === ">=" || this.operator === ">") &&
          (comparatorA.operator === "<=" || comparatorA.operator === "<");
        let isSemVerCompatible =
          logComparatorCreation(
            this.semver,
            ">",
            comparatorA.semver,
            options,
          ) &&
          (this.operator === "<=" || this.operator === "<") &&
          (comparatorA.operator === ">=" || comparatorA.operator === ">");
        return (
          isCompatible ||
          isLessOrEqualComparison ||
          (isVersionEqual && checkCompatibilityWithComparator) ||
          checkSemanticVersionCompatibility ||
          isSemVerCompatible
        );
      }
    };
    createComparatorFunction.exports = SemVerComparator;
    var validateComparatorOptions = decodedCharacter();
    var { re: comparatorPatterns, t: comparatorPattern } =
      ____________________________________________________________validateAndRetrieveIntrinsicProperty();
    var logComparatorCreation = compareBufferOffset();
    var _logComparatorCreation = validateAndProcessEncoding();
    var _SemVerComparator = processCharacterEncoding();
    var createSemVerComparator = getCompareSegmentBounds();
  },
);
var hexCharacterArray = conditionalModuleLoader(
  (__compareSegmentBounds, compareSegmentBoundsTester) => {
    var CompareSegmentBoundsTesterFunction = getCompareSegmentBounds();
    var testSegmentBounds = (
      segmentComparisonTester,
      _compareSegmentBoundsTester,
      segmentBoundsComparisonTester,
    ) => {
      try {
        _compareSegmentBoundsTester = new CompareSegmentBoundsTesterFunction(
          _compareSegmentBoundsTester,
          segmentBoundsComparisonTester,
        );
      } catch {
        return false;
      }
      return _compareSegmentBoundsTester.test(segmentComparisonTester);
    };
    compareSegmentBoundsTester.exports = testSegmentBounds;
  },
);
var generateHexPairs = conditionalModuleLoader(
  (createSegmentBounds, createSegmentBoundsExport) => {
    var ___compareSegmentBounds = getCompareSegmentBounds();
    var generateBoundSegments = (
      ____compareSegmentBounds,
      segmentBoundsComparator,
    ) =>
      new ___compareSegmentBounds(
        ____compareSegmentBounds,
        segmentBoundsComparator,
      ).set.map((extractValuesFromArray) =>
        extractValuesFromArray
          .map((inputFieldValue) => inputFieldValue.value)
          .join(" ")
          .trim()
          .split(" "),
      );
    createSegmentBoundsExport.exports = generateBoundSegments;
  },
);
var _____validateAndRetrieveIntrinsicProperties = conditionalModuleLoader(
  (processAndExportCharacterValidation, exportCharacterValidationFunction) => {
    var processCharacterValidator = processCharacterEncoding();
    var getCharacterValidationBoundaries = getCompareSegmentBounds();
    var _validateAndProcessCharacter = (
      findMostRecentValidCharacter,
      characterValidationBoundaries,
      characterBoundary,
    ) => {
      let mostRecentValidCharacter = null;
      let characterValidator = null;
      let characterValidation = null;
      try {
        characterValidation = new getCharacterValidationBoundaries(
          characterValidationBoundaries,
          characterBoundary,
        );
      } catch {
        return null;
      }
      findMostRecentValidCharacter.forEach((currentCharacterInput) => {
        if (
          characterValidation.test(currentCharacterInput) &&
          (!mostRecentValidCharacter ||
            characterValidator.compare(currentCharacterInput) === -1)
        ) {
          mostRecentValidCharacter = currentCharacterInput;
          characterValidator = new processCharacterValidator(
            mostRecentValidCharacter,
            characterBoundary,
          );
        }
      });
      return mostRecentValidCharacter;
    };
    exportCharacterValidationFunction.exports = _validateAndProcessCharacter;
  },
);
var ______validateAndRetrieveIntrinsicProperties = conditionalModuleLoader(
  (findBestMatchingSegment, exportedBestMatchingSegment) => {
    var _characterEncodingProcessor = processCharacterEncoding();
    var getBestMatchingSegment = getCompareSegmentBounds();
    var _findBestMatchingSegment = (
      findBestEncodingMatch,
      bestMatchingSegment,
      encodingCandidate,
    ) => {
      let bestMatchingEncoding = null;
      let __characterEncodingProcessor = null;
      let bestSegmentMatch = null;
      try {
        bestSegmentMatch = new getBestMatchingSegment(
          bestMatchingSegment,
          encodingCandidate,
        );
      } catch {
        return null;
      }
      findBestEncodingMatch.forEach((currentCharacterEncoding) => {
        if (
          bestSegmentMatch.test(currentCharacterEncoding) &&
          (!bestMatchingEncoding ||
            __characterEncodingProcessor.compare(currentCharacterEncoding) ===
              1)
        ) {
          bestMatchingEncoding = currentCharacterEncoding;
          __characterEncodingProcessor = new _characterEncodingProcessor(
            bestMatchingEncoding,
            encodingCandidate,
          );
        }
      });
      return bestMatchingEncoding;
    };
    exportedBestMatchingSegment.exports = _findBestMatchingSegment;
  },
);
var _______validateAndRetrieveIntrinsicProperties = conditionalModuleLoader(
  (validateSemverAgainstRange, _validateSemverAgainstRange) => {
    var SemverProcessor = processCharacterEncoding();
    var getSegmentationBounds = getCompareSegmentBounds();
    var _readInt16WithSignExtension = readInt16WithSignExtension();
    var __validateSemverAgainstRange = (
      getProcessedSemver,
      segmentationBounds,
    ) => {
      getProcessedSemver = new getSegmentationBounds(
        getProcessedSemver,
        segmentationBounds,
      );
      let initialSemver = new SemverProcessor("0.0.0");
      if (
        getProcessedSemver.test(initialSemver) ||
        ((initialSemver = new SemverProcessor("0.0.0-0")),
        getProcessedSemver.test(initialSemver))
      ) {
        return initialSemver;
      }
      initialSemver = null;
      for (
        let _____currentIndex = 0;
        _____currentIndex < getProcessedSemver.set.length;
        ++_____currentIndex
      ) {
        let processedSemvers = getProcessedSemver.set[_____currentIndex];
        let currentBestSemver = null;
        processedSemvers.forEach((semverOperation) => {
          let semverProcessor = new SemverProcessor(
            semverOperation.semver.version,
          );
          switch (semverOperation.operator) {
            case ">":
              if (semverProcessor.prerelease.length === 0) {
                semverProcessor.patch++;
              } else {
                semverProcessor.prerelease.push(0);
              }
              semverProcessor.raw = semverProcessor.format();
            case "":
            case ">=":
              if (
                !currentBestSemver ||
                _readInt16WithSignExtension(semverProcessor, currentBestSemver)
              ) {
                currentBestSemver = semverProcessor;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(
                "Unexpected operation: " + semverOperation.operator,
              );
          }
        });
        if (
          currentBestSemver &&
          (!initialSemver ||
            _readInt16WithSignExtension(initialSemver, currentBestSemver))
        ) {
          initialSemver = currentBestSemver;
        }
      }
      if (initialSemver && getProcessedSemver.test(initialSemver)) {
        return initialSemver;
      } else {
        return null;
      }
    };
    _validateSemverAgainstRange.exports = __validateSemverAgainstRange;
  },
);
var _________validateAndRetrieveIntrinsicValue = conditionalModuleLoader(
  (calculateSegmentRange, calculateSegmentRangeAndExport) => {
    var getSegmentRange = getCompareSegmentBounds();
    var getSegmentRangeFromPoints = (startAndEndRange, segmentRange) => {
      try {
        return new getSegmentRange(startAndEndRange, segmentRange).range || "*";
      } catch {
        return null;
      }
    };
    calculateSegmentRangeAndExport.exports = getSegmentRangeFromPoints;
  },
);
var currentIndex = conditionalModuleLoader(
  (_compareValues, comparisonOperator) => {
    var CharacterEncodingProcessor = processCharacterEncoding();
    var characterOrCodePointProcessed = processCharacterOrCodePoint();
    var { ANY: ANY_CHARACTER_OR_CODE_POINT } = characterOrCodePointProcessed;
    var getSegmentBounds = getCompareSegmentBounds();
    var retrieveHexCharacterArray = hexCharacterArray();
    var signedInt16Value = readInt16WithSignExtension();
    var maskedValueForComparison = applyBitwiseOrToMask();
    var bigInt64Value = _readBigInt64LE();
    var readBigInt64Value = readBigInt64LE();
    var compareEncodedSegments = (
      characterEncodingProcessor,
      segmentBounds,
      __comparisonOperator,
      encodingSegmentLength,
    ) => {
      characterEncodingProcessor = new CharacterEncodingProcessor(
        characterEncodingProcessor,
        encodingSegmentLength,
      );
      segmentBounds = new getSegmentBounds(
        segmentBounds,
        encodingSegmentLength,
      );
      let comparisonValue;
      let comparisonBigIntValue;
      let _maskedValueForComparison;
      let comparisonOperatorSymbol;
      let comparisonOperatorThreshold;
      switch (__comparisonOperator) {
        case ">":
          comparisonValue = signedInt16Value;
          comparisonBigIntValue = bigInt64Value;
          _maskedValueForComparison = maskedValueForComparison;
          comparisonOperatorSymbol = ">";
          comparisonOperatorThreshold = ">=";
          break;
        case "<":
          comparisonValue = maskedValueForComparison;
          comparisonBigIntValue = readBigInt64Value;
          _maskedValueForComparison = signedInt16Value;
          comparisonOperatorSymbol = "<";
          comparisonOperatorThreshold = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (
        retrieveHexCharacterArray(
          characterEncodingProcessor,
          segmentBounds,
          encodingSegmentLength,
        )
      ) {
        return false;
      }
      for (
        let segmentIndex = 0;
        segmentIndex < segmentBounds.set.length;
        ++segmentIndex
      ) {
        let segmentBoundsForCurrentSegment = segmentBounds.set[segmentIndex];
        let latestValidSegment = null;
        let latestProcessedSegment = null;
        segmentBoundsForCurrentSegment.forEach((processedSegment) => {
          if (processedSegment.semver === ANY_CHARACTER_OR_CODE_POINT) {
            processedSegment = new characterOrCodePointProcessed(">=0.0.0");
          }
          latestValidSegment = latestValidSegment || processedSegment;
          latestProcessedSegment = latestProcessedSegment || processedSegment;
          if (
            comparisonValue(
              processedSegment.semver,
              latestValidSegment.semver,
              encodingSegmentLength,
            )
          ) {
            latestValidSegment = processedSegment;
          } else if (
            _maskedValueForComparison(
              processedSegment.semver,
              latestProcessedSegment.semver,
              encodingSegmentLength,
            )
          ) {
            latestProcessedSegment = processedSegment;
          }
        });
        if (
          latestValidSegment.operator === comparisonOperatorSymbol ||
          latestValidSegment.operator === comparisonOperatorThreshold ||
          ((!latestProcessedSegment.operator ||
            latestProcessedSegment.operator === comparisonOperatorSymbol) &&
            comparisonBigIntValue(
              characterEncodingProcessor,
              latestProcessedSegment.semver,
            ))
        ) {
          return false;
        }
        if (
          latestProcessedSegment.operator === comparisonOperatorThreshold &&
          _maskedValueForComparison(
            characterEncodingProcessor,
            latestProcessedSegment.semver,
          )
        ) {
          return false;
        }
      }
      return true;
    };
    comparisonOperator.exports = compareEncodedSegments;
  },
);
var _validateAndRetrieveIntrinsicValues = conditionalModuleLoader(
  (____compareValues, compareValuesGreaterThan) => {
    var getCurrentIndexAsGreaterThanComparison = currentIndex();
    var compareCurrentIndexGreaterThan = (
      currentIndexGreaterThanComparison,
      _comparisonValue,
      comparisonThreshold,
    ) =>
      getCurrentIndexAsGreaterThanComparison(
        currentIndexGreaterThanComparison,
        _comparisonValue,
        ">",
        comparisonThreshold,
      );
    compareValuesGreaterThan.exports = compareCurrentIndexGreaterThan;
  },
);
var _retrieveAndValidateIntrinsicValue = conditionalModuleLoader(
  (compareIndices, compareValuesBasedOnIndex) => {
    var compareValuesUsingCurrentIndex = currentIndex();
    var compareValuesLessThan = (
      _compareValuesUsingCurrentIndex,
      _comparisonThreshold,
      _valueToCompare,
    ) =>
      compareValuesUsingCurrentIndex(
        _compareValuesUsingCurrentIndex,
        _comparisonThreshold,
        "<",
        _valueToCompare,
      );
    compareValuesBasedOnIndex.exports = compareValuesLessThan;
  },
);
var retrieveIntrinsicValues = conditionalModuleLoader(
  (checkSegmentIntersection, checkSegmentIntersectionAndExport) => {
    var createSegment = getCompareSegmentBounds();
    var _checkSegmentIntersection = (
      createAndCheckSegmentIntersection,
      segmentIntersectionChecker,
      segmentIntersection,
    ) => {
      createAndCheckSegmentIntersection = new createSegment(
        createAndCheckSegmentIntersection,
        segmentIntersection,
      );
      segmentIntersectionChecker = new createSegment(
        segmentIntersectionChecker,
        segmentIntersection,
      );
      return createAndCheckSegmentIntersection.intersects(
        segmentIntersectionChecker,
      );
    };
    checkSegmentIntersectionAndExport.exports = _checkSegmentIntersection;
  },
);
var ________validateAndRetrieveIntrinsicProperties = conditionalModuleLoader(
  (processSortedCharacterData, _processSortedCharacterData) => {
    var isHexCharacterValid = hexCharacterArray();
    var sortCharactersBasedOnHexValues = calculateBigInt();
    _processSortedCharacterData.exports = (
      processHexCharacterRanges,
      hexCharacterRangeProcessor,
      hexCharacterRangeTraversal,
    ) => {
      let hexCharacterRanges = [];
      let currentHexCharacter = null;
      let currentHexCharacterRange = null;
      let sortedHexCharacterRanges = processHexCharacterRanges.sort(
        (characterSortingCriteria, hexValueSortingCriteria) =>
          sortCharactersBasedOnHexValues(
            characterSortingCriteria,
            hexValueSortingCriteria,
            hexCharacterRangeTraversal,
          ),
      );
      for (let hexCharacterRange of sortedHexCharacterRanges) {
        if (
          isHexCharacterValid(
            hexCharacterRange,
            hexCharacterRangeProcessor,
            hexCharacterRangeTraversal,
          )
        ) {
          currentHexCharacterRange = hexCharacterRange;
          currentHexCharacter ||= hexCharacterRange;
        } else {
          if (currentHexCharacterRange) {
            hexCharacterRanges.push([
              currentHexCharacter,
              currentHexCharacterRange,
            ]);
          }
          currentHexCharacterRange = null;
          currentHexCharacter = null;
        }
      }
      if (currentHexCharacter) {
        hexCharacterRanges.push([currentHexCharacter, null]);
      }
      let duplicatesInHexCharacterRanges = [];
      for (let [currentHexRange, currentHexValue] of hexCharacterRanges) {
        if (currentHexRange === currentHexValue) {
          duplicatesInHexCharacterRanges.push(currentHexRange);
        } else if (
          !currentHexValue &&
          currentHexRange === sortedHexCharacterRanges[0]
        ) {
          duplicatesInHexCharacterRanges.push("*");
        } else if (currentHexValue) {
          if (currentHexRange === sortedHexCharacterRanges[0]) {
            duplicatesInHexCharacterRanges.push("<=" + currentHexValue);
          } else {
            duplicatesInHexCharacterRanges.push(
              currentHexRange + " - " + currentHexValue,
            );
          }
        } else {
          duplicatesInHexCharacterRanges.push(">=" + currentHexRange);
        }
      }
      let _currentHexCharacterRange =
        duplicatesInHexCharacterRanges.join(" || ");
      let __currentHexCharacterRange =
        typeof hexCharacterRangeProcessor.raw == "string"
          ? hexCharacterRangeProcessor.raw
          : String(hexCharacterRangeProcessor);
      if (
        _currentHexCharacterRange.length < __currentHexCharacterRange.length
      ) {
        return _currentHexCharacterRange;
      } else {
        return hexCharacterRangeProcessor;
      }
    };
  },
);
var deferredPromiseExecutor = conditionalModuleLoader(
  (areSegmentsComparable, _areSegmentsComparable) => {
    var SegmentBounds = getCompareSegmentBounds();
    var processedCharacterData = processCharacterOrCodePoint();
    var { ANY: ANY_CHARACTER_TYPE } = processedCharacterData;
    var hexCharacterArrayForComparisons = hexCharacterArray();
    var bigIntCalculation = calculateBigInt();
    var areSegmentsEqual = (
      _compareSegments,
      _compareSegmentBounds,
      __userSettings = {},
    ) => {
      if (_compareSegments === _compareSegmentBounds) {
        return true;
      }
      _compareSegments = new SegmentBounds(_compareSegments, __userSettings);
      _compareSegmentBounds = new SegmentBounds(
        _compareSegmentBounds,
        __userSettings,
      );
      let isAnySegmentOverlapping = false;
      _0x2c2450: for (let segmentToCompare of _compareSegments.set) {
        for (let segmentToCompareAgainst of _compareSegmentBounds.set) {
          let isSegmentStrictlyEqual = areSegmentsEqualStrictly(
            segmentToCompare,
            segmentToCompareAgainst,
            __userSettings,
          );
          isAnySegmentOverlapping =
            isAnySegmentOverlapping || isSegmentStrictlyEqual !== null;
          if (isSegmentStrictlyEqual) {
            continue _0x2c2450;
          }
        }
        if (isAnySegmentOverlapping) {
          return false;
        }
      }
      return true;
    };
    var areSegmentsEqualStrictly = (
      inputVersions,
      currentVersion,
      versionComparisonOptions,
    ) => {
      if (inputVersions === currentVersion) {
        return true;
      }
      if (
        inputVersions.length === 1 &&
        inputVersions[0].semver === ANY_CHARACTER_TYPE
      ) {
        if (
          currentVersion.length === 1 &&
          currentVersion[0].semver === ANY_CHARACTER_TYPE
        ) {
          return true;
        }
        if (versionComparisonOptions.includePrerelease) {
          inputVersions = [new processedCharacterData(">=0.0.0-0")];
        } else {
          inputVersions = [new processedCharacterData(">=0.0.0")];
        }
      }
      if (
        currentVersion.length === 1 &&
        currentVersion[0].semver === ANY_CHARACTER_TYPE
      ) {
        if (versionComparisonOptions.includePrerelease) {
          return true;
        }
        currentVersion = [new processedCharacterData(">=0.0.0")];
      }
      let versionSet = new Set();
      let lastComparisonResult;
      let _lastComparisonResult;
      for (let __versionComparison of inputVersions) {
        if (
          __versionComparison.operator === ">" ||
          __versionComparison.operator === ">="
        ) {
          lastComparisonResult = areSegmentsComparisonEqual(
            lastComparisonResult,
            __versionComparison,
            versionComparisonOptions,
          );
        } else if (
          __versionComparison.operator === "<" ||
          __versionComparison.operator === "<="
        ) {
          _lastComparisonResult = compareSegments(
            _lastComparisonResult,
            __versionComparison,
            versionComparisonOptions,
          );
        } else {
          versionSet.add(__versionComparison.semver);
        }
      }
      if (versionSet.size > 1) {
        return null;
      }
      let versionToCompare;
      if (lastComparisonResult && _lastComparisonResult) {
        versionToCompare = bigIntCalculation(
          lastComparisonResult.semver,
          _lastComparisonResult.semver,
          versionComparisonOptions,
        );
        if (versionToCompare > 0) {
          return null;
        }
        if (
          versionToCompare === 0 &&
          (lastComparisonResult.operator !== ">=" ||
            _lastComparisonResult.operator !== "<=")
        ) {
          return null;
        }
      }
      for (let versionInSet of versionSet) {
        if (
          (lastComparisonResult &&
            !hexCharacterArrayForComparisons(
              versionInSet,
              String(lastComparisonResult),
              versionComparisonOptions,
            )) ||
          (_lastComparisonResult &&
            !hexCharacterArrayForComparisons(
              versionInSet,
              String(_lastComparisonResult),
              versionComparisonOptions,
            ))
        ) {
          return null;
        }
        for (let versionCharacter of currentVersion) {
          if (
            !hexCharacterArrayForComparisons(
              versionInSet,
              String(versionCharacter),
              versionComparisonOptions,
            )
          ) {
            return false;
          }
        }
        return true;
      }
      let inputVersion;
      let compareVersionSegments;
      let compareInputVersionsToCurrent;
      let _compareVersionSegments;
      let compareInputVersionsToCurrentVersion =
        _lastComparisonResult &&
        !versionComparisonOptions.includePrerelease &&
        _lastComparisonResult.semver.prerelease.length
          ? _lastComparisonResult.semver
          : false;
      let _inputVersion =
        lastComparisonResult &&
        !versionComparisonOptions.includePrerelease &&
        lastComparisonResult.semver.prerelease.length
          ? lastComparisonResult.semver
          : false;
      if (
        compareInputVersionsToCurrentVersion &&
        compareInputVersionsToCurrentVersion.prerelease.length === 1 &&
        _lastComparisonResult.operator === "<" &&
        compareInputVersionsToCurrentVersion.prerelease[0] === 0
      ) {
        compareInputVersionsToCurrentVersion = false;
      }
      for (let versionCriteria of currentVersion) {
        _compareVersionSegments =
          _compareVersionSegments ||
          versionCriteria.operator === ">" ||
          versionCriteria.operator === ">=";
        compareInputVersionsToCurrent =
          compareInputVersionsToCurrent ||
          versionCriteria.operator === "<" ||
          versionCriteria.operator === "<=";
        if (lastComparisonResult) {
          if (
            _inputVersion &&
            versionCriteria.semver.prerelease &&
            versionCriteria.semver.prerelease.length &&
            versionCriteria.semver.major === _inputVersion.major &&
            versionCriteria.semver.minor === _inputVersion.minor &&
            versionCriteria.semver.patch === _inputVersion.patch
          ) {
            _inputVersion = false;
          }
          if (
            versionCriteria.operator === ">" ||
            versionCriteria.operator === ">="
          ) {
            inputVersion = areSegmentsComparisonEqual(
              lastComparisonResult,
              versionCriteria,
              versionComparisonOptions,
            );
            if (
              inputVersion === versionCriteria &&
              inputVersion !== lastComparisonResult
            ) {
              return false;
            }
          } else if (
            lastComparisonResult.operator === ">=" &&
            !hexCharacterArrayForComparisons(
              lastComparisonResult.semver,
              String(versionCriteria),
              versionComparisonOptions,
            )
          ) {
            return false;
          }
        }
        if (_lastComparisonResult) {
          if (
            compareInputVersionsToCurrentVersion &&
            versionCriteria.semver.prerelease &&
            versionCriteria.semver.prerelease.length &&
            versionCriteria.semver.major ===
              compareInputVersionsToCurrentVersion.major &&
            versionCriteria.semver.minor ===
              compareInputVersionsToCurrentVersion.minor &&
            versionCriteria.semver.patch ===
              compareInputVersionsToCurrentVersion.patch
          ) {
            compareInputVersionsToCurrentVersion = false;
          }
          if (
            versionCriteria.operator === "<" ||
            versionCriteria.operator === "<="
          ) {
            compareVersionSegments = compareSegments(
              _lastComparisonResult,
              versionCriteria,
              versionComparisonOptions,
            );
            if (
              compareVersionSegments === versionCriteria &&
              compareVersionSegments !== _lastComparisonResult
            ) {
              return false;
            }
          } else if (
            _lastComparisonResult.operator === "<=" &&
            !hexCharacterArrayForComparisons(
              _lastComparisonResult.semver,
              String(versionCriteria),
              versionComparisonOptions,
            )
          ) {
            return false;
          }
        }
        if (
          !versionCriteria.operator &&
          (_lastComparisonResult || lastComparisonResult) &&
          versionToCompare !== 0
        ) {
          return false;
        }
      }
      return (
        (!lastComparisonResult ||
          !compareInputVersionsToCurrent ||
          !!_lastComparisonResult ||
          versionToCompare === 0) &&
        (!_lastComparisonResult ||
          !_compareVersionSegments ||
          !!lastComparisonResult ||
          versionToCompare === 0) &&
        !_inputVersion &&
        !compareInputVersionsToCurrentVersion
      );
    };
    var areSegmentsComparisonEqual = (
      compareVersionConstraints,
      ___currentVersion,
      versionConstraintComparison,
    ) => {
      if (!compareVersionConstraints) {
        return ___currentVersion;
      }
      let versionComparisonResult = bigIntCalculation(
        compareVersionConstraints.semver,
        ___currentVersion.semver,
        versionConstraintComparison,
      );
      if (versionComparisonResult > 0) {
        return compareVersionConstraints;
      } else if (
        versionComparisonResult < 0 ||
        (___currentVersion.operator === ">" &&
          compareVersionConstraints.operator === ">=")
      ) {
        return ___currentVersion;
      } else {
        return compareVersionConstraints;
      }
    };
    var compareSegments = (
      _compareSemverVersions,
      __currentVersion,
      minRequiredVersion,
    ) => {
      if (!_compareSemverVersions) {
        return __currentVersion;
      }
      let comparisonResult = bigIntCalculation(
        _compareSemverVersions.semver,
        __currentVersion.semver,
        minRequiredVersion,
      );
      if (comparisonResult < 0) {
        return _compareSemverVersions;
      } else if (
        comparisonResult > 0 ||
        (__currentVersion.operator === "<" &&
          _compareSemverVersions.operator === "<=")
      ) {
        return __currentVersion;
      } else {
        return _compareSemverVersions;
      }
    };
    _areSegmentsComparable.exports = areSegmentsEqual;
  },
);
var defineVersionPatterns = conditionalModuleLoader(
  (processAndRetrieveData, processAndRetrieveDataCallback) => {
    var validatedIntrinsicProperty =
      ____________________________________________________________validateAndRetrieveIntrinsicProperty();
    var validatedEncoding = _validateAndRetrieveEncoding();
    var processedCharacterEncoding = processCharacterEncoding();
    var _intrinsicPropertiesArray = intrinsicPropertiesArray();
    var readBigUInt64LEBuffer = readBufferBigUInt64LE();
    var readBigUInt64Value = readBigUInt64Buffer();
    var readBigUInt64FromBufferResult = readBigUInt64FromBuffer();
    var calculateBigIntFromBufferWithOffset = calculateBigIntFromBuffer();
    var byteArrayInitialized = byteArray();
    var bufferLengthBytes = bufferLength();
    var bufferSizeInBytes = bufferSize();
    var readInt16LittleEndianValue = readInt16LittleEndian();
    var _calculateSigned16BitInteger = calculateSigned16BitInteger();
    var calculateBigIntValue = calculateBigInt();
    var readInt16FromBufferValue = readInt16FromBuffer();
    var logDataForProcessing = logDataHandler();
    var _processAndRetrieveData = logProcessIndex();
    var _______________________________________________________________validateAndRetrieveIntrinsicProperty =
      __processData();
    var processDataAndCallback = _processLoggingData();
    var ________________________________________________________________validateAndRetrieveIntrinsicProperty =
      readInt16WithSignExtension();
    var __validateAndRetrieveEncoding = applyBitwiseOrToMask();
    var _processDataAndCallback = readIntegerFromBuffer();
    var processAndRetrieveDataHandler = logForInstanceHandler();
    var processAndRetrieveDataWithValidation = readBigInt64LE();
    var __processAndRetrieveData = _readBigInt64LE();
    var ___processAndRetrieveData = compareBufferOffset();
    var processAndRetrieveValidatedData = compareAndReadFloatFromBuffer();
    var _________________________________________________________________validateAndRetrieveIntrinsicProperty =
      processCharacterOrCodePoint();
    var retrieveAndProcessData = getCompareSegmentBounds();
    var ____processAndRetrieveData = hexCharacterArray();
    var validateAndProcessData = generateHexPairs();
    var _____processAndRetrieveData =
      _____validateAndRetrieveIntrinsicProperties();
    var ______processAndRetrieveData =
      ______validateAndRetrieveIntrinsicProperties();
    var _______processAndRetrieveData =
      _______validateAndRetrieveIntrinsicProperties();
    var __processDataAndCallback = _________validateAndRetrieveIntrinsicValue();
    var ________processAndRetrieveData = currentIndex();
    var processDataAndRetrieve = _validateAndRetrieveIntrinsicValues();
    var _retrieveAndProcessData = _retrieveAndValidateIntrinsicValue();
    var processDataAndCallbacks = retrieveIntrinsicValues();
    var _processAndRetrieveDataHandler =
      ________validateAndRetrieveIntrinsicProperties();
    var _________processAndRetrieveData = deferredPromiseExecutor();
    processAndRetrieveDataCallback.exports = {
      parse: readBigUInt64LEBuffer,
      valid: readBigUInt64Value,
      clean: readBigUInt64FromBufferResult,
      inc: calculateBigIntFromBufferWithOffset,
      diff: byteArrayInitialized,
      major: bufferLengthBytes,
      minor: bufferSizeInBytes,
      patch: readInt16LittleEndianValue,
      prerelease: _calculateSigned16BitInteger,
      compare: calculateBigIntValue,
      rcompare: readInt16FromBufferValue,
      compareLoose: logDataForProcessing,
      compareBuild: _processAndRetrieveData,
      sort: _______________________________________________________________validateAndRetrieveIntrinsicProperty,
      rsort: processDataAndCallback,
      gt: ________________________________________________________________validateAndRetrieveIntrinsicProperty,
      lt: __validateAndRetrieveEncoding,
      eq: _processDataAndCallback,
      neq: processAndRetrieveDataHandler,
      gte: processAndRetrieveDataWithValidation,
      lte: __processAndRetrieveData,
      cmp: ___processAndRetrieveData,
      coerce: processAndRetrieveValidatedData,
      Comparator:
        _________________________________________________________________validateAndRetrieveIntrinsicProperty,
      Range: retrieveAndProcessData,
      satisfies: ____processAndRetrieveData,
      toComparators: validateAndProcessData,
      maxSatisfying: _____processAndRetrieveData,
      minSatisfying: ______processAndRetrieveData,
      minVersion: _______processAndRetrieveData,
      validRange: __processDataAndCallback,
      outside: ________processAndRetrieveData,
      gtr: processDataAndRetrieve,
      ltr: _retrieveAndProcessData,
      intersects: processDataAndCallbacks,
      simplifyRange: _processAndRetrieveDataHandler,
      subset: _________processAndRetrieveData,
      SemVer: processedCharacterEncoding,
      re: validatedIntrinsicProperty.re,
      src: validatedIntrinsicProperty.src,
      tokens: validatedIntrinsicProperty.t,
      SEMVER_SPEC_VERSION: validatedEncoding.SEMVER_SPEC_VERSION,
      compareIdentifiers: _intrinsicPropertiesArray.compareIdentifiers,
      rcompareIdentifiers: _intrinsicPropertiesArray.rcompareIdentifiers,
    };
  },
);
var initializePatternRegex = conditionalModuleLoader(
  (sanitizeString, sanitizeStringForRegex) => {
    sanitizeStringForRegex.exports = (escapeSpecialChars) => {
      if (typeof escapeSpecialChars != "string") {
        throw new TypeError("Expected a string");
      }
      return escapeSpecialChars
        .replace(/[|\\{}()[\]^$+*?.]/g, "\\$&")
        .replace(/-/g, "\\x2d");
    };
  },
);
var defineVersionRangePatterns = conditionalModuleLoader((moduleExport) => {
  var importDefaultOrWrapperFunction =
    (moduleExport && moduleExport.__importDefault) ||
    function (parseCaretRange) {
      if (parseCaretRange && parseCaretRange.__esModule) {
        return parseCaretRange;
      } else {
        return {
          default: parseCaretRange,
        };
      }
    };
  Object.defineProperty(moduleExport, "__esModule", {
    value: true,
  });
  moduleExport.createMatcherWithIndex = moduleExport.createMatcher = undefined;
  var initializedPatternRegex = importDefaultOrWrapperFunction(
    initializePatternRegex(),
  );
  function createComparatorCheckFunction(comparatorTrimRegex) {
    let createComparatorCheck = generateComparatorFunction(
      Array.isArray(comparatorTrimRegex)
        ? comparatorTrimRegex
        : [comparatorTrimRegex],
    );
    return (_____compareValues) =>
      createComparatorCheck(_____compareValues) !== -1;
  }
  moduleExport.createMatcher = createComparatorCheckFunction;
  function generateComparatorFunction(comparatorTrimParser) {
    switch (comparatorTrimParser.length) {
      case 0:
        return () => -1;
      case 1:
        return createVersionMatchHandler(comparatorTrimParser[0]);
    }
    let comparatorConditions = [];
    let hasIgnoreConditions = false;
    let hasDirectMatchConditions = false;
    for (let comparatorTrimValue of comparatorTrimParser) {
      if (isVersionNegated(comparatorTrimValue)) {
        hasIgnoreConditions = true;
        comparatorConditions.push({
          ignore: true,
          match: createEncodingMatcher(comparatorTrimValue.substring(1)),
        });
      } else {
        hasDirectMatchConditions = true;
        comparatorConditions.push({
          ignore: false,
          match: createEncodingMatcher(comparatorTrimValue),
        });
      }
    }
    if (hasIgnoreConditions) {
      if (hasDirectMatchConditions) {
        return findMatchingIdentifierIndex.bind(null, comparatorConditions);
      } else {
        return compareIdentifiersWithNumericStrings.bind(
          null,
          comparatorConditions,
        );
      }
    } else {
      return _findMatchingIndex.bind(null, comparatorConditions);
    }
  }
  moduleExport.createMatcherWithIndex = generateComparatorFunction;
  function _findMatchingIndex(
    compareAndFilterProperties,
    compareNumericStrings,
  ) {
    for (
      let ___________currentIndex = 0;
      ___________currentIndex < compareAndFilterProperties.length;
      ___________currentIndex++
    ) {
      if (
        compareAndFilterProperties[___________currentIndex].match(
          compareNumericStrings,
        )
      ) {
        return ___________currentIndex;
      }
    }
    return -1;
  }
  function compareIdentifiersWithNumericStrings(
    compareNumericIdentifiers,
    _compareNumericStrings,
  ) {
    if (
      compareNumericIdentifiers.some(({ match: matchCriteria }) =>
        matchCriteria(_compareNumericStrings),
      )
    ) {
      return -1;
    } else {
      return 0;
    }
  }
  function findMatchingIdentifierIndex(compareIdentifiers, compareValues) {
    let matchedIdentifierIndex = -1;
    for (
      let compareIndex = 0;
      compareIndex < compareIdentifiers.length;
      compareIndex++
    ) {
      let { ignore: ignoreIdentifier, match: isMatch } =
        compareIdentifiers[compareIndex];
      if (ignoreIdentifier) {
        if (isMatch(compareValues)) {
          matchedIdentifierIndex = -1;
        }
      } else if (matchedIdentifierIndex === -1 && isMatch(compareValues)) {
        matchedIdentifierIndex = compareIndex;
      }
    }
    return matchedIdentifierIndex;
  }
  function createEncodingMatcher(_processCharacterEncoding) {
    if (_processCharacterEncoding === "*") {
      return () => true;
    }
    let encodedCharacterPattern = (0, initializedPatternRegex.default)(
      _processCharacterEncoding,
    ).replace(/\\\*/g, ".*");
    if (encodedCharacterPattern === _processCharacterEncoding) {
      return (_______processCharacterEncoding) =>
        _______processCharacterEncoding === _processCharacterEncoding;
    }
    let characterEncodingRegex = new RegExp(
      "^" + encodedCharacterPattern + "$",
    );
    return (characterString) => characterEncodingRegex.test(characterString);
  }
  function isVersionNegated(compareVersion) {
    return compareVersion.startsWith("!");
  }
  function createVersionMatchHandler(validateAndRetrieveVersion) {
    let versionMatchHandler = createVersionEncodingMatcher(
      validateAndRetrieveVersion,
    );
    return (getMatchingVersionIndex) =>
      versionMatchHandler(getMatchingVersionIndex) ? 0 : -1;
  }
  function createVersionEncodingMatcher(createVersionInstance) {
    if (!isVersionNegated(createVersionInstance)) {
      return createEncodingMatcher(createVersionInstance);
    }
    let versionSubstring = createVersionInstance.substring(1);
    let createEncodingMatcherForVersionSubstring =
      createEncodingMatcher(versionSubstring);
    return (isVersionSubstringMatchingEncoding) =>
      !createEncodingMatcherForVersionSubstring(
        isVersionSubstringMatchingEncoding,
      );
  }
});
var validateVersionFormat = conditionalModuleLoader(
  (____parseVersion, moduleExporter) => {
    var globalVersionReference =
      typeof globalVersionReference === "undefined"
        ? globalThis
        : globalVersionReference;
    (function (parseVersion, _parseVersion) {
      if (typeof define == "function" && define.amd) {
        define([], _parseVersion);
      } else if (typeof ____parseVersion == "object") {
        moduleExporter.exports = _parseVersion();
      } else {
        parseVersion.untar = _parseVersion();
      }
    })(____parseVersion, function () {
      "use strict";

      function _processVersionString(versionString) {
        function executeVersionCallbacks(parseVersionOptions) {
          for (
            var callbackIndex = 0,
              versionCallbacksCount = versionCallbacks.length;
            callbackIndex < versionCallbacksCount;
            ++callbackIndex
          ) {
            versionCallbacks[callbackIndex](parseVersionOptions);
          }
          parsedVersionOptions.push(parseVersionOptions);
        }
        if (typeof Promise != "function") {
          throw new Error(
            "Promise implementation not available in this environment.",
          );
        }
        var versionCallbacks = [];
        var parsedVersionOptions = [];
        var versionPromise = new Promise(function (
          setVersionDetails,
          parseVersionNumbers,
        ) {
          versionString(
            setVersionDetails,
            parseVersionNumbers,
            executeVersionCallbacks,
          );
        });
        versionPromise.progress = function (validateVersionComponents) {
          if (typeof validateVersionComponents != "function") {
            throw new Error("cb is not a function.");
          }
          for (
            var _____________index = 0,
              parsedVersionCount = parsedVersionOptions.length;
            _____________index < parsedVersionCount;
            ++_____________index
          ) {
            validateVersionComponents(parsedVersionOptions[_____________index]);
          }
          versionCallbacks.push(validateVersionComponents);
          return versionPromise;
        };
        var registerVersionCallback = versionPromise.then;
        versionPromise.then = function (
          parsePrereleaseIdentifier,
          __parseVersion,
          ___parseVersion,
        ) {
          registerVersionCallback.call(
            versionPromise,
            parsePrereleaseIdentifier,
            __parseVersion,
          );
          if (___parseVersion !== undefined) {
            versionPromise.progress(___parseVersion);
          }
          return versionPromise;
        };
        return versionPromise;
      }
      function _initializeVersionComparisonWorker(_compareVersion) {
        if (!(_compareVersion instanceof ArrayBuffer)) {
          throw new TypeError("arrayBuffer is not an instance of ArrayBuffer.");
        }
        if (!processVersionString.Worker) {
          throw new Error(
            "Worker implementation is not available in this environment.",
          );
        }
        return new _processVersionString(function (
          __compareVersion,
          ___compareVersion,
          ____compareVersion,
        ) {
          var versionWorker = new Worker(parseVersionCallbacks);
          var parsedVersions = [];
          versionWorker.onerror = function (versionComparison) {
            ___compareVersion(versionComparison);
          };
          versionWorker.onmessage = function (_____compareVersion) {
            _____compareVersion = _____compareVersion.data;
            switch (_____compareVersion.type) {
              case "log":
                console[_____compareVersion.data.level](
                  "Worker: " + _____compareVersion.data.msg,
                );
                break;
              case "extract":
                var extractedVersion = defineVersionProgressProperties(
                  _____compareVersion.data,
                );
                parsedVersions.push(extractedVersion);
                ____compareVersion(extractedVersion);
                break;
              case "complete":
                versionWorker.terminate();
                __compareVersion(parsedVersions);
                break;
              case "error":
                versionWorker.terminate();
                ___compareVersion(new Error(_____compareVersion.data.message));
                break;
              default:
                versionWorker.terminate();
                ___compareVersion(
                  new Error(
                    "Unknown message from worker: " + _____compareVersion.type,
                  ),
                );
            }
          };
          versionWorker.postMessage(
            {
              type: "extract",
              buffer: _compareVersion,
            },
            [_compareVersion],
          );
        });
      }
      function defineVersionProgressProperties(comparePrereleaseVersions) {
        Object.defineProperties(
          comparePrereleaseVersions,
          handleVersionProgress,
        );
        return comparePrereleaseVersions;
      }
      var parseVersionCallbacks;
      var processVersionString = globalVersionReference || this;
      var processCallbacks =
        processVersionString.URL || processVersionString.webkitURL;
      var handleVersionProgress = {
        blob: {
          get() {
            return (this._blob ||= new Blob([this.buffer]));
          },
        },
        getBlobUrl: {
          value() {
            return (this._blobUrl ||= processCallbacks.createObjectURL(
              this.blob,
            ));
          },
        },
        readAsString: {
          value() {
            var bufferData = this.buffer;
            for (
              var _bufferDataLength = bufferData.byteLength,
                __byteMultiplier = 1,
                _dataView = new DataView(bufferData),
                _byteArray = [],
                ___index = 0;
              ___index < _bufferDataLength;
              ++___index
            ) {
              var byteValue = _dataView.getUint8(
                ___index * __byteMultiplier,
                true,
              );
              _byteArray.push(byteValue);
            }
            return (this._string = String.fromCharCode.apply(null, _byteArray));
          },
        },
        readAsJSON: {
          value() {
            return JSON.parse(this.readAsString());
          },
        },
      };
      parseVersionCallbacks = (
        globalVersionReference || this
      ).URL.createObjectURL(
        new Blob([
          '"use strict";function UntarWorker(){}function decodeUTF8(e){for(var r="",t=0;t<e.length;){var a=e[t++];if(a>127){if(a>191&&a<224){if(t>=e.length)throw"UTF-8 decode: incomplete 2-byte sequence";a=(31&a)<<6|63&e[t]}else if(a>223&&a<240){if(t+1>=e.length)throw"UTF-8 decode: incomplete 3-byte sequence";a=(15&a)<<12|(63&e[t])<<6|63&e[++t]}else{if(!(a>239&&a<248))throw"UTF-8 decode: unknown multibyte start 0x"+a.toString(16)+" at index "+(t-1);if(t+2>=e.length)throw"UTF-8 decode: incomplete 4-byte sequence";a=(7&a)<<18|(63&e[t])<<12|(63&e[++t])<<6|63&e[++t]}++t}if(a<=65535)r+=String.fromCharCode(a);else{if(!(a<=1114111))throw"UTF-8 decode: code point 0x"+a.toString(16)+" exceeds UTF-16 reach";a-=65536,r+=String.fromCharCode(a>>10|55296),r+=String.fromCharCode(1023&a|56320)}}return r}function PaxHeader(e){this._fields=e}function TarFile(){}function UntarStream(e){this._bufferView=new DataView(e),this._position=0}function UntarFileStream(e){this._stream=new UntarStream(e),this._globalPaxHeader=null}if(UntarWorker.prototype={onmessage:function(e){try{if("extract"!==e.data.type)throw new Error("Unknown message type: "+e.data.type);this.untarBuffer(e.data.buffer)}catch(r){this.postError(r)}},postError:function(e){this.postMessage({type:"error",data:{message:e.message}})},postLog:function(e,r){this.postMessage({type:"log",data:{level:e,msg:r}})},untarBuffer:function(e){try{for(var r=new UntarFileStream(e);r.hasNext();){var t=r.next();this.postMessage({type:"extract",data:t},[t.buffer])}this.postMessage({type:"complete"})}catch(a){this.postError(a)}},postMessage:function(e,r){self.postMessage(e,r)}},"undefined"!=typeof self){var worker=new UntarWorker;self.onmessage=function(e){worker.onmessage(e)}}PaxHeader.parse=function(e){for(var r=new Uint8Array(e),t=[];r.length>0;){var a=parseInt(decodeUTF8(r.subarray(0,r.indexOf(32)))),n=decodeUTF8(r.subarray(0,a)),i=n.match(/^\\d+ ([^=]+)=(.*)\\n$/);if(null===i)throw new Error("Invalid PAX header data format.");var s=i[1],o=i[2];0===o.length?o=null:null!==o.match(/^\\d+$/)&&(o=parseInt(o));var f={name:s,value:o};t.push(f),r=r.subarray(a)}return new PaxHeader(t)},PaxHeader.prototype={applyHeader:function(e){this._fields.forEach(function(r){var t=r.name,a=r.value;"path"===t?(t="name",void 0!==e.prefix&&delete e.prefix):"linkpath"===t&&(t="linkname"),null===a?delete e[t]:e[t]=a})}},UntarStream.prototype={readString:function(e){for(var r=1,t=e*r,a=[],n=0;n<e;++n){var i=this._bufferView.getUint8(this.position()+n*r,!0);if(0===i)break;a.push(i)}return this.seek(t),String.fromCharCode.apply(null,a)},readBuffer:function(e){var r;if("function"==typeof ArrayBuffer.prototype.slice)r=this._bufferView.buffer.slice(this.position(),this.position()+e);else{r=new ArrayBuffer(e);var t=new Uint8Array(r),a=new Uint8Array(this._bufferView.buffer,this.position(),e);t.set(a)}return this.seek(e),r},seek:function(e){this._position+=e},peekUint32:function(){return this._bufferView.getUint32(this.position(),!0)},position:function(e){return void 0===e?this._position:void(this._position=e)},size:function(){return this._bufferView.byteLength}},UntarFileStream.prototype={hasNext:function(){return this._stream.position()+4<this._stream.size()&&0!==this._stream.peekUint32()},next:function(){return this._readNextFile()},_readNextFile:function(){var e=this._stream,r=new TarFile,t=!1,a=null,n=e.position(),i=n+512;switch(r.name=e.readString(100),r.mode=e.readString(8),r.uid=parseInt(e.readString(8)),r.gid=parseInt(e.readString(8)),r.size=parseInt(e.readString(12),8),r.mtime=parseInt(e.readString(12),8),r.checksum=parseInt(e.readString(8)),r.type=e.readString(1),r.linkname=e.readString(100),r.ustarFormat=e.readString(6),r.ustarFormat.indexOf("ustar")>-1&&(r.version=e.readString(2),r.uname=e.readString(32),r.gname=e.readString(32),r.devmajor=parseInt(e.readString(8)),r.devminor=parseInt(e.readString(8)),r.namePrefix=e.readString(155),r.namePrefix.length>0&&(r.name=r.namePrefix+"/"+r.name)),e.position(i),r.type){case"0":case"":r.buffer=e.readBuffer(r.size);break;case"1":break;case"2":break;case"3":break;case"4":break;case"5":break;case"6":break;case"7":break;case"g":t=!0,this._globalPaxHeader=PaxHeader.parse(e.readBuffer(r.size));break;case"x":t=!0,a=PaxHeader.parse(e.readBuffer(r.size))}void 0===r.buffer&&(r.buffer=new ArrayBuffer(0));var s=i+r.size;return r.size%512!==0&&(s+=512-r.size%512),e.position(s),t&&(r=this._readNextFile()),null!==this._globalPaxHeader&&this._globalPaxHeader.applyHeader(r),null!==a&&a.applyHeader(r),r}};',
        ]),
      );
      return _initializeVersionComparisonWorker;
    });
  },
);
var compareVersionWithPrerelease = conditionalModuleLoader(
  (processConfiguration, processConfigurationHandler) => {
    var { hasOwnProperty: _hasOwnProperty } = Object.prototype;
    var newlineCharacterBasedOnOS =
      typeof process !== "undefined" && process.platform === "win32"
        ? "\r\n"
        : "\n";
    var processConfigurationObject = (
      processDataWithSectionAndWhitespace,
      sectionAndWhitespaceOptions,
    ) => {
      let nestedObjectKeys = [];
      let formattedOutput = "";
      if (typeof sectionAndWhitespaceOptions == "string") {
        sectionAndWhitespaceOptions = {
          section: sectionAndWhitespaceOptions,
          whitespace: false,
        };
      } else {
        sectionAndWhitespaceOptions =
          sectionAndWhitespaceOptions || Object.create(null);
        sectionAndWhitespaceOptions.whitespace =
          sectionAndWhitespaceOptions.whitespace === true;
      }
      let whitespaceSeparator = sectionAndWhitespaceOptions.whitespace
        ? " = "
        : "=";
      for (let sectionKey of Object.keys(processDataWithSectionAndWhitespace)) {
        let sectionData = processDataWithSectionAndWhitespace[sectionKey];
        if (sectionData && Array.isArray(sectionData)) {
          for (let sectionItem of sectionData) {
            formattedOutput +=
              formatValueForOutput(sectionKey + "[]") +
              whitespaceSeparator +
              formatValueForOutput(sectionItem) +
              newlineCharacterBasedOnOS;
          }
        } else if (sectionData && typeof sectionData == "object") {
          nestedObjectKeys.push(sectionKey);
        } else {
          formattedOutput +=
            formatValueForOutput(sectionKey) +
            whitespaceSeparator +
            formatValueForOutput(sectionData) +
            newlineCharacterBasedOnOS;
        }
      }
      if (sectionAndWhitespaceOptions.section && formattedOutput.length) {
        formattedOutput =
          "[" +
          formatValueForOutput(sectionAndWhitespaceOptions.section) +
          "]" +
          newlineCharacterBasedOnOS +
          formattedOutput;
      }
      for (let nestedKey of nestedObjectKeys) {
        let formattedConfigurationSections =
          _processConfigurationObject(nestedKey).join("\\.");
        let formattedSectionPath =
          (sectionAndWhitespaceOptions.section
            ? sectionAndWhitespaceOptions.section + "."
            : "") + formattedConfigurationSections;
        let { whitespace: whitespaceOption } = sectionAndWhitespaceOptions;
        let formattedConfigurationOutput = processConfigurationObject(
          processDataWithSectionAndWhitespace[nestedKey],
          {
            section: formattedSectionPath,
            whitespace: whitespaceOption,
          },
        );
        if (formattedOutput.length && formattedConfigurationOutput.length) {
          formattedOutput += newlineCharacterBasedOnOS;
        }
        formattedOutput += formattedConfigurationOutput;
      }
      return formattedOutput;
    };
    var _processConfigurationObject = (processStringWithLiteralReplacement) =>
      processStringWithLiteralReplacement
        .replace(/\1/g, "LITERAL\\1LITERAL")
        .replace(/\\\./g, "")
        .split(/\./)
        .map((replacePatternWithLiteral) =>
          replacePatternWithLiteral
            .replace(/\1/g, "\\.")
            .replace(/\2LITERAL\\1LITERAL\2/g, ""),
        );
    var processVariable = (parseConfigurationEntries) => {
      let configurationMap = Object.create(null);
      let currentConfigSection = configurationMap;
      let currentConfigKey = null;
      let configurationEntryRegex = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
      let configurationLines = parseConfigurationEntries.split(/[\r\n]+/g);
      for (let _configurationLine of configurationLines) {
        if (!_configurationLine || _configurationLine.match(/^\s*[;#]/)) {
          continue;
        }
        let configurationEntryMatch = _configurationLine.match(
          configurationEntryRegex,
        );
        if (!configurationEntryMatch) {
          continue;
        }
        if (configurationEntryMatch[1] !== undefined) {
          currentConfigKey = createConfigurationOutput(
            configurationEntryMatch[1],
          );
          if (currentConfigKey === "__proto__") {
            currentConfigSection = Object.create(null);
            continue;
          }
          currentConfigSection = configurationMap[currentConfigKey] =
            configurationMap[currentConfigKey] || Object.create(null);
          continue;
        }
        let configurationValue = createConfigurationOutput(
          configurationEntryMatch[2],
        );
        let isArrayNotation =
          configurationValue.length > 2 &&
          configurationValue.slice(-2) === "[]";
        let configurationKey = isArrayNotation
          ? configurationValue.slice(0, -2)
          : configurationValue;
        if (configurationKey === "__proto__") {
          continue;
        }
        let configurationValueOrFallback = configurationEntryMatch[3]
          ? createConfigurationOutput(configurationEntryMatch[4])
          : true;
        let processConfigurationEntry =
          configurationValueOrFallback === "true" ||
          configurationValueOrFallback === "false" ||
          configurationValueOrFallback === "null"
            ? JSON.parse(configurationValueOrFallback)
            : configurationValueOrFallback;
        if (isArrayNotation) {
          if (_hasOwnProperty.call(currentConfigSection, configurationKey)) {
            if (!Array.isArray(currentConfigSection[configurationKey])) {
              currentConfigSection[configurationKey] = [
                currentConfigSection[configurationKey],
              ];
            }
          } else {
            currentConfigSection[configurationKey] = [];
          }
        }
        if (Array.isArray(currentConfigSection[configurationKey])) {
          currentConfigSection[configurationKey].push(
            processConfigurationEntry,
          );
        } else {
          currentConfigSection[configurationKey] = processConfigurationEntry;
        }
      }
      let configurationLine = [];
      for (let configKey of Object.keys(configurationMap)) {
        if (
          !_hasOwnProperty.call(configurationMap, configKey) ||
          typeof configurationMap[configKey] != "object" ||
          Array.isArray(configurationMap[configKey])
        ) {
          continue;
        }
        let processedConfigKeys = _processConfigurationObject(configKey);
        currentConfigSection = configurationMap;
        let lastProcessedConfigKey = processedConfigKeys.pop();
        let sanitizedConfigKey = lastProcessedConfigKey.replace(/\\\./g, ".");
        for (let _configKey of processedConfigKeys) {
          if (_configKey !== "__proto__") {
            if (
              !_hasOwnProperty.call(currentConfigSection, _configKey) ||
              typeof currentConfigSection[_configKey] != "object"
            ) {
              currentConfigSection[_configKey] = Object.create(null);
            }
            currentConfigSection = currentConfigSection[_configKey];
          }
        }
        if (
          currentConfigSection !== configurationMap ||
          sanitizedConfigKey !== lastProcessedConfigKey
        ) {
          currentConfigSection[sanitizedConfigKey] =
            configurationMap[configKey];
          configurationLine.push(configKey);
        }
      }
      for (let configKeyToDelete of configurationLine) {
        delete configurationMap[configKeyToDelete];
      }
      return configurationMap;
    };
    var processConfigurationToString = (isStringEnclosed) =>
      (isStringEnclosed.startsWith('"') && isStringEnclosed.endsWith('"')) ||
      (isStringEnclosed.startsWith("'") && isStringEnclosed.endsWith("'"));
    var formatValueForOutput = (inputConfigurationString) =>
      typeof inputConfigurationString != "string" ||
      inputConfigurationString.match(/[=\r\n]/) ||
      inputConfigurationString.match(/^\[/) ||
      (inputConfigurationString.length > 1 &&
        processConfigurationToString(inputConfigurationString)) ||
      inputConfigurationString !== inputConfigurationString.trim()
        ? JSON.stringify(inputConfigurationString)
        : inputConfigurationString
            .split(";")
            .join("\\;")
            .split("#")
            .join("\\#");
    var createConfigurationOutput = (
      processAndParseInput,
      processAndParseJsonInput,
    ) => {
      processAndParseInput = (processAndParseInput || "").trim();
      if (processConfigurationToString(processAndParseInput)) {
        if (processAndParseInput.charAt(0) === "'") {
          processAndParseInput = processAndParseInput.slice(1, -1);
        }
        try {
          processAndParseInput = JSON.parse(processAndParseInput);
        } catch {}
      } else {
        let isEscapeCharacterActive = false;
        let parsedString = "";
        for (
          let currentCharIndex = 0, inputLength = processAndParseInput.length;
          currentCharIndex < inputLength;
          currentCharIndex++
        ) {
          let currentCharacter = processAndParseInput.charAt(currentCharIndex);
          if (isEscapeCharacterActive) {
            if ("\\;#".indexOf(currentCharacter) !== -1) {
              parsedString += currentCharacter;
            } else {
              parsedString += "\\" + currentCharacter;
            }
            isEscapeCharacterActive = false;
          } else {
            if (";#".indexOf(currentCharacter) !== -1) {
              break;
            }
            if (currentCharacter === "\\") {
              isEscapeCharacterActive = true;
            } else {
              parsedString += currentCharacter;
            }
          }
        }
        if (isEscapeCharacterActive) {
          parsedString += "\\";
        }
        return parsedString.trim();
      }
      return processAndParseInput;
    };
    processConfigurationHandler.exports = {
      parse: processVariable,
      decode: processVariable,
      stringify: processConfigurationObject,
      encode: processConfigurationObject,
      safe: formatValueForOutput,
      unsafe: createConfigurationOutput,
    };
  },
);
var compareAndParseFloat = conditionalModuleLoader(
  (exportWorkerScript, setWorkerScript) => {
    setWorkerScript.exports = "worker.js";
  },
);
var executeComparisonOperation = conditionalModuleLoader(
  (_moduleExports, __moduleExports) => {
    __moduleExports.exports = {
      ArrayIsArray(___isArray) {
        return Array.isArray(___isArray);
      },
      ArrayPrototypeIncludes(arrayIncludesElement, _arrayIncludesElement) {
        return arrayIncludesElement.includes(_arrayIncludesElement);
      },
      ArrayPrototypeIndexOf(ArrayPrototypeIndexOf, elementToFind) {
        return ArrayPrototypeIndexOf.indexOf(elementToFind);
      },
      ArrayPrototypeJoin(arrayJoinWithSeparator, separator) {
        return arrayJoinWithSeparator.join(separator);
      },
      ArrayPrototypeMap(arrayMap, ______callbackFunction) {
        return arrayMap.map(______callbackFunction);
      },
      ArrayPrototypePop(removeLastElementFromArray, removeLastElement) {
        return removeLastElementFromArray.pop(removeLastElement);
      },
      ArrayPrototypePush(arrayPushElement, addElementToArray) {
        return arrayPushElement.push(addElementToArray);
      },
      ArrayPrototypeSlice(sliceArray, startIndex, _endIndex) {
        return sliceArray.slice(startIndex, _endIndex);
      },
      Error: Error,
      FunctionPrototypeCall(
        callFunctionWithContext,
        contextualFunctionCall,
        ..._arguments
      ) {
        return callFunctionWithContext.call(
          contextualFunctionCall,
          ..._arguments,
        );
      },
      FunctionPrototypeSymbolHasInstance(
        checkInstanceAgainstPrototype,
        instanceCheckPrototypeFunction,
      ) {
        return Function.prototype[Symbol.hasInstance].call(
          checkInstanceAgainstPrototype,
          instanceCheckPrototypeFunction,
        );
      },
      MathFloor: Math.floor,
      Number: Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(___defineObjectProperties, propertiesDescriptor) {
        return Object.defineProperties(
          ___defineObjectProperties,
          propertiesDescriptor,
        );
      },
      ObjectDefineProperty(
        __defineObjectProperty,
        ________propertyDescriptor,
        _propertyValue,
      ) {
        return Object.defineProperty(
          __defineObjectProperty,
          ________propertyDescriptor,
          _propertyValue,
        );
      },
      ObjectGetOwnPropertyDescriptor(
        getOwnPropertyDescriptorFromObject,
        propertyDescriptorKey,
      ) {
        return Object.getOwnPropertyDescriptor(
          getOwnPropertyDescriptorFromObject,
          propertyDescriptorKey,
        );
      },
      ObjectKeys(___getObjectKeys) {
        return Object.keys(___getObjectKeys);
      },
      ObjectSetPrototypeOf(setObjectPrototype, setToPrototype) {
        return Object.setPrototypeOf(setObjectPrototype, setToPrototype);
      },
      Promise: Promise,
      PromisePrototypeCatch(promiseCatchHandler, promiseErrorHandler) {
        return promiseCatchHandler.catch(promiseErrorHandler);
      },
      PromisePrototypeThen(
        _promiseThenHandler,
        onFulfilledOrRejected,
        onFinalized,
      ) {
        return _promiseThenHandler.then(onFulfilledOrRejected, onFinalized);
      },
      PromiseReject(rejectWithError) {
        return Promise.reject(rejectWithError);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(regexTest, inputStringForRegexTest) {
        return regexTest.test(inputStringForRegexTest);
      },
      SafeSet: Set,
      String: String,
      StringPrototypeSlice(
        stringSlice,
        StringPrototypeSliceStringSliceStartIndexEndIndex,
        endIndex,
      ) {
        return stringSlice.slice(
          StringPrototypeSliceStringSliceStartIndexEndIndex,
          endIndex,
        );
      },
      StringPrototypeToLowerCase(convertStringToLowercase) {
        return convertStringToLowercase.toLowerCase();
      },
      StringPrototypeToUpperCase(convertStringToUpperCase) {
        return convertStringToUpperCase.toUpperCase();
      },
      StringPrototypeTrim(trimString) {
        return trimString.trim();
      },
      Symbol: Symbol,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      TypedArrayPrototypeSet(typedArraySet, sourceArray, targetIndex) {
        return typedArraySet.set(sourceArray, targetIndex);
      },
      Uint8Array: Uint8Array,
    };
  },
);
var ___validateAndProcessArrayBuffer = conditionalModuleLoader(
  (
    ______________________________________________________________validateAndRetrieveIntrinsicProperty,
    aggregateErrorModule,
  ) => {
    _validateAndRetrieveIntrinsicPropertyValue();
    var createESModuleFromIntrinsicProperty = createESModule(
      _retrieveAndValidateIntrinsicProperty,
    );
    var asyncFunctionConstructor = Object.getPrototypeOf(
      async function () {},
    ).constructor;
    var BlobConstructor =
      globalThis.Blob || createESModuleFromIntrinsicProperty.Blob;
    var isBlobInstance =
      typeof BlobConstructor !== "undefined"
        ? function (__validateAndProcessBuffer) {
            return __validateAndProcessBuffer instanceof BlobConstructor;
          }
        : function (processAndValidateBuffer) {
            return false;
          };
    var AggregateError = class extends Error {
      constructor(errorStackArray) {
        if (!Array.isArray(errorStackArray)) {
          throw new TypeError(
            "Expected input to be an Array, got " + typeof errorStackArray,
          );
        }
        let formattedStackTrace = "";
        for (
          let errorIndex = 0;
          errorIndex < errorStackArray.length;
          errorIndex++
        ) {
          formattedStackTrace +=
            "    " + errorStackArray[errorIndex].stack + "\n";
        }
        super(formattedStackTrace);
        this.name = "AggregateError";
        this.errors = errorStackArray;
      }
    };
    aggregateErrorModule.exports = {
      AggregateError: AggregateError,
      kEmptyObject: Object.freeze({}),
      once(_executeOnce) {
        let hasBeenExecuted = false;
        return function (...__executeOnce) {
          if (!hasBeenExecuted) {
            hasBeenExecuted = true;
            _executeOnce.apply(this, __executeOnce);
          }
        };
      },
      createDeferredPromise() {
        let resolvePromise;
        let rejectPromise;
        return {
          promise: new Promise((setPromiseHandlers, rejectPromiseHandler) => {
            resolvePromise = setPromiseHandlers;
            rejectPromise = rejectPromiseHandler;
          }),
          resolve: resolvePromise,
          reject: rejectPromise,
        };
      },
      promisify(callbackBasedFunction) {
        return new Promise((callbackHandler, responseHandler) => {
          callbackBasedFunction(
            (processResponseOrCallback, ...callbackArguments) =>
              processResponseOrCallback
                ? responseHandler(processResponseOrCallback)
                : callbackHandler(...callbackArguments),
          );
        });
      },
      debuglog() {
        return function () {};
      },
      format(_formatStringWithArgs, ...___argumentsArray) {
        return _formatStringWithArgs.replace(
          /%([sdifj])/g,
          function (...[formatValue, valueFormatType]) {
            let firstArgument = ___argumentsArray.shift();
            if (valueFormatType === "f") {
              return firstArgument.toFixed(6);
            } else if (valueFormatType === "j") {
              return JSON.stringify(firstArgument);
            } else if (
              valueFormatType === "s" &&
              typeof firstArgument == "object"
            ) {
              return (
                (firstArgument.constructor !== Object
                  ? firstArgument.constructor.name
                  : "") + " {}"
              ).trim();
            } else {
              return firstArgument.toString();
            }
          },
        );
      },
      inspect(___inspectValue) {
        switch (typeof ___inspectValue) {
          case "string":
            if (___inspectValue.includes("'")) {
              if (___inspectValue.includes('"')) {
                if (
                  !___inspectValue.includes("`") &&
                  !___inspectValue.includes("${")
                ) {
                  return "`" + ___inspectValue + "`";
                }
              } else {
                return '"' + ___inspectValue + '"';
              }
            }
            return "'" + ___inspectValue + "'";
          case "number":
            if (isNaN(___inspectValue)) {
              return "NaN";
            } else if (Object.is(___inspectValue, -0)) {
              return String(___inspectValue);
            } else {
              return ___inspectValue;
            }
          case "bigint":
            return String(___inspectValue) + "n";
          case "boolean":
          case "undefined":
            return String(___inspectValue);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(isAsyncFunctionInstance) {
          return isAsyncFunctionInstance instanceof asyncFunctionConstructor;
        },
        isArrayBufferView(_isArrayBufferView) {
          return ArrayBuffer.isView(_isArrayBufferView);
        },
      },
      isBlob: isBlobInstance,
    };
    aggregateErrorModule.exports.promisify.custom = Symbol.for(
      "nodejs.util.promisify.custom",
    );
  },
);
var _writeUint16LittleEndian = conditionalModuleLoader(
  (initializeAbortControllers, initAbortControllerExports) => {
    var _globalScope =
      typeof _globalScope === "undefined" ? globalThis : _globalScope;
    var { AbortController: AbortController, AbortSignal: AbortSignal } =
      typeof self !== "undefined"
        ? self
        : typeof _globalScope !== "undefined"
          ? _globalScope
          : undefined;
    initAbortControllerExports.exports = AbortController;
    initAbortControllerExports.exports.AbortSignal = AbortSignal;
    initAbortControllerExports.exports.default = AbortController;
  },
);
var getNodeValueAfterTraversal = conditionalModuleLoader(
  (processDataAndValidate, _processDataAndValidate) => {
    var {
      format: dataFormat,
      inspect: inspectData,
      AggregateError: CustomAggregateError,
    } = ___validateAndProcessArrayBuffer();
    var AggregateErrorInstance =
      globalThis.AggregateError || CustomAggregateError;
    var IS_NODE_ERROR_SYMBOL = Symbol("kIsNodeError");
    var dataTypeList = [
      "string",
      "function",
      "number",
      "object",
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol",
    ];
    var uppercaseCamelCaseRegex = /^([A-Z][a-z0-9]*)+$/;
    var internalNodeIdentifier = "__node_internal_";
    var errorTypes = {};
    function validateDataProcessing(processDataInChunks, mapThroughList) {
      if (!processDataInChunks) {
        throw new errorTypes.ERR_INTERNAL_ASSERTION(mapThroughList);
      }
    }
    function formatUint16BEString(reduceAndWriteUint16BE) {
      let formattedUint16BEString = "";
      let remainingLength = reduceAndWriteUint16BE.length;
      let isNegativeIndicator = reduceAndWriteUint16BE[0] === "-" ? 1 : 0;
      for (; remainingLength >= isNegativeIndicator + 4; remainingLength -= 3) {
        formattedUint16BEString =
          "_" +
          reduceAndWriteUint16BE.slice(remainingLength - 3, remainingLength) +
          formattedUint16BEString;
      }
      return (
        "" +
        reduceAndWriteUint16BE.slice(0, remainingLength) +
        formattedUint16BEString
      );
    }
    function validateAndFormatByteLengths(
      processEncodedByteLengths,
      calculateEncodedByteLengths,
      calculateEncodedByteLength,
    ) {
      if (typeof calculateEncodedByteLengths == "function") {
        validateDataProcessing(
          calculateEncodedByteLengths.length <=
            calculateEncodedByteLength.length,
          "Code: " +
            processEncodedByteLengths +
            "; The provided arguments length (" +
            calculateEncodedByteLength.length +
            ") does not match the required ones (" +
            calculateEncodedByteLengths.length +
            ").",
        );
        return calculateEncodedByteLengths(...calculateEncodedByteLength);
      }
      let expectedByteFormatCount = (
        calculateEncodedByteLengths.match(/%[dfijoOs]/g) || []
      ).length;
      validateDataProcessing(
        expectedByteFormatCount === calculateEncodedByteLength.length,
        "Code: " +
          processEncodedByteLengths +
          "; The provided arguments length (" +
          calculateEncodedByteLength.length +
          ") does not match the required ones (" +
          expectedByteFormatCount +
          ").",
      );
      if (calculateEncodedByteLength.length === 0) {
        return calculateEncodedByteLengths;
      } else {
        return dataFormat(
          calculateEncodedByteLengths,
          ...calculateEncodedByteLength,
        );
      }
    }
    function createErrorTypeWithMetadata(
      writeAndExportRandomValues,
      writeRandomValueLength,
      reduceListValues,
    ) {
      reduceListValues ||= Error;
      class RandomValueListReducer extends reduceListValues {
        constructor(...constructorParameters) {
          super(
            validateAndFormatByteLengths(
              writeAndExportRandomValues,
              writeRandomValueLength,
              constructorParameters,
            ),
          );
        }
        toString() {
          return (
            this.name + " [" + writeAndExportRandomValues + "]: " + this.message
          );
        }
      }
      Object.defineProperties(RandomValueListReducer.prototype, {
        name: {
          value: reduceListValues.name,
          writable: true,
          enumerable: false,
          configurable: true,
        },
        toString: {
          value() {
            return (
              this.name +
              " [" +
              writeAndExportRandomValues +
              "]: " +
              this.message
            );
          },
          writable: true,
          enumerable: false,
          configurable: true,
        },
      });
      RandomValueListReducer.prototype.code = writeAndExportRandomValues;
      RandomValueListReducer.prototype[IS_NODE_ERROR_SYMBOL] = true;
      errorTypes[writeAndExportRandomValues] = RandomValueListReducer;
    }
    function setInternalNodeName(_getRandomValueLength) {
      let fullNodeIdentifier =
        internalNodeIdentifier + _getRandomValueLength.name;
      Object.defineProperty(_getRandomValueLength, "name", {
        value: fullNodeIdentifier,
      });
      return _getRandomValueLength;
    }
    function mergeErrorMessages(createSubArray, sliceSubArray) {
      if (createSubArray && sliceSubArray && createSubArray !== sliceSubArray) {
        if (Array.isArray(sliceSubArray.errors)) {
          sliceSubArray.errors.push(createSubArray);
          return sliceSubArray;
        }
        let aggregateError = new AggregateErrorInstance(
          [sliceSubArray, createSubArray],
          sliceSubArray.message,
        );
        aggregateError.code = sliceSubArray.code;
        return aggregateError;
      }
      return createSubArray || sliceSubArray;
    }
    var generateFormattedData = class extends Error {
      constructor(
        operationAbortedMessage = "The operation was aborted",
        __options = undefined,
      ) {
        if (__options !== undefined && typeof __options != "object") {
          throw new errorTypes.ERR_INVALID_ARG_TYPE(
            "options",
            "Object",
            __options,
          );
        }
        super(operationAbortedMessage, __options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    createErrorTypeWithMetadata("ERR_ASSERTION", "%s", Error);
    createErrorTypeWithMetadata(
      "ERR_INVALID_ARG_TYPE",
      (nameArgument, expectedDataTypes, validateArgumentTypes) => {
        validateDataProcessing(
          typeof nameArgument == "string",
          "'name' must be a string",
        );
        if (!Array.isArray(expectedDataTypes)) {
          expectedDataTypes = [expectedDataTypes];
        }
        let argumentDescription = "The ";
        if (nameArgument.endsWith(" argument")) {
          argumentDescription += nameArgument + " ";
        } else {
          argumentDescription +=
            '"' +
            nameArgument +
            '" ' +
            (nameArgument.includes(".") ? "property" : "argument") +
            " ";
        }
        argumentDescription += "must be ";
        let expectedUppercaseTypes = [];
        let _expectedUppercaseTypes = [];
        let expectedArgumentTypes = [];
        for (let dataType of expectedDataTypes) {
          validateDataProcessing(
            typeof dataType == "string",
            "All expected entries have to be of type string",
          );
          if (dataTypeList.includes(dataType)) {
            expectedUppercaseTypes.push(dataType.toLowerCase());
          } else if (uppercaseCamelCaseRegex.test(dataType)) {
            _expectedUppercaseTypes.push(dataType);
          } else {
            validateDataProcessing(
              dataType !== "object",
              'The value "object" should be written as "Object"',
            );
            expectedArgumentTypes.push(dataType);
          }
        }
        if (_expectedUppercaseTypes.length > 0) {
          let objectTypeIndex = expectedUppercaseTypes.indexOf("object");
          if (objectTypeIndex !== -1) {
            expectedUppercaseTypes.splice(
              expectedUppercaseTypes,
              objectTypeIndex,
              1,
            );
            _expectedUppercaseTypes.push("Object");
          }
        }
        if (expectedUppercaseTypes.length > 0) {
          switch (expectedUppercaseTypes.length) {
            case 1:
              argumentDescription += "of type " + expectedUppercaseTypes[0];
              break;
            case 2:
              argumentDescription +=
                "one of type " +
                expectedUppercaseTypes[0] +
                " or " +
                expectedUppercaseTypes[1];
              break;
            default: {
              let poppedUppercaseType = expectedUppercaseTypes.pop();
              argumentDescription +=
                "one of type " +
                expectedUppercaseTypes.join(", ") +
                ", or " +
                poppedUppercaseType;
            }
          }
          if (
            _expectedUppercaseTypes.length > 0 ||
            expectedArgumentTypes.length > 0
          ) {
            argumentDescription += " or ";
          }
        }
        if (_expectedUppercaseTypes.length > 0) {
          switch (_expectedUppercaseTypes.length) {
            case 1:
              argumentDescription +=
                "an instance of " + _expectedUppercaseTypes[0];
              break;
            case 2:
              argumentDescription +=
                "an instance of " +
                _expectedUppercaseTypes[0] +
                " or " +
                _expectedUppercaseTypes[1];
              break;
            default: {
              let expectedUppercaseType = _expectedUppercaseTypes.pop();
              argumentDescription +=
                "an instance of " +
                _expectedUppercaseTypes.join(", ") +
                ", or " +
                expectedUppercaseType;
            }
          }
          if (expectedArgumentTypes.length > 0) {
            argumentDescription += " or ";
          }
        }
        switch (expectedArgumentTypes.length) {
          case 0:
            break;
          case 1:
            if (
              expectedArgumentTypes[0].toLowerCase() !==
              expectedArgumentTypes[0]
            ) {
              argumentDescription += "an ";
            }
            argumentDescription += "" + expectedArgumentTypes[0];
            break;
          case 2:
            argumentDescription +=
              "one of " +
              expectedArgumentTypes[0] +
              " or " +
              expectedArgumentTypes[1];
            break;
          default: {
            let lastExpectedArgumentType = expectedArgumentTypes.pop();
            argumentDescription +=
              "one of " +
              expectedArgumentTypes.join(", ") +
              ", or " +
              lastExpectedArgumentType;
          }
        }
        if (validateArgumentTypes == null) {
          argumentDescription += ". Received " + validateArgumentTypes;
        } else if (
          typeof validateArgumentTypes == "function" &&
          validateArgumentTypes.name
        ) {
          argumentDescription +=
            ". Received function " + validateArgumentTypes.name;
        } else if (typeof validateArgumentTypes == "object") {
          var constructorName;
          if (
            (constructorName = validateArgumentTypes.constructor) !== null &&
            constructorName !== undefined &&
            constructorName.name
          ) {
            argumentDescription +=
              ". Received an instance of " +
              validateArgumentTypes.constructor.name;
          } else {
            argumentDescription +=
              ". Received " +
              inspectData(validateArgumentTypes, {
                depth: -1,
              });
          }
        } else {
          let validatedArgumentsSummary = inspectData(validateArgumentTypes, {
            colors: false,
          });
          if (validatedArgumentsSummary.length > 25) {
            validatedArgumentsSummary =
              validatedArgumentsSummary.slice(0, 25) + "...";
          }
          argumentDescription +=
            ". Received type " +
            typeof validateArgumentTypes +
            " (" +
            validatedArgumentsSummary +
            ")";
        }
        return argumentDescription;
      },
      TypeError,
    );
    createErrorTypeWithMetadata(
      "ERR_INVALID_ARG_VALUE",
      (
        _formatErrorMessage,
        _____inputValue,
        validationMessageInvalid = "is invalid",
      ) => {
        let formattedInputValue = inspectData(_____inputValue);
        if (formattedInputValue.length > 128) {
          formattedInputValue = formattedInputValue.slice(0, 128) + "...";
        }
        return (
          "The " +
          (_formatErrorMessage.includes(".") ? "property" : "argument") +
          " '" +
          _formatErrorMessage +
          "' " +
          validationMessageInvalid +
          ". Received " +
          formattedInputValue
        );
      },
      TypeError,
    );
    createErrorTypeWithMetadata(
      "ERR_INVALID_RETURN_VALUE",
      (
        generateErrorMessage,
        functionNameExpectedReturn,
        getExpectedReturnErrorMessage,
      ) => {
        var expectedReturnTypeDescription;
        let actualReturnTypeDescription =
          getExpectedReturnErrorMessage != null &&
          (expectedReturnTypeDescription =
            getExpectedReturnErrorMessage.constructor) !== null &&
          expectedReturnTypeDescription !== undefined &&
          expectedReturnTypeDescription.name
            ? "instance of " + getExpectedReturnErrorMessage.constructor.name
            : "type " + typeof getExpectedReturnErrorMessage;
        return (
          "Expected " +
          generateErrorMessage +
          ' to be returned from the "' +
          functionNameExpectedReturn +
          '" function but got ' +
          actualReturnTypeDescription +
          "."
        );
      },
      TypeError,
    );
    createErrorTypeWithMetadata(
      "ERR_MISSING_ARGS",
      (...args) => {
        validateDataProcessing(
          args.length > 0,
          "At least one arg needs to be specified",
        );
        let argumentListDescription;
        let argumentCount = args.length;
        args = (Array.isArray(args) ? args : [args])
          .map((__formattedString) => '"' + __formattedString + '"')
          .join(" or ");
        switch (argumentCount) {
          case 1:
            argumentListDescription += "The " + args[0] + " argument";
            break;
          case 2:
            argumentListDescription +=
              "The " + args[0] + " and " + args[1] + " arguments";
            break;
          default:
            {
              let lastArgument = args.pop();
              argumentListDescription +=
                "The " +
                args.join(", ") +
                ", and " +
                lastArgument +
                " arguments";
            }
            break;
        }
        return argumentListDescription + " must be specified";
      },
      TypeError,
    );
    createErrorTypeWithMetadata(
      "ERR_OUT_OF_RANGE",
      (formatRangeErrorMessage, errorMessageFormatter, valueToCheck) => {
        validateDataProcessing(
          errorMessageFormatter,
          'Missing "range" argument',
        );
        let formattedValue;
        if (
          Number.isInteger(valueToCheck) &&
          Math.abs(valueToCheck) > 4294967296
        ) {
          formattedValue = formatUint16BEString(String(valueToCheck));
        } else if (typeof valueToCheck == "bigint") {
          formattedValue = String(valueToCheck);
          if (valueToCheck > 0x2n ** 0x20n || valueToCheck < -(0x2n ** 0x20n)) {
            formattedValue = formatUint16BEString(formattedValue);
          }
          formattedValue += "n";
        } else {
          formattedValue = inspectData(valueToCheck);
        }
        return (
          'The value of "' +
          formatRangeErrorMessage +
          '" is out of range. It must be ' +
          errorMessageFormatter +
          ". Received " +
          formattedValue
        );
      },
      RangeError,
    );
    createErrorTypeWithMetadata(
      "ERR_MULTIPLE_CALLBACK",
      "Callback called multiple times",
      Error,
    );
    createErrorTypeWithMetadata(
      "ERR_METHOD_NOT_IMPLEMENTED",
      "The %s method is not implemented",
      Error,
    );
    createErrorTypeWithMetadata(
      "ERR_STREAM_ALREADY_FINISHED",
      "Cannot call %s after a stream was finished",
      Error,
    );
    createErrorTypeWithMetadata(
      "ERR_STREAM_CANNOT_PIPE",
      "Cannot pipe, not readable",
      Error,
    );
    createErrorTypeWithMetadata(
      "ERR_STREAM_DESTROYED",
      "Cannot call %s after a stream was destroyed",
      Error,
    );
    createErrorTypeWithMetadata(
      "ERR_STREAM_NULL_VALUES",
      "May not write null values to stream",
      TypeError,
    );
    createErrorTypeWithMetadata(
      "ERR_STREAM_PREMATURE_CLOSE",
      "Premature close",
      Error,
    );
    createErrorTypeWithMetadata(
      "ERR_STREAM_PUSH_AFTER_EOF",
      "stream.push() after EOF",
      Error,
    );
    createErrorTypeWithMetadata(
      "ERR_STREAM_UNSHIFT_AFTER_END_EVENT",
      "stream.unshift() after end event",
      Error,
    );
    createErrorTypeWithMetadata(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end",
      Error,
    );
    createErrorTypeWithMetadata(
      "ERR_UNKNOWN_ENCODING",
      "Unknown encoding: %s",
      TypeError,
    );
    _processDataAndValidate.exports = {
      AbortError: generateFormattedData,
      aggregateTwoErrors: setInternalNodeName(mergeErrorMessages),
      hideStackFrames: setInternalNodeName,
      codes: errorTypes,
    };
  },
);
var updateMaxAgeSetting = conditionalModuleLoader(
  (executeNodeOperations, _executeNodeOperations) => {
    var {
      ArrayIsArray: _isArray,
      ArrayPrototypeIncludes: ArrayPrototypeIncludes,
      ArrayPrototypeJoin: ArrayPrototypeJoin,
      ArrayPrototypeMap: ArrayPrototypeMap,
      NumberIsInteger: _isInteger,
      NumberIsNaN: __isNaN,
      NumberMAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: MIN_SAFE_INTEGER,
      NumberParseInt: _parseInteger,
      ObjectPrototypeHasOwnProperty: ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec: regexpExec,
      String: StringUtility,
      StringPrototypeToUpperCase: stringPrototypeToUpperCase,
      StringPrototypeTrim: stringPrototypeTrim,
    } = executeComparisonOperation();
    var {
      hideStackFrames: hideStackFrames,
      codes: {
        ERR_SOCKET_BAD_PORT: ERROR_SOCKET_BAD_PORT,
        ERR_INVALID_ARG_TYPE: ERROR_INVALID_ARG_TYPE,
        ERR_INVALID_ARG_VALUE: ERROR_INVALID_ARG_VALUE,
        ERR_OUT_OF_RANGE: ERROR_OUT_OF_RANGE,
        ERR_UNKNOWN_SIGNAL: ERROR_UNKNOWN_SIGNAL,
      },
    } = getNodeValueAfterTraversal();
    var { normalizeEncoding: executeNodeOperationsFunction } =
      ___validateAndProcessArrayBuffer();
    var {
      isAsyncFunction: __executeNodeOperations,
      isArrayBufferView: ___executeNodeOperations,
    } = ___validateAndProcessArrayBuffer().types;
    var __executeComparisonOperation = {};
    function __isInteger(itemLengthCalculator) {
      return itemLengthCalculator === (itemLengthCalculator | 0);
    }
    function isValidNonNegativeInteger(setLengthCalculator) {
      return setLengthCalculator === setLengthCalculator >>> 0;
    }
    var ___executeComparisonOperation = /^[0-7]+$/;
    var ____executeComparisonOperation =
      "must be a 32-bit unsigned integer or an octal string";
    function processLengthAndTotal(
      updateLengthsAndTotal,
      lengthCalculator,
      calculateLength,
    ) {
      if (typeof updateLengthsAndTotal === "undefined") {
        updateLengthsAndTotal = calculateLength;
      }
      if (typeof updateLengthsAndTotal == "string") {
        if (
          regexpExec(___executeComparisonOperation, updateLengthsAndTotal) ===
          null
        ) {
          throw new ERROR_INVALID_ARG_VALUE(
            lengthCalculator,
            updateLengthsAndTotal,
            ____executeComparisonOperation,
          );
        }
        updateLengthsAndTotal = _parseInteger(updateLengthsAndTotal, 8);
      }
      ____executeNodeOperations(updateLengthsAndTotal, lengthCalculator);
      return updateLengthsAndTotal;
    }
    var _____executeComparisonOperation = hideStackFrames(
      (
        __validateIntegerInRange,
        ___validateIntegerInRange,
        minSafeInteger = MIN_SAFE_INTEGER,
        maxSafeIntegerValue = MAX_SAFE_INTEGER,
      ) => {
        if (typeof __validateIntegerInRange != "number") {
          throw new ERROR_INVALID_ARG_TYPE(
            ___validateIntegerInRange,
            "number",
            __validateIntegerInRange,
          );
        }
        if (!_isInteger(__validateIntegerInRange)) {
          throw new ERROR_OUT_OF_RANGE(
            ___validateIntegerInRange,
            "an integer",
            __validateIntegerInRange,
          );
        }
        if (
          __validateIntegerInRange < minSafeInteger ||
          __validateIntegerInRange > maxSafeIntegerValue
        ) {
          throw new ERROR_OUT_OF_RANGE(
            ___validateIntegerInRange,
            ">= " + minSafeInteger + " && <= " + maxSafeIntegerValue,
            __validateIntegerInRange,
          );
        }
      },
    );
    var ______executeComparisonOperation = hideStackFrames(
      (
        _validateIntegerInRange,
        validateAndCheckIntegerInRange,
        minIntegerValue = -2147483648,
        maxIntegerValue = 2147483647,
      ) => {
        if (typeof _validateIntegerInRange != "number") {
          throw new ERROR_INVALID_ARG_TYPE(
            validateAndCheckIntegerInRange,
            "number",
            _validateIntegerInRange,
          );
        }
        if (!_isInteger(_validateIntegerInRange)) {
          throw new ERROR_OUT_OF_RANGE(
            validateAndCheckIntegerInRange,
            "an integer",
            _validateIntegerInRange,
          );
        }
        if (
          _validateIntegerInRange < minIntegerValue ||
          _validateIntegerInRange > maxIntegerValue
        ) {
          throw new ERROR_OUT_OF_RANGE(
            validateAndCheckIntegerInRange,
            ">= " + minIntegerValue + " && <= " + maxIntegerValue,
            _validateIntegerInRange,
          );
        }
      },
    );
    var ____executeNodeOperations = hideStackFrames(
      (
        validateUnsignedInteger,
        validateUnsignedIntegerParameter,
        isConditionMet = false,
      ) => {
        if (typeof validateUnsignedInteger != "number") {
          throw new ERROR_INVALID_ARG_TYPE(
            validateUnsignedIntegerParameter,
            "number",
            validateUnsignedInteger,
          );
        }
        if (!_isInteger(validateUnsignedInteger)) {
          throw new ERROR_OUT_OF_RANGE(
            validateUnsignedIntegerParameter,
            "an integer",
            validateUnsignedInteger,
          );
        }
        let unsignedIntegerMinValue = isConditionMet ? 1 : 0;
        let unsignedIntegerMaxValue = 4294967295;
        if (
          validateUnsignedInteger < unsignedIntegerMinValue ||
          validateUnsignedInteger > unsignedIntegerMaxValue
        ) {
          throw new ERROR_OUT_OF_RANGE(
            validateUnsignedIntegerParameter,
            ">= " +
              unsignedIntegerMinValue +
              " && <= " +
              unsignedIntegerMaxValue,
            validateUnsignedInteger,
          );
        }
      },
    );
    function ________validateCacheEntry(setCacheEntry, setCacheValue) {
      if (typeof setCacheEntry != "string") {
        throw new ERROR_INVALID_ARG_TYPE(
          setCacheValue,
          "string",
          setCacheEntry,
        );
      }
    }
    function _______validateCacheEntry(
      updateCacheEntry,
      processCacheEntry,
      userSessionToken = undefined,
      _updateCacheEntry,
    ) {
      if (typeof updateCacheEntry != "number") {
        throw new ERROR_INVALID_ARG_TYPE(
          processCacheEntry,
          "number",
          updateCacheEntry,
        );
      }
      if (
        (userSessionToken != null && updateCacheEntry < userSessionToken) ||
        (_updateCacheEntry != null && updateCacheEntry > _updateCacheEntry) ||
        ((userSessionToken != null || _updateCacheEntry != null) &&
          __isNaN(updateCacheEntry))
      ) {
        throw new ERROR_OUT_OF_RANGE(
          processCacheEntry,
          "" +
            (userSessionToken != null ? ">= " + userSessionToken : "") +
            (userSessionToken != null && _updateCacheEntry != null
              ? " && "
              : "") +
            (_updateCacheEntry != null ? "<= " + _updateCacheEntry : ""),
          updateCacheEntry,
        );
      }
    }
    var _____executeNodeOperations = hideStackFrames(
      (
        validateArgumentAgainstAllowedValues,
        validateArgument,
        argumentValuesArray,
      ) => {
        if (
          !ArrayPrototypeIncludes(
            argumentValuesArray,
            validateArgumentAgainstAllowedValues,
          )
        ) {
          let formattedArgumentValuesString = ArrayPrototypeJoin(
            ArrayPrototypeMap(argumentValuesArray, (formatStringOrUtility) =>
              typeof formatStringOrUtility == "string"
                ? "'" + formatStringOrUtility + "'"
                : StringUtility(formatStringOrUtility),
            ),
            ", ",
          );
          let argumentValidationErrorMessage =
            "must be one of: " + formattedArgumentValuesString;
          throw new ERROR_INVALID_ARG_VALUE(
            validateArgument,
            validateArgumentAgainstAllowedValues,
            argumentValidationErrorMessage,
          );
        }
      },
    );
    function validateBooleanArgument(___processData, ____processData) {
      if (typeof ___processData != "boolean") {
        throw new ERROR_INVALID_ARG_TYPE(
          ____processData,
          "boolean",
          ___processData,
        );
      }
    }
    function getCachedElementOrDefault(
      addElementToCache,
      loadKeyValuePairs,
      addElementToQueue,
    ) {
      if (
        addElementToCache == null ||
        !ObjectPrototypeHasOwnProperty(addElementToCache, loadKeyValuePairs)
      ) {
        return addElementToQueue;
      } else {
        return addElementToCache[loadKeyValuePairs];
      }
    }
    var executeComparisonOperations = hideStackFrames(
      (validateInput, inputParameter, _userSession = null) => {
        let isArrayAllowed = getCachedElementOrDefault(
          _userSession,
          "allowArray",
          false,
        );
        let isFunctionAllowed = getCachedElementOrDefault(
          _userSession,
          "allowFunction",
          false,
        );
        if (
          (!getCachedElementOrDefault(_userSession, "nullable", false) &&
            validateInput === null) ||
          (!isArrayAllowed && _isArray(validateInput)) ||
          (typeof validateInput != "object" &&
            (!isFunctionAllowed || typeof validateInput != "function"))
        ) {
          throw new ERROR_INVALID_ARG_TYPE(
            inputParameter,
            "Object",
            validateInput,
          );
        }
      },
    );
    var _______executeComparisonOperation = hideStackFrames(
      (
        ___validateArrayLength,
        errorMessageForInvalidArrayLength,
        _initialValue = 0,
      ) => {
        if (!_isArray(___validateArrayLength)) {
          throw new ERROR_INVALID_ARG_TYPE(
            errorMessageForInvalidArrayLength,
            "Array",
            ___validateArrayLength,
          );
        }
        if (___validateArrayLength.length < _initialValue) {
          let errorMessageForArrayLength =
            "must be longer than " + _initialValue;
          throw new ERROR_INVALID_ARG_VALUE(
            errorMessageForInvalidArrayLength,
            ___validateArrayLength,
            errorMessageForArrayLength,
          );
        }
      },
    );
    function validateSignalAndExecute(
      getValueFromCacheOrDefault,
      signalType = "signal",
    ) {
      ________validateCacheEntry(getValueFromCacheOrDefault, signalType);
      if (
        __executeComparisonOperation[getValueFromCacheOrDefault] === undefined
      ) {
        throw __executeComparisonOperation[
          stringPrototypeToUpperCase(getValueFromCacheOrDefault)
        ] !== undefined
          ? new ERROR_UNKNOWN_SIGNAL(
              getValueFromCacheOrDefault +
                " (signals must use all capital letters)",
            )
          : new ERROR_UNKNOWN_SIGNAL(getValueFromCacheOrDefault);
      }
    }
    var ________executeComparisonOperation = hideStackFrames(
      (nodeOperationInput, _dataBuffer = "buffer") => {
        if (!___executeNodeOperations(nodeOperationInput)) {
          throw new ERROR_INVALID_ARG_TYPE(
            _dataBuffer,
            ["Buffer", "TypedArray", "DataView"],
            nodeOperationInput,
          );
        }
      },
    );
    function validateNodeEncoding(processNode, removeExpiredNode) {
      let nodeEncoding = executeNodeOperationsFunction(removeExpiredNode);
      let nodeLength = processNode.length;
      if (nodeEncoding === "hex" && nodeLength % 2 !== 0) {
        throw new ERROR_INVALID_ARG_VALUE(
          "encoding",
          removeExpiredNode,
          "is invalid for data of length " + nodeLength,
        );
      }
    }
    function validatePortNumber(
      processNodeRemoval,
      portName = "Port",
      isPortRequired = true,
    ) {
      if (
        (typeof processNodeRemoval != "number" &&
          typeof processNodeRemoval != "string") ||
        (typeof processNodeRemoval == "string" &&
          stringPrototypeTrim(processNodeRemoval).length === 0) ||
        +processNodeRemoval !== +processNodeRemoval >>> 0 ||
        processNodeRemoval > 65535 ||
        (processNodeRemoval === 0 && !isPortRequired)
      ) {
        throw new ERROR_SOCKET_BAD_PORT(
          portName,
          processNodeRemoval,
          isPortRequired,
        );
      }
      return processNodeRemoval | 0;
    }
    var initializeNodeOperationUtilities = hideStackFrames(
      (__________abortSignal, abortSignalParam) => {
        if (
          __________abortSignal !== undefined &&
          (__________abortSignal === null ||
            typeof __________abortSignal != "object" ||
            !("aborted" in __________abortSignal))
        ) {
          throw new ERROR_INVALID_ARG_TYPE(
            abortSignalParam,
            "AbortSignal",
            __________abortSignal,
          );
        }
      },
    );
    var ______executeNodeOperations = hideStackFrames(
      (_validateFunctionArgument, argumentValidator) => {
        if (typeof _validateFunctionArgument != "function") {
          throw new ERROR_INVALID_ARG_TYPE(
            argumentValidator,
            "Function",
            _validateFunctionArgument,
          );
        }
      },
    );
    var _________executeComparisonOperation = hideStackFrames(
      (validationFunc, validationFunction) => {
        if (
          typeof validationFunc != "function" ||
          __executeNodeOperations(validationFunc)
        ) {
          throw new ERROR_INVALID_ARG_TYPE(
            validationFunction,
            "Function",
            validationFunc,
          );
        }
      },
    );
    var __________executeComparisonOperation = hideStackFrames(
      (validateAndThrowErrorIfUndefined, argumentToValidate) => {
        if (validateAndThrowErrorIfUndefined !== undefined) {
          throw new ERROR_INVALID_ARG_TYPE(
            argumentToValidate,
            "undefined",
            validateAndThrowErrorIfUndefined,
          );
        }
      },
    );
    function validateSegmentBounds(
      compareSegmentBounds,
      valueSetter,
      _getCompareSegmentBounds,
    ) {
      if (
        !ArrayPrototypeIncludes(_getCompareSegmentBounds, compareSegmentBounds)
      ) {
        throw new ERROR_INVALID_ARG_TYPE(
          valueSetter,
          "('" + ArrayPrototypeJoin(_getCompareSegmentBounds, "|") + "')",
          compareSegmentBounds,
        );
      }
    }
    _executeNodeOperations.exports = {
      isInt32: __isInteger,
      isUint32: isValidNonNegativeInteger,
      parseFileMode: processLengthAndTotal,
      validateArray: _______executeComparisonOperation,
      validateBoolean: validateBooleanArgument,
      validateBuffer: ________executeComparisonOperation,
      validateEncoding: validateNodeEncoding,
      validateFunction: ______executeNodeOperations,
      validateInt32: ______executeComparisonOperation,
      validateInteger: _____executeComparisonOperation,
      validateNumber: _______validateCacheEntry,
      validateObject: executeComparisonOperations,
      validateOneOf: _____executeNodeOperations,
      validatePlainFunction: _________executeComparisonOperation,
      validatePort: validatePortNumber,
      validateSignalName: validateSignalAndExecute,
      validateString: ________validateCacheEntry,
      validateUint32: ____executeNodeOperations,
      validateUndefined: __________executeComparisonOperation,
      validateUnion: validateSegmentBounds,
      validateAbortSignal: initializeNodeOperationUtilities,
    };
  },
);
var isValidSemVerRange = conditionalModuleLoader(
  (defineSetTimeoutAndClearTimeout, defineTimeoutFunctions) => {
    var timeoutFunctionsMapping = (defineTimeoutFunctions.exports = {});
    var setTimeoutFallback;
    var clearTimeoutFallback;
    function throwSetTimeoutNotDefinedError() {
      throw new Error("setTimeout has not been defined");
    }
    function throwUndefinedTimeoutError() {
      throw new Error("clearTimeout has not been defined");
    }
    (function () {
      try {
        if (typeof setTimeout == "function") {
          setTimeoutFallback = setTimeout;
        } else {
          setTimeoutFallback = throwSetTimeoutNotDefinedError;
        }
      } catch {
        setTimeoutFallback = throwSetTimeoutNotDefinedError;
      }
      try {
        if (typeof clearTimeout == "function") {
          clearTimeoutFallback = clearTimeout;
        } else {
          clearTimeoutFallback = throwUndefinedTimeoutError;
        }
      } catch {
        clearTimeoutFallback = throwUndefinedTimeoutError;
      }
    })();
    function scheduleParseHyphenRange(parseHyphenRange) {
      if (setTimeoutFallback === setTimeout) {
        return setTimeout(parseHyphenRange, 0);
      }
      if (
        (setTimeoutFallback === throwSetTimeoutNotDefinedError ||
          !setTimeoutFallback) &&
        setTimeout
      ) {
        setTimeoutFallback = setTimeout;
        return setTimeout(parseHyphenRange, 0);
      }
      try {
        return setTimeoutFallback(parseHyphenRange, 0);
      } catch {
        try {
          return setTimeoutFallback.call(null, parseHyphenRange, 0);
        } catch {
          return setTimeoutFallback.call(this, parseHyphenRange, 0);
        }
      }
    }
    function clearTimeoutSafely(parseVersionRange) {
      if (clearTimeoutFallback === clearTimeout) {
        return clearTimeout(parseVersionRange);
      }
      if (
        (clearTimeoutFallback === throwUndefinedTimeoutError ||
          !clearTimeoutFallback) &&
        clearTimeout
      ) {
        clearTimeoutFallback = clearTimeout;
        return clearTimeout(parseVersionRange);
      }
      try {
        return clearTimeoutFallback(parseVersionRange);
      } catch {
        try {
          return clearTimeoutFallback.call(null, parseVersionRange);
        } catch {
          return clearTimeoutFallback.call(this, parseVersionRange);
        }
      }
    }
    var setTimeoutOrThrow = [];
    var setTimeoutHandler = false;
    var _setTimeoutHandler;
    var setTimeoutOrFallback = -1;
    function handleSetTimeoutConfiguration() {
      if (!!setTimeoutHandler && !!_setTimeoutHandler) {
        setTimeoutHandler = false;
        if (_setTimeoutHandler.length) {
          setTimeoutOrThrow = _setTimeoutHandler.concat(setTimeoutOrThrow);
        } else {
          setTimeoutOrFallback = -1;
        }
        if (setTimeoutOrThrow.length) {
          initializeSetTimeoutHandler();
        }
      }
    }
    function initializeSetTimeoutHandler() {
      if (!setTimeoutHandler) {
        var parsedSchedule = scheduleParseHyphenRange(
          handleSetTimeoutConfiguration,
        );
        setTimeoutHandler = true;
        for (
          var remainingTimeoutsCount = setTimeoutOrThrow.length;
          remainingTimeoutsCount;

        ) {
          _setTimeoutHandler = setTimeoutOrThrow;
          setTimeoutOrThrow = [];
          while (++setTimeoutOrFallback < remainingTimeoutsCount) {
            if (_setTimeoutHandler) {
              _setTimeoutHandler[setTimeoutOrFallback].run();
            }
          }
          setTimeoutOrFallback = -1;
          remainingTimeoutsCount = setTimeoutOrThrow.length;
        }
        _setTimeoutHandler = null;
        setTimeoutHandler = false;
        clearTimeoutSafely(parsedSchedule);
      }
    }
    timeoutFunctionsMapping.nextTick = function (matchesComparatorLoose) {
      var ____argumentsArray = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (
          var argArrayIndex = 1;
          argArrayIndex < arguments.length;
          argArrayIndex++
        ) {
          ____argumentsArray[argArrayIndex - 1] = arguments[argArrayIndex];
        }
      }
      setTimeoutOrThrow.push(
        new IntersectionCalculator(matchesComparatorLoose, ____argumentsArray),
      );
      if (setTimeoutOrThrow.length === 1 && !setTimeoutHandler) {
        scheduleParseHyphenRange(initializeSetTimeoutHandler);
      }
    };
    function IntersectionCalculator(
      calculateIntersections,
      calculateIntersectedRanges,
    ) {
      this.fun = calculateIntersections;
      this.array = calculateIntersectedRanges;
    }
    IntersectionCalculator.prototype.run = function () {
      this.fun.apply(null, this.array);
    };
    timeoutFunctionsMapping.title = "browser";
    timeoutFunctionsMapping.browser = true;
    timeoutFunctionsMapping.env = {};
    timeoutFunctionsMapping.argv = [];
    timeoutFunctionsMapping.version = "";
    timeoutFunctionsMapping.versions = {};
    function initializeApplication() {}
    timeoutFunctionsMapping.on = initializeApplication;
    timeoutFunctionsMapping.addListener = initializeApplication;
    timeoutFunctionsMapping.once = initializeApplication;
    timeoutFunctionsMapping.off = initializeApplication;
    timeoutFunctionsMapping.removeListener = initializeApplication;
    timeoutFunctionsMapping.removeAllListeners = initializeApplication;
    timeoutFunctionsMapping.emit = initializeApplication;
    timeoutFunctionsMapping.prependListener = initializeApplication;
    timeoutFunctionsMapping.prependOnceListener = initializeApplication;
    timeoutFunctionsMapping.listeners = function (processEncodedString) {
      return [];
    };
    timeoutFunctionsMapping.binding = function (
      processCharacterOrCodePointValidation,
    ) {
      throw new Error("process.binding is not supported");
    };
    timeoutFunctionsMapping.cwd = function () {
      return "/";
    };
    timeoutFunctionsMapping.chdir = function (isCharacterInSet) {
      throw new Error("process.chdir is not supported");
    };
    timeoutFunctionsMapping.umask = function () {
      return 0;
    };
  },
);
var validateAndProcessCharacterEncoding = conditionalModuleLoader(
  (validateAndCheckStreamProperties, validateStreamProperties) => {
    var {
      Symbol: getSymbolByKey,
      SymbolAsyncIterator: _asyncIteratorSymbol,
      SymbolIterator: symbolIterator,
    } = executeComparisonOperation();
    var kDestroyedSymbol = getSymbolByKey("kDestroyed");
    var kIsErroredSymbol = getSymbolByKey("kIsErrored");
    var kIsReadableSymbol = getSymbolByKey("kIsReadable");
    var kIsDisturbedSymbol = getSymbolByKey("kIsDisturbed");
    function __isValidVersionRange(
      validateVersionRange,
      checkVersionRangeRequirements = false,
    ) {
      return (
        !!validateVersionRange &&
        typeof validateVersionRange.pipe == "function" &&
        typeof validateVersionRange.on == "function" &&
        (!checkVersionRangeRequirements ||
          (typeof validateVersionRange.pause == "function" &&
            typeof validateVersionRange.resume == "function")) &&
        (!validateVersionRange._writableState ||
          validateVersionRange._readableState?.readable !== false) &&
        (!validateVersionRange._writableState ||
          !!validateVersionRange._readableState)
      );
    }
    function isValidWritableStream(validateIntersectingRanges) {
      return (
        !!validateIntersectingRanges &&
        typeof validateIntersectingRanges.write == "function" &&
        typeof validateIntersectingRanges.on == "function" &&
        (!validateIntersectingRanges._readableState ||
          validateIntersectingRanges._writableState?.writable !== false)
      );
    }
    function ____isReadableStream(processVersionRange) {
      return (
        !!processVersionRange &&
        typeof processVersionRange.pipe == "function" &&
        !!processVersionRange._readableState &&
        typeof processVersionRange.on == "function" &&
        typeof processVersionRange.write == "function"
      );
    }
    function isStreamLike(formattedVersion) {
      return (
        formattedVersion &&
        (formattedVersion._readableState ||
          formattedVersion._writableState ||
          (typeof formattedVersion.write == "function" &&
            typeof formattedVersion.on == "function") ||
          (typeof formattedVersion.pipe == "function" &&
            typeof formattedVersion.on == "function"))
      );
    }
    function isIterableVersion(
      replaceTildeVersion,
      generateVersionRangeFromTilde,
    ) {
      if (replaceTildeVersion == null) {
        return false;
      } else if (generateVersionRangeFromTilde === true) {
        return typeof replaceTildeVersion[_asyncIteratorSymbol] == "function";
      } else if (generateVersionRangeFromTilde === false) {
        return typeof replaceTildeVersion[symbolIterator] == "function";
      } else {
        return (
          typeof replaceTildeVersion[_asyncIteratorSymbol] == "function" ||
          typeof replaceTildeVersion[symbolIterator] == "function"
        );
      }
    }
    function isVersionRangeDestroyed(generateVersionRange) {
      if (!isStreamLike(generateVersionRange)) {
        return null;
      }
      let _____________________writableState =
        generateVersionRange._writableState;
      let _______________________readableState =
        generateVersionRange._readableState;
      let writableOrReadableState =
        _____________________writableState ||
        _______________________readableState;
      return (
        !!generateVersionRange.destroyed ||
        !!generateVersionRange[kDestroyedSymbol] ||
        (writableOrReadableState != null && !!writableOrReadableState.destroyed)
      );
    }
    function checkWritableRangeStatus(_parseVersionRange) {
      if (!isValidWritableStream(_parseVersionRange)) {
        return null;
      }
      if (_parseVersionRange.writableEnded === true) {
        return true;
      }
      let _________________writableState = _parseVersionRange._writableState;
      if (
        _________________writableState != null &&
        _________________writableState.errored
      ) {
        return false;
      } else if (typeof _________________writableState?.ended != "boolean") {
        return null;
      } else {
        return _________________writableState.ended;
      }
    }
    function checkWritableState(replaceCaretVersionRange, processCaretVersion) {
      if (!isValidWritableStream(replaceCaretVersionRange)) {
        return null;
      }
      if (replaceCaretVersionRange.writableFinished === true) {
        return true;
      }
      let _______________writableState =
        replaceCaretVersionRange._writableState;
      if (
        _______________writableState != null &&
        _______________writableState.errored
      ) {
        return false;
      } else if (typeof _______________writableState?.finished != "boolean") {
        return null;
      } else {
        return (
          !!_______________writableState.finished ||
          (processCaretVersion === false &&
            _______________writableState.ended === true &&
            _______________writableState.length === 0)
        );
      }
    }
    function isDependencyRangeReadable(getDependencyRangeString) {
      if (!__isValidVersionRange(getDependencyRangeString)) {
        return null;
      }
      if (getDependencyRangeString.readableEnded === true) {
        return true;
      }
      let __________________readableState =
        getDependencyRangeString._readableState;
      if (
        !__________________readableState ||
        __________________readableState.errored
      ) {
        return false;
      } else if (typeof __________________readableState?.ended != "boolean") {
        return null;
      } else {
        return __________________readableState.ended;
      }
    }
    function isPatchVersionEmitted(patchVersion, versionRange) {
      if (!__isValidVersionRange(patchVersion)) {
        return null;
      }
      let ________________readableState = patchVersion._readableState;
      if (
        ________________readableState != null &&
        ________________readableState.errored
      ) {
        return false;
      } else if (
        typeof ________________readableState?.endEmitted != "boolean"
      ) {
        return null;
      } else {
        return (
          !!________________readableState.endEmitted ||
          (versionRange === false &&
            ________________readableState.ended === true &&
            ________________readableState.length === 0)
        );
      }
    }
    function checkIfVersionRangeIsReadable(getVersionRange) {
      if (getVersionRange && getVersionRange[kIsReadableSymbol] != null) {
        return getVersionRange[kIsReadableSymbol];
      } else if (typeof getVersionRange?.readable != "boolean") {
        return null;
      } else if (isVersionRangeDestroyed(getVersionRange)) {
        return false;
      } else {
        return (
          __isValidVersionRange(getVersionRange) &&
          getVersionRange.readable &&
          !isPatchVersionEmitted(getVersionRange)
        );
      }
    }
    function validateWritableVersionRange(versionRangeParser) {
      if (typeof versionRangeParser?.writable != "boolean") {
        return null;
      } else if (isVersionRangeDestroyed(versionRangeParser)) {
        return false;
      } else {
        return (
          isValidWritableStream(versionRangeParser) &&
          versionRangeParser.writable &&
          !checkWritableRangeStatus(versionRangeParser)
        );
      }
    }
    function _isVersionRangeValid(versionRangeCondition, _getVersionRange) {
      if (isStreamLike(versionRangeCondition)) {
        if (isVersionRangeDestroyed(versionRangeCondition)) {
          return true;
        } else {
          return (
            (_getVersionRange?.readable === false ||
              !checkIfVersionRangeIsReadable(versionRangeCondition)) &&
            (_getVersionRange?.writable === false ||
              !validateWritableVersionRange(versionRangeCondition))
          );
        }
      } else {
        return null;
      }
    }
    function getWritableErrorState(__parseVersionRange) {
      if (isStreamLike(__parseVersionRange)) {
        if (__parseVersionRange.writableErrored) {
          return __parseVersionRange.writableErrored;
        } else {
          return __parseVersionRange._writableState?.errored ?? null;
        }
      } else {
        return null;
      }
    }
    function getParsedVersionRangeError(___parseVersionRange) {
      if (isStreamLike(___parseVersionRange)) {
        if (___parseVersionRange.readableErrored) {
          return ___parseVersionRange.readableErrored;
        } else {
          return ___parseVersionRange._readableState?.errored ?? null;
        }
      } else {
        return null;
      }
    }
    function getUpdateConstraintsClosureState(updateVersionConstraints) {
      if (!isStreamLike(updateVersionConstraints)) {
        return null;
      }
      if (typeof updateVersionConstraints.closed == "boolean") {
        return updateVersionConstraints.closed;
      }
      let _____________writableState = updateVersionConstraints._writableState;
      let ___________readableState = updateVersionConstraints._readableState;
      if (
        typeof _____________writableState?.closed == "boolean" ||
        typeof ___________readableState?.closed == "boolean"
      ) {
        return (
          _____________writableState?.closed || ___________readableState?.closed
        );
      } else if (
        typeof updateVersionConstraints._closed == "boolean" &&
        isMinorVersionValid(updateVersionConstraints)
      ) {
        return updateVersionConstraints._closed;
      } else {
        return null;
      }
    }
    function isMinorVersionValid(minorVersion) {
      return (
        typeof minorVersion._closed == "boolean" &&
        typeof minorVersion._defaultKeepAlive == "boolean" &&
        typeof minorVersion._removedConnection == "boolean" &&
        typeof minorVersion._removedContLen == "boolean"
      );
    }
    function __isVersionRangeValid(calculateVersionRange) {
      return (
        typeof calculateVersionRange._sent100 == "boolean" &&
        isMinorVersionValid(calculateVersionRange)
      );
    }
    function isVersionCountersValid(updateVersionCounters) {
      return (
        typeof updateVersionCounters._consuming == "boolean" &&
        typeof updateVersionCounters._dumped == "boolean" &&
        updateVersionCounters.req?.upgradeOrConnect === undefined
      );
    }
    function isNegativeSuffixValid(negativeSuffix) {
      if (!isStreamLike(negativeSuffix)) {
        return null;
      }
      let ____________________writableState = negativeSuffix._writableState;
      let ______________________readableState = negativeSuffix._readableState;
      let combinedWritableReadableState =
        ____________________writableState ||
        ______________________readableState;
      return (
        (!combinedWritableReadableState &&
          __isVersionRangeValid(negativeSuffix)) ||
        (!!combinedWritableReadableState &&
          !!combinedWritableReadableState.autoDestroy &&
          !!combinedWritableReadableState.emitClose &&
          combinedWritableReadableState.closed === false)
      );
    }
    function isVersionRangeDisturbed(_generateVersionRange) {
      return (
        !!_generateVersionRange &&
        !!(
          _generateVersionRange[kIsDisturbedSymbol] ??
          (_generateVersionRange.readableDidRead ||
            _generateVersionRange.readableAborted)
        )
      );
    }
    function hasErrorsInStream(removeStarsFromString) {
      return (
        !!removeStarsFromString &&
        !!(
          removeStarsFromString[kIsErroredSymbol] ??
          removeStarsFromString.readableErrored ??
          removeStarsFromString.writableErrored ??
          removeStarsFromString._readableState?.errorEmitted ??
          removeStarsFromString._writableState?.errorEmitted ??
          removeStarsFromString._readableState?.errored ??
          removeStarsFromString._writableState?.errored
        )
      );
    }
    validateStreamProperties.exports = {
      kDestroyed: kDestroyedSymbol,
      isDisturbed: isVersionRangeDisturbed,
      kIsDisturbed: kIsDisturbedSymbol,
      isErrored: hasErrorsInStream,
      kIsErrored: kIsErroredSymbol,
      isReadable: checkIfVersionRangeIsReadable,
      kIsReadable: kIsReadableSymbol,
      isClosed: getUpdateConstraintsClosureState,
      isDestroyed: isVersionRangeDestroyed,
      isDuplexNodeStream: ____isReadableStream,
      isFinished: _isVersionRangeValid,
      isIterable: isIterableVersion,
      isReadableNodeStream: __isValidVersionRange,
      isReadableEnded: isDependencyRangeReadable,
      isReadableFinished: isPatchVersionEmitted,
      isReadableErrored: getParsedVersionRangeError,
      isNodeStream: isStreamLike,
      isWritable: validateWritableVersionRange,
      isWritableNodeStream: isValidWritableStream,
      isWritableEnded: checkWritableRangeStatus,
      isWritableFinished: checkWritableState,
      isWritableErrored: getWritableErrorState,
      isServerRequest: isVersionCountersValid,
      isServerResponse: __isVersionRangeValid,
      willEmitClose: isNegativeSuffixValid,
    };
  },
);
var validateSemverPrerelease = conditionalModuleLoader(
  (processCharacterEncodingValidation, ___processCharacterEncoding) => {
    var _________isValidSemVerRangeResult = isValidSemVerRange();
    var { AbortError: ____AbortError, codes: _errorCodes } =
      getNodeValueAfterTraversal();
    var {
      ERR_INVALID_ARG_TYPE: _ERR_INVALID_ARG_TYPE,
      ERR_STREAM_PREMATURE_CLOSE: ERR_STREAM_PREMATURE_CLOSE,
    } = _errorCodes;
    var { kEmptyObject: kEmptyObject, once: executeOnce } =
      ___validateAndProcessArrayBuffer();
    var {
      validateAbortSignal: _____validateAbortSignal,
      validateFunction: validateCallbackFunction,
      validateObject: validateInputObject,
    } = updateMaxAgeSetting();
    var { Promise: _Promise } = executeComparisonOperation();
    var {
      isClosed: isStreamClosed,
      isReadable: ___isReadable,
      isReadableNodeStream: _isReadableNodeStream,
      isReadableFinished: isStreamReadableFinished,
      isReadableErrored: isReadableErrorState,
      isWritable: _isStreamWritable,
      isWritableNodeStream: _isWritableStream,
      isWritableFinished: _processCharacterEncodingValidation,
      isWritableErrored: isCharacterEncodingValidationActive,
      isNodeStream: ___validateCharacterEncoding,
      willEmitClose: processCharacterEncodingAndValidation,
    } = validateAndProcessCharacterEncoding();
    function isProcessAbortable(processComparator) {
      return (
        processComparator.setHeader &&
        typeof processComparator.abort == "function"
      );
    }
    var ____validateCharacterEncoding = () => {};
    function processAndValidateStreams(
      _processComparator,
      parseComparator,
      _parseComparator,
    ) {
      if (arguments.length === 2) {
        _parseComparator = parseComparator;
        parseComparator = kEmptyObject;
      } else if (parseComparator == null) {
        parseComparator = kEmptyObject;
      } else {
        validateInputObject(parseComparator, "options");
      }
      validateCallbackFunction(_parseComparator, "callback");
      _____validateAbortSignal(parseComparator.signal, "options.signal");
      _parseComparator = executeOnce(_parseComparator);
      let __isReadableStream =
        parseComparator.readable ?? _isReadableNodeStream(_processComparator);
      let isProcessWritableStream =
        parseComparator.writable ?? _isWritableStream(_processComparator);
      if (!___validateCharacterEncoding(_processComparator)) {
        throw new _ERR_INVALID_ARG_TYPE("stream", "Stream", _processComparator);
      }
      let ____writableState = _processComparator._writableState;
      let __readableState = _processComparator._readableState;
      let createReadableStream = () => {
        if (!_processComparator.writable) {
          validateWritableState();
        }
      };
      let _validateAndProcessStreams =
        processCharacterEncodingAndValidation(_processComparator) &&
        _isReadableNodeStream(_processComparator) === __isReadableStream &&
        _isWritableStream(_processComparator) === isProcessWritableStream;
      let processAndValidateStreamOptions = _processCharacterEncodingValidation(
        _processComparator,
        false,
      );
      let validateWritableState = () => {
        processAndValidateStreamOptions = true;
        if (_processComparator.destroyed) {
          _validateAndProcessStreams = false;
        }
        if (
          (!_validateAndProcessStreams ||
            (!!_processComparator.readable && !__isReadableStream)) &&
          (!__isReadableStream || __validateAndProcessStreams)
        ) {
          _parseComparator.call(_processComparator);
        }
      };
      let __validateAndProcessStreams = isStreamReadableFinished(
        _processComparator,
        false,
      );
      let validateAndPrepareStreams = () => {
        __validateAndProcessStreams = true;
        if (_processComparator.destroyed) {
          _validateAndProcessStreams = false;
        }
        if (
          (!_validateAndProcessStreams ||
            (!!_processComparator.writable && !isProcessWritableStream)) &&
          (!isProcessWritableStream || processAndValidateStreamOptions)
        ) {
          _parseComparator.call(_processComparator);
        }
      };
      let validateAndProcessStreamOptions = (processComparatorFunction) => {
        _parseComparator.call(_processComparator, processComparatorFunction);
      };
      let _processAndValidateStreams = isStreamClosed(_processComparator);
      let ______validateAbortSignal = () => {
        _processAndValidateStreams = true;
        let isValidationRequired =
          isCharacterEncodingValidationActive(_processComparator) ||
          isReadableErrorState(_processComparator);
        if (isValidationRequired && typeof isValidationRequired != "boolean") {
          return _parseComparator.call(
            _processComparator,
            isValidationRequired,
          );
        }
        if (
          __isReadableStream &&
          !__validateAndProcessStreams &&
          _isReadableNodeStream(_processComparator, true) &&
          !isStreamReadableFinished(_processComparator, false)
        ) {
          return _parseComparator.call(
            _processComparator,
            new ERR_STREAM_PREMATURE_CLOSE(),
          );
        }
        if (
          isProcessWritableStream &&
          !processAndValidateStreamOptions &&
          !_processCharacterEncodingValidation(_processComparator, false)
        ) {
          return _parseComparator.call(
            _processComparator,
            new ERR_STREAM_PREMATURE_CLOSE(),
          );
        }
        _parseComparator.call(_processComparator);
      };
      let ___validateAndProcessStreams = () => {
        _processComparator.req.on("finish", validateWritableState);
      };
      if (isProcessAbortable(_processComparator)) {
        _processComparator.on("complete", validateWritableState);
        if (!_validateAndProcessStreams) {
          _processComparator.on("abort", ______validateAbortSignal);
        }
        if (_processComparator.req) {
          ___validateAndProcessStreams();
        } else {
          _processComparator.on("request", ___validateAndProcessStreams);
        }
      } else if (isProcessWritableStream && !____writableState) {
        _processComparator.on("end", createReadableStream);
        _processComparator.on("close", createReadableStream);
      }
      if (
        !_validateAndProcessStreams &&
        typeof _processComparator.aborted == "boolean"
      ) {
        _processComparator.on("aborted", ______validateAbortSignal);
      }
      _processComparator.on("end", validateAndPrepareStreams);
      _processComparator.on("finish", validateWritableState);
      if (parseComparator.error !== false) {
        _processComparator.on("error", validateAndProcessStreamOptions);
      }
      _processComparator.on("close", ______validateAbortSignal);
      if (_processAndValidateStreams) {
        _________isValidSemVerRangeResult.nextTick(______validateAbortSignal);
      } else if (
        (____writableState != null && ____writableState.errorEmitted) ||
        (__readableState != null && __readableState.errorEmitted)
      ) {
        if (!_validateAndProcessStreams) {
          _________isValidSemVerRangeResult.nextTick(______validateAbortSignal);
        }
      } else if (
        (!__isReadableStream &&
          (!_validateAndProcessStreams || ___isReadable(_processComparator)) &&
          (processAndValidateStreamOptions ||
            _isStreamWritable(_processComparator) === false)) ||
        (!isProcessWritableStream &&
          (!_validateAndProcessStreams ||
            _isStreamWritable(_processComparator)) &&
          (__validateAndProcessStreams ||
            ___isReadable(_processComparator) === false)) ||
        (__readableState &&
          _processComparator.req &&
          _processComparator.aborted)
      ) {
        _________isValidSemVerRangeResult.nextTick(______validateAbortSignal);
      }
      let __processAndValidateStreams = () => {
        _parseComparator = ____validateCharacterEncoding;
        _processComparator.removeListener("aborted", ______validateAbortSignal);
        _processComparator.removeListener("complete", validateWritableState);
        _processComparator.removeListener("abort", ______validateAbortSignal);
        _processComparator.removeListener(
          "request",
          ___validateAndProcessStreams,
        );
        if (_processComparator.req) {
          _processComparator.req.removeListener(
            "finish",
            validateWritableState,
          );
        }
        _processComparator.removeListener("end", createReadableStream);
        _processComparator.removeListener("close", createReadableStream);
        _processComparator.removeListener("finish", validateWritableState);
        _processComparator.removeListener("end", validateAndPrepareStreams);
        _processComparator.removeListener(
          "error",
          validateAndProcessStreamOptions,
        );
        _processComparator.removeListener("close", ______validateAbortSignal);
      };
      if (parseComparator.signal && !_processAndValidateStreams) {
        let _handleAbortEvent = () => {
          let parseComparatorFunction = _parseComparator;
          __processAndValidateStreams();
          parseComparatorFunction.call(
            _processComparator,
            new ____AbortError(undefined, {
              cause: parseComparator.signal.reason,
            }),
          );
        };
        if (parseComparator.signal.aborted) {
          _________isValidSemVerRangeResult.nextTick(_handleAbortEvent);
        } else {
          let originalParseComparator = _parseComparator;
          _parseComparator = executeOnce((...comparatorArguments) => {
            parseComparator.signal.removeEventListener(
              "abort",
              _handleAbortEvent,
            );
            originalParseComparator.apply(
              _processComparator,
              comparatorArguments,
            );
          });
          parseComparator.signal.addEventListener("abort", _handleAbortEvent);
        }
      }
      return __processAndValidateStreams;
    }
    function ____validateAndProcessStreams(
      _________validateAndRetrieveIntrinsicProperties,
      conditionalCharacterRetriever,
    ) {
      return new _Promise(
        (handleStreamValidation, validateStreamAndProcess) => {
          processAndValidateStreams(
            _________validateAndRetrieveIntrinsicProperties,
            conditionalCharacterRetriever,
            (____streamData) => {
              if (____streamData) {
                validateStreamAndProcess(____streamData);
              } else {
                handleStreamValidation();
              }
            },
          );
        },
      );
    }
    ___processCharacterEncoding.exports = processAndValidateStreams;
    ___processCharacterEncoding.exports.finished =
      ____validateAndProcessStreams;
  },
);
var __________validateAndRetrieveIntrinsicProperties = conditionalModuleLoader(
  (handleAbortSignalAndValidation, _handleAbortSignalAndValidation) => {
    var AbortControllerReference =
      globalThis.AbortController || _writeUint16LittleEndian().AbortController;
    var {
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARGUMENT_TYPE,
        ERR_MISSING_ARGS: ERR_MISSING_ARGUMENTS,
        ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE,
      },
      AbortError: AbortError,
    } = getNodeValueAfterTraversal();
    var {
      validateAbortSignal: ____validateAbortSignal,
      validateInteger: validateIntegerValue,
      validateObject: validateObjectStructure,
    } = updateMaxAgeSetting();
    var abortSignalSymbol = executeComparisonOperation().Symbol("kWeak");
    var { finished: isFinished } = validateSemverPrerelease();
    var {
      ArrayPrototypePush: arrayPrototypePush,
      MathFloor: mathFloor,
      Number: GlobalNumberReference,
      NumberIsNaN: _isNaN,
      Promise: _PromiseImplementation,
      PromiseReject: promiseRejectHandler,
      PromisePrototypeThen: promiseThenHandler,
      Symbol: __handleAbortSignalAndValidation,
    } = executeComparisonOperation();
    var abortSignalHandlerAndValidator =
      __handleAbortSignalAndValidation("kEmpty");
    var __abortSignalHandler = __handleAbortSignalAndValidation("kEof");
    function _______validateAndRetrieveProperties(
      ___________validateAndRetrieveIntrinsicProperties,
      validateAndRetrieveSemanticVersionProperties,
    ) {
      if (
        typeof ___________validateAndRetrieveIntrinsicProperties != "function"
      ) {
        throw new ERR_INVALID_ARGUMENT_TYPE(
          "fn",
          ["Function", "AsyncFunction"],
          ___________validateAndRetrieveIntrinsicProperties,
        );
      }
      if (validateAndRetrieveSemanticVersionProperties != null) {
        validateObjectStructure(
          validateAndRetrieveSemanticVersionProperties,
          "options",
        );
      }
      if (validateAndRetrieveSemanticVersionProperties?.signal != null) {
        ____validateAbortSignal(
          validateAndRetrieveSemanticVersionProperties.signal,
          "options.signal",
        );
      }
      let concurrencyLimit = 1;
      if (validateAndRetrieveSemanticVersionProperties?.concurrency != null) {
        concurrencyLimit = mathFloor(
          validateAndRetrieveSemanticVersionProperties.concurrency,
        );
      }
      validateIntegerValue(concurrencyLimit, "concurrency", 1);
      return async function* () {
        var _abortSignal;
        var __abortSignal;
        let abortControllerReference = new AbortControllerReference();
        let _context = this;
        let abortedResponses = [];
        let ___abortSignal = abortControllerReference.signal;
        let abortSignalReference = {
          signal: ___abortSignal,
        };
        let abortControllerCallback = () => abortControllerReference.abort();
        if (
          validateAndRetrieveSemanticVersionProperties != null &&
          (_abortSignal =
            validateAndRetrieveSemanticVersionProperties.signal) !== null &&
          _abortSignal !== undefined &&
          _abortSignal.aborted
        ) {
          abortControllerCallback();
        }
        if (
          validateAndRetrieveSemanticVersionProperties != null &&
          (__abortSignal =
            validateAndRetrieveSemanticVersionProperties.signal) !== null &&
          __abortSignal !== undefined
        ) {
          __abortSignal.addEventListener("abort", abortControllerCallback);
        }
        let isAborted;
        let isTaskAborted;
        let isTaskCompleted = false;
        function markTaskAsCompleted() {
          isTaskCompleted = true;
        }
        async function processAbortedTasks() {
          try {
            for await (let taskItem of _context) {
              var taskItemForCatch;
              if (isTaskCompleted) {
                return;
              }
              if (___abortSignal.aborted) {
                throw new AbortError();
              }
              try {
                taskItem = ___________validateAndRetrieveIntrinsicProperties(
                  taskItem,
                  abortSignalReference,
                );
              } catch (____errorHandler) {
                taskItem = promiseRejectHandler(____errorHandler);
              }
              if (taskItem !== abortSignalHandlerAndValidator) {
                if (
                  typeof ((taskItemForCatch = taskItem) === null ||
                  taskItemForCatch === undefined
                    ? undefined
                    : taskItemForCatch.catch) == "function"
                ) {
                  taskItem.catch(markTaskAsCompleted);
                }
                abortedResponses.push(taskItem);
                if (isAborted) {
                  isAborted();
                  isAborted = null;
                }
                if (
                  !isTaskCompleted &&
                  abortedResponses.length &&
                  abortedResponses.length >= concurrencyLimit
                ) {
                  await new _PromiseImplementation((isTaskAbortedFlag) => {
                    isTaskAborted = isTaskAbortedFlag;
                  });
                }
              }
            }
            abortedResponses.push(__abortSignalHandler);
          } catch (errorCaught) {
            let handledPromiseRejection = promiseRejectHandler(errorCaught);
            promiseThenHandler(
              handledPromiseRejection,
              undefined,
              markTaskAsCompleted,
            );
            abortedResponses.push(handledPromiseRejection);
          } finally {
            var semanticVersionSignal;
            isTaskCompleted = true;
            if (isAborted) {
              isAborted();
              isAborted = null;
            }
            if (
              validateAndRetrieveSemanticVersionProperties != null &&
              (semanticVersionSignal =
                validateAndRetrieveSemanticVersionProperties.signal) !== null &&
              semanticVersionSignal !== undefined
            ) {
              semanticVersionSignal.removeEventListener(
                "abort",
                abortControllerCallback,
              );
            }
          }
        }
        processAbortedTasks();
        try {
          while (true) {
            while (abortedResponses.length > 0) {
              let firstAbortedResponse = await abortedResponses[0];
              if (firstAbortedResponse === __abortSignalHandler) {
                return;
              }
              if (___abortSignal.aborted) {
                throw new AbortError();
              }
              if (firstAbortedResponse !== abortSignalHandlerAndValidator) {
                yield firstAbortedResponse;
              }
              abortedResponses.shift();
              if (isTaskAborted) {
                isTaskAborted();
                isTaskAborted = null;
              }
            }
            await new _PromiseImplementation((isAbortedFlag) => {
              isAborted = isAbortedFlag;
            });
          }
        } finally {
          abortControllerReference.abort();
          isTaskCompleted = true;
          if (isTaskAborted) {
            isTaskAborted();
            isTaskAborted = null;
          }
        }
      }.call(this);
    }
    function createAsyncIterableWithAbort(defaultValue = undefined) {
      if (defaultValue != null) {
        validateObjectStructure(defaultValue, "options");
      }
      if (defaultValue?.signal != null) {
        ____validateAbortSignal(defaultValue.signal, "options.signal");
      }
      return async function* () {
        let ________currentIndex = 0;
        for await (let asyncIterableItem of this) {
          var ________abortSignal;
          if (
            defaultValue != null &&
            (________abortSignal = defaultValue.signal) !== null &&
            ________abortSignal !== undefined &&
            ________abortSignal.aborted
          ) {
            throw new AbortError({
              cause: defaultValue.signal.reason,
            });
          }
          yield [________currentIndex++, asyncIterableItem];
        }
      }.call(this);
    }
    async function validateSortedRange(
      ____________validateAndRetrieveIntrinsicProperties,
      myUndefinedVariable = undefined,
    ) {
      for await (let intrinsicProperties of validateAndRetrieveSortedRange.call(
        this,
        ____________validateAndRetrieveIntrinsicProperties,
        myUndefinedVariable,
      )) {
        return true;
      }
      return false;
    }
    async function validateAndRetrieveIntrinsicPropertiesAsync(
      _____________validateAndRetrieveIntrinsicProperties,
      playerScore = undefined,
    ) {
      if (
        typeof _____________validateAndRetrieveIntrinsicProperties != "function"
      ) {
        throw new ERR_INVALID_ARGUMENT_TYPE(
          "fn",
          ["Function", "AsyncFunction"],
          _____________validateAndRetrieveIntrinsicProperties,
        );
      }
      return !(await validateSortedRange.call(
        this,
        async (
          ...___________________________________________validateAndRetrieveIntrinsicProperties
        ) =>
          !(await _____________validateAndRetrieveIntrinsicProperties(
            ...___________________________________________validateAndRetrieveIntrinsicProperties,
          )),
        playerScore,
      ));
    }
    async function validateAndRetrieveInstanceProperties(
      intersectingVvfInstances,
      ______________validateAndRetrieveIntrinsicProperties,
    ) {
      for await (let _intrinsicProperties of validateAndRetrieveSortedRange.call(
        this,
        intersectingVvfInstances,
        ______________validateAndRetrieveIntrinsicProperties,
      )) {
        return _intrinsicProperties;
      }
    }
    async function _validateAndProcessData(
      _______________validateAndRetrieveIntrinsicProperties,
      ________________validateAndRetrieveIntrinsicProperties,
    ) {
      if (
        typeof _______________validateAndRetrieveIntrinsicProperties !=
        "function"
      ) {
        throw new ERR_INVALID_ARGUMENT_TYPE(
          "fn",
          ["Function", "AsyncFunction"],
          _______________validateAndRetrieveIntrinsicProperties,
        );
      }
      async function validateAndRetrieveIntrinsicPropertiesAndHandleAbort(
        processSortedData,
        processSortedValues,
      ) {
        await _______________validateAndRetrieveIntrinsicProperties(
          processSortedData,
          processSortedValues,
        );
        return abortSignalHandlerAndValidator;
      }
      for await (let propertyValidationResults of _______validateAndRetrieveProperties.call(
        this,
        validateAndRetrieveIntrinsicPropertiesAndHandleAbort,
        ________________validateAndRetrieveIntrinsicProperties,
      ));
    }
    function validateAndRetrieveSortedRange(
      getSortedRangeConditions,
      processVariablePairs,
    ) {
      if (typeof getSortedRangeConditions != "function") {
        throw new ERR_INVALID_ARGUMENT_TYPE(
          "fn",
          ["Function", "AsyncFunction"],
          getSortedRangeConditions,
        );
      }
      async function validateAndRetrieveComparisonSegments(
        processComparisonSegments,
        _processComparisonSegments,
      ) {
        if (
          await getSortedRangeConditions(
            processComparisonSegments,
            _processComparisonSegments,
          )
        ) {
          return processComparisonSegments;
        } else {
          return abortSignalHandlerAndValidator;
        }
      }
      return _______validateAndRetrieveProperties.call(
        this,
        validateAndRetrieveComparisonSegments,
        processVariablePairs,
      );
    }
    var ___handleAbortSignalAndValidation = class extends ERR_MISSING_ARGUMENTS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function setupComparisonProcess(
      compareBigInts,
      compareCharacterSegments,
      compareValuesAndReturnBasedOnLength,
    ) {
      var ____abortSignal;
      if (typeof compareBigInts != "function") {
        throw new ERR_INVALID_ARGUMENT_TYPE(
          "reducer",
          ["Function", "AsyncFunction"],
          compareBigInts,
        );
      }
      if (compareValuesAndReturnBasedOnLength != null) {
        validateObjectStructure(compareValuesAndReturnBasedOnLength, "options");
      }
      if (compareValuesAndReturnBasedOnLength?.signal != null) {
        ____validateAbortSignal(
          compareValuesAndReturnBasedOnLength.signal,
          "options.signal",
        );
      }
      let isMultipleArgumentsPassed = arguments.length > 1;
      if (
        compareValuesAndReturnBasedOnLength != null &&
        (____abortSignal = compareValuesAndReturnBasedOnLength.signal) !==
          null &&
        ____abortSignal !== undefined &&
        ____abortSignal.aborted
      ) {
        let abortErrorBasedOnComparison = new AbortError(undefined, {
          cause: compareValuesAndReturnBasedOnLength.signal.reason,
        });
        this.once("error", () => {});
        await isFinished(this.destroy(abortErrorBasedOnComparison));
        throw abortErrorBasedOnComparison;
      }
      let abortError = new AbortControllerReference();
      let _abortError = abortError.signal;
      if (
        compareValuesAndReturnBasedOnLength != null &&
        compareValuesAndReturnBasedOnLength.signal
      ) {
        let eventListenerOptions = {
          once: true,
          [abortSignalSymbol]: this,
        };
        compareValuesAndReturnBasedOnLength.signal.addEventListener(
          "abort",
          () => abortError.abort(),
          eventListenerOptions,
        );
      }
      let _____abortSignal = false;
      try {
        for await (let characterSegment of this) {
          var _______abortSignal;
          _____abortSignal = true;
          if (
            compareValuesAndReturnBasedOnLength != null &&
            (_______abortSignal =
              compareValuesAndReturnBasedOnLength.signal) !== null &&
            _______abortSignal !== undefined &&
            _______abortSignal.aborted
          ) {
            throw new AbortError();
          }
          if (isMultipleArgumentsPassed) {
            compareCharacterSegments = await compareBigInts(
              compareCharacterSegments,
              characterSegment,
              {
                signal: _abortError,
              },
            );
          } else {
            compareCharacterSegments = characterSegment;
            isMultipleArgumentsPassed = true;
          }
        }
        if (!_____abortSignal && !isMultipleArgumentsPassed) {
          throw new ___handleAbortSignalAndValidation();
        }
      } finally {
        abortError.abort();
      }
      return compareCharacterSegments;
    }
    async function processVersionConditions(prereleaseVersionCondition) {
      if (prereleaseVersionCondition != null) {
        validateObjectStructure(prereleaseVersionCondition, "options");
      }
      if (prereleaseVersionCondition?.signal != null) {
        ____validateAbortSignal(
          prereleaseVersionCondition.signal,
          "options.signal",
        );
      }
      let processedVersions = [];
      for await (let versionItem of this) {
        var _________abortSignal;
        if (
          prereleaseVersionCondition != null &&
          (_________abortSignal = prereleaseVersionCondition.signal) !== null &&
          _________abortSignal !== undefined &&
          _________abortSignal.aborted
        ) {
          throw new AbortError(undefined, {
            cause: prereleaseVersionCondition.signal.reason,
          });
        }
        arrayPrototypePush(processedVersions, versionItem);
      }
      return processedVersions;
    }
    function processSemanticVersion(
      validateSemverConditions,
      processSemanticVersionConstraints,
    ) {
      let validatedSemanticVersionProperties =
        _______validateAndRetrieveProperties.call(
          this,
          validateSemverConditions,
          processSemanticVersionConstraints,
        );
      return async function* () {
        for await (let semanticVersionProperty of validatedSemanticVersionProperties) {
          yield* semanticVersionProperty;
        }
      }.call(this);
    }
    function validateAndNormalizeSemverComparison(compareSemverAndOperators) {
      compareSemverAndOperators = GlobalNumberReference(
        compareSemverAndOperators,
      );
      if (_isNaN(compareSemverAndOperators)) {
        return 0;
      }
      if (compareSemverAndOperators < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", compareSemverAndOperators);
      }
      return compareSemverAndOperators;
    }
    function createAsyncGeneratorWithAbortSignal(
      isVersionRangeValid,
      undefinedValue = undefined,
    ) {
      if (undefinedValue != null) {
        validateObjectStructure(undefinedValue, "options");
      }
      if (undefinedValue?.signal != null) {
        ____validateAbortSignal(undefinedValue.signal, "options.signal");
      }
      isVersionRangeValid =
        validateAndNormalizeSemverComparison(isVersionRangeValid);
      return async function* () {
        var signal;
        if (
          undefinedValue != null &&
          (signal = undefinedValue.signal) !== null &&
          signal !== undefined &&
          signal.aborted
        ) {
          throw new AbortError();
        }
        for await (let itemToYield of this) {
          var signalProperty;
          if (
            undefinedValue != null &&
            (signalProperty = undefinedValue.signal) !== null &&
            signalProperty !== undefined &&
            signalProperty.aborted
          ) {
            throw new AbortError();
          }
          if (isVersionRangeValid-- <= 0) {
            yield itemToYield;
          }
        }
      }.call(this);
    }
    function processVersionComparisonsWithOptions(
      versionComparisons,
      userSession = undefined,
    ) {
      if (userSession != null) {
        validateObjectStructure(userSession, "options");
      }
      if (userSession?.signal != null) {
        ____validateAbortSignal(userSession.signal, "options.signal");
      }
      versionComparisons =
        validateAndNormalizeSemverComparison(versionComparisons);
      return async function* () {
        var signalControl;
        if (
          userSession != null &&
          (signalControl = userSession.signal) !== null &&
          signalControl !== undefined &&
          signalControl.aborted
        ) {
          throw new AbortError();
        }
        for await (let asyncIteratorItem of this) {
          var signalObject;
          if (
            userSession != null &&
            (signalObject = userSession.signal) !== null &&
            signalObject !== undefined &&
            signalObject.aborted
          ) {
            throw new AbortError();
          }
          if (versionComparisons-- > 0) {
            yield asyncIteratorItem;
          } else {
            return;
          }
        }
      }.call(this);
    }
    _handleAbortSignalAndValidation.exports.streamReturningOperators = {
      asIndexedPairs: createAsyncIterableWithAbort,
      drop: createAsyncGeneratorWithAbortSignal,
      filter: validateAndRetrieveSortedRange,
      flatMap: processSemanticVersion,
      map: _______validateAndRetrieveProperties,
      take: processVersionComparisonsWithOptions,
    };
    _handleAbortSignalAndValidation.exports.promiseReturningOperators = {
      every: validateAndRetrieveIntrinsicPropertiesAsync,
      forEach: _validateAndProcessData,
      reduce: setupComparisonProcess,
      toArray: processVersionConditions,
      some: validateSortedRange,
      find: validateAndRetrieveInstanceProperties,
    };
  },
);
var evaluateVersionOperators = conditionalModuleLoader(
  (validateSemverRange, handleSemanticVersioningError) => {
    var _isSemVerRangeValid = isValidSemVerRange();
    var {
      aggregateTwoErrors: aggregateErrors,
      codes: { ERR_MULTIPLE_CALLBACK: ERR_MULTIPLE_CALLBACK },
      AbortError: ___AbortError,
    } = getNodeValueAfterTraversal();
    var { Symbol: getSymbol } = executeComparisonOperation();
    var {
      kDestroyed: isCharacterEncodingDestroyed,
      isDestroyed: _isCharacterEncodingValid,
      isFinished: isCharacterEncodingCompleted,
      isServerRequest: isServerRequestValid,
    } = validateAndProcessCharacterEncoding();
    var getSymbolForDestruction = getSymbol("kDestroy");
    var getSymbolForConstruction = getSymbol("kConstruct");
    function _handleSemanticVersionComparison(
      chooseSemverBasedOnOperator,
      compareSemanticVersions,
      compareSemverVersions,
    ) {
      if (chooseSemverBasedOnOperator) {
        chooseSemverBasedOnOperator.stack;
        if (compareSemanticVersions && !compareSemanticVersions.errored) {
          compareSemanticVersions.errored = chooseSemverBasedOnOperator;
        }
        if (compareSemverVersions && !compareSemverVersions.errored) {
          compareSemverVersions.errored = chooseSemverBasedOnOperator;
        }
      }
    }
    function handleVersionStatesAndDestruction(
      compareVersionOperators,
      calculateVersionBasedOnOperators,
    ) {
      let ________readableState = this._readableState;
      let __________writableState = this._writableState;
      let activeState = __________writableState || ________readableState;
      if (
        (__________writableState && __________writableState.destroyed) ||
        (________readableState && ________readableState.destroyed)
      ) {
        if (typeof calculateVersionBasedOnOperators == "function") {
          calculateVersionBasedOnOperators();
        }
        return this;
      } else {
        _handleSemanticVersionComparison(
          compareVersionOperators,
          __________writableState,
          ________readableState,
        );
        if (__________writableState) {
          __________writableState.destroyed = true;
        }
        if (________readableState) {
          ________readableState.destroyed = true;
        }
        if (activeState.constructed) {
          processIntrinsicPropertyAndIndexData(
            this,
            compareVersionOperators,
            calculateVersionBasedOnOperators,
          );
        } else {
          this.once(
            getSymbolForDestruction,
            function (initializeConditionalModuleLoader) {
              processIntrinsicPropertyAndIndexData(
                this,
                aggregateErrors(
                  initializeConditionalModuleLoader,
                  compareVersionOperators,
                ),
                calculateVersionBasedOnOperators,
              );
            },
          );
        }
        return this;
      }
    }
    function processIntrinsicPropertyAndIndexData(
      _____________________________________________________________validateAndRetrieveIntrinsicProperty,
      validateAndRetrieveIndexData,
      logError,
    ) {
      let isProcessingIntrinsicProperty = false;
      function processIntrinsicProperty(validateAndRetrieveCharacterEncoding) {
        if (isProcessingIntrinsicProperty) {
          return;
        }
        isProcessingIntrinsicProperty = true;
        let __________readableState =
          _____________________________________________________________validateAndRetrieveIntrinsicProperty._readableState;
        let ____________writableState =
          _____________________________________________________________validateAndRetrieveIntrinsicProperty._writableState;
        _handleSemanticVersionComparison(
          validateAndRetrieveCharacterEncoding,
          ____________writableState,
          __________readableState,
        );
        if (____________writableState) {
          ____________writableState.closed = true;
        }
        if (__________readableState) {
          __________readableState.closed = true;
        }
        if (typeof logError == "function") {
          logError(validateAndRetrieveCharacterEncoding);
        }
        if (validateAndRetrieveCharacterEncoding) {
          _isSemVerRangeValid.nextTick(
            handleDataProcessingStream,
            _____________________________________________________________validateAndRetrieveIntrinsicProperty,
            validateAndRetrieveCharacterEncoding,
          );
        } else {
          _isSemVerRangeValid.nextTick(
            emitCloseIfStateEmitted,
            _____________________________________________________________validateAndRetrieveIntrinsicProperty,
          );
        }
      }
      try {
        _____________________________________________________________validateAndRetrieveIntrinsicProperty._destroy(
          validateAndRetrieveIndexData || null,
          processIntrinsicProperty,
        );
      } catch (________________error) {
        processIntrinsicProperty(________________error);
      }
    }
    function handleDataProcessingStream(
      retrieveAndValidateIntrinsicData,
      _____processData,
    ) {
      _handleStreamError(retrieveAndValidateIntrinsicData, _____processData);
      emitCloseIfStateEmitted(retrieveAndValidateIntrinsicData);
    }
    function emitCloseIfStateEmitted(retrieveAndValidateIntrinsicProperties) {
      let _____________________readableState =
        retrieveAndValidateIntrinsicProperties._readableState;
      let ___________________writableState =
        retrieveAndValidateIntrinsicProperties._writableState;
      if (___________________writableState) {
        ___________________writableState.closeEmitted = true;
      }
      if (_____________________readableState) {
        _____________________readableState.closeEmitted = true;
      }
      if (
        (___________________writableState &&
          ___________________writableState.emitClose) ||
        (_____________________readableState &&
          _____________________readableState.emitClose)
      ) {
        retrieveAndValidateIntrinsicProperties.emit("close");
      }
    }
    function _handleStreamError(
      _________________validateAndRetrieveIntrinsicProperties,
      __________________validateAndRetrieveIntrinsicProperties,
    ) {
      let ___________________readableState =
        _________________validateAndRetrieveIntrinsicProperties._readableState;
      let __________________writableState =
        _________________validateAndRetrieveIntrinsicProperties._writableState;
      if (
        (!__________________writableState ||
          !__________________writableState.errorEmitted) &&
        (!___________________readableState ||
          !___________________readableState.errorEmitted)
      ) {
        if (__________________writableState) {
          __________________writableState.errorEmitted = true;
        }
        if (___________________readableState) {
          ___________________readableState.errorEmitted = true;
        }
        _________________validateAndRetrieveIntrinsicProperties.emit(
          "error",
          __________________validateAndRetrieveIntrinsicProperties,
        );
      }
    }
    function initializeStreamStates() {
      let _____readableState = this._readableState;
      let _________writableState = this._writableState;
      if (_____readableState) {
        _____readableState.constructed = true;
        _____readableState.closed = false;
        _____readableState.closeEmitted = false;
        _____readableState.destroyed = false;
        _____readableState.errored = null;
        _____readableState.errorEmitted = false;
        _____readableState.reading = false;
        _____readableState.ended = _____readableState.readable === false;
        _____readableState.endEmitted = _____readableState.readable === false;
      }
      if (_________writableState) {
        _________writableState.constructed = true;
        _________writableState.destroyed = false;
        _________writableState.closed = false;
        _________writableState.closeEmitted = false;
        _________writableState.errored = null;
        _________writableState.errorEmitted = false;
        _________writableState.finalCalled = false;
        _________writableState.prefinished = false;
        _________writableState.ended =
          _________writableState.writable === false;
        _________writableState.ending =
          _________writableState.writable === false;
        _________writableState.finished =
          _________writableState.writable === false;
      }
    }
    function handlePatternRegexAndVersion(
      _initializePatternRegex,
      _defineVersionRangePatterns,
      __initializePatternRegex,
    ) {
      let _readableStreamState = _initializePatternRegex._readableState;
      let writableStreamState = _initializePatternRegex._writableState;
      if (
        (writableStreamState && writableStreamState.destroyed) ||
        (_readableStreamState && _readableStreamState.destroyed)
      ) {
        return this;
      }
      if (
        (_readableStreamState && _readableStreamState.autoDestroy) ||
        (writableStreamState && writableStreamState.autoDestroy)
      ) {
        _initializePatternRegex.destroy(_defineVersionRangePatterns);
      } else if (_defineVersionRangePatterns) {
        _defineVersionRangePatterns.stack;
        if (writableStreamState && !writableStreamState.errored) {
          writableStreamState.errored = _defineVersionRangePatterns;
        }
        if (_readableStreamState && !_readableStreamState.errored) {
          _readableStreamState.errored = _defineVersionRangePatterns;
        }
        if (__initializePatternRegex) {
          _isSemVerRangeValid.nextTick(
            _handleStreamError,
            _initializePatternRegex,
            _defineVersionRangePatterns,
          );
        } else {
          _handleStreamError(
            _initializePatternRegex,
            _defineVersionRangePatterns,
          );
        }
      }
    }
    function _initializeStreamStates(
      ___initializePatternRegex,
      ____initializePatternRegex,
    ) {
      if (typeof ___initializePatternRegex._construct != "function") {
        return;
      }
      let ______________readableState =
        ___initializePatternRegex._readableState;
      let ________________writableState =
        ___initializePatternRegex._writableState;
      if (______________readableState) {
        ______________readableState.constructed = false;
      }
      if (________________writableState) {
        ________________writableState.constructed = false;
      }
      ___initializePatternRegex.once(
        getSymbolForConstruction,
        ____initializePatternRegex,
      );
      if (
        !(___initializePatternRegex.listenerCount(getSymbolForConstruction) > 1)
      ) {
        _isSemVerRangeValid.nextTick(
          initializeModuleImport,
          ___initializePatternRegex,
        );
      }
    }
    function initializeModuleImport(checkIfModuleImported) {
      let isModuleImported = false;
      function initializeModuleHandler(createMatcher) {
        if (isModuleImported) {
          handlePatternRegexAndVersion(
            checkIfModuleImported,
            createMatcher ?? new ERR_MULTIPLE_CALLBACK(),
          );
          return;
        }
        isModuleImported = true;
        let _________readableState = checkIfModuleImported._readableState;
        let ___________writableState = checkIfModuleImported._writableState;
        let combinedReadableWritableState =
          ___________writableState || _________readableState;
        if (_________readableState) {
          _________readableState.constructed = true;
        }
        if (___________writableState) {
          ___________writableState.constructed = true;
        }
        if (combinedReadableWritableState.destroyed) {
          checkIfModuleImported.emit(getSymbolForDestruction, createMatcher);
        } else if (createMatcher) {
          handlePatternRegexAndVersion(
            checkIfModuleImported,
            createMatcher,
            true,
          );
        } else {
          _isSemVerRangeValid.nextTick(
            emitConstructionSymbol,
            checkIfModuleImported,
          );
        }
      }
      try {
        checkIfModuleImported._construct(initializeModuleHandler);
      } catch (_________________error) {
        initializeModuleHandler(_________________error);
      }
    }
    function emitConstructionSymbol(findMatchingIndexInComparatorTrimParser) {
      findMatchingIndexInComparatorTrimParser.emit(getSymbolForConstruction);
    }
    function isProcessComparatorTrimmable(processComparatorTrimParser) {
      return (
        processComparatorTrimParser &&
        processComparatorTrimParser.setHeader &&
        typeof processComparatorTrimParser.abort == "function"
      );
    }
    function closeMatchingFilters(findMatchingFilters) {
      findMatchingFilters.emit("close");
    }
    function emitErrorAndValidateSemVer(
      parseAndMatchProperties,
      createMatcherBasedOnConditions,
    ) {
      parseAndMatchProperties.emit("error", createMatcherBasedOnConditions);
      _isSemVerRangeValid.nextTick(
        closeMatchingFilters,
        parseAndMatchProperties,
      );
    }
    function handleMatchCreation(createMatchHandler, createMatcherUsingIndex) {
      if (
        !!createMatchHandler &&
        !_isCharacterEncodingValid(createMatchHandler)
      ) {
        if (
          !createMatcherUsingIndex &&
          !isCharacterEncodingCompleted(createMatchHandler)
        ) {
          createMatcherUsingIndex = new ___AbortError();
        }
        if (isServerRequestValid(createMatchHandler)) {
          createMatchHandler.socket = null;
          createMatchHandler.destroy(createMatcherUsingIndex);
        } else if (isProcessComparatorTrimmable(createMatchHandler)) {
          createMatchHandler.abort();
        } else if (isProcessComparatorTrimmable(createMatchHandler.req)) {
          createMatchHandler.req.abort();
        } else if (typeof createMatchHandler.destroy == "function") {
          createMatchHandler.destroy(createMatcherUsingIndex);
        } else if (typeof createMatchHandler.close == "function") {
          createMatchHandler.close();
        } else if (createMatcherUsingIndex) {
          _isSemVerRangeValid.nextTick(
            emitErrorAndValidateSemVer,
            createMatchHandler,
            createMatcherUsingIndex,
          );
        } else {
          _isSemVerRangeValid.nextTick(
            closeMatchingFilters,
            createMatchHandler,
          );
        }
        if (!createMatchHandler.destroyed) {
          createMatchHandler[isCharacterEncodingDestroyed] = true;
        }
      }
    }
    handleSemanticVersioningError.exports = {
      construct: _initializeStreamStates,
      destroyer: handleMatchCreation,
      destroy: handleVersionStatesAndDestruction,
      undestroy: initializeStreamStates,
      errorOrDestroy: handlePatternRegexAndVersion,
    };
  },
);
var getMatchingIndex = conditionalModuleLoader(
  (compareAndReturn, compareAndReturnWithValidation) => {
    var reflectObject = typeof Reflect == "object" ? Reflect : null;
    var applyFunction =
      reflectObject && typeof reflectObject.apply == "function"
        ? reflectObject.apply
        : function (
            compareIdentifierHelper,
            compareVersionIdentifiers,
            getComparisonResult,
          ) {
            return Function.prototype.apply.call(
              compareIdentifierHelper,
              compareVersionIdentifiers,
              getComparisonResult,
            );
          };
    var getAllPropertyKeys;
    if (reflectObject && typeof reflectObject.ownKeys == "function") {
      getAllPropertyKeys = reflectObject.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      getAllPropertyKeys = function (compareWithCondition) {
        return Object.getOwnPropertyNames(compareWithCondition).concat(
          Object.getOwnPropertySymbols(compareWithCondition),
        );
      };
    } else {
      getAllPropertyKeys = function (isCharacterEncodingValid) {
        return Object.getOwnPropertyNames(isCharacterEncodingValid);
      };
    }
    function warnCharacterEncoding(validateCharacterEncoding) {
      if (console && console.warn) {
        console.warn(validateCharacterEncoding);
      }
    }
    var _getAllPropertyKeys =
      Number.isNaN ||
      function (_validateCharacterEncoding) {
        return _validateCharacterEncoding !== _validateCharacterEncoding;
      };
    function initializeComponent() {
      initializeComponent.init.call(this);
    }
    compareAndReturnWithValidation.exports = initializeComponent;
    compareAndReturnWithValidation.exports.once = _handleVersionComparisonEvent;
    initializeComponent.EventEmitter = initializeComponent;
    initializeComponent.prototype._events = undefined;
    initializeComponent.prototype._eventsCount = 0;
    initializeComponent.prototype._maxListeners = undefined;
    var getPropertyKeysIncludingSymbols = 10;
    function validateListenerFunction(parseVersionString) {
      if (typeof parseVersionString != "function") {
        throw new TypeError(
          'The "listener" argument must be of type Function. Received type ' +
            typeof parseVersionString,
        );
      }
    }
    Object.defineProperty(initializeComponent, "defaultMaxListeners", {
      enumerable: true,
      get() {
        return getPropertyKeysIncludingSymbols;
      },
      set(defaultMaxListeners) {
        if (
          typeof defaultMaxListeners != "number" ||
          defaultMaxListeners < 0 ||
          _getAllPropertyKeys(defaultMaxListeners)
        ) {
          throw new RangeError(
            'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
              defaultMaxListeners +
              ".",
          );
        }
        getPropertyKeysIncludingSymbols = defaultMaxListeners;
      },
    });
    initializeComponent.init = function () {
      if (
        this._events === undefined ||
        this._events === Object.getPrototypeOf(this)._events
      ) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || undefined;
    };
    initializeComponent.prototype.setMaxListeners = function (
      versionProcessingPromise,
    ) {
      if (
        typeof versionProcessingPromise != "number" ||
        versionProcessingPromise < 0 ||
        _getAllPropertyKeys(versionProcessingPromise)
      ) {
        throw new RangeError(
          'The value of "n" is out of range. It must be a non-negative number. Received ' +
            versionProcessingPromise +
            ".",
        );
      }
      this._maxListeners = versionProcessingPromise;
      return this;
    };
    function getMaxListeners(createVersionPromise) {
      if (createVersionPromise._maxListeners === undefined) {
        return initializeComponent.defaultMaxListeners;
      } else {
        return createVersionPromise._maxListeners;
      }
    }
    initializeComponent.prototype.getMaxListeners = function () {
      return getMaxListeners(this);
    };
    initializeComponent.prototype.emit = function (
      validateVersionComponentsFunction,
    ) {
      var versionArguments = [];
      for (
        var currentEventHandlerIndex = 1;
        currentEventHandlerIndex < arguments.length;
        currentEventHandlerIndex++
      ) {
        versionArguments.push(arguments[currentEventHandlerIndex]);
      }
      var isValidationError = validateVersionComponentsFunction === "error";
      var _eventHandlers = this._events;
      if (_eventHandlers !== undefined) {
        isValidationError =
          isValidationError && _eventHandlers.error === undefined;
      } else if (!isValidationError) {
        return false;
      }
      if (isValidationError) {
        var initialError;
        if (versionArguments.length > 0) {
          initialError = versionArguments[0];
        }
        if (initialError instanceof Error) {
          throw initialError;
        }
        var unhandledError = new Error(
          "Unhandled error." +
            (initialError ? " (" + initialError.message + ")" : ""),
        );
        unhandledError.context = initialError;
        throw unhandledError;
      }
      var eventHandlerFunction =
        _eventHandlers[validateVersionComponentsFunction];
      if (eventHandlerFunction === undefined) {
        return false;
      }
      if (typeof eventHandlerFunction == "function") {
        applyFunction(eventHandlerFunction, this, versionArguments);
      } else {
        for (
          var eventHandlerFunctionLength = eventHandlerFunction.length,
            processedPaxHeaderArray = processPaxHeaderArray(
              eventHandlerFunction,
              eventHandlerFunctionLength,
            ),
            currentEventHandlerIndex = 0;
          currentEventHandlerIndex < eventHandlerFunctionLength;
          ++currentEventHandlerIndex
        ) {
          applyFunction(
            processedPaxHeaderArray[currentEventHandlerIndex],
            this,
            versionArguments,
          );
        }
      }
      return true;
    };
    function _initializeVersionComparisonHandler(
      handleVersionComparisonWorker,
      versionComparisonWorker,
      handleVersionComparison,
      initializeVersionComparisonWorker,
    ) {
      var _versionComparisonHandler;
      var _eventListeners;
      var __versionComparisonHandler;
      validateListenerFunction(handleVersionComparison);
      _eventListeners = handleVersionComparisonWorker._events;
      if (_eventListeners === undefined) {
        _eventListeners = handleVersionComparisonWorker._events =
          Object.create(null);
        handleVersionComparisonWorker._eventsCount = 0;
      } else {
        if (_eventListeners.newListener !== undefined) {
          handleVersionComparisonWorker.emit(
            "newListener",
            versionComparisonWorker,
            handleVersionComparison.listener
              ? handleVersionComparison.listener
              : handleVersionComparison,
          );
          _eventListeners = handleVersionComparisonWorker._events;
        }
        __versionComparisonHandler = _eventListeners[versionComparisonWorker];
      }
      if (__versionComparisonHandler === undefined) {
        __versionComparisonHandler = _eventListeners[versionComparisonWorker] =
          handleVersionComparison;
        ++handleVersionComparisonWorker._eventsCount;
      } else {
        if (typeof __versionComparisonHandler == "function") {
          __versionComparisonHandler = _eventListeners[
            versionComparisonWorker
          ] = initializeVersionComparisonWorker
            ? [handleVersionComparison, __versionComparisonHandler]
            : [__versionComparisonHandler, handleVersionComparison];
        } else if (initializeVersionComparisonWorker) {
          __versionComparisonHandler.unshift(handleVersionComparison);
        } else {
          __versionComparisonHandler.push(handleVersionComparison);
        }
        _versionComparisonHandler = getMaxListeners(
          handleVersionComparisonWorker,
        );
        if (
          _versionComparisonHandler > 0 &&
          __versionComparisonHandler.length > _versionComparisonHandler &&
          !__versionComparisonHandler.warned
        ) {
          __versionComparisonHandler.warned = true;
          var maxListenersExceededWarning = new Error(
            "Possible EventEmitter memory leak detected. " +
              __versionComparisonHandler.length +
              " " +
              String(versionComparisonWorker) +
              " listeners added. Use emitter.setMaxListeners() to increase limit",
          );
          maxListenersExceededWarning.name = "MaxListenersExceededWarning";
          maxListenersExceededWarning.emitter = handleVersionComparisonWorker;
          maxListenersExceededWarning.type = versionComparisonWorker;
          maxListenersExceededWarning.count = __versionComparisonHandler.length;
          warnCharacterEncoding(maxListenersExceededWarning);
        }
      }
      return handleVersionComparisonWorker;
    }
    initializeComponent.prototype.addListener = function (
      _comparePrereleaseVersions,
      compareBlobVersions,
    ) {
      return _initializeVersionComparisonHandler(
        this,
        _comparePrereleaseVersions,
        compareBlobVersions,
        false,
      );
    };
    initializeComponent.prototype.on =
      initializeComponent.prototype.addListener;
    initializeComponent.prototype.prependListener = function (
      createBlobURL,
      BlobHandler,
    ) {
      return _initializeVersionComparisonHandler(
        this,
        createBlobURL,
        BlobHandler,
        true,
      );
    };
    function triggerListenerOnce() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) {
          return this.listener.call(this.target);
        } else {
          return this.listener.apply(this.target, arguments);
        }
      }
    }
    function createAndTriggerBlobURLListener(
      _createBlobURL,
      createObjectURLFromBlob,
      readBlobData,
    ) {
      var blobURLListener = {
        fired: false,
        wrapFn: undefined,
        target: _createBlobURL,
        type: createObjectURLFromBlob,
        listener: readBlobData,
      };
      var triggerBlobURLListener = triggerListenerOnce.bind(blobURLListener);
      triggerBlobURLListener.listener = readBlobData;
      blobURLListener.wrapFn = triggerBlobURLListener;
      return triggerBlobURLListener;
    }
    initializeComponent.prototype.once = function (
      createBlobAndDownload,
      decodeUTF8,
    ) {
      validateListenerFunction(decodeUTF8);
      this.on(
        createBlobAndDownload,
        createAndTriggerBlobURLListener(
          this,
          createBlobAndDownload,
          decodeUTF8,
        ),
      );
      return this;
    };
    initializeComponent.prototype.prependOnceListener = function (
      __createBlobURL,
      processFilePaxHeader,
    ) {
      validateListenerFunction(processFilePaxHeader);
      this.prependListener(
        __createBlobURL,
        createAndTriggerBlobURLListener(
          this,
          __createBlobURL,
          processFilePaxHeader,
        ),
      );
      return this;
    };
    initializeComponent.prototype.removeListener = function (
      untarFileProcess,
      decodeUTF8String,
    ) {
      var __eventListeners;
      var eventListenersMap;
      var eventListenerIndex;
      var _eventListenerIndex;
      var currentListener;
      validateListenerFunction(decodeUTF8String);
      eventListenersMap = this._events;
      if (eventListenersMap === undefined) {
        return this;
      }
      __eventListeners = eventListenersMap[untarFileProcess];
      if (__eventListeners === undefined) {
        return this;
      }
      if (
        __eventListeners === decodeUTF8String ||
        __eventListeners.listener === decodeUTF8String
      ) {
        if (--this._eventsCount === 0) {
          this._events = Object.create(null);
        } else {
          delete eventListenersMap[untarFileProcess];
          if (eventListenersMap.removeListener) {
            this.emit(
              "removeListener",
              untarFileProcess,
              __eventListeners.listener || decodeUTF8String,
            );
          }
        }
      } else if (typeof __eventListeners != "function") {
        eventListenerIndex = -1;
        _eventListenerIndex = __eventListeners.length - 1;
        for (; _eventListenerIndex >= 0; _eventListenerIndex--) {
          if (
            __eventListeners[_eventListenerIndex] === decodeUTF8String ||
            __eventListeners[_eventListenerIndex].listener === decodeUTF8String
          ) {
            currentListener = __eventListeners[_eventListenerIndex].listener;
            eventListenerIndex = _eventListenerIndex;
            break;
          }
        }
        if (eventListenerIndex < 0) {
          return this;
        }
        if (eventListenerIndex === 0) {
          __eventListeners.shift();
        } else {
          removePrereleaseVersion(__eventListeners, eventListenerIndex);
        }
        if (__eventListeners.length === 1) {
          eventListenersMap[untarFileProcess] = __eventListeners[0];
        }
        if (eventListenersMap.removeListener !== undefined) {
          this.emit(
            "removeListener",
            untarFileProcess,
            currentListener || decodeUTF8String,
          );
        }
      }
      return this;
    };
    initializeComponent.prototype.off =
      initializeComponent.prototype.removeListener;
    initializeComponent.prototype.removeAllListeners = function (
      postLogMessage,
    ) {
      var _eventHandler;
      var ___eventListeners;
      var keyIndex;
      ___eventListeners = this._events;
      if (___eventListeners === undefined) {
        return this;
      }
      if (___eventListeners.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (___eventListeners[postLogMessage] !== undefined) {
          if (--this._eventsCount === 0) {
            this._events = Object.create(null);
          } else {
            delete ___eventListeners[postLogMessage];
          }
        }
        return this;
      }
      if (arguments.length === 0) {
        var eventListenerKeys = Object.keys(___eventListeners);
        var eventListenerKey;
        for (keyIndex = 0; keyIndex < eventListenerKeys.length; ++keyIndex) {
          eventListenerKey = eventListenerKeys[keyIndex];
          if (eventListenerKey !== "removeListener") {
            this.removeAllListeners(eventListenerKey);
          }
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      _eventHandler = ___eventListeners[postLogMessage];
      if (typeof _eventHandler == "function") {
        this.removeListener(postLogMessage, _eventHandler);
      } else if (_eventHandler !== undefined) {
        for (keyIndex = _eventHandler.length - 1; keyIndex >= 0; keyIndex--) {
          this.removeListener(postLogMessage, _eventHandler[keyIndex]);
        }
      }
      return this;
    };
    function getTarFileListeners(readTarFile, readNextFileSize, readNextFile) {
      var ____eventListeners = readTarFile._events;
      if (____eventListeners === undefined) {
        return [];
      }
      var __eventListener = ____eventListeners[readNextFileSize];
      if (__eventListener === undefined) {
        return [];
      } else if (typeof __eventListener == "function") {
        if (readNextFile) {
          return [__eventListener.listener || __eventListener];
        } else {
          return [__eventListener];
        }
      } else if (readNextFile) {
        return extractListenersFromPrerelease(__eventListener);
      } else {
        return processPaxHeaderArray(__eventListener, __eventListener.length);
      }
    }
    initializeComponent.prototype.listeners = function (readNextTarFile) {
      return getTarFileListeners(this, readNextTarFile, true);
    };
    initializeComponent.prototype.rawListeners = function (_readNextTarFile) {
      return getTarFileListeners(this, _readNextTarFile, false);
    };
    initializeComponent.listenerCount = function (
      __readNextTarFile,
      ___readNextTarFile,
    ) {
      if (typeof __readNextTarFile.listenerCount == "function") {
        return __readNextTarFile.listenerCount(___readNextTarFile);
      } else {
        return getEventHandlerLength.call(
          __readNextTarFile,
          ___readNextTarFile,
        );
      }
    };
    initializeComponent.prototype.listenerCount = getEventHandlerLength;
    function getEventHandlerLength(parseTarEntry) {
      var __eventHandlers = this._events;
      if (__eventHandlers !== undefined) {
        var parseTarEntryHandler = __eventHandlers[parseTarEntry];
        if (typeof parseTarEntryHandler == "function") {
          return 1;
        }
        if (parseTarEntryHandler !== undefined) {
          return parseTarEntryHandler.length;
        }
      }
      return 0;
    }
    initializeComponent.prototype.eventNames = function () {
      if (this._eventsCount > 0) {
        return getAllPropertyKeys(this._events);
      } else {
        return [];
      }
    };
    function processPaxHeaderArray(parseAndProcessPaxHeader, parsePaxHeader) {
      var processedPassengerHeaders = new Array(parsePaxHeader);
      for (
        var ______________index = 0;
        ______________index < parsePaxHeader;
        ++______________index
      ) {
        processedPassengerHeaders[______________index] =
          parseAndProcessPaxHeader[______________index];
      }
      return processedPassengerHeaders;
    }
    function removePrereleaseVersion(
      _compareVersionWithPrerelease,
      __compareVersionWithPrerelease,
    ) {
      for (
        ;
        __compareVersionWithPrerelease + 1 <
        _compareVersionWithPrerelease.length;
        __compareVersionWithPrerelease++
      ) {
        _compareVersionWithPrerelease[__compareVersionWithPrerelease] =
          _compareVersionWithPrerelease[__compareVersionWithPrerelease + 1];
      }
      _compareVersionWithPrerelease.pop();
    }
    function extractListenersFromPrerelease(___compareVersionWithPrerelease) {
      for (
        var listenersArray = new Array(___compareVersionWithPrerelease.length),
          _________index = 0;
        _________index < listenersArray.length;
        ++_________index
      ) {
        listenersArray[_________index] =
          ___compareVersionWithPrerelease[_________index].listener ||
          ___compareVersionWithPrerelease[_________index];
      }
      return listenersArray;
    }
    function _handleVersionComparisonEvent(
      ____compareVersionWithPrerelease,
      _____compareVersionWithPrerelease,
    ) {
      return new Promise(function (
        ______compareVersionWithPrerelease,
        compareVersionsWithPrerelease,
      ) {
        function _removeErrorListenerAndCompareVersions(
          _______compareVersionWithPrerelease,
        ) {
          ____compareVersionWithPrerelease.removeListener(
            _____compareVersionWithPrerelease,
            removeErrorListenerAndCompareVersions,
          );
          compareVersionsWithPrerelease(_______compareVersionWithPrerelease);
        }
        function removeErrorListenerAndCompareVersions() {
          if (
            typeof ____compareVersionWithPrerelease.removeListener == "function"
          ) {
            ____compareVersionWithPrerelease.removeListener(
              "error",
              _removeErrorListenerAndCompareVersions,
            );
          }
          ______compareVersionWithPrerelease([].slice.call(arguments));
        }
        handleConfigEvent(
          ____compareVersionWithPrerelease,
          _____compareVersionWithPrerelease,
          removeErrorListenerAndCompareVersions,
          {
            once: true,
          },
        );
        if (_____compareVersionWithPrerelease !== "error") {
          handleGenerateFormattedOutputEvent(
            ____compareVersionWithPrerelease,
            _removeErrorListenerAndCompareVersions,
            {
              once: true,
            },
          );
        }
      });
    }
    function handleGenerateFormattedOutputEvent(
      generateFormattedOutput,
      _generateFormattedOutput,
      processControlStructure,
    ) {
      if (typeof generateFormattedOutput.on == "function") {
        handleConfigEvent(
          generateFormattedOutput,
          "error",
          _generateFormattedOutput,
          processControlStructure,
        );
      }
    }
    function handleConfigEvent(
      configSettings,
      configOptions,
      _configOptions,
      __configOptions,
    ) {
      if (typeof configSettings.on == "function") {
        if (__configOptions.once) {
          configSettings.once(configOptions, _configOptions);
        } else {
          configSettings.on(configOptions, _configOptions);
        }
      } else if (typeof configSettings.addEventListener == "function") {
        configSettings.addEventListener(
          configOptions,
          function processSectionsAndObjects(aggregateDataBasedOnSections) {
            if (__configOptions.once) {
              configSettings.removeEventListener(
                configOptions,
                processSectionsAndObjects,
              );
            }
            _configOptions(aggregateDataBasedOnSections);
          },
        );
      } else {
        throw new TypeError(
          'The "emitter" argument must be of type EventEmitter. Received type ' +
            typeof configSettings,
        );
      }
    }
  },
);
var processSectionedValues = conditionalModuleLoader(
  (createStreamPipeline, createStreamPipelineProcess) => {
    var { ArrayIsArray: __isArray, ObjectSetPrototypeOf: setPrototype } =
      executeComparisonOperation();
    var { EventEmitter: CustomEventEmitter } = getMatchingIndex();
    function initializeProcessSection(processSectionData) {
      CustomEventEmitter.call(this, processSectionData);
    }
    setPrototype(
      initializeProcessSection.prototype,
      CustomEventEmitter.prototype,
    );
    setPrototype(initializeProcessSection, CustomEventEmitter);
    initializeProcessSection.prototype.pipe = function (
      processConfigData,
      parseConfiguration,
    ) {
      let __context = this;
      function handleWritableProcess(processInputString) {
        if (
          processConfigData.writable &&
          processConfigData.write(processInputString) === false &&
          __context.pause
        ) {
          __context.pause();
        }
      }
      __context.on("data", handleWritableProcess);
      function resumeReadableContext() {
        if (__context.readable && __context.resume) {
          __context.resume();
        }
      }
      processConfigData.on("drain", resumeReadableContext);
      if (
        !processConfigData._isStdio &&
        (!parseConfiguration || parseConfiguration.end !== false)
      ) {
        __context.on("end", endProcessIfNotComplete);
        __context.on("close", terminateProcess);
      }
      let isProcessEnded = false;
      function endProcessIfNotComplete() {
        if (!isProcessEnded) {
          isProcessEnded = true;
          processConfigData.end();
        }
      }
      function terminateProcess() {
        if (!isProcessEnded) {
          isProcessEnded = true;
          if (typeof processConfigData.destroy == "function") {
            processConfigData.destroy();
          }
        }
      }
      function handleErrorEvent(updateProtoType) {
        removeAllListeners();
        if (CustomEventEmitter.listenerCount(this, "error") === 0) {
          this.emit("error", updateProtoType);
        }
      }
      handleEventRegistration(__context, "error", handleErrorEvent);
      handleEventRegistration(processConfigData, "error", handleErrorEvent);
      function removeAllListeners() {
        __context.removeListener("data", handleWritableProcess);
        processConfigData.removeListener("drain", resumeReadableContext);
        __context.removeListener("end", endProcessIfNotComplete);
        __context.removeListener("close", terminateProcess);
        __context.removeListener("error", handleErrorEvent);
        processConfigData.removeListener("error", handleErrorEvent);
        __context.removeListener("end", removeAllListeners);
        __context.removeListener("close", removeAllListeners);
        processConfigData.removeListener("close", removeAllListeners);
      }
      __context.on("end", removeAllListeners);
      __context.on("close", removeAllListeners);
      processConfigData.on("close", removeAllListeners);
      processConfigData.emit("pipe", __context);
      return processConfigData;
    };
    function handleEventRegistration(
      processAndCleanData,
      ______processData,
      processItem,
    ) {
      if (typeof processAndCleanData.prependListener == "function") {
        return processAndCleanData.prependListener(
          ______processData,
          processItem,
        );
      }
      if (
        !processAndCleanData._events ||
        !processAndCleanData._events[______processData]
      ) {
        processAndCleanData.on(______processData, processItem);
      } else if (__isArray(processAndCleanData._events[______processData])) {
        processAndCleanData._events[______processData].unshift(processItem);
      } else {
        processAndCleanData._events[______processData] = [
          processItem,
          processAndCleanData._events[______processData],
        ];
      }
    }
    createStreamPipelineProcess.exports = {
      Stream: initializeProcessSection,
      prependListener: handleEventRegistration,
    };
  },
);
var nestedObjectCreation = conditionalModuleLoader(
  (addAbortSignalWithValidation, ___abortSignalHandler) => {
    var { AbortError: ______AbortError, codes: __errorCodes } =
      getNodeValueAfterTraversal();
    var getSemverPrereleaseValidation = validateSemverPrerelease();
    var { ERR_INVALID_ARG_TYPE: InvalidArgumentTypeError } = __errorCodes;
    var _______validateAbortSignal = (
      ___________abortSignal,
      abortSignalValidation,
    ) => {
      if (
        typeof ___________abortSignal != "object" ||
        !("aborted" in ___________abortSignal)
      ) {
        throw new InvalidArgumentTypeError(
          abortSignalValidation,
          "AbortSignal",
          ___________abortSignal,
        );
      }
    };
    function isPipeableString(cleanString) {
      return !!cleanString && typeof cleanString.pipe == "function";
    }
    ___abortSignalHandler.exports.addAbortSignal = function (
      isWrappedInQuotes,
      isStringWithValidQuotes,
    ) {
      _______validateAbortSignal(isWrappedInQuotes, "signal");
      if (!isPipeableString(isStringWithValidQuotes)) {
        throw new InvalidArgumentTypeError(
          "stream",
          "stream.Stream",
          isStringWithValidQuotes,
        );
      }
      return ___abortSignalHandler.exports.addAbortSignalNoValidate(
        isWrappedInQuotes,
        isStringWithValidQuotes,
      );
    };
    ___abortSignalHandler.exports.addAbortSignalNoValidate = function (
      escapeSpecialCharacters,
      parseAndSanitizeInput,
    ) {
      if (
        typeof escapeSpecialCharacters != "object" ||
        !("aborted" in escapeSpecialCharacters)
      ) {
        return parseAndSanitizeInput;
      }
      let __handleAbortEvent = () => {
        parseAndSanitizeInput.destroy(
          new ______AbortError(undefined, {
            cause: escapeSpecialCharacters.reason,
          }),
        );
      };
      if (escapeSpecialCharacters.aborted) {
        __handleAbortEvent();
      } else {
        escapeSpecialCharacters.addEventListener("abort", __handleAbortEvent);
        getSemverPrereleaseValidation(parseAndSanitizeInput, () =>
          escapeSpecialCharacters.removeEventListener(
            "abort",
            __handleAbortEvent,
          ),
        );
      }
      return parseAndSanitizeInput;
    };
  },
);
var getParsedString = conditionalModuleLoader(
  (LinkedList, LinkedListModule) => {
    var {
      StringPrototypeSlice: stringPrototypeSlice,
      SymbolIterator: SymbolIterator,
      TypedArrayPrototypeSet: typedArrayPrototypeSet,
      Uint8Array: Uint8ArrayType,
    } = executeComparisonOperation();
    _validateAndRetrieveIntrinsicPropertyValue();
    var { Buffer: BufferModule } = createESModule(
      _retrieveAndValidateIntrinsicProperty,
    );
    var { inspect: __inspectBuffer } = ___validateAndProcessArrayBuffer();
    LinkedListModule.exports = class {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(pushDataElement) {
        let newNode = {
          data: pushDataElement,
          next: null,
        };
        if (this.length > 0) {
          this.tail.next = newNode;
        } else {
          this.head = newNode;
        }
        this.tail = newNode;
        ++this.length;
      }
      unshift(addNodeToFront) {
        let _newNode = {
          data: addNodeToFront,
          next: this.head,
        };
        if (this.length === 0) {
          this.tail = _newNode;
        }
        this.head = _newNode;
        ++this.length;
      }
      shift() {
        if (this.length === 0) {
          return;
        }
        let shiftedElement = this.head.data;
        if (this.length === 1) {
          this.head = this.tail = null;
        } else {
          this.head = this.head.next;
        }
        --this.length;
        return shiftedElement;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(joinWithDelimiter) {
        if (this.length === 0) {
          return "";
        }
        let ____currentNode = this.head;
        let resultString = "" + ____currentNode.data;
        while ((____currentNode = ____currentNode.next) !== null) {
          resultString += joinWithDelimiter + ____currentNode.data;
        }
        return resultString;
      }
      concat(getBufferLength) {
        if (this.length === 0) {
          return BufferModule.alloc(0);
        }
        let ___allocateBuffer = BufferModule.allocUnsafe(getBufferLength >>> 0);
        let __currentNode = this.head;
        let currentBufferPosition = 0;
        while (__currentNode) {
          typedArrayPrototypeSet(
            ___allocateBuffer,
            __currentNode.data,
            currentBufferPosition,
          );
          currentBufferPosition += __currentNode.data.length;
          __currentNode = __currentNode.next;
        }
        return ___allocateBuffer;
      }
      consume(consumeFromHead, isBufferMode) {
        let headData = this.head.data;
        if (consumeFromHead < headData.length) {
          let consumedHeadData = headData.slice(0, consumeFromHead);
          this.head.data = headData.slice(consumeFromHead);
          return consumedHeadData;
        }
        if (consumeFromHead === headData.length) {
          return this.shift();
        } else if (isBufferMode) {
          return this._getString(consumeFromHead);
        } else {
          return this._getBuffer(consumeFromHead);
        }
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (
          let _______________currentNode = this.head;
          _______________currentNode;
          _______________currentNode = _______________currentNode.next
        ) {
          yield _______________currentNode.data;
        }
      }
      _getString(getSubstringAndUpdateList) {
        let currentString = "";
        let currentNode = this.head;
        let processedItemsCount = 0;
        do {
          let currentNodeData = currentNode.data;
          if (getSubstringAndUpdateList > currentNodeData.length) {
            currentString += currentNodeData;
            getSubstringAndUpdateList -= currentNodeData.length;
          } else {
            if (getSubstringAndUpdateList === currentNodeData.length) {
              currentString += currentNodeData;
              ++processedItemsCount;
              if (currentNode.next) {
                this.head = currentNode.next;
              } else {
                this.head = this.tail = null;
              }
            } else {
              currentString += stringPrototypeSlice(
                currentNodeData,
                0,
                getSubstringAndUpdateList,
              );
              this.head = currentNode;
              currentNode.data = stringPrototypeSlice(
                currentNodeData,
                getSubstringAndUpdateList,
              );
            }
            break;
          }
          ++processedItemsCount;
        } while ((currentNode = currentNode.next) !== null);
        this.length -= processedItemsCount;
        return currentString;
      }
      _getBuffer(allocateBufferWithSize) {
        let bufferAllocation = BufferModule.allocUnsafe(allocateBufferWithSize);
        let initialBufferSize = allocateBufferWithSize;
        let currentBufferNode = this.head;
        let completedBufferAllocations = 0;
        do {
          let currentBufferData = currentBufferNode.data;
          if (allocateBufferWithSize > currentBufferData.length) {
            typedArrayPrototypeSet(
              bufferAllocation,
              currentBufferData,
              initialBufferSize - allocateBufferWithSize,
            );
            allocateBufferWithSize -= currentBufferData.length;
          } else {
            if (allocateBufferWithSize === currentBufferData.length) {
              typedArrayPrototypeSet(
                bufferAllocation,
                currentBufferData,
                initialBufferSize - allocateBufferWithSize,
              );
              ++completedBufferAllocations;
              if (currentBufferNode.next) {
                this.head = currentBufferNode.next;
              } else {
                this.head = this.tail = null;
              }
            } else {
              typedArrayPrototypeSet(
                bufferAllocation,
                new Uint8ArrayType(
                  currentBufferData.buffer,
                  currentBufferData.byteOffset,
                  allocateBufferWithSize,
                ),
                initialBufferSize - allocateBufferWithSize,
              );
              this.head = currentBufferNode;
              currentBufferNode.data = currentBufferData.slice(
                allocateBufferWithSize,
              );
            }
            break;
          }
          ++completedBufferAllocations;
        } while ((currentBufferNode = currentBufferNode.next) !== null);
        this.length -= completedBufferAllocations;
        return bufferAllocation;
      }
      [Symbol.for("nodejs.util.inspect.custom")](
        inspectBufferCustom,
        inspectBufferOptions,
      ) {
        return __inspectBuffer(this, {
          ...inspectBufferOptions,
          depth: 0,
          customInspect: false,
        });
      }
    };
  },
);
var errorStackTrace = conditionalModuleLoader(
  (getHighWaterMarkOrDefaultValue, getHighWaterMarkOrDefault) => {
    var { MathFloor: _mathFloor, NumberIsInteger: isIntegerValue } =
      executeComparisonOperation();
    var { ERR_INVALID_ARG_VALUE: InvalidArgumentValueError } =
      getNodeValueAfterTraversal().codes;
    function _getHighWaterMark(
      handleFormattedString,
      formatString,
      callbackFunction,
    ) {
      return (
        handleFormattedString.highWaterMark ??
        (formatString ? handleFormattedString[callbackFunction] : null)
      );
    }
    function getBufferSize(onceWrapper) {
      if (onceWrapper) {
        return 16;
      } else {
        return 16384;
      }
    }
    function processCallbackResolution(
      handleConditionalInvocation,
      _callbackFunction,
      handleCallback,
      handlePromiseResolution,
    ) {
      let callbackResult = _getHighWaterMark(
        _callbackFunction,
        handlePromiseResolution,
        handleCallback,
      );
      if (callbackResult != null) {
        if (!isIntegerValue(callbackResult) || callbackResult < 0) {
          let optionsValue = handlePromiseResolution
            ? "options." + handleCallback
            : "options.highWaterMark";
          throw new InvalidArgumentValueError(optionsValue, callbackResult);
        }
        return _mathFloor(callbackResult);
      }
      return getBufferSize(handleConditionalInvocation.objectMode);
    }
    getHighWaterMarkOrDefault.exports = {
      getHighWaterMark: processCallbackResolution,
      getDefaultHighWaterMark: getBufferSize,
    };
  },
);
var formatStringWithPlaceholders = conditionalModuleLoader(
  (bufferModule, bufferModuleExports) => {
    _validateAndRetrieveIntrinsicPropertyValue();
    var esModuleWrapper = createESModule(_retrieveAndValidateIntrinsicProperty);
    var _BufferModule = esModuleWrapper.Buffer;
    function populateFormatStringWithParams(
      _formatString,
      formatStringWithParams,
    ) {
      for (var formatKey in _formatString) {
        formatStringWithParams[formatKey] = _formatString[formatKey];
      }
    }
    if (
      _BufferModule.from &&
      _BufferModule.alloc &&
      _BufferModule.allocUnsafe &&
      _BufferModule.allocUnsafeSlow
    ) {
      bufferModuleExports.exports = esModuleWrapper;
    } else {
      populateFormatStringWithParams(esModuleWrapper, bufferModule);
      bufferModule.Buffer = formatAndInspectVariable;
    }
    function formatAndInspectVariable(
      formatInspectValue,
      inspectVariable,
      inputValue,
    ) {
      return _BufferModule(formatInspectValue, inspectVariable, inputValue);
    }
    formatAndInspectVariable.prototype = Object.create(_BufferModule.prototype);
    populateFormatStringWithParams(_BufferModule, formatAndInspectVariable);
    formatAndInspectVariable.from = function (
      inspectValue,
      _inspectValue,
      __inspectValue,
    ) {
      if (typeof inspectValue == "number") {
        throw new TypeError("Argument must not be a number");
      }
      return _BufferModule(inspectValue, _inspectValue, __inspectValue);
    };
    formatAndInspectVariable.alloc = function (
      valueFormatter,
      _inputValue,
      __inputValue,
    ) {
      if (typeof valueFormatter != "number") {
        throw new TypeError("Argument must be a number");
      }
      var __buffer = _BufferModule(valueFormatter);
      if (_inputValue !== undefined) {
        if (typeof __inputValue == "string") {
          __buffer.fill(_inputValue, __inputValue);
        } else {
          __buffer.fill(_inputValue);
        }
      } else {
        __buffer.fill(0);
      }
      return __buffer;
    };
    formatAndInspectVariable.allocUnsafe = function (checkValueType) {
      if (typeof checkValueType != "number") {
        throw new TypeError("Argument must be a number");
      }
      return _BufferModule(checkValueType);
    };
    formatAndInspectVariable.allocUnsafeSlow = function (getTypeAsString) {
      if (typeof getTypeAsString != "number") {
        throw new TypeError("Argument must be a number");
      }
      return esModuleWrapper.SlowBuffer(getTypeAsString);
    };
  },
);
var isNodeError = conditionalModuleLoader((validateEncodingAndFormat) => {
  var bufferUtil = formatStringWithPlaceholders().Buffer;
  var _isValidEncoding =
    bufferUtil.isEncoding ||
    function (isArrayBufferView) {
      isArrayBufferView = "" + isArrayBufferView;
      switch (isArrayBufferView && isArrayBufferView.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
  function detectEncoding(abortSignal) {
    if (!abortSignal) {
      return "utf8";
    }
    var hasCheckedEncoding;
    while (true) {
      switch (abortSignal) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return abortSignal;
        default:
          if (hasCheckedEncoding) {
            return;
          }
          abortSignal = ("" + abortSignal).toLowerCase();
          hasCheckedEncoding = true;
      }
    }
  }
  function validateProcessEncoding(validateProcessData) {
    var detectedEncoding = detectEncoding(validateProcessData);
    if (
      typeof detectedEncoding != "string" &&
      (bufferUtil.isEncoding === _isValidEncoding ||
        !_isValidEncoding(validateProcessData))
    ) {
      throw new Error("Unknown encoding: " + validateProcessData);
    }
    return detectedEncoding || validateProcessData;
  }
  validateEncodingAndFormat.StringDecoder = initializeEncodingHandler;
  function initializeEncodingHandler(processAndFormatEncodedByteLengths) {
    this.encoding = validateProcessEncoding(processAndFormatEncodedByteLengths);
    var byteLength;
    switch (this.encoding) {
      case "utf16le":
        this.text = handleUTF16ErrorsAndGetDescriptions;
        this.end = appendInstanceAndWrite;
        byteLength = 4;
        break;
      case "utf8":
        this.fillLast = processInvalidArgumentAndCopy;
        byteLength = 4;
        break;
      case "base64":
        this.text = convertToBase64;
        this.end = writeAndEncodeDescription;
        byteLength = 3;
        break;
      default:
        this.write = logEncodingAsString;
        this.end = writeDescription;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = bufferUtil.allocUnsafe(byteLength);
  }
  initializeEncodingHandler.prototype.write = function (
    validateEncodedByteLengths,
  ) {
    if (validateEncodedByteLengths.length === 0) {
      return "";
    }
    var filledLastByte;
    var currentFillByteIndex;
    if (this.lastNeed) {
      filledLastByte = this.fillLast(validateEncodedByteLengths);
      if (filledLastByte === undefined) {
        return "";
      }
      currentFillByteIndex = this.lastNeed;
      this.lastNeed = 0;
    } else {
      currentFillByteIndex = 0;
    }
    if (currentFillByteIndex < validateEncodedByteLengths.length) {
      if (filledLastByte) {
        return (
          filledLastByte +
          this.text(validateEncodedByteLengths, currentFillByteIndex)
        );
      } else {
        return this.text(validateEncodedByteLengths, currentFillByteIndex);
      }
    } else {
      return filledLastByte || "";
    }
  };
  initializeEncodingHandler.prototype.end = processHandleValueTypes;
  initializeEncodingHandler.prototype.text = processAndCopyProperty;
  initializeEncodingHandler.prototype.fillLast = function (
    _calculateEncodedByteLengths,
  ) {
    if (this.lastNeed <= _calculateEncodedByteLengths.length) {
      _calculateEncodedByteLengths.copy(
        this.lastChar,
        this.lastTotal - this.lastNeed,
        0,
        this.lastNeed,
      );
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    _calculateEncodedByteLengths.copy(
      this.lastChar,
      this.lastTotal - this.lastNeed,
      0,
      _calculateEncodedByteLengths.length,
    );
    this.lastNeed -= _calculateEncodedByteLengths.length;
  };
  function calculateCategoryFromRandomValue(handleRandomValueExport) {
    if (handleRandomValueExport <= 127) {
      return 0;
    } else if (handleRandomValueExport >> 5 === 6) {
      return 2;
    } else if (handleRandomValueExport >> 4 === 14) {
      return 3;
    } else if (handleRandomValueExport >> 3 === 30) {
      return 4;
    } else if (handleRandomValueExport >> 6 === 2) {
      return -1;
    } else {
      return -2;
    }
  }
  function processRandomValueHandler(
    processRandomValue,
    handleRandomValueAndErrors,
    handleArrayErrors,
  ) {
    var lastIndex = handleRandomValueAndErrors.length - 1;
    if (lastIndex < handleArrayErrors) {
      return 0;
    }
    var calculatedRandomValue = calculateCategoryFromRandomValue(
      handleRandomValueAndErrors[lastIndex],
    );
    if (calculatedRandomValue >= 0) {
      if (calculatedRandomValue > 0) {
        processRandomValue.lastNeed = calculatedRandomValue - 1;
      }
      return calculatedRandomValue;
    } else if (
      --lastIndex < handleArrayErrors ||
      calculatedRandomValue === -2
    ) {
      return 0;
    } else {
      calculatedRandomValue = calculateCategoryFromRandomValue(
        handleRandomValueAndErrors[lastIndex],
      );
      if (calculatedRandomValue >= 0) {
        if (calculatedRandomValue > 0) {
          processRandomValue.lastNeed = calculatedRandomValue - 2;
        }
        return calculatedRandomValue;
      } else if (
        --lastIndex < handleArrayErrors ||
        calculatedRandomValue === -2
      ) {
        return 0;
      } else {
        calculatedRandomValue = calculateCategoryFromRandomValue(
          handleRandomValueAndErrors[lastIndex],
        );
        if (calculatedRandomValue >= 0) {
          if (calculatedRandomValue > 0) {
            if (calculatedRandomValue === 2) {
              calculatedRandomValue = 0;
            } else {
              processRandomValue.lastNeed = calculatedRandomValue - 3;
            }
          }
          return calculatedRandomValue;
        } else {
          return 0;
        }
      }
    }
  }
  function handleAbortOperation(
    abortOperationError,
    handleAbortError,
    createAbortError,
  ) {
    if ((handleAbortError[0] & 192) !== 128) {
      abortOperationError.lastNeed = 0;
      return "";
    }
    if (abortOperationError.lastNeed > 1 && handleAbortError.length > 1) {
      if ((handleAbortError[1] & 192) !== 128) {
        abortOperationError.lastNeed = 1;
        return "";
      }
      if (
        abortOperationError.lastNeed > 2 &&
        handleAbortError.length > 2 &&
        (handleAbortError[2] & 192) !== 128
      ) {
        abortOperationError.lastNeed = 2;
        return "";
      }
    }
  }
  function processInvalidArgumentAndCopy(assertInvalidArgumentTypeError) {
    var remainingCharactersToProcess = this.lastTotal - this.lastNeed;
    var processAndCopyCharacters = handleAbortOperation(
      this,
      assertInvalidArgumentTypeError,
      remainingCharactersToProcess,
    );
    if (processAndCopyCharacters !== undefined) {
      return processAndCopyCharacters;
    }
    if (this.lastNeed <= assertInvalidArgumentTypeError.length) {
      assertInvalidArgumentTypeError.copy(
        this.lastChar,
        remainingCharactersToProcess,
        0,
        this.lastNeed,
      );
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    assertInvalidArgumentTypeError.copy(
      this.lastChar,
      remainingCharactersToProcess,
      0,
      assertInvalidArgumentTypeError.length,
    );
    this.lastNeed -= assertInvalidArgumentTypeError.length;
  }
  function processAndCopyProperty(
    propertyOrArgument,
    validateAndFormatExpectedEntries,
  ) {
    var _processedRandomValue = processRandomValueHandler(
      this,
      propertyOrArgument,
      validateAndFormatExpectedEntries,
    );
    if (!this.lastNeed) {
      return propertyOrArgument.toString(
        "utf8",
        validateAndFormatExpectedEntries,
      );
    }
    this.lastTotal = _processedRandomValue;
    var copyOffset =
      propertyOrArgument.length - (_processedRandomValue - this.lastNeed);
    propertyOrArgument.copy(this.lastChar, 0, copyOffset);
    return propertyOrArgument.toString(
      "utf8",
      validateAndFormatExpectedEntries,
      copyOffset,
    );
  }
  function processHandleValueTypes(handleValueTypes) {
    var formattedHandleValue =
      handleValueTypes && handleValueTypes.length
        ? this.write(handleValueTypes)
        : "";
    if (this.lastNeed) {
      return formattedHandleValue + "";
    } else {
      return formattedHandleValue;
    }
  }
  function handleUTF16ErrorsAndGetDescriptions(
    handleObjectTypeErrors,
    getTypeDescriptions,
  ) {
    if ((handleObjectTypeErrors.length - getTypeDescriptions) % 2 === 0) {
      var encodedObjectTypeErrorString = handleObjectTypeErrors.toString(
        "utf16le",
        getTypeDescriptions,
      );
      if (encodedObjectTypeErrorString) {
        var lastCharacterCode = encodedObjectTypeErrorString.charCodeAt(
          encodedObjectTypeErrorString.length - 1,
        );
        if (lastCharacterCode >= 55296 && lastCharacterCode <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] =
            handleObjectTypeErrors[handleObjectTypeErrors.length - 2];
          this.lastChar[1] =
            handleObjectTypeErrors[handleObjectTypeErrors.length - 1];
          return encodedObjectTypeErrorString.slice(0, -1);
        }
      }
      return encodedObjectTypeErrorString;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] =
      handleObjectTypeErrors[handleObjectTypeErrors.length - 1];
    return handleObjectTypeErrors.toString(
      "utf16le",
      getTypeDescriptions,
      handleObjectTypeErrors.length - 1,
    );
  }
  function appendInstanceAndWrite(appendInstanceDescriptions) {
    var writtenContent =
      appendInstanceDescriptions && appendInstanceDescriptions.length
        ? this.write(appendInstanceDescriptions)
        : "";
    if (this.lastNeed) {
      var remainingCharacterCount = this.lastTotal - this.lastNeed;
      return (
        writtenContent +
        this.lastChar.toString("utf16le", 0, remainingCharacterCount)
      );
    }
    return writtenContent;
  }
  function convertToBase64(receivedValue, appendInstanceMessage) {
    var paddingNeeded = (receivedValue.length - appendInstanceMessage) % 3;
    if (paddingNeeded === 0) {
      return receivedValue.toString("base64", appendInstanceMessage);
    } else {
      this.lastNeed = 3 - paddingNeeded;
      this.lastTotal = 3;
      if (paddingNeeded === 1) {
        this.lastChar[0] = receivedValue[receivedValue.length - 1];
      } else {
        this.lastChar[0] = receivedValue[receivedValue.length - 2];
        this.lastChar[1] = receivedValue[receivedValue.length - 1];
      }
      return receivedValue.toString(
        "base64",
        appendInstanceMessage,
        receivedValue.length - paddingNeeded,
      );
    }
  }
  function writeAndEncodeDescription(receivedParameterDescription) {
    var encodedDescription =
      receivedParameterDescription && receivedParameterDescription.length
        ? this.write(receivedParameterDescription)
        : "";
    if (this.lastNeed) {
      return (
        encodedDescription +
        this.lastChar.toString("base64", 0, 3 - this.lastNeed)
      );
    } else {
      return encodedDescription;
    }
  }
  function logEncodingAsString(logInvalidArgumentType) {
    return logInvalidArgumentType.toString(this.encoding);
  }
  function writeDescription(argTypeDescription) {
    if (argTypeDescription && argTypeDescription.length) {
      return this.write(argTypeDescription);
    } else {
      return "";
    }
  }
});
var formatErrorMessage = conditionalModuleLoader(
  (createStreamFromError, createStreamFromErrorHandling) => {
    var __isSemVerRangeValid = isValidSemVerRange();
    var {
      PromisePrototypeThen: PromisePrototypeThen,
      SymbolAsyncIterator: _SymbolAsyncIterator,
      SymbolIterator: _SymbolIterator,
    } = executeComparisonOperation();
    _validateAndRetrieveIntrinsicPropertyValue();
    var { Buffer: __Buffer } = createESModule(
      _retrieveAndValidateIntrinsicProperty,
    );
    var {
      ERR_INVALID_ARG_TYPE: _ERR_INVALID_ARGUMENT_TYPE,
      ERR_STREAM_NULL_VALUES: ERR_STREAM_NULL_VALUES,
    } = getNodeValueAfterTraversal().codes;
    function createStreamFromIterable(
      handleErrorInvalidArgumentValue,
      handleInvalidReturnValue,
      errorFormatter,
    ) {
      let asyncIterator;
      if (
        typeof handleInvalidReturnValue == "string" ||
        handleInvalidReturnValue instanceof __Buffer
      ) {
        return new handleErrorInvalidArgumentValue({
          objectMode: true,
          ...errorFormatter,
          read() {
            this.push(handleInvalidReturnValue);
            this.push(null);
          },
        });
      }
      let isAsyncIterable;
      if (
        handleInvalidReturnValue &&
        handleInvalidReturnValue[_SymbolAsyncIterator]
      ) {
        isAsyncIterable = true;
        asyncIterator = handleInvalidReturnValue[_SymbolAsyncIterator]();
      } else if (
        handleInvalidReturnValue &&
        handleInvalidReturnValue[_SymbolIterator]
      ) {
        isAsyncIterable = false;
        asyncIterator = handleInvalidReturnValue[_SymbolIterator]();
      } else {
        throw new _ERR_INVALID_ARGUMENT_TYPE(
          "iterable",
          ["Iterable"],
          handleInvalidReturnValue,
        );
      }
      let streamGenerator = new handleErrorInvalidArgumentValue({
        objectMode: true,
        highWaterMark: 1,
        ...errorFormatter,
      });
      let _createStreamFromIterable = false;
      streamGenerator._read = function () {
        if (!_createStreamFromIterable) {
          _createStreamFromIterable = true;
          processAsyncIterable();
        }
      };
      streamGenerator._destroy = function (
        handleMissingArgsError,
        createErrorMessage,
      ) {
        PromisePrototypeThen(
          handleAsyncIteratorError(handleMissingArgsError),
          () =>
            __isSemVerRangeValid.nextTick(
              createErrorMessage,
              handleMissingArgsError,
            ),
          (___isSemVerRangeValid) =>
            __isSemVerRangeValid.nextTick(
              createErrorMessage,
              ___isSemVerRangeValid || handleMissingArgsError,
            ),
        );
      };
      async function handleAsyncIteratorError(generateMissingArgsMessage) {
        let isMissingArgsMessageProvided = generateMissingArgsMessage != null;
        let isAsyncIteratorThrowSupported =
          typeof asyncIterator.throw == "function";
        if (isMissingArgsMessageProvided && isAsyncIteratorThrowSupported) {
          let { value: asyncIteratorResultValue, done: asyncIteratorDone } =
            await asyncIterator.throw(generateMissingArgsMessage);
          await asyncIteratorResultValue;
          if (asyncIteratorDone) {
            return;
          }
        }
        if (typeof asyncIterator.return == "function") {
          let { value: _returnValue } = await asyncIterator.return();
          await _returnValue;
        }
      }
      async function processAsyncIterable() {
        while (true) {
          try {
            let { value: nextAsyncValue, done: isAsyncIteratorDone } =
              isAsyncIterable
                ? await asyncIterator.next()
                : asyncIterator.next();
            if (isAsyncIteratorDone) {
              streamGenerator.push(null);
            } else {
              let resolvedAsyncValue =
                nextAsyncValue && typeof nextAsyncValue.then == "function"
                  ? await nextAsyncValue
                  : nextAsyncValue;
              if (resolvedAsyncValue === null) {
                _createStreamFromIterable = false;
                throw new ERR_STREAM_NULL_VALUES();
              }
              if (streamGenerator.push(resolvedAsyncValue)) {
                continue;
              }
              _createStreamFromIterable = false;
            }
          } catch (________error) {
            streamGenerator.destroy(________error);
          }
          break;
        }
      }
      return streamGenerator;
    }
    createStreamFromErrorHandling.exports = createStreamFromIterable;
  },
);
var handleErrorMessages = conditionalModuleLoader(
  (initializeStreamHandler, _streamHandler) => {
    var isValidSemVerRangeResult = isValidSemVerRange();
    var {
      ArrayPrototypeIndexOf: arrayPrototypeIndexOf,
      NumberIsInteger: isInteger,
      NumberIsNaN: isNumberNaN,
      NumberParseInt: parseInteger,
      ObjectDefineProperties: _defineObjectProperties,
      ObjectKeys: getObjectKeys,
      ObjectSetPrototypeOf: setPrototypeOfObject,
      Promise: PromiseImplementation,
      SafeSet: SafeSetImplementation,
      SymbolAsyncIterator: SymbolAsyncIterator,
      Symbol: SymbolImplementation,
    } = executeComparisonOperation();
    _streamHandler.exports = StreamValidator;
    StreamValidator.ReadableState = initializeStreamOptions;
    var { EventEmitter: EventEmitter } = getMatchingIndex();
    var {
      Stream: StreamImplementation,
      prependListener: prependListenerToStream,
    } = processSectionedValues();
    _validateAndRetrieveIntrinsicPropertyValue();
    var { Buffer: BufferImplementation } = createESModule(
      _retrieveAndValidateIntrinsicProperty,
    );
    var { addAbortSignal: initializeStreamHandlerFunction } =
      nestedObjectCreation();
    var initializeAndValidateStreamHandler = validateSemverPrerelease();
    var initializeStreamHandler_ = ___validateAndProcessArrayBuffer().debuglog(
      "stream",
      (streamHandlerInitializer) => {
        initializeStreamHandler_ = streamHandlerInitializer;
      },
    );
    var _initializeStreamHandler = getParsedString();
    var initializeAndSetupStreamHandler = evaluateVersionOperators();
    var {
      getHighWaterMark: __initializeStreamHandler,
      getDefaultHighWaterMark: initializeStreamHandlerWithValidation,
    } = errorStackTrace();
    var {
      aggregateTwoErrors: ___initializeStreamHandler,
      codes: {
        ERR_INVALID_ARG_TYPE: initializeStreamHandlerWithContext,
        ERR_METHOD_NOT_IMPLEMENTED: ____initializeStreamHandler,
        ERR_OUT_OF_RANGE: _____initializeStreamHandler,
        ERR_STREAM_PUSH_AFTER_EOF: initializeStreamWithHandler,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT:
          initializeStreamHandlerWithImplementation,
      },
    } = getNodeValueAfterTraversal();
    var { validateObject: _initializeStreamHandlerFunction } =
      updateMaxAgeSetting();
    var __initializeStreamHandlerFunction = SymbolImplementation("kPaused");
    var { StringDecoder: ______initializeStreamHandler } = isNodeError();
    var streamInitializationHandler = formatErrorMessage();
    setPrototypeOfObject(
      StreamValidator.prototype,
      StreamImplementation.prototype,
    );
    setPrototypeOfObject(StreamValidator, StreamImplementation);
    var initializeAndHandleStream = () => {};
    var { errorOrDestroy: _______initializeStreamHandler } =
      initializeAndSetupStreamHandler;
    function initializeStreamOptions(
      validateAndReturnItemLength,
      validateAndProcessInput,
      validateAndCalculateLengths,
    ) {
      if (typeof validateAndCalculateLengths != "boolean") {
        validateAndCalculateLengths =
          validateAndProcessInput instanceof initializeEventListeners();
      }
      this.objectMode =
        !!validateAndReturnItemLength &&
        !!validateAndReturnItemLength.objectMode;
      if (validateAndCalculateLengths) {
        this.objectMode =
          this.objectMode ||
          (!!validateAndReturnItemLength &&
            !!validateAndReturnItemLength.readableObjectMode);
      }
      if (validateAndReturnItemLength) {
        this.highWaterMark = __initializeStreamHandler(
          this,
          validateAndReturnItemLength,
          "readableHighWaterMark",
          validateAndCalculateLengths,
        );
      } else {
        this.highWaterMark = initializeStreamHandlerWithValidation(false);
      }
      this.buffer = new _initializeStreamHandler();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.constructed = true;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this[__initializeStreamHandlerFunction] = null;
      this.errorEmitted = false;
      this.emitClose =
        !validateAndReturnItemLength ||
        validateAndReturnItemLength.emitClose !== false;
      this.autoDestroy =
        !validateAndReturnItemLength ||
        validateAndReturnItemLength.autoDestroy !== false;
      this.destroyed = false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this.defaultEncoding =
        (validateAndReturnItemLength &&
          validateAndReturnItemLength.defaultEncoding) ||
        "utf8";
      this.awaitDrainWriters = null;
      this.multiAwaitDrain = false;
      this.readingMore = false;
      this.dataEmitted = false;
      this.decoder = null;
      this.encoding = null;
      if (validateAndReturnItemLength && validateAndReturnItemLength.encoding) {
        this.decoder = new ______initializeStreamHandler(
          validateAndReturnItemLength.encoding,
        );
        this.encoding = validateAndReturnItemLength.encoding;
      }
    }
    function StreamValidator(validateNumberInRange) {
      if (!(this instanceof StreamValidator)) {
        return new StreamValidator(validateNumberInRange);
      }
      let isInitializingEventListeners =
        this instanceof initializeEventListeners();
      this._readableState = new initializeStreamOptions(
        validateNumberInRange,
        this,
        isInitializingEventListeners,
      );
      if (validateNumberInRange) {
        if (typeof validateNumberInRange.read == "function") {
          this._read = validateNumberInRange.read;
        }
        if (typeof validateNumberInRange.destroy == "function") {
          this._destroy = validateNumberInRange.destroy;
        }
        if (typeof validateNumberInRange.construct == "function") {
          this._construct = validateNumberInRange.construct;
        }
        if (validateNumberInRange.signal && !isInitializingEventListeners) {
          initializeStreamHandlerFunction(validateNumberInRange.signal, this);
        }
      }
      StreamImplementation.call(this, validateNumberInRange);
      initializeAndSetupStreamHandler.construct(this, () => {
        if (this._readableState.needReadable) {
          handleStreamProcessing(this, this._readableState);
        }
      });
    }
    StreamValidator.prototype.destroy = initializeAndSetupStreamHandler.destroy;
    StreamValidator.prototype._undestroy =
      initializeAndSetupStreamHandler.undestroy;
    StreamValidator.prototype._destroy = function (
      _validateNumberInRange,
      validateIntegerInRange,
    ) {
      validateIntegerInRange(_validateNumberInRange);
    };
    StreamValidator.prototype[EventEmitter.captureRejectionSymbol] = function (
      __validateNumberInRange,
    ) {
      this.destroy(__validateNumberInRange);
    };
    StreamValidator.prototype.push = function (
      ___validateNumberInRange,
      validateNumberRange,
    ) {
      return ______processCacheEntry(
        this,
        ___validateNumberInRange,
        validateNumberRange,
        false,
      );
    };
    StreamValidator.prototype.unshift = function (
      validateStringInput,
      validateCacheKey,
    ) {
      return ______processCacheEntry(
        this,
        validateStringInput,
        validateCacheKey,
        true,
      );
    };
    function ______processCacheEntry(
      validateCacheEntryConstraints,
      validateCacheValue,
      validateCacheEntry,
      validateAndProcessCacheEntry,
    ) {
      initializeStreamHandler_("readableAddChunk", validateCacheValue);
      let ____readableState = validateCacheEntryConstraints._readableState;
      let cachedEntryBuffer;
      if (!____readableState.objectMode) {
        if (typeof validateCacheValue == "string") {
          validateCacheEntry =
            validateCacheEntry || ____readableState.defaultEncoding;
          if (____readableState.encoding !== validateCacheEntry) {
            if (validateAndProcessCacheEntry && ____readableState.encoding) {
              validateCacheValue = BufferImplementation.from(
                validateCacheValue,
                validateCacheEntry,
              ).toString(____readableState.encoding);
            } else {
              validateCacheValue = BufferImplementation.from(
                validateCacheValue,
                validateCacheEntry,
              );
              validateCacheEntry = "";
            }
          }
        } else if (validateCacheValue instanceof BufferImplementation) {
          validateCacheEntry = "";
        } else if (StreamImplementation._isUint8Array(validateCacheValue)) {
          validateCacheValue =
            StreamImplementation._uint8ArrayToBuffer(validateCacheValue);
          validateCacheEntry = "";
        } else if (validateCacheValue != null) {
          cachedEntryBuffer = new initializeStreamHandlerWithContext(
            "chunk",
            ["string", "Buffer", "Uint8Array"],
            validateCacheValue,
          );
        }
      }
      if (cachedEntryBuffer) {
        _______initializeStreamHandler(
          validateCacheEntryConstraints,
          cachedEntryBuffer,
        );
      } else if (validateCacheValue === null) {
        ____readableState.reading = false;
        finalizePendingTasks(validateCacheEntryConstraints, ____readableState);
      } else if (
        ____readableState.objectMode ||
        (validateCacheValue && validateCacheValue.length > 0)
      ) {
        if (validateAndProcessCacheEntry) {
          if (____readableState.endEmitted) {
            _______initializeStreamHandler(
              validateCacheEntryConstraints,
              new initializeStreamHandlerWithImplementation(),
            );
          } else {
            if (____readableState.destroyed || ____readableState.errored) {
              return false;
            }
            handleDataAndBufferManagement(
              validateCacheEntryConstraints,
              ____readableState,
              validateCacheValue,
              true,
            );
          }
        } else if (____readableState.ended) {
          _______initializeStreamHandler(
            validateCacheEntryConstraints,
            new initializeStreamWithHandler(),
          );
        } else {
          if (____readableState.destroyed || ____readableState.errored) {
            return false;
          }
          ____readableState.reading = false;
          if (____readableState.decoder && !validateCacheEntry) {
            validateCacheValue =
              ____readableState.decoder.write(validateCacheValue);
            if (
              ____readableState.objectMode ||
              validateCacheValue.length !== 0
            ) {
              handleDataAndBufferManagement(
                validateCacheEntryConstraints,
                ____readableState,
                validateCacheValue,
                false,
              );
            } else {
              handleStreamProcessing(
                validateCacheEntryConstraints,
                ____readableState,
              );
            }
          } else {
            handleDataAndBufferManagement(
              validateCacheEntryConstraints,
              ____readableState,
              validateCacheValue,
              false,
            );
          }
        }
      } else if (!validateAndProcessCacheEntry) {
        ____readableState.reading = false;
        handleStreamProcessing(
          validateCacheEntryConstraints,
          ____readableState,
        );
      }
      return (
        !____readableState.ended &&
        (____readableState.length < ____readableState.highWaterMark ||
          ____readableState.length === 0)
      );
    }
    function handleDataAndBufferManagement(
      validateSignalName,
      validateArrayLength,
      _validateArrayLength,
      __validateArrayLength,
    ) {
      if (
        validateArrayLength.flowing &&
        validateArrayLength.length === 0 &&
        !validateArrayLength.sync &&
        validateSignalName.listenerCount("data") > 0
      ) {
        if (validateArrayLength.multiAwaitDrain) {
          validateArrayLength.awaitDrainWriters.clear();
        } else {
          validateArrayLength.awaitDrainWriters = null;
        }
        validateArrayLength.dataEmitted = true;
        validateSignalName.emit("data", _validateArrayLength);
      } else {
        if (validateArrayLength.objectMode) {
          validateArrayLength.length += 1;
        } else {
          validateArrayLength.length += _validateArrayLength.length;
        }
        if (__validateArrayLength) {
          validateArrayLength.buffer.unshift(_validateArrayLength);
        } else {
          validateArrayLength.buffer.push(_validateArrayLength);
        }
        if (validateArrayLength.needReadable) {
          ___handleReadableStream(validateSignalName);
        }
      }
      handleStreamProcessing(validateSignalName, validateArrayLength);
    }
    StreamValidator.prototype.isPaused = function () {
      let ___________________________readableState = this._readableState;
      return (
        ___________________________readableState[
          __initializeStreamHandlerFunction
        ] === true || ___________________________readableState.flowing === false
      );
    };
    StreamValidator.prototype.setEncoding = function (
      processAbortSignalValidation,
    ) {
      let ______streamHandler = new ______initializeStreamHandler(
        processAbortSignalValidation,
      );
      this._readableState.decoder = ______streamHandler;
      this._readableState.encoding = this._readableState.decoder.encoding;
      let buffer = this._readableState.buffer;
      let _outputBuffer = "";
      for (let bufferItem of buffer) {
        _outputBuffer += ______streamHandler.write(bufferItem);
      }
      buffer.clear();
      if (_outputBuffer !== "") {
        buffer.push(_outputBuffer);
      }
      this._readableState.length = _outputBuffer.length;
      return this;
    };
    var ________initializeStreamHandler = 1073741824;
    function validateAndPrepareNodeRemoval(validateNodeRemoval) {
      if (validateNodeRemoval > ________initializeStreamHandler) {
        throw new _____initializeStreamHandler(
          "size",
          "<= 1GiB",
          validateNodeRemoval,
        );
      }
      validateNodeRemoval--;
      validateNodeRemoval |= validateNodeRemoval >>> 1;
      validateNodeRemoval |= validateNodeRemoval >>> 2;
      validateNodeRemoval |= validateNodeRemoval >>> 4;
      validateNodeRemoval |= validateNodeRemoval >>> 8;
      validateNodeRemoval |= validateNodeRemoval >>> 16;
      validateNodeRemoval++;
      return validateNodeRemoval;
    }
    function determineLengthWithSignalAndBuffer(
      validateAbortSignal,
      validateFunctionArgument,
    ) {
      if (
        validateAbortSignal <= 0 ||
        (validateFunctionArgument.length === 0 &&
          validateFunctionArgument.ended)
      ) {
        return 0;
      } else if (validateFunctionArgument.objectMode) {
        return 1;
      } else if (isNumberNaN(validateAbortSignal)) {
        if (
          validateFunctionArgument.flowing &&
          validateFunctionArgument.length
        ) {
          return validateFunctionArgument.buffer.first().length;
        } else {
          return validateFunctionArgument.length;
        }
      } else if (validateAbortSignal <= validateFunctionArgument.length) {
        return validateAbortSignal;
      } else if (validateFunctionArgument.ended) {
        return validateFunctionArgument.length;
      } else {
        return 0;
      }
    }
    StreamValidator.prototype.read = function (validateUndefinedValue) {
      initializeStreamHandler_("read", validateUndefinedValue);
      if (validateUndefinedValue === undefined) {
        validateUndefinedValue = NaN;
      } else if (!isInteger(validateUndefinedValue)) {
        validateUndefinedValue = parseInteger(validateUndefinedValue, 10);
      }
      let readableValue = this._readableState;
      let desiredReadValue = validateUndefinedValue;
      if (validateUndefinedValue > readableValue.highWaterMark) {
        readableValue.highWaterMark = validateAndPrepareNodeRemoval(
          validateUndefinedValue,
        );
      }
      if (validateUndefinedValue !== 0) {
        readableValue.emittedReadable = false;
      }
      if (
        validateUndefinedValue === 0 &&
        readableValue.needReadable &&
        ((readableValue.highWaterMark !== 0
          ? readableValue.length >= readableValue.highWaterMark
          : readableValue.length > 0) ||
          readableValue.ended)
      ) {
        initializeStreamHandler_(
          "read: emitReadable",
          readableValue.length,
          readableValue.ended,
        );
        if (readableValue.length === 0 && readableValue.ended) {
          handleReadableEnd(this);
        } else {
          ___handleReadableStream(this);
        }
        return null;
      }
      validateUndefinedValue = determineLengthWithSignalAndBuffer(
        validateUndefinedValue,
        readableValue,
      );
      if (validateUndefinedValue === 0 && readableValue.ended) {
        if (readableValue.length === 0) {
          handleReadableEnd(this);
        }
        return null;
      }
      let ___inputValue = readableValue.needReadable;
      initializeStreamHandler_("need readable", ___inputValue);
      if (
        readableValue.length === 0 ||
        readableValue.length - validateUndefinedValue <
          readableValue.highWaterMark
      ) {
        ___inputValue = true;
        initializeStreamHandler_("length less than watermark", ___inputValue);
      }
      if (
        readableValue.ended ||
        readableValue.reading ||
        readableValue.destroyed ||
        readableValue.errored ||
        !readableValue.constructed
      ) {
        ___inputValue = false;
        initializeStreamHandler_(
          "reading, ended or constructing",
          ___inputValue,
        );
      } else if (___inputValue) {
        initializeStreamHandler_("do read");
        readableValue.reading = true;
        readableValue.sync = true;
        if (readableValue.length === 0) {
          readableValue.needReadable = true;
        }
        try {
          this._read(readableValue.highWaterMark);
        } catch (_________error) {
          _______initializeStreamHandler(this, _________error);
        }
        readableValue.sync = false;
        if (!readableValue.reading) {
          validateUndefinedValue = determineLengthWithSignalAndBuffer(
            desiredReadValue,
            readableValue,
          );
        }
      }
      let _desiredReadValue;
      if (validateUndefinedValue > 0) {
        _desiredReadValue = processComparatorHandler(
          validateUndefinedValue,
          readableValue,
        );
      } else {
        _desiredReadValue = null;
      }
      if (_desiredReadValue === null) {
        readableValue.needReadable =
          readableValue.length <= readableValue.highWaterMark;
        validateUndefinedValue = 0;
      } else {
        readableValue.length -= validateUndefinedValue;
        if (readableValue.multiAwaitDrain) {
          readableValue.awaitDrainWriters.clear();
        } else {
          readableValue.awaitDrainWriters = null;
        }
      }
      if (readableValue.length === 0) {
        if (!readableValue.ended) {
          readableValue.needReadable = true;
        }
        if (
          desiredReadValue !== validateUndefinedValue &&
          readableValue.ended
        ) {
          handleReadableEnd(this);
        }
      }
      if (
        _desiredReadValue !== null &&
        !readableValue.errorEmitted &&
        !readableValue.closeEmitted
      ) {
        readableValue.dataEmitted = true;
        this.emit("data", _desiredReadValue);
      }
      return _desiredReadValue;
    };
    function finalizePendingTasks(executePendingTasks, processPendingTasks) {
      initializeStreamHandler_("onEofChunk");
      if (!processPendingTasks.ended) {
        if (processPendingTasks.decoder) {
          let decodedTasks = processPendingTasks.decoder.end();
          if (decodedTasks && decodedTasks.length) {
            processPendingTasks.buffer.push(decodedTasks);
            if (processPendingTasks.objectMode) {
              processPendingTasks.length += 1;
            } else {
              processPendingTasks.length += decodedTasks.length;
            }
          }
        }
        processPendingTasks.ended = true;
        if (processPendingTasks.sync) {
          ___handleReadableStream(executePendingTasks);
        } else {
          processPendingTasks.needReadable = false;
          processPendingTasks.emittedReadable = true;
          __handleReadableStream(executePendingTasks);
        }
      }
    }
    function ___handleReadableStream(scheduleTask) {
      let ____________________readableState = scheduleTask._readableState;
      initializeStreamHandler_(
        "emitReadable",
        ____________________readableState.needReadable,
        ____________________readableState.emittedReadable,
      );
      ____________________readableState.needReadable = false;
      if (!____________________readableState.emittedReadable) {
        initializeStreamHandler_(
          "emitReadable",
          ____________________readableState.flowing,
        );
        ____________________readableState.emittedReadable = true;
        isValidSemVerRangeResult.nextTick(__handleReadableStream, scheduleTask);
      }
    }
    function __handleReadableStream(addNextTickListener) {
      let _______________readableState = addNextTickListener._readableState;
      initializeStreamHandler_(
        "emitReadable_",
        _______________readableState.destroyed,
        _______________readableState.length,
        _______________readableState.ended,
      );
      if (
        !_______________readableState.destroyed &&
        !_______________readableState.errored &&
        (_______________readableState.length ||
          _______________readableState.ended)
      ) {
        addNextTickListener.emit("readable");
        _______________readableState.emittedReadable = false;
      }
      _______________readableState.needReadable =
        !_______________readableState.flowing &&
        !_______________readableState.ended &&
        _______________readableState.length <=
          _______________readableState.highWaterMark;
      processReadableStream(addNextTickListener);
    }
    function handleStreamProcessing(
      isSingleElementAndUndefined,
      processHandler,
    ) {
      if (!processHandler.readingMore && processHandler.constructed) {
        processHandler.readingMore = true;
        isValidSemVerRangeResult.nextTick(
          processCharacterStream,
          isSingleElementAndUndefined,
          processHandler,
        );
      }
    }
    function processCharacterStream(
      calculateAndProcessCharacterEncoding,
      _calculateAndProcessCharacterEncoding,
    ) {
      while (
        !_calculateAndProcessCharacterEncoding.reading &&
        !_calculateAndProcessCharacterEncoding.ended &&
        (_calculateAndProcessCharacterEncoding.length <
          _calculateAndProcessCharacterEncoding.highWaterMark ||
          (_calculateAndProcessCharacterEncoding.flowing &&
            _calculateAndProcessCharacterEncoding.length === 0))
      ) {
        let initialCharacterEncodingLength =
          _calculateAndProcessCharacterEncoding.length;
        initializeStreamHandler_("maybeReadMore read 0");
        calculateAndProcessCharacterEncoding.read(0);
        if (
          initialCharacterEncodingLength ===
          _calculateAndProcessCharacterEncoding.length
        ) {
          break;
        }
      }
      _calculateAndProcessCharacterEncoding.readingMore = false;
    }
    StreamValidator.prototype._read = function (
      _validateAndProcessCharacterEncoding,
    ) {
      throw new ____initializeStreamHandler("_read()");
    };
    StreamValidator.prototype.pipe = function (
      __validateAndProcessCharacterEncoding,
      initializeListenerBindings,
    ) {
      let context = this;
      let ___readableState = this._readableState;
      if (___readableState.pipes.length === 1) {
        if (!___readableState.multiAwaitDrain) {
          ___readableState.multiAwaitDrain = true;
          ___readableState.awaitDrainWriters = new SafeSetImplementation(
            ___readableState.awaitDrainWriters
              ? [___readableState.awaitDrainWriters]
              : [],
          );
        }
      }
      ___readableState.pipes.push(__validateAndProcessCharacterEncoding);
      initializeStreamHandler_(
        "pipe count=%d opts=%j",
        ___readableState.pipes.length,
        initializeListenerBindings,
      );
      let shouldProcessStreamEnd =
        (!initializeListenerBindings ||
          initializeListenerBindings.end !== false) &&
        __validateAndProcessCharacterEncoding !==
          isValidSemVerRangeResult.stdout &&
        __validateAndProcessCharacterEncoding !==
          isValidSemVerRangeResult.stderr
          ? _handleStreamEnd
          : unpipeStreamHandler;
      if (___readableState.endEmitted) {
        isValidSemVerRangeResult.nextTick(shouldProcessStreamEnd);
      } else {
        context.once("end", shouldProcessStreamEnd);
      }
      __validateAndProcessCharacterEncoding.on("unpipe", _handleStreamUnpipe);
      function _handleStreamUnpipe(validateStream, isReadableStream) {
        initializeStreamHandler_("onunpipe");
        if (
          validateStream === context &&
          isReadableStream &&
          isReadableStream.hasUnpiped === false
        ) {
          isReadableStream.hasUnpiped = true;
          cleanupStreamHandlers();
        }
      }
      function _handleStreamEnd() {
        initializeStreamHandler_("onend");
        __validateAndProcessCharacterEncoding.end();
      }
      let ____processCharacterEncoding;
      let _____processCharacterEncoding = false;
      function cleanupStreamHandlers() {
        initializeStreamHandler_("cleanup");
        __validateAndProcessCharacterEncoding.removeListener(
          "close",
          removeFinishListenerAndProcessEncoding,
        );
        __validateAndProcessCharacterEncoding.removeListener(
          "finish",
          handleStreamCompletion,
        );
        if (____processCharacterEncoding) {
          __validateAndProcessCharacterEncoding.removeListener(
            "drain",
            ____processCharacterEncoding,
          );
        }
        __validateAndProcessCharacterEncoding.removeListener(
          "error",
          handleErrorForTildeVersion,
        );
        __validateAndProcessCharacterEncoding.removeListener(
          "unpipe",
          _handleStreamUnpipe,
        );
        context.removeListener("end", _handleStreamEnd);
        context.removeListener("end", unpipeStreamHandler);
        context.removeListener("data", ____processStreamData);
        _____processCharacterEncoding = true;
        if (
          ____processCharacterEncoding &&
          ___readableState.awaitDrainWriters &&
          (!__validateAndProcessCharacterEncoding._writableState ||
            __validateAndProcessCharacterEncoding._writableState.needDrain)
        ) {
          ____processCharacterEncoding();
        }
      }
      function handleCharacterEncoding() {
        if (!_____processCharacterEncoding) {
          if (
            ___readableState.pipes.length === 1 &&
            ___readableState.pipes[0] === __validateAndProcessCharacterEncoding
          ) {
            initializeStreamHandler_("false write response, pause", 0);
            ___readableState.awaitDrainWriters =
              __validateAndProcessCharacterEncoding;
            ___readableState.multiAwaitDrain = false;
          } else if (
            ___readableState.pipes.length > 1 &&
            ___readableState.pipes.includes(
              __validateAndProcessCharacterEncoding,
            )
          ) {
            initializeStreamHandler_(
              "false write response, pause",
              ___readableState.awaitDrainWriters.size,
            );
            ___readableState.awaitDrainWriters.add(
              __validateAndProcessCharacterEncoding,
            );
          }
          context.pause();
        }
        if (!____processCharacterEncoding) {
          ____processCharacterEncoding = handleDrainEvent(
            context,
            __validateAndProcessCharacterEncoding,
          );
          __validateAndProcessCharacterEncoding.on(
            "drain",
            ____processCharacterEncoding,
          );
        }
      }
      context.on("data", ____processStreamData);
      function ____processStreamData(isStreamObject) {
        initializeStreamHandler_("ondata");
        let __processedCharacterEncoding =
          __validateAndProcessCharacterEncoding.write(isStreamObject);
        initializeStreamHandler_("dest.write", __processedCharacterEncoding);
        if (__processedCharacterEncoding === false) {
          handleCharacterEncoding();
        }
      }
      function handleErrorForTildeVersion(isTildeVersionFunction) {
        initializeStreamHandler_("onerror", isTildeVersionFunction);
        unpipeStreamHandler();
        __validateAndProcessCharacterEncoding.removeListener(
          "error",
          handleErrorForTildeVersion,
        );
        if (
          __validateAndProcessCharacterEncoding.listenerCount("error") === 0
        ) {
          let characterEncodingState =
            __validateAndProcessCharacterEncoding._writableState ||
            __validateAndProcessCharacterEncoding._readableState;
          if (characterEncodingState && !characterEncodingState.errorEmitted) {
            _______initializeStreamHandler(
              __validateAndProcessCharacterEncoding,
              isTildeVersionFunction,
            );
          } else {
            __validateAndProcessCharacterEncoding.emit(
              "error",
              isTildeVersionFunction,
            );
          }
        }
      }
      prependListenerToStream(
        __validateAndProcessCharacterEncoding,
        "error",
        handleErrorForTildeVersion,
      );
      function removeFinishListenerAndProcessEncoding() {
        __validateAndProcessCharacterEncoding.removeListener(
          "finish",
          handleStreamCompletion,
        );
        unpipeStreamHandler();
      }
      __validateAndProcessCharacterEncoding.once(
        "close",
        removeFinishListenerAndProcessEncoding,
      );
      function handleStreamCompletion() {
        initializeStreamHandler_("onfinish");
        __validateAndProcessCharacterEncoding.removeListener(
          "close",
          removeFinishListenerAndProcessEncoding,
        );
        unpipeStreamHandler();
      }
      __validateAndProcessCharacterEncoding.once(
        "finish",
        handleStreamCompletion,
      );
      function unpipeStreamHandler() {
        initializeStreamHandler_("unpipe");
        context.unpipe(__validateAndProcessCharacterEncoding);
      }
      __validateAndProcessCharacterEncoding.emit("pipe", context);
      if (__validateAndProcessCharacterEncoding.writableNeedDrain === true) {
        if (___readableState.flowing) {
          handleCharacterEncoding();
        }
      } else if (!___readableState.flowing) {
        initializeStreamHandler_("pipe resume");
        context.resume();
      }
      return __validateAndProcessCharacterEncoding;
    };
    function handleDrainEvent(isWritableStateErrored, isWritableEnded) {
      return function () {
        let _____________readableState = isWritableStateErrored._readableState;
        if (_____________readableState.awaitDrainWriters === isWritableEnded) {
          initializeStreamHandler_("pipeOnDrain", 1);
          _____________readableState.awaitDrainWriters = null;
        } else if (_____________readableState.multiAwaitDrain) {
          initializeStreamHandler_(
            "pipeOnDrain",
            _____________readableState.awaitDrainWriters.size,
          );
          _____________readableState.awaitDrainWriters.delete(isWritableEnded);
        }
        if (
          (!_____________readableState.awaitDrainWriters ||
            _____________readableState.awaitDrainWriters.size === 0) &&
          isWritableStateErrored.listenerCount("data")
        ) {
          isWritableStateErrored.resume();
        }
      };
    }
    StreamValidator.prototype.unpipe = function (isStreamEnded) {
      let ______readableState = this._readableState;
      let unpipeEventData = {
        hasUnpiped: false,
      };
      if (______readableState.pipes.length === 0) {
        return this;
      }
      if (!isStreamEnded) {
        let pipesArray = ______readableState.pipes;
        ______readableState.pipes = [];
        this.pause();
        for (let pipeIndex = 0; pipeIndex < pipesArray.length; pipeIndex++) {
          pipesArray[pipeIndex].emit("unpipe", this, {
            hasUnpiped: false,
          });
        }
        return this;
      }
      let findPipeIndex = arrayPrototypeIndexOf(
        ______readableState.pipes,
        isStreamEnded,
      );
      if (findPipeIndex === -1) {
        return this;
      } else {
        ______readableState.pipes.splice(findPipeIndex, 1);
        if (______readableState.pipes.length === 0) {
          this.pause();
        }
        isStreamEnded.emit("unpipe", this, unpipeEventData);
        return this;
      }
    };
    StreamValidator.prototype.on = function (
      isWritableVersionRangeParser,
      isPatchVersionEnded,
    ) {
      let parsedStreamData = StreamImplementation.prototype.on.call(
        this,
        isWritableVersionRangeParser,
        isPatchVersionEnded,
      );
      let _______readableState = this._readableState;
      if (isWritableVersionRangeParser === "data") {
        _______readableState.readableListening =
          this.listenerCount("readable") > 0;
        if (_______readableState.flowing !== false) {
          this.resume();
        }
      } else if (
        isWritableVersionRangeParser === "readable" &&
        !_______readableState.endEmitted &&
        !_______readableState.readableListening
      ) {
        _______readableState.readableListening =
          _______readableState.needReadable = true;
        _______readableState.flowing = false;
        _______readableState.emittedReadable = false;
        initializeStreamHandler_(
          "on readable",
          _______readableState.length,
          _______readableState.reading,
        );
        if (_______readableState.length) {
          ___handleReadableStream(this);
        } else if (!_______readableState.reading) {
          isValidSemVerRangeResult.nextTick(readStreamWithErrorHandler, this);
        }
      }
      return parsedStreamData;
    };
    StreamValidator.prototype.addListener = StreamValidator.prototype.on;
    StreamValidator.prototype.removeListener = function (
      isVersionRangeWritable,
      isValidWritableVersionRange,
    ) {
      let removeListenerAndUpdateFlow =
        StreamImplementation.prototype.removeListener.call(
          this,
          isVersionRangeWritable,
          isValidWritableVersionRange,
        );
      if (isVersionRangeWritable === "readable") {
        isValidSemVerRangeResult.nextTick(updateStreamFlowStatus, this);
      }
      return removeListenerAndUpdateFlow;
    };
    StreamValidator.prototype.off = StreamValidator.prototype.removeListener;
    StreamValidator.prototype.removeAllListeners = function (
      checkVersionRangeConditions,
    ) {
      let resultOfRemovingListeners =
        StreamImplementation.prototype.removeAllListeners.apply(
          this,
          arguments,
        );
      if (
        checkVersionRangeConditions === "readable" ||
        checkVersionRangeConditions === undefined
      ) {
        isValidSemVerRangeResult.nextTick(updateStreamFlowStatus, this);
      }
      return resultOfRemovingListeners;
    };
    function updateStreamFlowStatus(checkWritableErrors) {
      let _________________readableState = checkWritableErrors._readableState;
      _________________readableState.readableListening =
        checkWritableErrors.listenerCount("readable") > 0;
      if (
        _________________readableState.resumeScheduled &&
        _________________readableState[__initializeStreamHandlerFunction] ===
          false
      ) {
        _________________readableState.flowing = true;
      } else if (checkWritableErrors.listenerCount("data") > 0) {
        checkWritableErrors.resume();
      } else if (!_________________readableState.readableListening) {
        _________________readableState.flowing = null;
      }
    }
    function readStreamWithErrorHandler(getReadableError) {
      initializeStreamHandler_("readable nexttick read 0");
      getReadableError.read(0);
    }
    StreamValidator.prototype.resume = function () {
      let ________________________readableState = this._readableState;
      if (!________________________readableState.flowing) {
        initializeStreamHandler_("resume");
        ________________________readableState.flowing =
          !________________________readableState.readableListening;
        scheduleResumeUpdate(this, ________________________readableState);
      }
      ________________________readableState[__initializeStreamHandlerFunction] =
        false;
      return this;
    };
    function scheduleResumeUpdate(
      isUpdateVersionConstraintsClosed,
      _isUpdateVersionConstraintsClosed,
    ) {
      if (!_isUpdateVersionConstraintsClosed.resumeScheduled) {
        _isUpdateVersionConstraintsClosed.resumeScheduled = true;
        isValidSemVerRangeResult.nextTick(
          handleResumeUpdate,
          isUpdateVersionConstraintsClosed,
          _isUpdateVersionConstraintsClosed,
        );
      }
    }
    function handleResumeUpdate(
      isUpdateVersionClosed,
      checkUpdateVersionClosed,
    ) {
      initializeStreamHandler_("resume", checkUpdateVersionClosed.reading);
      if (!checkUpdateVersionClosed.reading) {
        isUpdateVersionClosed.read(0);
      }
      checkUpdateVersionClosed.resumeScheduled = false;
      isUpdateVersionClosed.emit("resume");
      processReadableStream(isUpdateVersionClosed);
      if (
        checkUpdateVersionClosed.flowing &&
        !checkUpdateVersionClosed.reading
      ) {
        isUpdateVersionClosed.read(0);
      }
    }
    StreamValidator.prototype.pause = function () {
      initializeStreamHandler_(
        "call pause flowing=%j",
        this._readableState.flowing,
      );
      if (this._readableState.flowing !== false) {
        initializeStreamHandler_("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[__initializeStreamHandlerFunction] = true;
      return this;
    };
    function processReadableStream(validateMinorVersionProperties) {
      let ___readableStreamState =
        validateMinorVersionProperties._readableState;
      for (
        initializeStreamHandler_("flow", ___readableStreamState.flowing);
        ___readableStreamState.flowing &&
        validateMinorVersionProperties.read() !== null;

      ) {}
    }
    StreamValidator.prototype.wrap = function (isConsumingOrDumped) {
      let _isPaused = false;
      isConsumingOrDumped.on("data", (dataItemToPush) => {
        if (!this.push(dataItemToPush) && isConsumingOrDumped.pause) {
          _isPaused = true;
          isConsumingOrDumped.pause();
        }
      });
      isConsumingOrDumped.on("end", () => {
        this.push(null);
      });
      isConsumingOrDumped.on("error", (_________streamHandler) => {
        _______initializeStreamHandler(this, _________streamHandler);
      });
      isConsumingOrDumped.on("close", () => {
        this.destroy();
      });
      isConsumingOrDumped.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (_isPaused && isConsumingOrDumped.resume) {
          _isPaused = false;
          isConsumingOrDumped.resume();
        }
      };
      let getFunctionalMethods = getObjectKeys(isConsumingOrDumped);
      for (
        let methodIndex = 1;
        methodIndex < getFunctionalMethods.length;
        methodIndex++
      ) {
        let functionalMethod = getFunctionalMethods[methodIndex];
        if (
          this[functionalMethod] === undefined &&
          typeof isConsumingOrDumped[functionalMethod] == "function"
        ) {
          this[functionalMethod] =
            isConsumingOrDumped[functionalMethod].bind(isConsumingOrDumped);
        }
      }
      return this;
    };
    StreamValidator.prototype[SymbolAsyncIterator] = function () {
      return initializeStreamValidator(this);
    };
    StreamValidator.prototype.iterator = function (isStreamErrored) {
      if (isStreamErrored !== undefined) {
        _initializeStreamHandlerFunction(isStreamErrored, "options");
      }
      return initializeStreamValidator(this, isStreamErrored);
    };
    function initializeStreamValidator(
      checkReadableOrWritableError,
      checkForReadableStreamErrors,
    ) {
      if (typeof checkReadableOrWritableError.read != "function") {
        checkReadableOrWritableError = StreamValidator.wrap(
          checkReadableOrWritableError,
          {
            objectMode: true,
          },
        );
      }
      let _______streamHandler = streamHandlerGenerator(
        checkReadableOrWritableError,
        checkForReadableStreamErrors,
      );
      _______streamHandler.stream = checkReadableOrWritableError;
      return _______streamHandler;
    }
    async function* streamHandlerGenerator(
      _validateSemverPrerelease,
      validateStreamStatus,
    ) {
      let handleStreamStatus = initializeAndHandleStream;
      function handleStreamUpdate(__validateSemverPrerelease) {
        if (this === _validateSemverPrerelease) {
          handleStreamStatus();
          handleStreamStatus = initializeAndHandleStream;
        } else {
          handleStreamStatus = __validateSemverPrerelease;
        }
      }
      _validateSemverPrerelease.on("readable", handleStreamUpdate);
      let streamHandlerError;
      let _____streamHandler = initializeAndValidateStreamHandler(
        _validateSemverPrerelease,
        {
          writable: false,
        },
        (streamHandlerInitialized) => {
          if (streamHandlerInitialized) {
            streamHandlerError = ___initializeStreamHandler(
              streamHandlerError,
              streamHandlerInitialized,
            );
          } else {
            streamHandlerError = null;
          }
          handleStreamStatus();
          handleStreamStatus = initializeAndHandleStream;
        },
      );
      try {
        while (true) {
          let _prereleaseVersion = _validateSemverPrerelease.destroyed
            ? null
            : _validateSemverPrerelease.read();
          if (_prereleaseVersion !== null) {
            yield _prereleaseVersion;
          } else {
            if (streamHandlerError) {
              throw streamHandlerError;
            }
            if (streamHandlerError === null) {
              return;
            }
            await new PromiseImplementation(handleStreamUpdate);
          }
        }
      } catch (__errorHandling) {
        streamHandlerError = ___initializeStreamHandler(
          streamHandlerError,
          __errorHandling,
        );
        throw streamHandlerError;
      } finally {
        if (
          (streamHandlerError ||
            validateStreamStatus?.destroyOnReturn !== false) &&
          (streamHandlerError === undefined ||
            _validateSemverPrerelease._readableState.autoDestroy)
        ) {
          initializeAndSetupStreamHandler.destroyer(
            _validateSemverPrerelease,
            null,
          );
        } else {
          _validateSemverPrerelease.off("readable", handleStreamUpdate);
          _____streamHandler();
        }
      }
    }
    _defineObjectProperties(StreamValidator.prototype, {
      readable: {
        __proto__: null,
        get() {
          let isStreamReadable = this._readableState;
          return (
            !!isStreamReadable &&
            isStreamReadable.readable !== false &&
            !isStreamReadable.destroyed &&
            !isStreamReadable.errorEmitted &&
            !isStreamReadable.endEmitted
          );
        },
        set(setReadableState) {
          if (this._readableState) {
            this._readableState.readable = !!setReadableState;
          }
        },
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.dataEmitted;
        },
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get() {
          return (
            this._readableState.readable !== false &&
            (!!this._readableState.destroyed ||
              !!this._readableState.errored) &&
            !this._readableState.endEmitted
          );
        },
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.highWaterMark;
        },
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState && this._readableState.buffer;
        },
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.flowing;
        },
        set(setFlowingState) {
          if (this._readableState) {
            this._readableState.flowing = setFlowingState;
          }
        },
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        },
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          if (this._readableState) {
            return this._readableState.objectMode;
          } else {
            return false;
          }
        },
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          if (this._readableState) {
            return this._readableState.encoding;
          } else {
            return null;
          }
        },
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          if (this._readableState) {
            return this._readableState.errored;
          } else {
            return null;
          }
        },
      },
      closed: {
        __proto__: null,
        get() {
          if (this._readableState) {
            return this._readableState.closed;
          } else {
            return false;
          }
        },
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          if (this._readableState) {
            return this._readableState.destroyed;
          } else {
            return false;
          }
        },
        set(setDestroyedState) {
          if (this._readableState) {
            this._readableState.destroyed = setDestroyedState;
          }
        },
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          if (this._readableState) {
            return this._readableState.endEmitted;
          } else {
            return false;
          }
        },
      },
    });
    _defineObjectProperties(initializeStreamOptions.prototype, {
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        },
      },
      paused: {
        __proto__: null,
        get() {
          return this[__initializeStreamHandlerFunction] !== false;
        },
        set(isStreamHandlerInitialized) {
          this[__initializeStreamHandlerFunction] =
            !!isStreamHandlerInitialized;
        },
      },
    });
    StreamValidator._fromList = processComparatorHandler;
    function processComparatorHandler(
      __processComparator,
      handleProcessComparatorEvents,
    ) {
      if (handleProcessComparatorEvents.length === 0) {
        return null;
      }
      let processedData;
      if (handleProcessComparatorEvents.objectMode) {
        processedData = handleProcessComparatorEvents.buffer.shift();
      } else if (
        !__processComparator ||
        __processComparator >= handleProcessComparatorEvents.length
      ) {
        if (handleProcessComparatorEvents.decoder) {
          processedData = handleProcessComparatorEvents.buffer.join("");
        } else if (handleProcessComparatorEvents.buffer.length === 1) {
          processedData = handleProcessComparatorEvents.buffer.first();
        } else {
          processedData = handleProcessComparatorEvents.buffer.concat(
            handleProcessComparatorEvents.length,
          );
        }
        handleProcessComparatorEvents.buffer.clear();
      } else {
        processedData = handleProcessComparatorEvents.buffer.consume(
          __processComparator,
          handleProcessComparatorEvents.decoder,
        );
      }
      return processedData;
    }
    function handleReadableEnd(processCompletionHandler) {
      let _________________________readableState =
        processCompletionHandler._readableState;
      initializeStreamHandler_(
        "endReadable",
        _________________________readableState.endEmitted,
      );
      if (!_________________________readableState.endEmitted) {
        _________________________readableState.ended = true;
        isValidSemVerRangeResult.nextTick(
          processEventStream,
          _________________________readableState,
          processCompletionHandler,
        );
      }
    }
    function processEventStream(handleProcessErrors, handleProcessEvents) {
      initializeStreamHandler_(
        "endReadableNT",
        handleProcessErrors.endEmitted,
        handleProcessErrors.length,
      );
      if (
        !handleProcessErrors.errored &&
        !handleProcessErrors.closeEmitted &&
        !handleProcessErrors.endEmitted &&
        handleProcessErrors.length === 0
      ) {
        handleProcessErrors.endEmitted = true;
        handleProcessEvents.emit("end");
        if (
          handleProcessEvents.writable &&
          handleProcessEvents.allowHalfOpen === false
        ) {
          isValidSemVerRangeResult.nextTick(
            endComparatorIfWritable,
            handleProcessEvents,
          );
        } else if (handleProcessErrors.autoDestroy) {
          let _______________________writableState =
            handleProcessEvents._writableState;
          if (
            !_______________________writableState ||
            (_______________________writableState.autoDestroy &&
              (_______________________writableState.finished ||
                _______________________writableState.writable === false))
          ) {
            handleProcessEvents.destroy();
          }
        }
      }
    }
    function endComparatorIfWritable(removeEventListenersFromComparator) {
      if (
        removeEventListenersFromComparator.writable &&
        !removeEventListenersFromComparator.writableEnded &&
        !removeEventListenersFromComparator.destroyed
      ) {
        removeEventListenersFromComparator.end();
      }
    }
    StreamValidator.from = function (
      removeComparisonListeners,
      removeProcessListeners,
    ) {
      return streamInitializationHandler(
        StreamValidator,
        removeComparisonListeners,
        removeProcessListeners,
      );
    };
    var initializeStreamHandlerWithValidations;
    function getStreamHandlerWithValidations() {
      if (initializeStreamHandlerWithValidations === undefined) {
        initializeStreamHandlerWithValidations = {};
      }
      return initializeStreamHandlerWithValidations;
    }
    StreamValidator.fromWeb = function (
      processEndListenerHandler,
      _removeProcessListeners,
    ) {
      return getStreamHandlerWithValidations().newStreamReadableFromReadableStream(
        processEndListenerHandler,
        _removeProcessListeners,
      );
    };
    StreamValidator.toWeb = function (
      removeEventListenersOnFinish,
      __removeProcessListeners,
    ) {
      return getStreamHandlerWithValidations().newReadableStreamFromStreamReadable(
        removeEventListenersOnFinish,
        __removeProcessListeners,
      );
    };
    StreamValidator.wrap = function (
      processSignalAndHandleError,
      handleParseComparatorAbort,
    ) {
      return new StreamValidator({
        objectMode:
          processSignalAndHandleError.readableObjectMode ??
          processSignalAndHandleError.objectMode ??
          true,
        ...handleParseComparatorAbort,
        destroy(streamHandlerDestroyer, handleStreamDestruction) {
          initializeAndSetupStreamHandler.destroyer(
            processSignalAndHandleError,
            streamHandlerDestroyer,
          );
          handleStreamDestruction(streamHandlerDestroyer);
        },
      }).wrap(processSignalAndHandleError);
    };
  },
);
var ___________________validateAndRetrieveIntrinsicProperties =
  conditionalModuleLoader((processAndExportModules, moduleExports) => {
    var _isValidSemVerRangeResult = isValidSemVerRange();
    var {
      ArrayPrototypeSlice: ArraySlice,
      Error: ErrorClass,
      FunctionPrototypeSymbolHasInstance: isInstanceOfFunction,
      ObjectDefineProperty: defineObjectProperty,
      ObjectDefineProperties: defineMultipleObjectProperties,
      ObjectSetPrototypeOf: setPrototypeOf,
      StringPrototypeToLowerCase: stringPrototypeToLowerCase,
      Symbol: uniqueSymbol,
      SymbolHasInstance: isSymbolInstance,
    } = executeComparisonOperation();
    moduleExports.exports = StreamHandler;
    StreamHandler.WritableState = initializeStreamSettings;
    var { EventEmitter: _EventEmitter } = getMatchingIndex();
    var streamedValues = processSectionedValues().Stream;
    _validateAndRetrieveIntrinsicPropertyValue();
    var { Buffer: Buffer } = createESModule(
      _retrieveAndValidateIntrinsicProperty,
    );
    var evaluateVersionOperatorsResult = evaluateVersionOperators();
    var { addAbortSignal: addAbortSignal } = nestedObjectCreation();
    var {
      getHighWaterMark: processAndExportModulesToExports,
      getDefaultHighWaterMark: _processAndExportModules,
    } = errorStackTrace();
    var {
      ERR_INVALID_ARG_TYPE: __isValidSemVerRangeResult,
      ERR_METHOD_NOT_IMPLEMENTED: __validateSemVerRange,
      ERR_MULTIPLE_CALLBACK: processAndExportModulesToModuleExports,
      ERR_STREAM_CANNOT_PIPE: ___isValidSemVerRangeResult,
      ERR_STREAM_DESTROYED: ____isValidSemVerRangeResult,
      ERR_STREAM_ALREADY_FINISHED: processAndExportModulesHandler,
      ERR_STREAM_NULL_VALUES: __validateAndRetrieveIntrinsicPropertyValue,
      ERR_STREAM_WRITE_AFTER_END: evaluateAndExportModules,
      ERR_UNKNOWN_ENCODING: _____isValidSemVerRangeResult,
    } = getNodeValueAfterTraversal().codes;
    var { errorOrDestroy: __processAndExportModules } =
      evaluateVersionOperatorsResult;
    setPrototypeOf(StreamHandler.prototype, streamedValues.prototype);
    setPrototypeOf(StreamHandler, streamedValues);
    function initializeApp() {}
    var ___processAndExportModules = uniqueSymbol("kOnFinished");
    function initializeStreamSettings(
      validateAndRetrieveProperties,
      ____________________validateAndRetrieveIntrinsicProperties,
      updateMaxAgeSettings,
    ) {
      if (typeof updateMaxAgeSettings != "boolean") {
        updateMaxAgeSettings =
          ____________________validateAndRetrieveIntrinsicProperties instanceof
          initializeEventListeners();
      }
      this.objectMode =
        !!validateAndRetrieveProperties &&
        !!validateAndRetrieveProperties.objectMode;
      if (updateMaxAgeSettings) {
        this.objectMode =
          this.objectMode ||
          (!!validateAndRetrieveProperties &&
            !!validateAndRetrieveProperties.writableObjectMode);
      }
      if (validateAndRetrieveProperties) {
        this.highWaterMark = processAndExportModulesToExports(
          this,
          validateAndRetrieveProperties,
          "writableHighWaterMark",
          updateMaxAgeSettings,
        );
      } else {
        this.highWaterMark = _processAndExportModules(false);
      }
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      let shouldUpdateMaxAgeSettings =
        !!validateAndRetrieveProperties &&
        validateAndRetrieveProperties.decodeStrings === false;
      this.decodeStrings = !shouldUpdateMaxAgeSettings;
      this.defaultEncoding =
        (validateAndRetrieveProperties &&
          validateAndRetrieveProperties.defaultEncoding) ||
        "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = processDefaultReturnValue.bind(
        undefined,
        ____________________validateAndRetrieveIntrinsicProperties,
      );
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      initializeProcessOperations(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose =
        !validateAndRetrieveProperties ||
        validateAndRetrieveProperties.emitClose !== false;
      this.autoDestroy =
        !validateAndRetrieveProperties ||
        validateAndRetrieveProperties.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[___processAndExportModules] = [];
    }
    function initializeProcessOperations(processOperations) {
      processOperations.buffered = [];
      processOperations.bufferedIndex = 0;
      processOperations.allBuffers = true;
      processOperations.allNoop = true;
    }
    initializeStreamSettings.prototype.getBuffer = function () {
      return ArraySlice(this.buffered, this.bufferedIndex);
    };
    defineObjectProperty(
      initializeStreamSettings.prototype,
      "bufferedRequestCount",
      {
        __proto__: null,
        get() {
          return this.buffered.length - this.bufferedIndex;
        },
      },
    );
    function StreamHandler(abortSignalHandler) {
      let isInitialized = this instanceof initializeEventListeners();
      if (!isInitialized && !isInstanceOfFunction(StreamHandler, this)) {
        return new StreamHandler(abortSignalHandler);
      }
      this._writableState = new initializeStreamSettings(
        abortSignalHandler,
        this,
        isInitialized,
      );
      if (abortSignalHandler) {
        if (typeof abortSignalHandler.write == "function") {
          this._write = abortSignalHandler.write;
        }
        if (typeof abortSignalHandler.writev == "function") {
          this._writev = abortSignalHandler.writev;
        }
        if (typeof abortSignalHandler.destroy == "function") {
          this._destroy = abortSignalHandler.destroy;
        }
        if (typeof abortSignalHandler.final == "function") {
          this._final = abortSignalHandler.final;
        }
        if (typeof abortSignalHandler.construct == "function") {
          this._construct = abortSignalHandler.construct;
        }
        if (abortSignalHandler.signal) {
          addAbortSignal(abortSignalHandler.signal, this);
        }
      }
      streamedValues.call(this, abortSignalHandler);
      evaluateVersionOperatorsResult.construct(this, () => {
        let _________________________writableState = this._writableState;
        if (!_________________________writableState.writing) {
          processBufferedCharacterSegments(
            this,
            _________________________writableState,
          );
        }
        ________handleVersionComparison(
          this,
          _________________________writableState,
        );
      });
    }
    defineObjectProperty(StreamHandler, isSymbolInstance, {
      __proto__: null,
      value(streamSettingsIsInitialized) {
        if (isInstanceOfFunction(this, streamSettingsIsInitialized)) {
          return true;
        } else if (this !== StreamHandler) {
          return false;
        } else {
          return (
            streamSettingsIsInitialized &&
            streamSettingsIsInitialized._writableState instanceof
              initializeStreamSettings
          );
        }
      },
    });
    StreamHandler.prototype.pipe = function () {
      __processAndExportModules(this, new ___isValidSemVerRangeResult());
    };
    function processAndValidateData(
      processPromisesAndHandleErrors,
      handleAsyncOperations,
      processAsyncTasks,
      handleErrorsAndPushToQueue,
    ) {
      let _____writableState = processPromisesAndHandleErrors._writableState;
      if (typeof processAsyncTasks == "function") {
        handleErrorsAndPushToQueue = processAsyncTasks;
        processAsyncTasks = _____writableState.defaultEncoding;
      } else {
        if (!processAsyncTasks) {
          processAsyncTasks = _____writableState.defaultEncoding;
        } else if (
          processAsyncTasks !== "buffer" &&
          !Buffer.isEncoding(processAsyncTasks)
        ) {
          throw new _____isValidSemVerRangeResult(processAsyncTasks);
        }
        if (typeof handleErrorsAndPushToQueue != "function") {
          handleErrorsAndPushToQueue = initializeApp;
        }
      }
      if (handleAsyncOperations === null) {
        throw new __validateAndRetrieveIntrinsicPropertyValue();
      }
      if (!_____writableState.objectMode) {
        if (typeof handleAsyncOperations == "string") {
          if (_____writableState.decodeStrings !== false) {
            handleAsyncOperations = Buffer.from(
              handleAsyncOperations,
              processAsyncTasks,
            );
            processAsyncTasks = "buffer";
          }
        } else if (handleAsyncOperations instanceof Buffer) {
          processAsyncTasks = "buffer";
        } else if (streamedValues._isUint8Array(handleAsyncOperations)) {
          handleAsyncOperations = streamedValues._uint8ArrayToBuffer(
            handleAsyncOperations,
          );
          processAsyncTasks = "buffer";
        } else {
          throw new __isValidSemVerRangeResult(
            "chunk",
            ["string", "Buffer", "Uint8Array"],
            handleAsyncOperations,
          );
        }
      }
      let ______writableState;
      if (_____writableState.ending) {
        ______writableState = new evaluateAndExportModules();
      } else if (_____writableState.destroyed) {
        ______writableState = new ____isValidSemVerRangeResult("write");
      }
      if (______writableState) {
        _isValidSemVerRangeResult.nextTick(
          handleErrorsAndPushToQueue,
          ______writableState,
        );
        __processAndExportModules(
          processPromisesAndHandleErrors,
          ______writableState,
          true,
        );
        return ______writableState;
      } else {
        _____writableState.pendingcb++;
        return validateAndManageBuffer(
          processPromisesAndHandleErrors,
          _____writableState,
          handleAsyncOperations,
          processAsyncTasks,
          handleErrorsAndPushToQueue,
        );
      }
    }
    StreamHandler.prototype.write = function (
      processSignalOptions,
      validateAndProcessOptions,
      _validateAndProcessOptions,
    ) {
      return (
        processAndValidateData(
          this,
          processSignalOptions,
          validateAndProcessOptions,
          _validateAndProcessOptions,
        ) === true
      );
    };
    StreamHandler.prototype.cork = function () {
      this._writableState.corked++;
    };
    StreamHandler.prototype.uncork = function () {
      let ________________________writableState = this._writableState;
      if (________________________writableState.corked) {
        ________________________writableState.corked--;
        if (!________________________writableState.writing) {
          processBufferedCharacterSegments(
            this,
            ________________________writableState,
          );
        }
      }
    };
    StreamHandler.prototype.setDefaultEncoding = function (
      handleAbortedSignal,
    ) {
      if (typeof handleAbortedSignal == "string") {
        handleAbortedSignal = stringPrototypeToLowerCase(handleAbortedSignal);
      }
      if (!Buffer.isEncoding(handleAbortedSignal)) {
        throw new _____isValidSemVerRangeResult(handleAbortedSignal);
      }
      this._writableState.defaultEncoding = handleAbortedSignal;
      return this;
    };
    function validateAndManageBuffer(
      _____________________validateAndRetrieveIntrinsicProperties,
      ______________________validateAndRetrieveIntrinsicProperties,
      _______________________validateAndRetrieveIntrinsicProperties,
      ________________________validateAndRetrieveIntrinsicProperties,
      _________________________validateAndRetrieveIntrinsicProperties,
    ) {
      let bufferIncrement =
        ______________________validateAndRetrieveIntrinsicProperties.objectMode
          ? 1
          : _______________________validateAndRetrieveIntrinsicProperties.length;
      ______________________validateAndRetrieveIntrinsicProperties.length +=
        bufferIncrement;
      let isBufferUnderHighWaterMark =
        ______________________validateAndRetrieveIntrinsicProperties.length <
        ______________________validateAndRetrieveIntrinsicProperties.highWaterMark;
      if (!isBufferUnderHighWaterMark) {
        ______________________validateAndRetrieveIntrinsicProperties.needDrain = true;
      }
      if (
        ______________________validateAndRetrieveIntrinsicProperties.writing ||
        ______________________validateAndRetrieveIntrinsicProperties.corked ||
        ______________________validateAndRetrieveIntrinsicProperties.errored ||
        !______________________validateAndRetrieveIntrinsicProperties.constructed
      ) {
        ______________________validateAndRetrieveIntrinsicProperties.buffered.push(
          {
            chunk:
              _______________________validateAndRetrieveIntrinsicProperties,
            encoding:
              ________________________validateAndRetrieveIntrinsicProperties,
            callback:
              _________________________validateAndRetrieveIntrinsicProperties,
          },
        );
        if (
          ______________________validateAndRetrieveIntrinsicProperties.allBuffers &&
          ________________________validateAndRetrieveIntrinsicProperties !==
            "buffer"
        ) {
          ______________________validateAndRetrieveIntrinsicProperties.allBuffers = false;
        }
        if (
          ______________________validateAndRetrieveIntrinsicProperties.allNoop &&
          _________________________validateAndRetrieveIntrinsicProperties !==
            initializeApp
        ) {
          ______________________validateAndRetrieveIntrinsicProperties.allNoop = false;
        }
      } else {
        ______________________validateAndRetrieveIntrinsicProperties.writelen =
          bufferIncrement;
        ______________________validateAndRetrieveIntrinsicProperties.writecb =
          _________________________validateAndRetrieveIntrinsicProperties;
        ______________________validateAndRetrieveIntrinsicProperties.writing = true;
        ______________________validateAndRetrieveIntrinsicProperties.sync = true;
        _____________________validateAndRetrieveIntrinsicProperties._write(
          _______________________validateAndRetrieveIntrinsicProperties,
          ________________________validateAndRetrieveIntrinsicProperties,
          ______________________validateAndRetrieveIntrinsicProperties.onwrite,
        );
        ______________________validateAndRetrieveIntrinsicProperties.sync = false;
      }
      return (
        isBufferUnderHighWaterMark &&
        !______________________validateAndRetrieveIntrinsicProperties.errored &&
        !______________________validateAndRetrieveIntrinsicProperties.destroyed
      );
    }
    function processWriteOperation(
      _validateAndRetrieveProperties,
      __validateAndRetrieveProperties,
      __________________________validateAndRetrieveIntrinsicProperties,
      ___________________________validateAndRetrieveIntrinsicProperties,
      ____________________________validateAndRetrieveIntrinsicProperties,
      _____________________________validateAndRetrieveIntrinsicProperties,
      ______________________________validateAndRetrieveIntrinsicProperties,
    ) {
      __validateAndRetrieveProperties.writelen =
        ___________________________validateAndRetrieveIntrinsicProperties;
      __validateAndRetrieveProperties.writecb =
        ______________________________validateAndRetrieveIntrinsicProperties;
      __validateAndRetrieveProperties.writing = true;
      __validateAndRetrieveProperties.sync = true;
      if (__validateAndRetrieveProperties.destroyed) {
        __validateAndRetrieveProperties.onwrite(
          new ____isValidSemVerRangeResult("write"),
        );
      } else if (
        __________________________validateAndRetrieveIntrinsicProperties
      ) {
        _validateAndRetrieveProperties._writev(
          ____________________________validateAndRetrieveIntrinsicProperties,
          __validateAndRetrieveProperties.onwrite,
        );
      } else {
        _validateAndRetrieveProperties._write(
          ____________________________validateAndRetrieveIntrinsicProperties,
          _____________________________validateAndRetrieveIntrinsicProperties,
          __validateAndRetrieveProperties.onwrite,
        );
      }
      __validateAndRetrieveProperties.sync = false;
    }
    function processAndExportIntrinsicProperties(
      _______________________________validateAndRetrieveIntrinsicProperties,
      ________________________________validateAndRetrieveIntrinsicProperties,
      ___validateAndRetrieveProperties,
      _________________________________validateAndRetrieveIntrinsicProperties,
    ) {
      --________________________________validateAndRetrieveIntrinsicProperties.pendingcb;
      _________________________________validateAndRetrieveIntrinsicProperties(
        ___validateAndRetrieveProperties,
      );
      __processBufferedSegments(
        ________________________________validateAndRetrieveIntrinsicProperties,
      );
      __processAndExportModules(
        _______________________________validateAndRetrieveIntrinsicProperties,
        ___validateAndRetrieveProperties,
      );
    }
    function processDefaultReturnValue(
      defaultReturnValue,
      _defaultReturnValue,
    ) {
      let _______writableState = defaultReturnValue._writableState;
      let isWritableStateSync = _______writableState.sync;
      let writeCallback = _______writableState.writecb;
      if (typeof writeCallback != "function") {
        __processAndExportModules(
          defaultReturnValue,
          new processAndExportModulesToModuleExports(),
        );
        return;
      }
      _______writableState.writing = false;
      _______writableState.writecb = null;
      _______writableState.length -= _______writableState.writelen;
      _______writableState.writelen = 0;
      if (_defaultReturnValue) {
        _defaultReturnValue.stack;
        _______writableState.errored ||= _defaultReturnValue;
        if (
          defaultReturnValue._readableState &&
          !defaultReturnValue._readableState.errored
        ) {
          defaultReturnValue._readableState.errored = _defaultReturnValue;
        }
        if (isWritableStateSync) {
          _isValidSemVerRangeResult.nextTick(
            processAndExportIntrinsicProperties,
            defaultReturnValue,
            _______writableState,
            _defaultReturnValue,
            writeCallback,
          );
        } else {
          processAndExportIntrinsicProperties(
            defaultReturnValue,
            _______writableState,
            _defaultReturnValue,
            writeCallback,
          );
        }
      } else {
        if (
          _______writableState.buffered.length >
          _______writableState.bufferedIndex
        ) {
          processBufferedCharacterSegments(
            defaultReturnValue,
            _______writableState,
          );
        }
        if (isWritableStateSync) {
          if (
            _______writableState.afterWriteTickInfo !== null &&
            _______writableState.afterWriteTickInfo.cb === writeCallback
          ) {
            _______writableState.afterWriteTickInfo.count++;
          } else {
            _______writableState.afterWriteTickInfo = {
              count: 1,
              cb: writeCallback,
              stream: defaultReturnValue,
              state: _______writableState,
            };
            _isValidSemVerRangeResult.nextTick(
              processStreamAfterWrite,
              _______writableState.afterWriteTickInfo,
            );
          }
        } else {
          processAsyncAbortHandling(
            defaultReturnValue,
            _______writableState,
            1,
            writeCallback,
          );
        }
      }
    }
    function processStreamAfterWrite({
      stream: dataStream,
      state: processingState,
      count: processedItemCount,
      cb: _____callbackFunction,
    }) {
      processingState.afterWriteTickInfo = null;
      return processAsyncAbortHandling(
        dataStream,
        processingState,
        processedItemCount,
        _____callbackFunction,
      );
    }
    function processAsyncAbortHandling(
      handleAbortSignal,
      abortcheck_with_signal,
      _handleAbortedSignal,
      handleAbortSignalInAsyncOperation,
    ) {
      for (
        !abortcheck_with_signal.ending &&
        !handleAbortSignal.destroyed &&
        abortcheck_with_signal.length === 0 &&
        abortcheck_with_signal.needDrain &&
        ((abortcheck_with_signal.needDrain = false),
        handleAbortSignal.emit("drain"));
        _handleAbortedSignal-- > 0;

      ) {
        abortcheck_with_signal.pendingcb--;
        handleAbortSignalInAsyncOperation();
      }
      if (abortcheck_with_signal.destroyed) {
        __processBufferedSegments(abortcheck_with_signal);
      }
      ________handleVersionComparison(
        handleAbortSignal,
        abortcheck_with_signal,
      );
    }
    function __processBufferedSegments(handleSignalAndCompareSegments) {
      if (handleSignalAndCompareSegments.writing) {
        return;
      }
      for (
        let _bufferedIndex = handleSignalAndCompareSegments.bufferedIndex;
        _bufferedIndex < handleSignalAndCompareSegments.buffered.length;
        ++_bufferedIndex
      ) {
        var errorStatus;
        let { chunk: bufferChunk, callback: bufferCallback } =
          handleSignalAndCompareSegments.buffered[_bufferedIndex];
        let ____bufferLength = handleSignalAndCompareSegments.objectMode
          ? 1
          : bufferChunk.length;
        handleSignalAndCompareSegments.length -= ____bufferLength;
        bufferCallback(
          (errorStatus = handleSignalAndCompareSegments.errored) !== null &&
            errorStatus !== undefined
            ? errorStatus
            : new ____isValidSemVerRangeResult("write"),
        );
      }
      let processedExportModules =
        handleSignalAndCompareSegments[___processAndExportModules].splice(0);
      for (
        let moduleIndex = 0;
        moduleIndex < processedExportModules.length;
        moduleIndex++
      ) {
        var isSignalErred;
        processedExportModules[moduleIndex](
          (isSignalErred = handleSignalAndCompareSegments.errored) !== null &&
            isSignalErred !== undefined
            ? isSignalErred
            : new ____isValidSemVerRangeResult("end"),
        );
      }
      initializeProcessOperations(handleSignalAndCompareSegments);
    }
    function processBufferedCharacterSegments(
      compareCharacterSegmentsLogic,
      _compareCharacterSegments,
    ) {
      if (
        _compareCharacterSegments.corked ||
        _compareCharacterSegments.bufferProcessing ||
        _compareCharacterSegments.destroyed ||
        !_compareCharacterSegments.constructed
      ) {
        return;
      }
      let {
        buffered: bufferedCharacterSegments,
        bufferedIndex: bufferedIndex,
        objectMode: isObjectMode,
      } = _compareCharacterSegments;
      let remainingBufferedSegments =
        bufferedCharacterSegments.length - bufferedIndex;
      if (!remainingBufferedSegments) {
        return;
      }
      let initialBufferedIndex = bufferedIndex;
      _compareCharacterSegments.bufferProcessing = true;
      if (
        remainingBufferedSegments > 1 &&
        compareCharacterSegmentsLogic._writev
      ) {
        _compareCharacterSegments.pendingcb -= remainingBufferedSegments - 1;
        let invokeBufferedCallbacks = _compareCharacterSegments.allNoop
          ? initializeApp
          : (executeBufferedCallbacks) => {
              for (
                let currentBufferedIndex = initialBufferedIndex;
                currentBufferedIndex < bufferedCharacterSegments.length;
                ++currentBufferedIndex
              ) {
                bufferedCharacterSegments[currentBufferedIndex].callback(
                  executeBufferedCallbacks,
                );
              }
            };
        let activeBufferedSegments =
          _compareCharacterSegments.allNoop && initialBufferedIndex === 0
            ? bufferedCharacterSegments
            : ArraySlice(bufferedCharacterSegments, initialBufferedIndex);
        activeBufferedSegments.allBuffers =
          _compareCharacterSegments.allBuffers;
        processWriteOperation(
          compareCharacterSegmentsLogic,
          _compareCharacterSegments,
          true,
          _compareCharacterSegments.length,
          activeBufferedSegments,
          "",
          invokeBufferedCallbacks,
        );
        initializeProcessOperations(_compareCharacterSegments);
      } else {
        do {
          let {
            chunk: characterSegmentChunk,
            encoding: characterEncoding,
            callback: _writeCallback,
          } = bufferedCharacterSegments[initialBufferedIndex];
          bufferedCharacterSegments[initialBufferedIndex++] = null;
          let chunkLength = isObjectMode ? 1 : characterSegmentChunk.length;
          processWriteOperation(
            compareCharacterSegmentsLogic,
            _compareCharacterSegments,
            false,
            chunkLength,
            characterSegmentChunk,
            characterEncoding,
            _writeCallback,
          );
        } while (
          initialBufferedIndex < bufferedCharacterSegments.length &&
          !_compareCharacterSegments.writing
        );
        if (initialBufferedIndex === bufferedCharacterSegments.length) {
          initializeProcessOperations(_compareCharacterSegments);
        } else if (initialBufferedIndex > 256) {
          bufferedCharacterSegments.splice(0, initialBufferedIndex);
          _compareCharacterSegments.bufferedIndex = 0;
        } else {
          _compareCharacterSegments.bufferedIndex = initialBufferedIndex;
        }
      }
      _compareCharacterSegments.bufferProcessing = false;
    }
    StreamHandler.prototype._write = function (
      validateVersionRangeWithOptions,
      validateVersionRangeOptions,
      validateVersionAndOptions,
    ) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk: validateVersionRangeWithOptions,
              encoding: validateVersionRangeOptions,
            },
          ],
          validateVersionAndOptions,
        );
      } else {
        throw new __validateSemVerRange("_write()");
      }
    };
    StreamHandler.prototype._writev = null;
    StreamHandler.prototype.end = function (
      signalValidationFunction,
      abortSignalChecker,
      signalAbortChecker,
    ) {
      let ________writableState = this._writableState;
      if (typeof signalValidationFunction == "function") {
        signalAbortChecker = signalValidationFunction;
        signalValidationFunction = null;
        abortSignalChecker = null;
      } else if (typeof abortSignalChecker == "function") {
        signalAbortChecker = abortSignalChecker;
        abortSignalChecker = null;
      }
      let errorFromValidation;
      if (signalValidationFunction != null) {
        let validatedData = processAndValidateData(
          this,
          signalValidationFunction,
          abortSignalChecker,
        );
        if (validatedData instanceof ErrorClass) {
          errorFromValidation = validatedData;
        }
      }
      if (________writableState.corked) {
        ________writableState.corked = 1;
        this.uncork();
      }
      if (!errorFromValidation) {
        if (!________writableState.errored && !________writableState.ending) {
          ________writableState.ending = true;
          ________handleVersionComparison(this, ________writableState, true);
          ________writableState.ended = true;
        } else if (________writableState.finished) {
          errorFromValidation = new processAndExportModulesHandler("end");
        } else if (________writableState.destroyed) {
          errorFromValidation = new ____isValidSemVerRangeResult("end");
        }
      }
      if (typeof signalAbortChecker == "function") {
        if (errorFromValidation || ________writableState.finished) {
          _isValidSemVerRangeResult.nextTick(
            signalAbortChecker,
            errorFromValidation,
          );
        } else {
          ________writableState[___processAndExportModules].push(
            signalAbortChecker,
          );
        }
      }
      return this;
    };
    function shouldProcessVersionOperators(_evaluateVersionOperators) {
      return (
        _evaluateVersionOperators.ending &&
        !_evaluateVersionOperators.destroyed &&
        _evaluateVersionOperators.constructed &&
        _evaluateVersionOperators.length === 0 &&
        !_evaluateVersionOperators.errored &&
        _evaluateVersionOperators.buffered.length === 0 &&
        !_evaluateVersionOperators.finished &&
        !_evaluateVersionOperators.writing &&
        !_evaluateVersionOperators.errorEmitted &&
        !_evaluateVersionOperators.closeEmitted
      );
    }
    function processVersionOperators(
      __evaluateVersionOperators,
      ___evaluateVersionOperators,
    ) {
      let isProcessingVersion = false;
      function evaluateAndProcessVersionOperators(
        ____evaluateVersionOperators,
      ) {
        if (isProcessingVersion) {
          __processAndExportModules(
            __evaluateVersionOperators,
            ____evaluateVersionOperators ??
              processAndExportModulesToModuleExports(),
          );
          return;
        }
        isProcessingVersion = true;
        ___evaluateVersionOperators.pendingcb--;
        if (____evaluateVersionOperators) {
          let extractedVersionOperators =
            ___evaluateVersionOperators[___processAndExportModules].splice(0);
          for (
            let operatorFunctionIndex = 0;
            operatorFunctionIndex < extractedVersionOperators.length;
            operatorFunctionIndex++
          ) {
            extractedVersionOperators[operatorFunctionIndex](
              ____evaluateVersionOperators,
            );
          }
          __processAndExportModules(
            __evaluateVersionOperators,
            ____evaluateVersionOperators,
            ___evaluateVersionOperators.sync,
          );
        } else if (shouldProcessVersionOperators(___evaluateVersionOperators)) {
          ___evaluateVersionOperators.prefinished = true;
          __evaluateVersionOperators.emit("prefinish");
          ___evaluateVersionOperators.pendingcb++;
          _isValidSemVerRangeResult.nextTick(
            handleStreamAndFinalize,
            __evaluateVersionOperators,
            ___evaluateVersionOperators,
          );
        }
      }
      ___evaluateVersionOperators.sync = true;
      ___evaluateVersionOperators.pendingcb++;
      try {
        __evaluateVersionOperators._final(evaluateAndProcessVersionOperators);
      } catch (__________________error) {
        evaluateAndProcessVersionOperators(__________________error);
      }
      ___evaluateVersionOperators.sync = false;
    }
    function handleVersionProcessing(
      _handleVersionComparison,
      __handleVersionComparison,
    ) {
      if (
        !__handleVersionComparison.prefinished &&
        !__handleVersionComparison.finalCalled
      ) {
        if (
          typeof _handleVersionComparison._final == "function" &&
          !__handleVersionComparison.destroyed
        ) {
          __handleVersionComparison.finalCalled = true;
          processVersionOperators(
            _handleVersionComparison,
            __handleVersionComparison,
          );
        } else {
          __handleVersionComparison.prefinished = true;
          _handleVersionComparison.emit("prefinish");
        }
      }
    }
    function ________handleVersionComparison(
      handleVersionComparisonAndDestruction,
      handleVersionComparisonAndErrors,
      handleSemanticVersionComparison,
    ) {
      if (shouldProcessVersionOperators(handleVersionComparisonAndErrors)) {
        handleVersionProcessing(
          handleVersionComparisonAndDestruction,
          handleVersionComparisonAndErrors,
        );
        if (handleVersionComparisonAndErrors.pendingcb === 0) {
          if (handleSemanticVersionComparison) {
            handleVersionComparisonAndErrors.pendingcb++;
            _isValidSemVerRangeResult.nextTick(
              (
                processVersionOperatorsAndHandleStream,
                versionOperatorPayload,
              ) => {
                if (shouldProcessVersionOperators(versionOperatorPayload)) {
                  handleStreamAndFinalize(
                    processVersionOperatorsAndHandleStream,
                    versionOperatorPayload,
                  );
                } else {
                  versionOperatorPayload.pendingcb--;
                }
              },
              handleVersionComparisonAndDestruction,
              handleVersionComparisonAndErrors,
            );
          } else if (
            shouldProcessVersionOperators(handleVersionComparisonAndErrors)
          ) {
            handleVersionComparisonAndErrors.pendingcb++;
            handleStreamAndFinalize(
              handleVersionComparisonAndDestruction,
              handleVersionComparisonAndErrors,
            );
          }
        }
      }
    }
    function handleStreamAndFinalize(
      handleStreamDestructionAndVersioning,
      handleStateDestruction,
    ) {
      handleStateDestruction.pendingcb--;
      handleStateDestruction.finished = true;
      let pendingCallbacks =
        handleStateDestruction[___processAndExportModules].splice(0);
      for (
        let _callbackIndex = 0;
        _callbackIndex < pendingCallbacks.length;
        _callbackIndex++
      ) {
        pendingCallbacks[_callbackIndex]();
      }
      handleStreamDestructionAndVersioning.emit("finish");
      if (handleStateDestruction.autoDestroy) {
        let __________________________readableState =
          handleStreamDestructionAndVersioning._readableState;
        if (
          !__________________________readableState ||
          (__________________________readableState.autoDestroy &&
            (__________________________readableState.endEmitted ||
              __________________________readableState.readable === false))
        ) {
          handleStreamDestructionAndVersioning.destroy();
        }
      }
    }
    defineMultipleObjectProperties(StreamHandler.prototype, {
      closed: {
        __proto__: null,
        get() {
          if (this._writableState) {
            return this._writableState.closed;
          } else {
            return false;
          }
        },
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._writableState) {
            return this._writableState.destroyed;
          } else {
            return false;
          }
        },
        set(setIsDestroyed) {
          if (this._writableState) {
            this._writableState.destroyed = setIsDestroyed;
          }
        },
      },
      writable: {
        __proto__: null,
        get() {
          let writableStateIsValid = this._writableState;
          return (
            !!writableStateIsValid &&
            writableStateIsValid.writable !== false &&
            !writableStateIsValid.destroyed &&
            !writableStateIsValid.errored &&
            !writableStateIsValid.ending &&
            !writableStateIsValid.ended
          );
        },
        set(setWritableState) {
          if (this._writableState) {
            this._writableState.writable = !!setWritableState;
          }
        },
      },
      writableFinished: {
        __proto__: null,
        get() {
          if (this._writableState) {
            return this._writableState.finished;
          } else {
            return false;
          }
        },
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          if (this._writableState) {
            return this._writableState.objectMode;
          } else {
            return false;
          }
        },
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        },
      },
      writableEnded: {
        __proto__: null,
        get() {
          if (this._writableState) {
            return this._writableState.ending;
          } else {
            return false;
          }
        },
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          let writableStateProperties = this._writableState;
          if (writableStateProperties) {
            return (
              !writableStateProperties.destroyed &&
              !writableStateProperties.ending &&
              writableStateProperties.needDrain
            );
          } else {
            return false;
          }
        },
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        },
      },
      writableCorked: {
        __proto__: null,
        get() {
          if (this._writableState) {
            return this._writableState.corked;
          } else {
            return 0;
          }
        },
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        },
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          if (this._writableState) {
            return this._writableState.errored;
          } else {
            return null;
          }
        },
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get() {
          return (
            this._writableState.writable !== false &&
            (!!this._writableState.destroyed ||
              !!this._writableState.errored) &&
            !this._writableState.finished
          );
        },
      },
    });
    var _evaluateVersionOperatorsResult =
      evaluateVersionOperatorsResult.destroy;
    StreamHandler.prototype.destroy = function (
      ____validateAndRetrieveProperties,
      __________________________________validateAndRetrieveIntrinsicProperties,
    ) {
      let ______________________writableState = this._writableState;
      if (
        !______________________writableState.destroyed &&
        (______________________writableState.bufferedIndex <
          ______________________writableState.buffered.length ||
          ______________________writableState[___processAndExportModules]
            .length)
      ) {
        _isValidSemVerRangeResult.nextTick(
          __processBufferedSegments,
          ______________________writableState,
        );
      }
      _evaluateVersionOperatorsResult.call(
        this,
        ____validateAndRetrieveProperties,
        __________________________________validateAndRetrieveIntrinsicProperties,
      );
      return this;
    };
    StreamHandler.prototype._undestroy =
      evaluateVersionOperatorsResult.undestroy;
    StreamHandler.prototype._destroy = function (
      isStreamDestroyedOrErrored,
      initializePatternState,
    ) {
      initializePatternState(isStreamDestroyedOrErrored);
    };
    StreamHandler.prototype[_EventEmitter.captureRejectionSymbol] = function (
      streamStateHandler,
    ) {
      this.destroy(streamStateHandler);
    };
    var validateAndRetrieveSemVerRange;
    function getOrInitializeSemVerRange() {
      if (validateAndRetrieveSemVerRange === undefined) {
        validateAndRetrieveSemVerRange = {};
      }
      return validateAndRetrieveSemVerRange;
    }
    StreamHandler.fromWeb = function (_streamStateHandler, updateStreamState) {
      return getOrInitializeSemVerRange().newStreamWritableFromWritableStream(
        _streamStateHandler,
        updateStreamState,
      );
    };
    StreamHandler.toWeb = function (initializePatternWithVersionHandling) {
      return getOrInitializeSemVerRange().newWritableStreamFromStreamWritable(
        initializePatternWithVersionHandling,
      );
    };
  });
var isInputStreamFinished = conditionalModuleLoader(
  (processInputAndValidate, processBlobCreation) => {
    var isSemVerRangeValid = isValidSemVerRange();
    _validateAndRetrieveIntrinsicPropertyValue();
    var createESModuleForIntrinsicProperty = createESModule(
      _retrieveAndValidateIntrinsicProperty,
    );
    var {
      isReadable: _isReadableStream,
      isWritable: isWritableStream,
      isIterable: isIterableStream,
      isNodeStream: isNodeStream,
      isReadableNodeStream: isReadableNodeStream,
      isWritableNodeStream: isWritableNodeStream,
      isDuplexNodeStream: isDuplexNodeStream,
    } = validateAndProcessCharacterEncoding();
    var validateSemanticVersioningPrerelease = validateSemverPrerelease();
    var {
      AbortError: __AbortError,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE,
        ERR_INVALID_RETURN_VALUE: ERR_INVALID_RETURN_VALUE,
      },
    } = getNodeValueAfterTraversal();
    var { destroyer: streamDestroyer } = evaluateVersionOperators();
    var initializeAndSetupEventListeners = initializeEventListeners();
    var validateAndProcessStreamProperties = handleErrorMessages();
    var {
      createDeferredPromise: ___validateAndRetrieveIntrinsicPropertyValue,
    } = ___validateAndProcessArrayBuffer();
    var initializeStreamProcessing = formatErrorMessage();
    var validateAndInitializeStreamSetup =
      globalThis.Blob || createESModuleForIntrinsicProperty.Blob;
    var validateInputAndPrepareStream =
      typeof validateAndInitializeStreamSetup !== "undefined"
        ? function (handlePatternInitialization) {
            return (
              handlePatternInitialization instanceof
              validateAndInitializeStreamSetup
            );
          }
        : function (initializePatternConfiguration) {
            return false;
          };
    var validateAndInitializeModuleForIntrinsicProperty =
      globalThis.AbortController || _writeUint16LittleEndian().AbortController;
    var {
      FunctionPrototypeCall: ____validateAndRetrieveIntrinsicPropertyValue,
    } = executeComparisonOperation();
    var validateAndProcessStreams = class extends initializeAndSetupEventListeners {
      constructor(streamOptions) {
        super(streamOptions);
        if (streamOptions?.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (streamOptions?.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    processBlobCreation.exports = function handleModuleImport(
      initializeReaderAndEmitEvent,
      initializeModuleState,
    ) {
      if (isDuplexNodeStream(initializeReaderAndEmitEvent)) {
        return initializeReaderAndEmitEvent;
      }
      if (isReadableNodeStream(initializeReaderAndEmitEvent)) {
        return initializeStreamHandling({
          readable: initializeReaderAndEmitEvent,
        });
      }
      if (isWritableNodeStream(initializeReaderAndEmitEvent)) {
        return initializeStreamHandling({
          writable: initializeReaderAndEmitEvent,
        });
      }
      if (isNodeStream(initializeReaderAndEmitEvent)) {
        return initializeStreamHandling({
          writable: false,
          readable: false,
        });
      }
      if (typeof initializeReaderAndEmitEvent == "function") {
        let {
          value: asyncIterableStream,
          write: writeDataToStream,
          final: finalizeStreamProcessing,
          destroy: destroyStreamHandling,
        } = createAsyncIterableWithAbortHandling(initializeReaderAndEmitEvent);
        if (isIterableStream(asyncIterableStream)) {
          return initializeStreamProcessing(
            validateAndProcessStreams,
            asyncIterableStream,
            {
              objectMode: true,
              write: writeDataToStream,
              final: finalizeStreamProcessing,
              destroy: destroyStreamHandling,
            },
          );
        }
        let getStreamThenMethod = asyncIterableStream?.then;
        if (typeof getStreamThenMethod == "function") {
          let _streamProcessor;
          let validateAndRetrieveStreamValue =
            ____validateAndRetrieveIntrinsicPropertyValue(
              getStreamThenMethod,
              asyncIterableStream,
              (returnValue) => {
                if (returnValue != null) {
                  throw new ERR_INVALID_RETURN_VALUE(
                    "nully",
                    "body",
                    returnValue,
                  );
                }
              },
              (streamHelper) => {
                streamDestroyer(_streamProcessor, streamHelper);
              },
            );
          return (_streamProcessor = new validateAndProcessStreams({
            objectMode: true,
            readable: false,
            write: writeDataToStream,
            final(handleStreamFinalization) {
              finalizeStreamProcessing(async () => {
                try {
                  await validateAndRetrieveStreamValue;
                  isSemVerRangeValid.nextTick(handleStreamFinalization, null);
                } catch (_errorHandling) {
                  isSemVerRangeValid.nextTick(
                    handleStreamFinalization,
                    _errorHandling,
                  );
                }
              });
            },
            destroy: destroyStreamHandling,
          }));
        }
        throw new ERR_INVALID_RETURN_VALUE(
          "Iterable, AsyncIterable or AsyncFunction",
          initializeModuleState,
          asyncIterableStream,
        );
      }
      if (validateInputAndPrepareStream(initializeReaderAndEmitEvent)) {
        return handleModuleImport(initializeReaderAndEmitEvent.arrayBuffer());
      }
      if (isIterableStream(initializeReaderAndEmitEvent)) {
        return initializeStreamProcessing(
          validateAndProcessStreams,
          initializeReaderAndEmitEvent,
          {
            objectMode: true,
            writable: false,
          },
        );
      }
      if (
        typeof initializeReaderAndEmitEvent?.writable == "object" ||
        typeof initializeReaderAndEmitEvent?.readable == "object"
      ) {
        let _readableStream =
          initializeReaderAndEmitEvent != null &&
          initializeReaderAndEmitEvent.readable
            ? isReadableNodeStream(initializeReaderAndEmitEvent?.readable)
              ? initializeReaderAndEmitEvent?.readable
              : handleModuleImport(initializeReaderAndEmitEvent.readable)
            : undefined;
        let _writableStream =
          initializeReaderAndEmitEvent != null &&
          initializeReaderAndEmitEvent.writable
            ? isWritableNodeStream(initializeReaderAndEmitEvent?.writable)
              ? initializeReaderAndEmitEvent?.writable
              : handleModuleImport(initializeReaderAndEmitEvent.writable)
            : undefined;
        return initializeStreamHandling({
          readable: _readableStream,
          writable: _writableStream,
        });
      }
      let readerInput = initializeReaderAndEmitEvent?.then;
      if (typeof readerInput == "function") {
        let intrinsicPropertyValues;
        ____validateAndRetrieveIntrinsicPropertyValue(
          readerInput,
          initializeReaderAndEmitEvent,
          (_____________intrinsicPropertyValue) => {
            if (_____________intrinsicPropertyValue != null) {
              intrinsicPropertyValues.push(_____________intrinsicPropertyValue);
            }
            intrinsicPropertyValues.push(null);
          },
          (streamDestroyerHandler) => {
            streamDestroyer(intrinsicPropertyValues, streamDestroyerHandler);
          },
        );
        return (intrinsicPropertyValues = new validateAndProcessStreams({
          objectMode: true,
          writable: false,
          read() {},
        }));
      }
      throw new ERR_INVALID_ARG_TYPE(
        initializeModuleState,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise",
        ],
        initializeReaderAndEmitEvent,
      );
    };
    function createAsyncIterableWithAbortHandling(_getMatchingIndex) {
      let {
        promise: matchingIndexPromise,
        resolve: resolveMatchingIndexPromise,
      } = ___validateAndRetrieveIntrinsicPropertyValue();
      let asyncIterableWithAbortHandling =
        new validateAndInitializeModuleForIntrinsicProperty();
      let ______abortSignal = asyncIterableWithAbortHandling.signal;
      return {
        value: _getMatchingIndex(
          (async function* () {
            while (true) {
              let matchingIndexPromiseHandler = matchingIndexPromise;
              matchingIndexPromise = null;
              let {
                chunk: matchingIndexChunk,
                done: isMatchingIndexDone,
                cb: callbackForMatchingIndex,
              } = await matchingIndexPromiseHandler;
              isSemVerRangeValid.nextTick(callbackForMatchingIndex);
              if (isMatchingIndexDone) {
                return;
              }
              if (______abortSignal.aborted) {
                throw new __AbortError(undefined, {
                  cause: ______abortSignal.reason,
                });
              }
              ({
                promise: matchingIndexPromise,
                resolve: resolveMatchingIndexPromise,
              } = ___validateAndRetrieveIntrinsicPropertyValue());
              yield matchingIndexChunk;
            }
          })(),
          {
            signal: ______abortSignal,
          },
        ),
        write(sendChunkData, sendChunkCallback, sendChunkCompletionCallback) {
          let resolvePromiseAndSendChunk = resolveMatchingIndexPromise;
          resolveMatchingIndexPromise = null;
          resolvePromiseAndSendChunk({
            chunk: sendChunkData,
            done: false,
            cb: sendChunkCompletionCallback,
          });
        },
        final(processFinalResolution) {
          let resolveIndexAndProcessFinalResolution =
            resolveMatchingIndexPromise;
          resolveMatchingIndexPromise = null;
          resolveIndexAndProcessFinalResolution({
            done: true,
            cb: processFinalResolution,
          });
        },
        destroy(handleAbortAndDestroy, handleAbortAndDestroyCallback) {
          asyncIterableWithAbortHandling.abort();
          handleAbortAndDestroyCallback(handleAbortAndDestroy);
        },
      };
    }
    function initializeStreamHandling(setMaxListeners) {
      let readableStream =
        setMaxListeners.readable &&
        typeof setMaxListeners.readable.read != "function"
          ? validateAndProcessStreamProperties.wrap(setMaxListeners.readable)
          : setMaxListeners.readable;
      let writableStream = setMaxListeners.writable;
      let isReadableStreamInitialized = !!_isReadableStream(readableStream);
      let isWritableStreamInitialized = !!isWritableStream(writableStream);
      let __streamHandler;
      let ___streamHandler;
      let streamProcessor;
      let streamErrorHandler;
      let ____streamHandler;
      function __handleStreamError(maxListeners) {
        let currentStreamErrorHandler = streamErrorHandler;
        streamErrorHandler = null;
        if (currentStreamErrorHandler) {
          currentStreamErrorHandler(maxListeners);
        } else if (maxListeners) {
          ____streamHandler.destroy(maxListeners);
        } else if (
          !isReadableStreamInitialized &&
          !isWritableStreamInitialized
        ) {
          ____streamHandler.destroy();
        }
      }
      ____streamHandler = new validateAndProcessStreams({
        readableObjectMode:
          readableStream != null && !!readableStream.readableObjectMode,
        writableObjectMode:
          writableStream != null && !!writableStream.writableObjectMode,
        readable: isReadableStreamInitialized,
        writable: isWritableStreamInitialized,
      });
      if (isWritableStreamInitialized) {
        validateSemanticVersioningPrerelease(
          writableStream,
          (________streamHandler) => {
            isWritableStreamInitialized = false;
            if (________streamHandler) {
              streamDestroyer(readableStream, ________streamHandler);
            }
            __handleStreamError(________streamHandler);
          },
        );
        ____streamHandler._write = function (
          _setMaxListeners,
          __setMaxListeners,
          ___setMaxListeners,
        ) {
          if (writableStream.write(_setMaxListeners, __setMaxListeners)) {
            ___setMaxListeners();
          } else {
            __streamHandler = ___setMaxListeners;
          }
        };
        ____streamHandler._final = function (____setMaxListeners) {
          writableStream.end();
          ___streamHandler = ____setMaxListeners;
        };
        writableStream.on("drain", function () {
          if (__streamHandler) {
            let setStreamHandlerAndInvoke = __streamHandler;
            __streamHandler = null;
            setStreamHandlerAndInvoke();
          }
        });
        writableStream.on("finish", function () {
          if (___streamHandler) {
            let streamCleanupHandler = ___streamHandler;
            ___streamHandler = null;
            streamCleanupHandler();
          }
        });
      }
      if (isReadableStreamInitialized) {
        validateSemanticVersioningPrerelease(
          readableStream,
          (_streamErrorHandler) => {
            isReadableStreamInitialized = false;
            if (_streamErrorHandler) {
              streamDestroyer(readableStream, _streamErrorHandler);
            }
            __handleStreamError(_streamErrorHandler);
          },
        );
        readableStream.on("readable", function () {
          if (streamProcessor) {
            let executeStreamProcessor = streamProcessor;
            streamProcessor = null;
            executeStreamProcessor();
          }
        });
        readableStream.on("end", function () {
          ____streamHandler.push(null);
        });
        ____streamHandler._read = function () {
          while (true) {
            let readableData = readableStream.read();
            if (readableData === null) {
              streamProcessor = ____streamHandler._read;
              return;
            }
            if (!____streamHandler.push(readableData)) {
              return;
            }
          }
        };
      }
      ____streamHandler._destroy = function (
        _handleVersionComparisonWorker,
        __handleVersionComparisonWorker,
      ) {
        if (!_handleVersionComparisonWorker && streamErrorHandler !== null) {
          _handleVersionComparisonWorker = new __AbortError();
        }
        streamProcessor = null;
        __streamHandler = null;
        ___streamHandler = null;
        if (streamErrorHandler === null) {
          __handleVersionComparisonWorker(_handleVersionComparisonWorker);
        } else {
          streamErrorHandler = __handleVersionComparisonWorker;
          streamDestroyer(writableStream, _handleVersionComparisonWorker);
          streamDestroyer(readableStream, _handleVersionComparisonWorker);
        }
      };
      return ____streamHandler;
    }
  },
);
var initializeEventListeners = conditionalModuleLoader(
  (createCustomErrorHandler, customErrorHandler) => {
    var {
      ObjectDefineProperties: __defineObjectProperties,
      ObjectGetOwnPropertyDescriptor: ObjectGetOwnPropertyDescriptor,
      ObjectKeys: _getObjectKeys,
      ObjectSetPrototypeOf: _setPrototypeOf,
    } = executeComparisonOperation();
    customErrorHandler.exports = VersionComparisonHandler;
    var __errorHandler = handleErrorMessages();
    var _________________________________________validateAndRetrieveIntrinsicProperties =
      ___________________validateAndRetrieveIntrinsicProperties();
    _setPrototypeOf(
      VersionComparisonHandler.prototype,
      __errorHandler.prototype,
    );
    _setPrototypeOf(VersionComparisonHandler, __errorHandler);
    {
      let intrinsicPropertyKeys = _getObjectKeys(
        _________________________________________validateAndRetrieveIntrinsicProperties.prototype,
      );
      for (
        let intrinsicPropertyIndex = 0;
        intrinsicPropertyIndex < intrinsicPropertyKeys.length;
        intrinsicPropertyIndex++
      ) {
        let intrinsicPropertyKey =
          intrinsicPropertyKeys[intrinsicPropertyIndex];
        VersionComparisonHandler.prototype[intrinsicPropertyKey] ||=
          _________________________________________validateAndRetrieveIntrinsicProperties.prototype[
            intrinsicPropertyKey
          ];
      }
    }
    function VersionComparisonHandler(handleVersionComparisonEvent) {
      if (!(this instanceof VersionComparisonHandler)) {
        return new VersionComparisonHandler(handleVersionComparisonEvent);
      }
      __errorHandler.call(this, handleVersionComparisonEvent);
      _________________________________________validateAndRetrieveIntrinsicProperties.call(
        this,
        handleVersionComparisonEvent,
      );
      if (handleVersionComparisonEvent) {
        this.allowHalfOpen =
          handleVersionComparisonEvent.allowHalfOpen !== false;
        if (handleVersionComparisonEvent.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (handleVersionComparisonEvent.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    __defineObjectProperties(VersionComparisonHandler.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(
          _________________________________________validateAndRetrieveIntrinsicProperties.prototype,
          "writable",
        ),
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(
          _________________________________________validateAndRetrieveIntrinsicProperties.prototype,
          "writableHighWaterMark",
        ),
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(
          _________________________________________validateAndRetrieveIntrinsicProperties.prototype,
          "writableObjectMode",
        ),
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(
          _________________________________________validateAndRetrieveIntrinsicProperties.prototype,
          "writableBuffer",
        ),
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(
          _________________________________________validateAndRetrieveIntrinsicProperties.prototype,
          "writableLength",
        ),
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(
          _________________________________________validateAndRetrieveIntrinsicProperties.prototype,
          "writableFinished",
        ),
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(
          _________________________________________validateAndRetrieveIntrinsicProperties.prototype,
          "writableCorked",
        ),
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(
          _________________________________________validateAndRetrieveIntrinsicProperties.prototype,
          "writableEnded",
        ),
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(
          _________________________________________validateAndRetrieveIntrinsicProperties.prototype,
          "writableNeedDrain",
        ),
      },
      destroyed: {
        __proto__: null,
        get() {
          if (
            this._readableState === undefined ||
            this._writableState === undefined
          ) {
            return false;
          } else {
            return (
              this._readableState.destroyed && this._writableState.destroyed
            );
          }
        },
        set(_setStreamDestroyedState) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = _setStreamDestroyedState;
            this._writableState.destroyed = _setStreamDestroyedState;
          }
        },
      },
    });
    var ___errorHandler;
    function getErrorHandler() {
      if (___errorHandler === undefined) {
        ___errorHandler = {};
      }
      return ___errorHandler;
    }
    VersionComparisonHandler.fromWeb = function (
      processBlobDownloadListener,
      removeEventListener,
    ) {
      return getErrorHandler().newStreamDuplexFromReadableWritablePair(
        processBlobDownloadListener,
        removeEventListener,
      );
    };
    VersionComparisonHandler.toWeb = function (eventListenerWrapper) {
      return getErrorHandler().newReadableWritablePairFromDuplex(
        eventListenerWrapper,
      );
    };
    var defineAndExtendErrorProperties;
    VersionComparisonHandler.from = function (
      removeEventListenerForFileProcessing,
    ) {
      defineAndExtendErrorProperties ||= isInputStreamFinished();
      return defineAndExtendErrorProperties(
        removeEventListenerForFileProcessing,
        "body",
      );
    };
  },
);
var _removeEventListener = conditionalModuleLoader(
  (createCustomReadableStream, initializeCustomReadableStream) => {
    var {
      ObjectSetPrototypeOf: setPrototypeProperties,
      Symbol: symbolCallbackKey,
    } = executeComparisonOperation();
    initializeCustomReadableStream.exports = createStreamHandler;
    var { ERR_METHOD_NOT_IMPLEMENTED: ERR_METHOD_NOT_IMPLEMENTED } =
      getNodeValueAfterTraversal().codes;
    var eventListeners = initializeEventListeners();
    var { getHighWaterMark: getHighWaterMark } = errorStackTrace();
    setPrototypeProperties(
      createStreamHandler.prototype,
      eventListeners.prototype,
    );
    setPrototypeProperties(createStreamHandler, eventListeners);
    var callbackSymbol = symbolCallbackKey("kCallback");
    function createStreamHandler(__removeEventListener) {
      if (!(this instanceof createStreamHandler)) {
        return new createStreamHandler(__removeEventListener);
      }
      let highWaterMark = __removeEventListener
        ? getHighWaterMark(
            this,
            __removeEventListener,
            "readableHighWaterMark",
            true,
          )
        : null;
      if (highWaterMark === 0) {
        __removeEventListener = {
          ...__removeEventListener,
          highWaterMark: null,
          readableHighWaterMark: highWaterMark,
          writableHighWaterMark:
            __removeEventListener.writableHighWaterMark || 0,
        };
      }
      eventListeners.call(this, __removeEventListener);
      this._readableState.sync = false;
      this[callbackSymbol] = null;
      if (__removeEventListener) {
        if (typeof __removeEventListener.transform == "function") {
          this._transform = __removeEventListener.transform;
        }
        if (typeof __removeEventListener.flush == "function") {
          this._flush = __removeEventListener.flush;
        }
      }
      this.on("prefinish", executeFlushIfNeeded);
    }
    function handleFlushProcess(removeListenerByEvent) {
      if (typeof this._flush == "function" && !this.destroyed) {
        this._flush((eventOrListener, listenerOrData) => {
          if (eventOrListener) {
            if (removeListenerByEvent) {
              removeListenerByEvent(eventOrListener);
            } else {
              this.destroy(eventOrListener);
            }
            return;
          }
          if (listenerOrData != null) {
            this.push(listenerOrData);
          }
          this.push(null);
          if (removeListenerByEvent) {
            removeListenerByEvent();
          }
        });
      } else {
        this.push(null);
        if (removeListenerByEvent) {
          removeListenerByEvent();
        }
      }
    }
    function executeFlushIfNeeded() {
      if (this._final !== handleFlushProcess) {
        handleFlushProcess.call(this);
      }
    }
    createStreamHandler.prototype._final = handleFlushProcess;
    createStreamHandler.prototype._transform = function (
      handleEventCleanup,
      removeAllEventListeners,
      removePostLogMessageListener,
    ) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    createStreamHandler.prototype._write = function (
      ___removeEventListener,
      handleEventRemoval,
      eventEmitter,
    ) {
      let ____________readableState = this._readableState;
      let ______________writableState = this._writableState;
      let readableStateLength = ____________readableState.length;
      this._transform(
        ___removeEventListener,
        handleEventRemoval,
        (handleEventOrPushData, dataToPush) => {
          if (handleEventOrPushData) {
            eventEmitter(handleEventOrPushData);
            return;
          }
          if (dataToPush != null) {
            this.push(dataToPush);
          }
          if (
            ______________writableState.ended ||
            readableStateLength === ____________readableState.length ||
            ____________readableState.length <
              ____________readableState.highWaterMark
          ) {
            eventEmitter();
          } else {
            this[callbackSymbol] = eventEmitter;
          }
        },
      );
    };
    createStreamHandler.prototype._read = function () {
      if (this[callbackSymbol]) {
        let executeCallback = this[callbackSymbol];
        this[callbackSymbol] = null;
        executeCallback();
      }
    };
  },
);
var ____removeEventListener = conditionalModuleLoader(
  (_createEventListenerHandler, eventListenerModule) => {
    var { ObjectSetPrototypeOf: __setPrototypeOf } =
      executeComparisonOperation();
    eventListenerModule.exports = _EventListenerManager;
    var EventListenerBase = _removeEventListener();
    __setPrototypeOf(
      _EventListenerManager.prototype,
      EventListenerBase.prototype,
    );
    __setPrototypeOf(_EventListenerManager, EventListenerBase);
    function _EventListenerManager(removeEventListeners) {
      if (!(this instanceof _EventListenerManager)) {
        return new _EventListenerManager(removeEventListeners);
      }
      EventListenerBase.call(this, removeEventListeners);
    }
    _EventListenerManager.prototype._transform = function (
      postLogMessageListener,
      f270_getEventListeners,
      getListenersForEvent,
    ) {
      getListenersForEvent(null, postLogMessageListener);
    };
  },
);
var getEventListeners = conditionalModuleLoader(
  (
    validateSemVerRangesAndInitializeListeners,
    initializeSemVerValidationAndListeners,
  ) => {
    var ______isValidSemVerRangeResult = isValidSemVerRange();
    var {
      ArrayIsArray: isArray,
      Promise: PromiseExecutor,
      SymbolAsyncIterator: asyncIteratorSymbol,
    } = executeComparisonOperation();
    var ____validateSemverPrerelease = validateSemverPrerelease();
    var { once: registerSingleEventListener } =
      ___validateAndProcessArrayBuffer();
    var _______evaluateVersionOperators = evaluateVersionOperators();
    var __initializeEventListeners = initializeEventListeners();
    var {
      aggregateTwoErrors: aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE: ERROR_INVALID_ARGUMENT_TYPE,
        ERR_INVALID_RETURN_VALUE: ERROR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS: ERROR_MISSING_ARGUMENTS,
        ERR_STREAM_DESTROYED: ERROR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE: ERROR_STREAM_PREMATURE_CLOSE,
      },
      AbortError: _AbortError,
    } = getNodeValueAfterTraversal();
    var {
      validateFunction: _______isValidSemVerRangeResult,
      validateAbortSignal: _validateSemVerRangesAndInitializeListeners,
    } = updateMaxAgeSetting();
    var {
      isIterable: validateSemVerAndInitializeListeners,
      isReadable: validateSemVerRangesResult,
      isReadableNodeStream: __validateSemVerRangesAndInitializeListeners,
      isNodeStream: validateSemVerRangeResult,
    } = validateAndProcessCharacterEncoding();
    var _validateSemVerRangeResult =
      globalThis.AbortController || _writeUint16LittleEndian().AbortController;
    var validateSemanticVersioningAndSetupEventListeners;
    var ________isValidSemVerRangeResult;
    function _initializeEventListener(
      getEventListenerCount,
      _getEventListenerCount,
      getListenerCount,
    ) {
      let isListenerClosed = false;
      getEventListenerCount.on("close", () => {
        isListenerClosed = true;
      });
      let validatedSemverPrerelease = ____validateSemverPrerelease(
        getEventListenerCount,
        {
          readable: _getEventListenerCount,
          writable: getListenerCount,
        },
        (isListenerClosedByDefault) => {
          isListenerClosed = !isListenerClosedByDefault;
        },
      );
      return {
        destroy: (handleListenerClosure) => {
          if (!isListenerClosed) {
            isListenerClosed = true;
            _______evaluateVersionOperators.destroyer(
              getEventListenerCount,
              handleListenerClosure || new ERROR_STREAM_DESTROYED("pipe"),
            );
          }
        },
        cleanup: validatedSemverPrerelease,
      };
    }
    function getLastEventListener(_getEventListeners) {
      _______isValidSemVerRangeResult(
        _getEventListeners[_getEventListeners.length - 1],
        "streams[stream.length - 1]",
      );
      return _getEventListeners.pop();
    }
    function processPassengerHeader(processPaxHeader) {
      if (validateSemVerAndInitializeListeners(processPaxHeader)) {
        return processPaxHeader;
      }
      if (__validateSemVerRangesAndInitializeListeners(processPaxHeader)) {
        return handleAsyncListeners(processPaxHeader);
      }
      throw new ERROR_INVALID_ARGUMENT_TYPE(
        "val",
        ["Readable", "Iterable", "AsyncIterable"],
        processPaxHeader,
      );
    }
    async function* handleAsyncListeners(removeAndShiftListeners) {
      ________isValidSemVerRangeResult ||= handleErrorMessages();
      yield* ________isValidSemVerRangeResult.prototype[
        asyncIteratorSymbol
      ].call(removeAndShiftListeners);
    }
    async function processVersionWithPrerelease(
      ________compareVersionWithPrerelease,
      compareVersionAndRemoveListener,
      compareVersionWithPrereleaseListener,
      { end: endFunction },
    ) {
      let latestReceivedValue;
      let pendingPrereleaseCallback = null;
      let handlePrereleaseValue = (receivedValueHandler) => {
        if (receivedValueHandler) {
          latestReceivedValue = receivedValueHandler;
        }
        if (pendingPrereleaseCallback) {
          let executePendingPrereleaseCallback = pendingPrereleaseCallback;
          pendingPrereleaseCallback = null;
          executePendingPrereleaseCallback();
        }
      };
      let createPendingPrereleasePromise = () =>
        new PromiseExecutor(
          (handleCallbackWithLatestValue, invokeCallbackWithValue) => {
            if (latestReceivedValue) {
              invokeCallbackWithValue(latestReceivedValue);
            } else {
              pendingPrereleaseCallback = () => {
                if (latestReceivedValue) {
                  invokeCallbackWithValue(latestReceivedValue);
                } else {
                  handleCallbackWithLatestValue();
                }
              };
            }
          },
        );
      compareVersionAndRemoveListener.on("drain", handlePrereleaseValue);
      let validatePrereleaseVersion = ____validateSemverPrerelease(
        compareVersionAndRemoveListener,
        {
          readable: false,
        },
        handlePrereleaseValue,
      );
      try {
        if (compareVersionAndRemoveListener.writableNeedDrain) {
          await createPendingPrereleasePromise();
        }
        for await (let ___prereleaseVersion of ________compareVersionWithPrerelease) {
          if (!compareVersionAndRemoveListener.write(___prereleaseVersion)) {
            await createPendingPrereleasePromise();
          }
        }
        if (endFunction) {
          compareVersionAndRemoveListener.end();
        }
        await createPendingPrereleasePromise();
        compareVersionWithPrereleaseListener();
      } catch (_errorCaught) {
        compareVersionWithPrereleaseListener(
          latestReceivedValue !== _errorCaught
            ? aggregateTwoErrors(latestReceivedValue, _errorCaught)
            : _errorCaught,
        );
      } finally {
        validatePrereleaseVersion();
        compareVersionAndRemoveListener.off("drain", handlePrereleaseValue);
      }
    }
    function validateAndRegisterEventListener(...eventListenerDetails) {
      return compareAndValidateVersions(
        eventListenerDetails,
        registerSingleEventListener(getLastEventListener(eventListenerDetails)),
      );
    }
    function compareAndValidateVersions(
      _________compareVersionWithPrerelease,
      validateVersionAndHandlePrerelease,
      ___handleVersionComparison,
    ) {
      if (
        _________compareVersionWithPrerelease.length === 1 &&
        isArray(_________compareVersionWithPrerelease[0])
      ) {
        _________compareVersionWithPrerelease =
          _________compareVersionWithPrerelease[0];
      }
      if (_________compareVersionWithPrerelease.length < 2) {
        throw new ERROR_MISSING_ARGUMENTS("streams");
      }
      let semverValidationResult = new _validateSemVerRangeResult();
      let semverValidationSignal = semverValidationResult.signal;
      let versionComparisonSignal = ___handleVersionComparison?.signal;
      let versionComparisonResults = [];
      _validateSemVerRangesAndInitializeListeners(
        versionComparisonSignal,
        "options.signal",
      );
      function _handleAbortError() {
        processVersionComparison(new _AbortError());
      }
      versionComparisonSignal?.addEventListener("abort", _handleAbortError);
      let _versionComparisonResults;
      let versionComparisonHandler;
      let __versionComparisonResults = [];
      let versionComparisonParams = 0;
      function handleProcessVersionComparison(processEventEmitter) {
        processVersionComparison(
          processEventEmitter,
          --versionComparisonParams === 0,
        );
      }
      function processVersionComparison(processEventListener, processEvents) {
        if (
          processEventListener &&
          (!_versionComparisonResults ||
            _versionComparisonResults.code === "ERR_STREAM_PREMATURE_CLOSE")
        ) {
          _versionComparisonResults = processEventListener;
        }
        if (!!_versionComparisonResults || !!processEvents) {
          while (__versionComparisonResults.length) {
            __versionComparisonResults.shift()(_versionComparisonResults);
          }
          versionComparisonSignal?.removeEventListener(
            "abort",
            _handleAbortError,
          );
          semverValidationResult.abort();
          if (processEvents) {
            if (!_versionComparisonResults) {
              versionComparisonResults.forEach((calculateTotalPrice) =>
                calculateTotalPrice(),
              );
            }
            ______isValidSemVerRangeResult.nextTick(
              validateVersionAndHandlePrerelease,
              _versionComparisonResults,
              versionComparisonHandler,
            );
          }
        }
      }
      let compareAndValidateVersionRanges;
      for (
        let currentVersionIndex = 0;
        currentVersionIndex < _________compareVersionWithPrerelease.length;
        currentVersionIndex++
      ) {
        let _currentVersion =
          _________compareVersionWithPrerelease[currentVersionIndex];
        let isNextVersionAvailable =
          currentVersionIndex <
          _________compareVersionWithPrerelease.length - 1;
        let isCurrentVersionStable = currentVersionIndex > 0;
        let isVersionComparisonNeeded =
          isNextVersionAvailable || ___handleVersionComparison?.end !== false;
        let isCurrentVersionLatest =
          currentVersionIndex ===
          _________compareVersionWithPrerelease.length - 1;
        if (validateSemVerRangeResult(_currentVersion)) {
          let handleVersionError = function (_processSectionedValues) {
            if (
              _processSectionedValues &&
              _processSectionedValues.name !== "AbortError" &&
              _processSectionedValues.code !== "ERR_STREAM_PREMATURE_CLOSE"
            ) {
              handleProcessVersionComparison(_processSectionedValues);
            }
          };
          var _handleVersionError = handleVersionError;
          if (isVersionComparisonNeeded) {
            let {
              destroy: destroyEventListener,
              cleanup: cleanupEventListener,
            } = _initializeEventListener(
              _currentVersion,
              isNextVersionAvailable,
              isCurrentVersionStable,
            );
            __versionComparisonResults.push(destroyEventListener);
            if (
              validateSemVerRangesResult(_currentVersion) &&
              isCurrentVersionLatest
            ) {
              versionComparisonResults.push(cleanupEventListener);
            }
          }
          _currentVersion.on("error", handleVersionError);
          if (
            validateSemVerRangesResult(_currentVersion) &&
            isCurrentVersionLatest
          ) {
            versionComparisonResults.push(() => {
              _currentVersion.removeListener("error", handleVersionError);
            });
          }
        }
        if (currentVersionIndex === 0) {
          if (typeof _currentVersion == "function") {
            compareAndValidateVersionRanges = _currentVersion({
              signal: semverValidationSignal,
            });
            if (
              !validateSemVerAndInitializeListeners(
                compareAndValidateVersionRanges,
              )
            ) {
              throw new ERROR_INVALID_RETURN_VALUE(
                "Iterable, AsyncIterable or Stream",
                "source",
                compareAndValidateVersionRanges,
              );
            }
          } else if (
            validateSemVerAndInitializeListeners(_currentVersion) ||
            __validateSemVerRangesAndInitializeListeners(_currentVersion)
          ) {
            compareAndValidateVersionRanges = _currentVersion;
          } else {
            compareAndValidateVersionRanges =
              __initializeEventListeners.from(_currentVersion);
          }
        } else if (typeof _currentVersion == "function") {
          compareAndValidateVersionRanges = processPassengerHeader(
            compareAndValidateVersionRanges,
          );
          compareAndValidateVersionRanges = _currentVersion(
            compareAndValidateVersionRanges,
            {
              signal: semverValidationSignal,
            },
          );
          if (isNextVersionAvailable) {
            if (
              !validateSemVerAndInitializeListeners(
                compareAndValidateVersionRanges,
                true,
              )
            ) {
              throw new ERROR_INVALID_RETURN_VALUE(
                "AsyncIterable",
                "transform[" + (currentVersionIndex - 1) + "]",
                compareAndValidateVersionRanges,
              );
            }
          } else {
            var activeVersionComparisonPromise;
            validateSemanticVersioningAndSetupEventListeners ||=
              ____removeEventListener();
            let versionValidationStream =
              new validateSemanticVersioningAndSetupEventListeners({
                objectMode: true,
              });
            let activeVersionComparisonHandler =
              (activeVersionComparisonPromise =
                compareAndValidateVersionRanges) === null ||
              activeVersionComparisonPromise === undefined
                ? undefined
                : activeVersionComparisonPromise.then;
            if (typeof activeVersionComparisonHandler == "function") {
              versionComparisonParams++;
              activeVersionComparisonHandler.call(
                compareAndValidateVersionRanges,
                (versionComparisonFunc) => {
                  versionComparisonHandler = versionComparisonFunc;
                  if (versionComparisonFunc != null) {
                    versionValidationStream.write(versionComparisonFunc);
                  }
                  if (isVersionComparisonNeeded) {
                    versionValidationStream.end();
                  }
                  ______isValidSemVerRangeResult.nextTick(
                    handleProcessVersionComparison,
                  );
                },
                (versionValidationStreamHandler) => {
                  versionValidationStream.destroy(
                    versionValidationStreamHandler,
                  );
                  ______isValidSemVerRangeResult.nextTick(
                    handleProcessVersionComparison,
                    versionValidationStreamHandler,
                  );
                },
              );
            } else if (
              validateSemVerAndInitializeListeners(
                compareAndValidateVersionRanges,
                true,
              )
            ) {
              versionComparisonParams++;
              processVersionWithPrerelease(
                compareAndValidateVersionRanges,
                versionValidationStream,
                handleProcessVersionComparison,
                {
                  end: isVersionComparisonNeeded,
                },
              );
            } else {
              throw new ERROR_INVALID_RETURN_VALUE(
                "AsyncIterable or Promise",
                "destination",
                compareAndValidateVersionRanges,
              );
            }
            compareAndValidateVersionRanges = versionValidationStream;
            let {
              destroy: activeVersionPromiseHandler,
              cleanup: ___versionComparisonHandler,
            } = _initializeEventListener(
              compareAndValidateVersionRanges,
              false,
              true,
            );
            __versionComparisonResults.push(activeVersionPromiseHandler);
            if (isCurrentVersionLatest) {
              versionComparisonResults.push(___versionComparisonHandler);
            }
          }
        } else if (validateSemVerRangeResult(_currentVersion)) {
          if (
            __validateSemVerRangesAndInitializeListeners(
              compareAndValidateVersionRanges,
            )
          ) {
            versionComparisonParams += 2;
            let _versionComparisonResult = handleAbortSignalAndStream(
              compareAndValidateVersionRanges,
              _currentVersion,
              handleProcessVersionComparison,
              {
                end: isVersionComparisonNeeded,
              },
            );
            if (
              validateSemVerRangesResult(_currentVersion) &&
              isCurrentVersionLatest
            ) {
              versionComparisonResults.push(_versionComparisonResult);
            }
          } else if (
            validateSemVerAndInitializeListeners(
              compareAndValidateVersionRanges,
            )
          ) {
            versionComparisonParams++;
            processVersionWithPrerelease(
              compareAndValidateVersionRanges,
              _currentVersion,
              handleProcessVersionComparison,
              {
                end: isVersionComparisonNeeded,
              },
            );
          } else {
            throw new ERROR_INVALID_ARGUMENT_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable"],
              compareAndValidateVersionRanges,
            );
          }
          compareAndValidateVersionRanges = _currentVersion;
        } else {
          compareAndValidateVersionRanges =
            __initializeEventListeners.from(_currentVersion);
        }
      }
      if (
        (semverValidationSignal != null && semverValidationSignal.aborted) ||
        (versionComparisonSignal != null && versionComparisonSignal.aborted)
      ) {
        ______isValidSemVerRangeResult.nextTick(_handleAbortError);
      }
      return compareAndValidateVersionRanges;
    }
    function handleAbortSignalAndStream(
      _validateAbortSignal,
      __validateAbortSignal,
      ___validateAbortSignal,
      { end: endTime },
    ) {
      let _isStreamClosed = false;
      __validateAbortSignal.on("close", () => {
        if (!_isStreamClosed) {
          ___validateAbortSignal(new ERROR_STREAM_PREMATURE_CLOSE());
        }
      });
      _validateAbortSignal.pipe(__validateAbortSignal, {
        end: endTime,
      });
      if (endTime) {
        _validateAbortSignal.once("end", () => {
          _isStreamClosed = true;
          __validateAbortSignal.end();
        });
      } else {
        ___validateAbortSignal();
      }
      ____validateSemverPrerelease(
        _validateAbortSignal,
        {
          readable: true,
          writable: false,
        },
        (handleStreamPrematureCloseEvent) => {
          let __readableStreamState = _validateAbortSignal._readableState;
          if (
            handleStreamPrematureCloseEvent &&
            handleStreamPrematureCloseEvent.code ===
              "ERR_STREAM_PREMATURE_CLOSE" &&
            __readableStreamState &&
            __readableStreamState.ended &&
            !__readableStreamState.errored &&
            !__readableStreamState.errorEmitted
          ) {
            _validateAbortSignal
              .once("end", ___validateAbortSignal)
              .once("error", ___validateAbortSignal);
          } else {
            ___validateAbortSignal(handleStreamPrematureCloseEvent);
          }
        },
      );
      return ____validateSemverPrerelease(
        __validateAbortSignal,
        {
          readable: false,
          writable: true,
        },
        ___validateAbortSignal,
      );
    }
    initializeSemVerValidationAndListeners.exports = {
      pipelineImpl: compareAndValidateVersions,
      pipeline: validateAndRegisterEventListener,
    };
  },
);
var handleAbortEvent = conditionalModuleLoader(
  (handleStreamInput, handleStreamOutput) => {
    var { pipeline: createPipeline } = getEventListeners();
    var __eventListenerInitializer = initializeEventListeners();
    var { destroyer: _streamDestroyer } = evaluateVersionOperators();
    var {
      isNodeStream: isStreamNode,
      isReadable: ___isReadableStream,
      isWritable: __isWritableStream,
    } = validateAndProcessCharacterEncoding();
    var {
      AbortError: _____AbortError,
      codes: {
        ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE,
        ERR_MISSING_ARGS: ERR_MISSING_ARGS,
      },
    } = getNodeValueAfterTraversal();
    handleStreamOutput.exports = function (...validateStreams) {
      if (validateStreams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (validateStreams.length === 1) {
        return __eventListenerInitializer.from(validateStreams[0]);
      }
      let streamArray = [...validateStreams];
      if (typeof validateStreams[0] == "function") {
        validateStreams[0] = __eventListenerInitializer.from(
          validateStreams[0],
        );
      }
      if (typeof validateStreams[validateStreams.length - 1] == "function") {
        let lastValidatedStreamIndex = validateStreams.length - 1;
        validateStreams[lastValidatedStreamIndex] =
          __eventListenerInitializer.from(
            validateStreams[lastValidatedStreamIndex],
          );
      }
      for (
        let _streamIndex = 0;
        _streamIndex < validateStreams.length;
        ++_streamIndex
      ) {
        if (isStreamNode(validateStreams[_streamIndex])) {
          if (
            _streamIndex < validateStreams.length - 1 &&
            !___isReadableStream(validateStreams[_streamIndex])
          ) {
            throw new ERR_INVALID_ARG_VALUE(
              "streams[" + _streamIndex + "]",
              streamArray[_streamIndex],
              "must be readable",
            );
          }
          if (
            _streamIndex > 0 &&
            !__isWritableStream(validateStreams[_streamIndex])
          ) {
            throw new ERR_INVALID_ARG_VALUE(
              "streams[" + _streamIndex + "]",
              streamArray[_streamIndex],
              "must be writable",
            );
          }
        }
      }
      let lastFunctionArgument;
      let streamIndex;
      let indexOfLastFunctionArgument;
      let lastFunction;
      let lastStreamIndex;
      function handlePushToTail(pushToTail) {
        let previousFunction = lastFunction;
        lastFunction = null;
        if (previousFunction) {
          previousFunction(pushToTail);
        } else if (pushToTail) {
          lastStreamIndex.destroy(pushToTail);
        } else if (!lastFunctionIndex && !_lastStreamIndex) {
          lastStreamIndex.destroy();
        }
      }
      let streamValidationHandler = validateStreams[0];
      let validateAndInitializeStreams = createPipeline(
        validateStreams,
        handlePushToTail,
      );
      let _lastStreamIndex = !!__isWritableStream(streamValidationHandler);
      let lastFunctionIndex = !!___isReadableStream(
        validateAndInitializeStreams,
      );
      lastStreamIndex = new __eventListenerInitializer({
        writableObjectMode:
          streamValidationHandler != null &&
          !!streamValidationHandler.writableObjectMode,
        readableObjectMode:
          validateAndInitializeStreams != null &&
          !!validateAndInitializeStreams.writableObjectMode,
        writable: _lastStreamIndex,
        readable: lastFunctionIndex,
      });
      if (_lastStreamIndex) {
        lastStreamIndex._write = function (
          concatBuffer,
          concatBuffers,
          consumeData,
        ) {
          if (streamValidationHandler.write(concatBuffer, concatBuffers)) {
            consumeData();
          } else {
            lastFunctionArgument = consumeData;
          }
        };
        lastStreamIndex._final = function (allocateBufferFromLinkedListData) {
          streamValidationHandler.end();
          streamIndex = allocateBufferFromLinkedListData;
        };
        streamValidationHandler.on("drain", function () {
          if (lastFunctionArgument) {
            let executeLastFunctionArgument = lastFunctionArgument;
            lastFunctionArgument = null;
            executeLastFunctionArgument();
          }
        });
        validateAndInitializeStreams.on("finish", function () {
          if (streamIndex) {
            let resetStreamIndex = streamIndex;
            streamIndex = null;
            resetStreamIndex();
          }
        });
      }
      if (lastFunctionIndex) {
        validateAndInitializeStreams.on("readable", function () {
          if (indexOfLastFunctionArgument) {
            let _executeLastFunctionArgument = indexOfLastFunctionArgument;
            indexOfLastFunctionArgument = null;
            _executeLastFunctionArgument();
          }
        });
        validateAndInitializeStreams.on("end", function () {
          lastStreamIndex.push(null);
        });
        lastStreamIndex._read = function () {
          while (true) {
            let initializedStream = validateAndInitializeStreams.read();
            if (initializedStream === null) {
              indexOfLastFunctionArgument = lastStreamIndex._read;
              return;
            }
            if (!lastStreamIndex.push(initializedStream)) {
              return;
            }
          }
        };
      }
      lastStreamIndex._destroy = function (
        appendDataToBuffer,
        processDataAndUpdateBuffer,
      ) {
        if (!appendDataToBuffer && lastFunction !== null) {
          appendDataToBuffer = new _____AbortError();
        }
        indexOfLastFunctionArgument = null;
        lastFunctionArgument = null;
        streamIndex = null;
        if (lastFunction === null) {
          processDataAndUpdateBuffer(appendDataToBuffer);
        } else {
          lastFunction = processDataAndUpdateBuffer;
          _streamDestroyer(validateAndInitializeStreams, appendDataToBuffer);
        }
      };
      return lastStreamIndex;
    };
  },
);
var appendToBuffer = conditionalModuleLoader(
  (processPipelineWithSignal, _processPipelineWithSignal) => {
    var {
      ArrayPrototypePop: extractLastArgument,
      Promise: PromiseConstructor,
    } = executeComparisonOperation();
    var { isIterable: isObjectIterable, isNodeStream: isStream } =
      validateAndProcessCharacterEncoding();
    var { pipelineImpl: pipelineFunction } = getEventListeners();
    var { finished: completedPromise } = validateSemverPrerelease();
    function executePipelineWithSignal(...executePipelineWithSignalAndOptions) {
      return new PromiseConstructor(
        (handlePipelineResult, handlePipelineError) => {
          let pipelineSignalAndEndOptions;
          let pipelineEndOption;
          let lastPipelineResult =
            executePipelineWithSignalAndOptions[
              executePipelineWithSignalAndOptions.length - 1
            ];
          if (
            lastPipelineResult &&
            typeof lastPipelineResult == "object" &&
            !isStream(lastPipelineResult) &&
            !isObjectIterable(lastPipelineResult)
          ) {
            let pipelineExecutionResult = extractLastArgument(
              executePipelineWithSignalAndOptions,
            );
            pipelineSignalAndEndOptions = pipelineExecutionResult.signal;
            pipelineEndOption = pipelineExecutionResult.end;
          }
          pipelineFunction(
            executePipelineWithSignalAndOptions,
            (pipelineStatus, pipelineResult) => {
              if (pipelineStatus) {
                handlePipelineError(pipelineStatus);
              } else {
                handlePipelineResult(pipelineResult);
              }
            },
            {
              signal: pipelineSignalAndEndOptions,
              end: pipelineEndOption,
            },
          );
        },
      );
    }
    _processPipelineWithSignal.exports = {
      finished: completedPromise,
      pipeline: executePipelineWithSignal,
    };
  },
);
var calculateDataSlice = conditionalModuleLoader(
  (processSectionedValuesExport, exportProcessSectionedValues) => {
    _validateAndRetrieveIntrinsicPropertyValue();
    var { Buffer: _Buffer } = createESModule(
      _retrieveAndValidateIntrinsicProperty,
    );
    var {
      ObjectDefineProperty: _defineObjectProperty,
      ObjectKeys: __getObjectKeys,
      ReflectApply: reflectApplyFunction,
    } = executeComparisonOperation();
    var {
      promisify: { custom: customPromisifyFunction },
    } = ___validateAndProcessArrayBuffer();
    var {
      streamReturningOperators: streamOperators,
      promiseReturningOperators: promiseReturningOperators,
    } = __________validateAndRetrieveIntrinsicProperties();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR: ERR_ILLEGAL_CONSTRUCTOR },
    } = getNodeValueAfterTraversal();
    var abortEventHandler = handleAbortEvent();
    var { pipeline: pipelineStream } = getEventListeners();
    var { destroyer: ____destroyStream } = evaluateVersionOperators();
    var validateSemanticVersionPrerelease = validateSemverPrerelease();
    var handleSectionedValuesExport = appendToBuffer();
    var ___processSectionedValues = validateAndProcessCharacterEncoding();
    var _processSectionedValuesExport = (exportProcessSectionedValues.exports =
      processSectionedValues().Stream);
    _processSectionedValuesExport.isDisturbed =
      ___processSectionedValues.isDisturbed;
    _processSectionedValuesExport.isErrored =
      ___processSectionedValues.isErrored;
    _processSectionedValuesExport.isReadable =
      ___processSectionedValues.isReadable;
    _processSectionedValuesExport.Readable = handleErrorMessages();
    for (let streamOperatorKey of __getObjectKeys(streamOperators)) {
      let validateStreamOperatorPrerquisite = function (
        ...streamOperatorWithArguments
      ) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return _processSectionedValuesExport.Readable.from(
          reflectApplyFunction(
            streamOperator,
            this,
            streamOperatorWithArguments,
          ),
        );
      };
      validateSemanticVersionPrereleaseFunction =
        validateStreamOperatorPrerquisite;
      let streamOperator = streamOperators[streamOperatorKey];
      _defineObjectProperty(validateStreamOperatorPrerquisite, "name", {
        __proto__: null,
        value: streamOperator.name,
      });
      _defineObjectProperty(validateStreamOperatorPrerquisite, "length", {
        __proto__: null,
        value: streamOperator.length,
      });
      _defineObjectProperty(
        _processSectionedValuesExport.Readable.prototype,
        streamOperatorKey,
        {
          __proto__: null,
          value: validateStreamOperatorPrerquisite,
          enumerable: false,
          configurable: true,
          writable: true,
        },
      );
    }
    var validateSemanticVersionPrereleaseFunction;
    for (let operatorKey of __getObjectKeys(promiseReturningOperators)) {
      let _validateSemanticVersionPrerelease = function (...__args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return reflectApplyFunction(promiseReturningOperator, this, __args);
      };
      validateSemanticVersionPrereleaseFunction =
        _validateSemanticVersionPrerelease;
      let promiseReturningOperator = promiseReturningOperators[operatorKey];
      _defineObjectProperty(_validateSemanticVersionPrerelease, "name", {
        __proto__: null,
        value: promiseReturningOperator.name,
      });
      _defineObjectProperty(_validateSemanticVersionPrerelease, "length", {
        __proto__: null,
        value: promiseReturningOperator.length,
      });
      _defineObjectProperty(
        _processSectionedValuesExport.Readable.prototype,
        operatorKey,
        {
          __proto__: null,
          value: _validateSemanticVersionPrerelease,
          enumerable: false,
          configurable: true,
          writable: true,
        },
      );
    }
    var validateSemanticVersionPrereleaseFunction;
    _processSectionedValuesExport.Writable =
      ___________________validateAndRetrieveIntrinsicProperties();
    _processSectionedValuesExport.Duplex = initializeEventListeners();
    _processSectionedValuesExport.Transform = _removeEventListener();
    _processSectionedValuesExport.PassThrough = ____removeEventListener();
    _processSectionedValuesExport.pipeline = pipelineStream;
    var { addAbortSignal: __processSectionedValuesExport } =
      nestedObjectCreation();
    _processSectionedValuesExport.addAbortSignal =
      __processSectionedValuesExport;
    _processSectionedValuesExport.finished = validateSemanticVersionPrerelease;
    _processSectionedValuesExport.destroy = ____destroyStream;
    _processSectionedValuesExport.compose = abortEventHandler;
    _defineObjectProperty(_processSectionedValuesExport, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return handleSectionedValuesExport;
      },
    });
    _defineObjectProperty(pipelineStream, customPromisifyFunction, {
      __proto__: null,
      enumerable: true,
      get() {
        return handleSectionedValuesExport.pipeline;
      },
    });
    _defineObjectProperty(
      validateSemanticVersionPrerelease,
      customPromisifyFunction,
      {
        __proto__: null,
        enumerable: true,
        get() {
          return handleSectionedValuesExport.finished;
        },
      },
    );
    _processSectionedValuesExport.Stream = _processSectionedValuesExport;
    _processSectionedValuesExport._isUint8Array = function (
      validateAndAllocateBuffer,
    ) {
      return validateAndAllocateBuffer instanceof Uint8Array;
    };
    _processSectionedValuesExport._uint8ArrayToBuffer = function (
      ___conditionalModuleLoader,
    ) {
      return _Buffer.from(
        ___conditionalModuleLoader.buffer,
        ___conditionalModuleLoader.byteOffset,
        ___conditionalModuleLoader.byteLength,
      );
    };
  },
);
var getEncodingValidation = conditionalModuleLoader(
  (exportStreamUtilities, streamUtilities) => {
    var encodingValidation = getEncodingValidation();
    {
      let dataStreamUtils = calculateDataSlice();
      let _appendDataToBuffer = appendToBuffer();
      let destroyReadableStream = dataStreamUtils.Readable.destroy;
      streamUtilities.exports = dataStreamUtils.Readable;
      streamUtilities.exports._uint8ArrayToBuffer =
        dataStreamUtils._uint8ArrayToBuffer;
      streamUtilities.exports._isUint8Array = dataStreamUtils._isUint8Array;
      streamUtilities.exports.isDisturbed = dataStreamUtils.isDisturbed;
      streamUtilities.exports.isErrored = dataStreamUtils.isErrored;
      streamUtilities.exports.isReadable = dataStreamUtils.isReadable;
      streamUtilities.exports.Readable = dataStreamUtils.Readable;
      streamUtilities.exports.Writable = dataStreamUtils.Writable;
      streamUtilities.exports.Duplex = dataStreamUtils.Duplex;
      streamUtilities.exports.Transform = dataStreamUtils.Transform;
      streamUtilities.exports.PassThrough = dataStreamUtils.PassThrough;
      streamUtilities.exports.addAbortSignal = dataStreamUtils.addAbortSignal;
      streamUtilities.exports.finished = dataStreamUtils.finished;
      streamUtilities.exports.destroy = dataStreamUtils.destroy;
      streamUtilities.exports.destroy = destroyReadableStream;
      streamUtilities.exports.pipeline = dataStreamUtils.pipeline;
      streamUtilities.exports.compose = dataStreamUtils.compose;
      Object.defineProperty(dataStreamUtils, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return _appendDataToBuffer;
        },
      });
      streamUtilities.exports.Stream = dataStreamUtils.Stream;
    }
    streamUtilities.exports.default = streamUtilities.exports;
  },
);
var isValidEncoding = defineObjectProperties(_isValidPromise());
var isAbortSignalHandled = "/nodebox";
var isEncodingSupported = isAbortSignalHandled;
function isEncodingSupportedCheck() {
  return isEncodingSupported;
}
function _normalizePathSegments(stringDecoder, validateEncodingAndProcess) {
  var normalizedPathSegments = [];
  for (
    var pathSegmentIndex = 0;
    pathSegmentIndex < stringDecoder.length;
    pathSegmentIndex++
  ) {
    var pathSegment = stringDecoder[pathSegmentIndex];
    if (!!pathSegment && pathSegment !== ".") {
      if (pathSegment === "..") {
        if (
          normalizedPathSegments.length &&
          normalizedPathSegments[normalizedPathSegments.length - 1] !== ".."
        ) {
          normalizedPathSegments.pop();
        } else if (validateEncodingAndProcess) {
          normalizedPathSegments.push("..");
        }
      } else {
        normalizedPathSegments.push(pathSegment);
      }
    }
  }
  return normalizedPathSegments;
}
var _stringDecoder =
  /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
function decodeProcessedData(__processEncodedData) {
  return _stringDecoder.exec(__processEncodedData).slice(1);
}
function resolvePath(...resolvePathSegments) {
  var resolvedPath = "";
  for (
    var isRootPathDetected = false,
      lastIndexInPathSegments = resolvePathSegments.length - 1;
    lastIndexInPathSegments >= -1 && !isRootPathDetected;
    lastIndexInPathSegments--
  ) {
    var resolvedSegment =
      lastIndexInPathSegments >= 0
        ? resolvePathSegments[lastIndexInPathSegments]
        : isEncodingSupportedCheck();
    if (isValidEncoding.default.isString(resolvedSegment)) {
      if (!resolvedSegment) {
        continue;
      }
    } else {
      throw new TypeError("Arguments to path.resolve must be strings");
    }
    resolvedPath = resolvedSegment + "/" + resolvedPath;
    isRootPathDetected = resolvedSegment[0] === "/";
  }
  resolvedPath = _normalizePathSegments(
    resolvedPath.split("/"),
    !isRootPathDetected,
  ).join("/");
  return (isRootPathDetected ? "/" : "") + resolvedPath || ".";
}
function isPathStartsWithSlash(BufferWriter) {
  return BufferWriter.charAt(0) === "/";
}
function normalizeAndFormatPath(allocateBufferForEncodedBytes) {
  var isAbsPath = isPathStartsWithSlash(allocateBufferForEncodedBytes);
  var endsWithSlash =
    allocateBufferForEncodedBytes &&
    allocateBufferForEncodedBytes[allocateBufferForEncodedBytes.length - 1] ===
      "/";
  allocateBufferForEncodedBytes = _normalizePathSegments(
    allocateBufferForEncodedBytes.split("/"),
    !isAbsPath,
  ).join("/");
  if (!allocateBufferForEncodedBytes && !isAbsPath) {
    allocateBufferForEncodedBytes = ".";
  }
  if (allocateBufferForEncodedBytes && endsWithSlash) {
    allocateBufferForEncodedBytes += "/";
  }
  return (isAbsPath ? "/" : "") + allocateBufferForEncodedBytes;
}
function joinPaths(...joinPathSegments) {
  var joinedPath = "";
  for (
    var _segmentIndex = 0;
    _segmentIndex < joinPathSegments.length;
    _segmentIndex++
  ) {
    var currentPathSegment = joinPathSegments[_segmentIndex];
    if (!isValidEncoding.default.isString(currentPathSegment)) {
      throw new TypeError("Arguments to path.join must be strings");
    }
    if (currentPathSegment) {
      if (joinedPath) {
        joinedPath += "/" + currentPathSegment;
      } else {
        joinedPath += currentPathSegment;
      }
    }
  }
  return normalizeAndFormatPath(joinedPath);
}
function formatByteLength(getByteLength) {
  var formattedByteLength = decodeProcessedData(getByteLength);
  var formattedLengthBeforeUnit = formattedByteLength[0];
  var formattedByteUnit = formattedByteLength[1];
  if (!formattedLengthBeforeUnit && !formattedByteUnit) {
    return ".";
  } else {
    formattedByteUnit &&= formattedByteUnit.substr(
      0,
      formattedByteUnit.length - 1,
    );
    return formattedLengthBeforeUnit + formattedByteUnit;
  }
}
var calculateUtf8ByteLength = defineObjectProperties(
  getStylizedRepresentation(),
);
var ___getEncodedByteLength = Object.create;
var calculateByteLength = Object.defineProperty;
var calculateEncodedLength = Object.getOwnPropertyDescriptor;
var _calculateUtf8ByteLength = Object.getOwnPropertyNames;
var ____getEncodedByteLength = Object.getPrototypeOf;
var lastEncodedByteCount = Object.prototype.hasOwnProperty;
var determineByteLength = (
  assignPropertyOrCalculateLength,
  propertyOrKey,
  valueToAssign,
) =>
  propertyOrKey in assignPropertyOrCalculateLength
    ? calculateByteLength(assignPropertyOrCalculateLength, propertyOrKey, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: valueToAssign,
      })
    : (assignPropertyOrCalculateLength[propertyOrKey] = valueToAssign);
var getRandomValueStatus = (loadModule, loadModuleWrapper) =>
  function () {
    if (!loadModuleWrapper) {
      (0, loadModule[_calculateUtf8ByteLength(loadModule)[0]])(
        (loadModuleWrapper = {
          exports: {},
        }).exports,
        loadModuleWrapper,
      );
    }
    return loadModuleWrapper.exports;
  };
var handleRandomValueResult = (
  processUtf8ByteLength,
  processObjectUtf8ByteLength,
  excludedByteValue,
  isPropertyEnumerable,
) => {
  if (
    (processObjectUtf8ByteLength &&
      typeof processObjectUtf8ByteLength == "object") ||
    typeof processObjectUtf8ByteLength == "function"
  ) {
    for (let currentByteValue of _calculateUtf8ByteLength(
      processObjectUtf8ByteLength,
    )) {
      if (
        !lastEncodedByteCount.call(processUtf8ByteLength, currentByteValue) &&
        currentByteValue !== excludedByteValue
      ) {
        calculateByteLength(processUtf8ByteLength, currentByteValue, {
          get: () => processObjectUtf8ByteLength[currentByteValue],
          enumerable:
            !(isPropertyEnumerable = calculateEncodedLength(
              processObjectUtf8ByteLength,
              currentByteValue,
            )) || isPropertyEnumerable.enumerable,
        });
      }
    }
  }
  return processUtf8ByteLength;
};
var previousRandomValue = (
  ____processEncodedData,
  encodedDataLength,
  _processedData,
) => {
  if (____processEncodedData != null) {
    _processedData = ___getEncodedByteLength(
      ____getEncodedByteLength(____processEncodedData),
    );
  } else {
    _processedData = {};
  }
  return handleRandomValueResult(
    encodedDataLength ||
      !____processEncodedData ||
      !____processEncodedData.__esModule
      ? calculateByteLength(_processedData, "default", {
          value: ____processEncodedData,
          enumerable: true,
        })
      : _processedData,
    ____processEncodedData,
  );
};
var currentRandomValue = (
  determineByteLengthAndReturnResult,
  inputString,
  byteLengthResult,
) => {
  determineByteLength(
    determineByteLengthAndReturnResult,
    typeof inputString != "symbol" ? inputString + "" : inputString,
    byteLengthResult,
  );
  return byteLengthResult;
};
var processedRandomValue = (
  checkIfValueExistsAndThrowError,
  checkIfValueExists,
  operationDescription,
) => {
  if (!checkIfValueExists.has(checkIfValueExistsAndThrowError)) {
    throw TypeError("Cannot " + operationDescription);
  }
};
var _processRandomValue = (
  handlePrivateFieldAccess,
  getPrivateFieldValue,
  fetchPrivateFieldValue,
) => {
  processedRandomValue(
    handlePrivateFieldAccess,
    getPrivateFieldValue,
    "read from private field",
  );
  if (fetchPrivateFieldValue) {
    return fetchPrivateFieldValue.call(handlePrivateFieldAccess);
  } else {
    return getPrivateFieldValue.get(handlePrivateFieldAccess);
  }
};
var calculateRemainingValue = (
  addPrivateMember,
  privateMemberSet,
  associatePrivateMember,
) => {
  if (privateMemberSet.has(addPrivateMember)) {
    throw TypeError("Cannot add the same private member more than once");
  }
  if (privateMemberSet instanceof WeakSet) {
    privateMemberSet.add(addPrivateMember);
  } else {
    privateMemberSet.set(addPrivateMember, associatePrivateMember);
  }
};
var calculateOutputBuffer = (
  processAndStoreValue,
  privateFieldHandler,
  valueToStore,
  callbackForValueStorage,
) => {
  processedRandomValue(
    processAndStoreValue,
    privateFieldHandler,
    "write to private field",
  );
  if (callbackForValueStorage) {
    callbackForValueStorage.call(processAndStoreValue, valueToStore);
  } else {
    privateFieldHandler.set(processAndStoreValue, valueToStore);
  }
  return valueToStore;
};
var calculateDataEncodingError = (
  accessPrivateMethodWithRandomValue,
  processedPrivateMethodValue,
  returnProcessedValue,
) => {
  processedRandomValue(
    accessPrivateMethodWithRandomValue,
    processedPrivateMethodValue,
    "access private method",
  );
  return returnProcessedValue;
};
var getFormattedOutput = getRandomValueStatus({
  "../../node_modules/.pnpm/cuid@2.1.8/node_modules/cuid/lib/pad.js"(
    padWithZeroes,
    padBufferWithZeros,
  ) {
    padBufferWithZeros.exports = function (
      calculateRemainingBytesBuffer,
      __processCharacterEncoding,
    ) {
      var remainingBytesBuffer = "000000000" + calculateRemainingBytesBuffer;
      return remainingBytesBuffer.substr(
        remainingBytesBuffer.length - __processCharacterEncoding,
      );
    };
  },
});
var processLastNeed = getRandomValueStatus({
  "../../node_modules/.pnpm/cuid@2.1.8/node_modules/cuid/lib/fingerprint.browser.js"(
    getBrowserFingerprint,
    browserFingerprintExporter,
  ) {
    var getBrowserFingerprintOutput = getFormattedOutput();
    var globalScope = typeof window == "object" ? window : self;
    var globalVariableCount = Object.keys(globalScope).length;
    var mimeTypesCount = navigator.mimeTypes ? navigator.mimeTypes.length : 0;
    var browserFingerprint = getBrowserFingerprintOutput(
      (mimeTypesCount + navigator.userAgent.length).toString(36) +
        globalVariableCount.toString(36),
      4,
    );
    browserFingerprintExporter.exports = function () {
      return browserFingerprint;
    };
  },
});
var convertPropertyToUTF8 = getRandomValueStatus({
  "../../node_modules/.pnpm/cuid@2.1.8/node_modules/cuid/lib/getRandomValue.browser.js"(
    getRandomValue,
    _getRandomValue,
  ) {
    var __getRandomValue;
    var isCryptoAvailable =
      (typeof window !== "undefined" && (window.crypto || window.msCrypto)) ||
      (typeof self !== "undefined" && self.crypto);
    if (isCryptoAvailable) {
      maxRandomValue = Math.pow(2, 32) - 1;
      __getRandomValue = function () {
        return Math.abs(
          isCryptoAvailable.getRandomValues(new Uint32Array(1))[0] /
            maxRandomValue,
        );
      };
    } else {
      __getRandomValue = Math.random;
    }
    var maxRandomValue;
    _getRandomValue.exports = __getRandomValue;
  },
});
var handleObjectTypeErrorsProcessor = getRandomValueStatus({
  "../../node_modules/.pnpm/cuid@2.1.8/node_modules/cuid/index.js"(
    ___generateUniqueIdentifier,
    ____generateUniqueIdentifier,
  ) {
    var _____generateUniqueIdentifier = processLastNeed();
    var formattedUniqueIdentifier = getFormattedOutput();
    var ______generateUniqueIdentifier = convertPropertyToUTF8();
    var currentCounter = 0;
    var uniqueIdentifierLength = 4;
    var base36 = 36;
    var maxUniqueIdentifiers = Math.pow(base36, uniqueIdentifierLength);
    function generateFormattedUniqueIdentifier() {
      return formattedUniqueIdentifier(
        (
          (______generateUniqueIdentifier() * maxUniqueIdentifiers) <<
          0
        ).toString(base36),
        uniqueIdentifierLength,
      );
    }
    function getNextUniqueIdentifier() {
      if (currentCounter < maxUniqueIdentifiers) {
        currentCounter = currentCounter;
      } else {
        currentCounter = 0;
      }
      currentCounter++;
      return currentCounter - 1;
    }
    function generateUniqueIdentifierString() {
      var prefixCharacter = "c";
      var timestampBase36 = new Date().getTime().toString(base36);
      var formattedUniqueIdentifierString = formattedUniqueIdentifier(
        getNextUniqueIdentifier().toString(base36),
        uniqueIdentifierLength,
      );
      var generatedUniqueIdentifier = _____generateUniqueIdentifier();
      var concatenatedIdentifiers =
        generateFormattedUniqueIdentifier() +
        generateFormattedUniqueIdentifier();
      return (
        prefixCharacter +
        timestampBase36 +
        formattedUniqueIdentifierString +
        generatedUniqueIdentifier +
        concatenatedIdentifiers
      );
    }
    generateUniqueIdentifierString.slug = function () {
      var _timestampBase36 = new Date().getTime().toString(36);
      var lastFourDigitsOfFunction399 = getNextUniqueIdentifier()
        .toString(36)
        .slice(-4);
      var uniqueIdentifierPart =
        _____generateUniqueIdentifier().slice(0, 1) +
        _____generateUniqueIdentifier().slice(-1);
      var lastTwoDigitsOfF398 = generateFormattedUniqueIdentifier().slice(-2);
      return (
        _timestampBase36.slice(-2) +
        lastFourDigitsOfFunction399 +
        uniqueIdentifierPart +
        lastTwoDigitsOfF398
      );
    };
    generateUniqueIdentifierString.isCuid = function (processBase64Encoding) {
      if (typeof processBase64Encoding != "string") {
        return false;
      } else {
        return !!processBase64Encoding.startsWith("c");
      }
    };
    generateUniqueIdentifierString.isSlug = function (
      calculateBase64EncodedString,
    ) {
      if (typeof calculateBase64EncodedString != "string") {
        return false;
      }
      var encodedStringLength = calculateBase64EncodedString.length;
      return encodedStringLength >= 7 && encodedStringLength <= 10;
    };
    generateUniqueIdentifierString.fingerprint = _____generateUniqueIdentifier;
    ____generateUniqueIdentifier.exports = generateUniqueIdentifierString;
  },
});
var calculateBase64Encoding = getRandomValueStatus({
  "../../node_modules/.pnpm/@open-draft+deferred-promise@2.1.0/node_modules/@open-draft/deferred-promise/build/createDeferredExecutor.js"(
    _deferredPromiseExecutor,
  ) {
    "use strict";

    Object.defineProperty(_deferredPromiseExecutor, "__esModule", {
      value: true,
    });
    _deferredPromiseExecutor.createDeferredExecutor = undefined;
    function _createDeferredPromise() {
      let __createDeferredPromise = (
        ___createDeferredPromise,
        _handlePromiseRejection,
      ) => {
        __createDeferredPromise.state = "pending";
        __createDeferredPromise.resolve = (_handlePromiseResolution) => {
          if (__createDeferredPromise.state !== "pending") {
            return;
          }
          __createDeferredPromise.result = _handlePromiseResolution;
          let fulfillDeferredPromise = (fulfilledPromise) => {
            __createDeferredPromise.state = "fulfilled";
            return fulfilledPromise;
          };
          return ___createDeferredPromise(
            _handlePromiseResolution instanceof Promise
              ? _handlePromiseResolution
              : Promise.resolve(_handlePromiseResolution).then(
                  fulfillDeferredPromise,
                ),
          );
        };
        __createDeferredPromise.reject = (handlePendingPromiseRejection) => {
          if (__createDeferredPromise.state === "pending") {
            queueMicrotask(() => {
              __createDeferredPromise.state = "rejected";
            });
            return _handlePromiseRejection(
              (__createDeferredPromise.rejectionReason =
                handlePendingPromiseRejection),
            );
          }
        };
      };
      return __createDeferredPromise;
    }
    _deferredPromiseExecutor.createDeferredExecutor = _createDeferredPromise;
  },
});
var handleErrorAndReturnFormattedValue = getRandomValueStatus({
  "../../node_modules/.pnpm/@open-draft+deferred-promise@2.1.0/node_modules/@open-draft/deferred-promise/build/DeferredPromise.js"(
    DeferredPromiseModule,
  ) {
    "use strict";

    Object.defineProperty(DeferredPromiseModule, "__esModule", {
      value: true,
    });
    DeferredPromiseModule.DeferredPromise = undefined;
    var deferredExecutor = calculateBase64Encoding();
    var DeferredPromise = class extends Promise {
      #e;
      resolve;
      reject;
      constructor(userSessionData = null) {
        let __deferredExecutor = (0, deferredExecutor.createDeferredExecutor)();
        super((executeDeferredTask, taskDelayDuration) => {
          __deferredExecutor(executeDeferredTask, taskDelayDuration);
          userSessionData?.(
            __deferredExecutor.resolve,
            __deferredExecutor.reject,
          );
        });
        this.#e = __deferredExecutor;
        this.resolve = this.#e.resolve;
        this.reject = this.#e.reject;
      }
      get state() {
        return this.#e.state;
      }
      get rejectionReason() {
        return this.#e.rejectionReason;
      }
      then(handleThenPromise, resolveWithHandleThenPromise) {
        return this.#t(
          super.then(handleThenPromise, resolveWithHandleThenPromise),
        );
      }
      catch(_____errorHandler) {
        return this.#t(super.catch(_____errorHandler));
      }
      finally(finallyHandler) {
        return this.#t(super.finally(finallyHandler));
      }
      #t(_createPromiseHandler) {
        return Object.defineProperties(_createPromiseHandler, {
          resolve: {
            configurable: true,
            value: this.resolve,
          },
          reject: {
            configurable: true,
            value: this.reject,
          },
        });
      }
    };
    DeferredPromiseModule.DeferredPromise = DeferredPromise;
  },
});
var handleInvalidArgumentError = getRandomValueStatus({
  "../../node_modules/.pnpm/@open-draft+deferred-promise@2.1.0/node_modules/@open-draft/deferred-promise/build/index.js"(
    ___moduleExports,
  ) {
    "use strict";

    var _createBinding =
      (___moduleExports && ___moduleExports.__createBinding) ||
      (Object.create
        ? function (
            handleErrorAndRecover,
            handleMissingArgsErrorAndCreateErrorMessage,
            handleMissingArgsErrorAndCreateMessage,
            handleMissingArgumentsErrorAndGenerateMessage = handleMissingArgsErrorAndCreateMessage,
          ) {
            var propertyDescriptorForErrorHandler =
              Object.getOwnPropertyDescriptor(
                handleMissingArgsErrorAndCreateErrorMessage,
                handleMissingArgsErrorAndCreateMessage,
              );
            if (
              !propertyDescriptorForErrorHandler ||
              ("get" in propertyDescriptorForErrorHandler
                ? !handleMissingArgsErrorAndCreateErrorMessage.__esModule
                : propertyDescriptorForErrorHandler.writable ||
                  propertyDescriptorForErrorHandler.configurable)
            ) {
              propertyDescriptorForErrorHandler = {
                enumerable: true,
                get() {
                  return handleMissingArgsErrorAndCreateErrorMessage[
                    handleMissingArgsErrorAndCreateMessage
                  ];
                },
              };
            }
            Object.defineProperty(
              handleErrorAndRecover,
              handleMissingArgumentsErrorAndGenerateMessage,
              propertyDescriptorForErrorHandler,
            );
          }
        : function (
            handleAsyncIterator,
            awaitNextValueFromIterator,
            handleIteratorControlFlow,
            _handleIteratorControlFlow = handleIteratorControlFlow,
          ) {
            handleAsyncIterator[_handleIteratorControlFlow] =
              awaitNextValueFromIterator[handleIteratorControlFlow];
          });
    var bindModuleProperties =
      (___moduleExports && ___moduleExports.__exportStar) ||
      function (generateAndProcessValues, handleAsyncIteration) {
        for (var valueKey in generateAndProcessValues) {
          if (
            valueKey !== "default" &&
            !Object.prototype.hasOwnProperty.call(
              handleAsyncIteration,
              valueKey,
            )
          ) {
            _createBinding(
              handleAsyncIteration,
              generateAndProcessValues,
              valueKey,
            );
          }
        }
      };
    Object.defineProperty(___moduleExports, "__esModule", {
      value: true,
    });
    bindModuleProperties(calculateBase64Encoding(), ___moduleExports);
    bindModuleProperties(
      handleErrorAndReturnFormattedValue(),
      ___moduleExports,
    );
  },
});
var handleAsyncIterable = getRandomValueStatus({
  "../../node_modules/.pnpm/strict-event-emitter@0.4.3/node_modules/strict-event-emitter/lib/MemoryLeakError.js"(
    MemoryLeakErrorModule,
  ) {
    "use strict";

    Object.defineProperty(MemoryLeakErrorModule, "__esModule", {
      value: true,
    });
    MemoryLeakErrorModule.MemoryLeakError = undefined;
    var MemoryLeakError = class extends Error {
      emitter;
      type;
      count;
      constructor(
        MaxListenersExceededWarningConstructor,
        listenerCountExceeded,
        _listenerCountExceeded,
      ) {
        super(
          "Possible EventEmitter memory leak detected. " +
            _listenerCountExceeded +
            " " +
            listenerCountExceeded.toString() +
            " listeners added. Use emitter.setMaxListeners() to increase limit",
        );
        this.emitter = MaxListenersExceededWarningConstructor;
        this.type = listenerCountExceeded;
        this.count = _listenerCountExceeded;
        this.name = "MaxListenersExceededWarning";
      }
    };
    MemoryLeakErrorModule.MemoryLeakError = MemoryLeakError;
  },
});
var validateAndProcessStream = getRandomValueStatus({
  "../../node_modules/.pnpm/strict-event-emitter@0.4.3/node_modules/strict-event-emitter/lib/Emitter.js"(
    StrictEventEmitter,
  ) {
    "use strict";

    Object.defineProperty(StrictEventEmitter, "__esModule", {
      value: true,
    });
    StrictEventEmitter.Emitter = undefined;
    var asyncIterableHandler = handleAsyncIterable();
    var outputBuffer;
    var eventEmitterCallbacksBuffer;
    var eventEmitterCallbacks;
    var asyncEventHandlers;
    var eventHandler;
    var handlerFunction;
    var eventHandlers;
    var eventHandlersBuffer;
    var eventEmitterInternalState;
    var eventEmitterState;
    var eventEmitterStateManager;
    var EventEmitterHandler = class {
      constructor() {
        calculateRemainingValue(this, asyncEventHandlers);
        calculateRemainingValue(this, handlerFunction);
        calculateRemainingValue(this, eventHandlersBuffer);
        calculateRemainingValue(this, eventEmitterState);
        calculateRemainingValue(this, outputBuffer, undefined);
        calculateRemainingValue(this, eventEmitterCallbacksBuffer, undefined);
        calculateRemainingValue(this, eventEmitterCallbacks, undefined);
        calculateOutputBuffer(this, outputBuffer, new Map());
        calculateOutputBuffer(
          this,
          eventEmitterCallbacksBuffer,
          EventEmitterHandler.defaultMaxListeners,
        );
        calculateOutputBuffer(this, eventEmitterCallbacks, false);
      }
      static listenerCount(_getListenerCount, listenerIdentifier) {
        return _getListenerCount.listenerCount(listenerIdentifier);
      }
      setMaxListeners(outputBufferSize) {
        calculateOutputBuffer(
          this,
          eventEmitterCallbacksBuffer,
          outputBufferSize,
        );
        return this;
      }
      getMaxListeners() {
        return _processRandomValue(this, eventEmitterCallbacksBuffer);
      }
      eventNames() {
        return Array.from(_processRandomValue(this, outputBuffer).keys());
      }
      emit(__dataEncodingErrorHandler, ...errorHandlerArguments) {
        let encodedDataErrorHandlers = calculateDataEncodingError(
          this,
          asyncEventHandlers,
          eventHandler,
        ).call(this, __dataEncodingErrorHandler);
        encodedDataErrorHandlers.forEach((_______errorHandler) => {
          _______errorHandler.apply(this, errorHandlerArguments);
        });
        return encodedDataErrorHandlers.length > 0;
      }
      addListener(addListenerForEvent, eventListenerCallback) {
        calculateDataEncodingError(
          this,
          eventEmitterState,
          eventEmitterStateManager,
        ).call(this, "newListener", addListenerForEvent, eventListenerCallback);
        let mergedEventListenerCallbacks = calculateDataEncodingError(
          this,
          asyncEventHandlers,
          eventHandler,
        )
          .call(this, addListenerForEvent)
          .concat(eventListenerCallback);
        _processRandomValue(this, outputBuffer).set(
          addListenerForEvent,
          mergedEventListenerCallbacks,
        );
        if (
          _processRandomValue(this, eventEmitterCallbacksBuffer) > 0 &&
          this.listenerCount(addListenerForEvent) >
            _processRandomValue(this, eventEmitterCallbacksBuffer) &&
          !_processRandomValue(this, eventEmitterCallbacks)
        ) {
          calculateOutputBuffer(this, eventEmitterCallbacks, true);
          let memoryLeakErrorInstance =
            new asyncIterableHandler.MemoryLeakError(
              this,
              addListenerForEvent,
              this.listenerCount(addListenerForEvent),
            );
          console.warn(memoryLeakErrorInstance);
        }
        return this;
      }
      on(_addEventListener, _eventListenerCallback) {
        return this.addListener(_addEventListener, _eventListenerCallback);
      }
      once(addListenerWithEncodingError, handleEncodingError) {
        return this.addListener(
          addListenerWithEncodingError,
          calculateDataEncodingError(
            this,
            eventHandlersBuffer,
            eventEmitterInternalState,
          ).call(this, addListenerWithEncodingError, handleEncodingError),
        );
      }
      prependListener(eventHandlerKey, _eventHandlerFunction) {
        let dataEncodingErrors = calculateDataEncodingError(
          this,
          asyncEventHandlers,
          eventHandler,
        ).call(this, eventHandlerKey);
        if (dataEncodingErrors.length > 0) {
          let eventHandlerAndDataErrors = [_eventHandlerFunction].concat(
            dataEncodingErrors,
          );
          _processRandomValue(this, outputBuffer).set(
            eventHandlerKey,
            eventHandlerAndDataErrors,
          );
        } else {
          _processRandomValue(this, outputBuffer).set(
            eventHandlerKey,
            dataEncodingErrors.concat(_eventHandlerFunction),
          );
        }
        return this;
      }
      prependOnceListener(
        eventHandlerPrependListener,
        eventHandlerWithEncodingErrorHandling,
      ) {
        return this.prependListener(
          eventHandlerPrependListener,
          calculateDataEncodingError(
            this,
            eventHandlersBuffer,
            eventEmitterInternalState,
          ).call(
            this,
            eventHandlerPrependListener,
            eventHandlerWithEncodingErrorHandling,
          ),
        );
      }
      removeListener(removeDataListener, eventEmitterInstance) {
        let dataEncodingError = calculateDataEncodingError(
          this,
          asyncEventHandlers,
          eventHandler,
        ).call(this, removeDataListener);
        if (dataEncodingError.length > 0) {
          calculateDataEncodingError(this, handlerFunction, eventHandlers).call(
            this,
            dataEncodingError,
            eventEmitterInstance,
          );
          _processRandomValue(this, outputBuffer).set(
            removeDataListener,
            dataEncodingError,
          );
          calculateDataEncodingError(
            this,
            eventEmitterState,
            eventEmitterStateManager,
          ).call(
            this,
            "removeListener",
            removeDataListener,
            eventEmitterInstance,
          );
        }
        return this;
      }
      off(_____removeEventListener, _eventType) {
        return this.removeListener(_____removeEventListener, _eventType);
      }
      removeAllListeners(removeSpecificListener) {
        if (removeSpecificListener) {
          _processRandomValue(this, outputBuffer).delete(
            removeSpecificListener,
          );
        } else {
          _processRandomValue(this, outputBuffer).clear();
        }
        return this;
      }
      listeners(eventData) {
        return Array.from(
          calculateDataEncodingError(
            this,
            asyncEventHandlers,
            eventHandler,
          ).call(this, eventData),
        );
      }
      listenerCount(eventHandlerReference) {
        return calculateDataEncodingError(
          this,
          asyncEventHandlers,
          eventHandler,
        ).call(this, eventHandlerReference).length;
      }
      rawListeners(___getEventListeners) {
        return this.listeners(___getEventListeners);
      }
    };
    var _eventEmitterStateManager = EventEmitterHandler;
    outputBuffer = new WeakMap();
    eventEmitterCallbacksBuffer = new WeakMap();
    eventEmitterCallbacks = new WeakMap();
    asyncEventHandlers = new WeakSet();
    eventHandler = function (initializeReadableStream) {
      return (
        _processRandomValue(this, outputBuffer).get(initializeReadableStream) ||
        []
      );
    };
    handlerFunction = new WeakSet();
    eventHandlers = function (ReadableStream, ReadableStreamFactory) {
      let indexInStream = ReadableStream.indexOf(ReadableStreamFactory);
      if (indexInStream > -1) {
        ReadableStream.splice(indexInStream, 1);
      }
      return [];
    };
    eventHandlersBuffer = new WeakSet();
    eventEmitterInternalState = function (
      initializeReadableState,
      initializeReadableStreamState,
    ) {
      let removeListenerAndInitializeStream = (...___args) => {
        this.removeListener(
          initializeReadableState,
          removeListenerAndInitializeStream,
        );
        initializeReadableStreamState.apply(this, ___args);
      };
      return removeListenerAndInitializeStream;
    };
    eventEmitterState = new WeakSet();
    eventEmitterStateManager = function (
      validateNumberInRangeFunction,
      ____validateNumberInRange,
      validateNumberInRangeHandler,
    ) {
      this.emit(
        validateNumberInRangeFunction,
        ____validateNumberInRange,
        validateNumberInRangeHandler,
      );
    };
    currentRandomValue(_eventEmitterStateManager, "defaultMaxListeners", 10);
    StrictEventEmitter.Emitter = _eventEmitterStateManager;
  },
});
var _____validateNumberInRange = getRandomValueStatus({
  "../../node_modules/.pnpm/strict-event-emitter@0.4.3/node_modules/strict-event-emitter/lib/index.js"(
    _StrictEventEmitter,
  ) {
    "use strict";

    var __createBinding =
      (_StrictEventEmitter && _StrictEventEmitter.__createBinding) ||
      (Object.create
        ? function (
            validateRangeAndPush,
            _processInput,
            validateReadableStreamAndPush,
            _validateReadableStreamAndPush = validateReadableStreamAndPush,
          ) {
            var _____propertyDescriptor = Object.getOwnPropertyDescriptor(
              _processInput,
              validateReadableStreamAndPush,
            );
            if (
              !_____propertyDescriptor ||
              ("get" in _____propertyDescriptor
                ? !_processInput.__esModule
                : _____propertyDescriptor.writable ||
                  _____propertyDescriptor.configurable)
            ) {
              _____propertyDescriptor = {
                enumerable: true,
                get() {
                  return _processInput[validateReadableStreamAndPush];
                },
              };
            }
            Object.defineProperty(
              validateRangeAndPush,
              _validateReadableStreamAndPush,
              _____propertyDescriptor,
            );
          }
        : function (
            ______validateNumberInRange,
            _______validateNumberInRange,
            _validateAndProcessCacheEntry,
            ________validateAndProcessCacheEntry = _validateAndProcessCacheEntry,
          ) {
            ______validateNumberInRange[________validateAndProcessCacheEntry] =
              _______validateNumberInRange[_validateAndProcessCacheEntry];
          });
    var definePropertyWithBinding =
      (_StrictEventEmitter && _StrictEventEmitter.__exportStar) ||
      function (________validateNumberInRange, __validateAndProcessCacheEntry) {
        for (var numberRangeKey in ________validateNumberInRange) {
          if (
            numberRangeKey !== "default" &&
            !Object.prototype.hasOwnProperty.call(
              __validateAndProcessCacheEntry,
              numberRangeKey,
            )
          ) {
            __createBinding(
              __validateAndProcessCacheEntry,
              ________validateNumberInRange,
              numberRangeKey,
            );
          }
        }
      };
    Object.defineProperty(_StrictEventEmitter, "__esModule", {
      value: true,
    });
    definePropertyWithBinding(validateAndProcessStream(), _StrictEventEmitter);
    definePropertyWithBinding(handleAsyncIterable(), _StrictEventEmitter);
  },
});
var _validateCacheEntryConstraints = previousRandomValue(
  handleObjectTypeErrorsProcessor(),
);
var readableAddChunk = /(%?)(%([sdjo]))/g;
function processAndTransformData(
  processReadableChunk,
  validateAndProcessCacheValue,
) {
  switch (validateAndProcessCacheValue) {
    case "s":
      return processReadableChunk;
    case "d":
    case "i":
      return Number(processReadableChunk);
    case "j":
      return JSON.stringify(processReadableChunk);
    case "o": {
      if (typeof processReadableChunk == "string") {
        return processReadableChunk;
      }
      let serializedProcessReadableChunk = JSON.stringify(processReadableChunk);
      if (
        serializedProcessReadableChunk === "{}" ||
        serializedProcessReadableChunk === "[]" ||
        /^\[object .+?\]$/.test(serializedProcessReadableChunk)
      ) {
        return processReadableChunk;
      } else {
        return serializedProcessReadableChunk;
      }
    }
  }
}
function replaceAndTransform(
  validateAndCacheEntry,
  ...additionalTransformations
) {
  if (additionalTransformations.length === 0) {
    return validateAndCacheEntry;
  }
  let transformationIndex = 0;
  let transformedEntry = validateAndCacheEntry.replace(
    readableAddChunk,
    (
      processDataBasedOnTransformation,
      shouldProcessData,
      transformData,
      dataTransformFunction,
    ) => {
      let selectedTransformation =
        additionalTransformations[transformationIndex];
      let processedTransformedData = processAndTransformData(
        selectedTransformation,
        dataTransformFunction,
      );
      if (shouldProcessData) {
        return processDataBasedOnTransformation;
      } else {
        transformationIndex++;
        return processedTransformedData;
      }
    },
  );
  if (transformationIndex < additionalTransformations.length) {
    transformedEntry +=
      " " + additionalTransformations.slice(transformationIndex).join(" ");
  }
  transformedEntry = transformedEntry.replace(/%{2,2}/g, "%");
  return transformedEntry;
}
var cacheEntryValidator = 2;
function validateCacheStack(_validateCacheEntry) {
  if (!_validateCacheEntry.stack) {
    return;
  }
  let splitCacheStack = _validateCacheEntry.stack.split("\n");
  splitCacheStack.splice(1, cacheEntryValidator);
  _validateCacheEntry.stack = splitCacheStack.join("\n");
}
var validateCacheAndProcessEntry = class extends Error {
  constructor(_errorMessage, ...replacementParameters) {
    super(_errorMessage);
    this.message = _errorMessage;
    this.name = "Invariant Violation";
    this.message = replaceAndTransform(_errorMessage, ...replacementParameters);
    validateCacheStack(this);
  }
};
var validateAndProcessStreamData = (
  _________validateCacheEntry,
  cacheEntryValidationError,
  ...cacheEntryProcessingError
) => {
  if (!_________validateCacheEntry) {
    throw new validateCacheAndProcessEntry(
      cacheEntryValidationError,
      ...cacheEntryProcessingError,
    );
  }
};
validateAndProcessStreamData.as = (
  handleErrorOrCreateInstance,
  createOrHandleErrorInstance,
  errorInstanceOrHandle,
  ...errorHandlingOrCreationParams
) => {
  if (!createOrHandleErrorInstance) {
    throw handleErrorOrCreateInstance.prototype.name != null
      ? new handleErrorOrCreateInstance(
          replaceAndTransform(
            errorInstanceOrHandle,
            errorHandlingOrCreationParams,
          ),
        )
      : handleErrorOrCreateInstance(
          replaceAndTransform(
            errorInstanceOrHandle,
            errorHandlingOrCreationParams,
          ),
        );
  }
};
var cacheEntryProcessor = previousRandomValue(handleInvalidArgumentError());
var cacheEntry = window.localStorage.CSB_EMULATOR_DEBUG;
var cacheValue = "[0m";
var cacheEntryHandler = "[32;1m";
var _cacheEntry = "[31m";
var isCacheEntryValid = "[34m";
var __validateCacheEntry = "[33;1m";
var _isCacheEntryValid = "[35;1m";
var _validateCacheValue = "[36;1m";
var __cacheEntry = {
  preview: __validateCacheEntry,
  emulator: _isCacheEntryValid,
  runtime: _validateCacheValue,
  bridge: isCacheEntryValid,
  "runtime:worker": _validateCacheValue,
};
function createCacheEntryLogger(_processCacheEntry) {
  return function (processValidateCacheEntry, ...debugConsoleOutput) {
    let getCacheEntryRole = () =>
      processValidateCacheEntry.includes("sender")
        ? cacheEntryHandler + "sender"
        : processValidateCacheEntry.includes("receiver")
          ? _cacheEntry + "receiver"
          : "";
    let cleansedCacheEntry = processValidateCacheEntry.replace(/\[.+\]:/, "");
    console.debug(
      "" +
        __cacheEntry[_processCacheEntry] +
        _processCacheEntry +
        ":" +
        getCacheEntryRole() +
        cacheValue +
        ":" +
        cleansedCacheEntry,
      ...debugConsoleOutput,
    );
  };
}
var __processCacheEntry = createCacheEntryLogger("emulator");
var handleCacheEntryValidation = class {
  emitter;
  senderPort = null;
  constructor() {
    this.emitter = new EventTarget();
    this.waitForHandshake();
  }
  waitForHandshake() {
    let handshakeDeferredPromise = new cacheEntryProcessor.DeferredPromise();
    let ___handleIncomingMessage = (handleIncomingMessageReceiver) => {
      let { data: messageData } = handleIncomingMessageReceiver;
      __processCacheEntry(
        "[message-receiver]: incoming",
        handleIncomingMessageReceiver,
      );
      if (messageData.type === "internal/handshake") {
        validateAndProcessStreamData(
          handleIncomingMessageReceiver.ports.length > 0,
          "Failed to confirm a MessageReceiver handshake: received event has no ports",
        );
        this.senderPort = handleIncomingMessageReceiver.ports[0];
        this.addMessageListener();
        __processCacheEntry(
          "[message-receiver]: handshake received!",
          this.senderPort,
        );
        this.send("internal/handshake/done");
        __processCacheEntry("[message-receiver]: finish handshake");
      }
    };
    window.addEventListener("message", ___handleIncomingMessage);
    handshakeDeferredPromise.then(() => {
      window.removeEventListener("message", ___handleIncomingMessage);
    });
    window.parent.postMessage(
      {
        type: "internal/ready",
      },
      "*",
    );
    return handshakeDeferredPromise;
  }
  addMessageListener() {
    validateAndProcessStreamData(
      this.senderPort,
      "[MessageReceiver] Failed to add a message listener: sender port is not defined. Did you forget to await a handshake?",
    );
    this.senderPort.onmessage = (handleDataEvent) => {
      let dataEvent = handleDataEvent.data;
      if (dataEvent.type != null) {
        this.emitter.dispatchEvent(
          new MessageEvent(dataEvent.type, {
            data: dataEvent.payload,
          }),
        );
      }
    };
  }
  on(handleOperationEvent, handleOperation, operationEventOptions) {
    this.emitter.addEventListener(
      handleOperationEvent,
      async (_handleMessageEvent) => {
        if (!(_handleMessageEvent instanceof MessageEvent)) {
          return;
        }
        let { operationId: operationId, payload: operationPayload } =
          _handleMessageEvent.data;
        try {
          let operationResult = await handleOperation(operationPayload);
          this.send("internal/operation/done", {
            operationId: operationId,
            listenerPayload: operationResult,
          });
        } catch (error) {
          if (error instanceof Error) {
            this.send("internal/operation/failed", {
              operationId: operationId,
              error: error,
            });
          }
        }
      },
      operationEventOptions,
    );
  }
  send(_messageType, ..._messagePayload) {
    validateAndProcessStreamData(
      this.senderPort,
      '[MessageReceiver] Failed to send a message "%j": sender port is not defined. Did you forget to await a handshake?',
      _messageType,
    );
    let __messagePayload = _messagePayload[0] || {};
    __processCacheEntry(
      '[message-receiver]: send "%s"',
      _messageType,
      __messagePayload,
    );
    this.senderPort.postMessage({
      type: _messageType,
      payload: __messagePayload,
    });
  }
};
var incrementNodeRemovalCount = previousRandomValue(
  handleInvalidArgumentError(),
);
var incrementNodeValidation = previousRandomValue(
  handleObjectTypeErrorsProcessor(),
);
var _incrementNodeRemovalCount = previousRandomValue(
  _____validateNumberInRange(),
);
var validateNodeRemovalFunction = previousRandomValue(
  handleInvalidArgumentError(),
);
var validateReadLimit = createCacheEntryLogger("emulator");
var validateAndReadStream = defineObjectProperties(getStylizedRepresentation());
var getReadableLength = 4294967295;
function _____processStreamData(
  calculateReadableLength,
  validateStreamRead,
  _getReadableLength,
) {
  var readableLengthInGigabytes = _getReadableLength / 4294967296;
  var streamDataLengthInBytes = _getReadableLength;
  calculateReadableLength.setUint32(
    validateStreamRead,
    readableLengthInGigabytes,
  );
  calculateReadableLength.setUint32(
    validateStreamRead + 4,
    streamDataLengthInBytes,
  );
}
function setBufferSizesBasedOnSignalLength(
  getAvailableDataLength,
  getBufferSizeOrDefault,
  checkAbortSignalAndCalculateLength,
) {
  var bufferSizeFromSignalLength = Math.floor(
    checkAbortSignalAndCalculateLength / 4294967296,
  );
  var signalLength = checkAbortSignalAndCalculateLength;
  getAvailableDataLength.setUint32(
    getBufferSizeOrDefault,
    bufferSizeFromSignalLength,
  );
  getAvailableDataLength.setUint32(getBufferSizeOrDefault + 4, signalLength);
}
function calculateLargeIntFromData(readFunction, readData) {
  var largeIntegerFromData = readFunction.getInt32(readData);
  var lowOrderLargeInt = readFunction.getUint32(readData + 4);
  return largeIntegerFromData * 4294967296 + lowOrderLargeInt;
}
function combineUInt32ToNumber(_______processData, _readData) {
  var highOrderUInt32 = _______processData.getUint32(_readData);
  var lowOrderUInt32 = _______processData.getUint32(_readData + 4);
  return highOrderUInt32 * 4294967296 + lowOrderUInt32;
}
var _bufferLength =
  (typeof process === "undefined" ||
    (process == null ? undefined : process.env)?.TEXT_ENCODING !== "never") &&
  typeof TextEncoder !== "undefined" &&
  typeof TextDecoder !== "undefined";
function calculateUtf8Length(validateRequestLength) {
  for (
    var iteratedCharacterCount = validateRequestLength.length,
      _byteCount = 0,
      byteIndex = 0;
    byteIndex < iteratedCharacterCount;

  ) {
    var charCode = validateRequestLength.charCodeAt(byteIndex++);
    if ((charCode & 4294967168) === 0) {
      _byteCount++;
      continue;
    } else if ((charCode & 4294965248) === 0) {
      _byteCount += 2;
    } else {
      if (
        charCode >= 55296 &&
        charCode <= 56319 &&
        byteIndex < iteratedCharacterCount
      ) {
        var currentCharCode = validateRequestLength.charCodeAt(byteIndex);
        if ((currentCharCode & 64512) === 56320) {
          ++byteIndex;
          charCode =
            ((charCode & 1023) << 10) + (currentCharCode & 1023) + 65536;
        }
      }
      if ((charCode & 4294901760) === 0) {
        _byteCount += 3;
      } else {
        _byteCount += 4;
      }
    }
  }
  return _byteCount;
}
function processAndValidateDataStream(
  checkAndReadDataStream,
  _validateAndReadStream,
  validateStreamReadiness,
) {
  for (
    var dataStreamLength = checkAndReadDataStream.length,
      streamDataIndex = validateStreamReadiness,
      ____currentIndex = 0;
    ____currentIndex < dataStreamLength;

  ) {
    var charCodeValue = checkAndReadDataStream.charCodeAt(____currentIndex++);
    if ((charCodeValue & 4294967168) === 0) {
      _validateAndReadStream[streamDataIndex++] = charCodeValue;
      continue;
    } else if ((charCodeValue & 4294965248) === 0) {
      _validateAndReadStream[streamDataIndex++] =
        ((charCodeValue >> 6) & 31) | 192;
    } else {
      if (
        charCodeValue >= 55296 &&
        charCodeValue <= 56319 &&
        ____currentIndex < dataStreamLength
      ) {
        var charCodeAtCurrentIndex =
          checkAndReadDataStream.charCodeAt(____currentIndex);
        if ((charCodeAtCurrentIndex & 64512) === 56320) {
          ++____currentIndex;
          charCodeValue =
            ((charCodeValue & 1023) << 10) +
            (charCodeAtCurrentIndex & 1023) +
            65536;
        }
      }
      if ((charCodeValue & 4294901760) === 0) {
        _validateAndReadStream[streamDataIndex++] =
          ((charCodeValue >> 12) & 15) | 224;
        _validateAndReadStream[streamDataIndex++] =
          ((charCodeValue >> 6) & 63) | 128;
      } else {
        _validateAndReadStream[streamDataIndex++] =
          ((charCodeValue >> 18) & 7) | 240;
        _validateAndReadStream[streamDataIndex++] =
          ((charCodeValue >> 12) & 63) | 128;
        _validateAndReadStream[streamDataIndex++] =
          ((charCodeValue >> 6) & 63) | 128;
      }
    }
    _validateAndReadStream[streamDataIndex++] = (charCodeValue & 63) | 128;
  }
}
var validateData = _bufferLength ? new TextEncoder() : undefined;
var processDataOrBuffer = _bufferLength
  ? typeof process !== "undefined" &&
    (process == null ? undefined : process.env)?.TEXT_ENCODING !== "force"
    ? 200
    : 0
  : getReadableLength;
function processAndEncodeChunk(
  processChunkData,
  processDataChunk,
  processStreamChunk,
) {
  processDataChunk.set(
    validateData.encode(processChunkData),
    processStreamChunk,
  );
}
function encodeBufferedData(
  processBufferedData,
  _processBufferedData,
  processPendingData,
) {
  validateData.encodeInto(
    processBufferedData,
    _processBufferedData.subarray(processPendingData),
  );
}
var currentDataLength = validateData?.encodeInto
  ? encodeBufferedData
  : processAndEncodeChunk;
var dataBuffer = 4096;
function decodeBufferToUtf8(
  handleBufferProcessing,
  processStreamData,
  handleDataProcessing,
) {
  for (
    var bufferIndex = processStreamData,
      decodedBufferEndIndex = bufferIndex + handleDataProcessing,
      decodedUnicodeCharacters = [],
      decodedString = "";
    bufferIndex < decodedBufferEndIndex;

  ) {
    var currentByte = handleBufferProcessing[bufferIndex++];
    if ((currentByte & 128) === 0) {
      decodedUnicodeCharacters.push(currentByte);
    } else if ((currentByte & 224) === 192) {
      var processedBufferValue = handleBufferProcessing[bufferIndex++] & 63;
      decodedUnicodeCharacters.push(
        ((currentByte & 31) << 6) | processedBufferValue,
      );
    } else if ((currentByte & 240) === 224) {
      var processedBufferValue = handleBufferProcessing[bufferIndex++] & 63;
      var secondProcessedBufferValue =
        handleBufferProcessing[bufferIndex++] & 63;
      decodedUnicodeCharacters.push(
        ((currentByte & 31) << 12) |
          (processedBufferValue << 6) |
          secondProcessedBufferValue,
      );
    } else if ((currentByte & 248) === 240) {
      var processedBufferValue = handleBufferProcessing[bufferIndex++] & 63;
      var secondProcessedBufferValue =
        handleBufferProcessing[bufferIndex++] & 63;
      var thirdProcessedBufferValue =
        handleBufferProcessing[bufferIndex++] & 63;
      var __decodedUnicodeValue =
        ((currentByte & 7) << 18) |
        (processedBufferValue << 12) |
        (secondProcessedBufferValue << 6) |
        thirdProcessedBufferValue;
      if (__decodedUnicodeValue > 65535) {
        __decodedUnicodeValue -= 65536;
        decodedUnicodeCharacters.push(
          ((__decodedUnicodeValue >>> 10) & 1023) | 55296,
        );
        __decodedUnicodeValue = (__decodedUnicodeValue & 1023) | 56320;
      }
      decodedUnicodeCharacters.push(__decodedUnicodeValue);
    } else {
      decodedUnicodeCharacters.push(currentByte);
    }
    if (decodedUnicodeCharacters.length >= dataBuffer) {
      decodedString += String.fromCharCode.apply(
        String,
        decodedUnicodeCharacters,
      );
      decodedUnicodeCharacters.length = 0;
    }
  }
  if (decodedUnicodeCharacters.length > 0) {
    decodedString += String.fromCharCode.apply(
      String,
      decodedUnicodeCharacters,
    );
  }
  return decodedString;
}
var handlePendingTasks = _bufferLength ? new TextDecoder() : null;
var _processPendingTasks = _bufferLength
  ? typeof process !== "undefined" &&
    (process == null ? undefined : process.env)?.TEXT_DECODER !== "force"
    ? 200
    : 0
  : getReadableLength;
function decodeReadableStateChange(
  emitReadableStateChange,
  _emitReadableStateChange,
  emitReadableStateCheck,
) {
  var readableStateChangeSlice = emitReadableStateChange.subarray(
    _emitReadableStateChange,
    _emitReadableStateChange + emitReadableStateCheck,
  );
  return handlePendingTasks.decode(readableStateChangeSlice);
}
var handleEmittedReadable = (function () {
  function ReadableEventEmitter(emitReadableEvent, emitReadableStateListener) {
    this.type = emitReadableEvent;
    this.data = emitReadableStateListener;
  }
  return ReadableEventEmitter;
})();
var emitReadableState = (function () {
  function manageReadableStreamState(
    handleReadableStateChange,
    addNextTickListenerHandler,
  ) {
    manageReadableStreamState =
      Object.setPrototypeOf ||
      ({
        __proto__: [],
      } instanceof Array &&
        function (updateStreamReadableState, processStreamReadableState) {
          updateStreamReadableState.__proto__ = processStreamReadableState;
        }) ||
      function (handleReadableStream, checkReadableStreamState) {
        for (var streamStateKey in checkReadableStreamState) {
          if (
            Object.prototype.hasOwnProperty.call(
              checkReadableStreamState,
              streamStateKey,
            )
          ) {
            handleReadableStream[streamStateKey] =
              checkReadableStreamState[streamStateKey];
          }
        }
      };
    return manageReadableStreamState(
      handleReadableStateChange,
      addNextTickListenerHandler,
    );
  }
  return function (processNextTickIfNeeded, scheduleReadingMore) {
    if (
      typeof scheduleReadingMore != "function" &&
      scheduleReadingMore !== null
    ) {
      throw new TypeError(
        "Class extends value " +
          String(scheduleReadingMore) +
          " is not a constructor or null",
      );
    }
    manageReadableStreamState(processNextTickIfNeeded, scheduleReadingMore);
    function setProcessNextTickConstructor() {
      this.constructor = processNextTickIfNeeded;
    }
    if (scheduleReadingMore === null) {
      processNextTickIfNeeded.prototype = Object.create(scheduleReadingMore);
    } else {
      processNextTickIfNeeded.prototype =
        ((setProcessNextTickConstructor.prototype =
          scheduleReadingMore.prototype),
        new setProcessNextTickConstructor());
    }
  };
})();
var characterEncodingLength = (function (
  __calculateAndProcessCharacterEncoding,
) {
  emitReadableState(
    _createCharacterEncodingProcessor,
    __calculateAndProcessCharacterEncoding,
  );
  function _createCharacterEncodingProcessor(
    ___calculateAndProcessCharacterEncoding,
  ) {
    var ___characterEncodingProcessor =
      __calculateAndProcessCharacterEncoding.call(
        this,
        ___calculateAndProcessCharacterEncoding,
      ) || this;
    var characterEncodingProcessorPrototype = Object.create(
      _createCharacterEncodingProcessor.prototype,
    );
    Object.setPrototypeOf(
      ___characterEncodingProcessor,
      characterEncodingProcessorPrototype,
    );
    Object.defineProperty(___characterEncodingProcessor, "name", {
      configurable: true,
      enumerable: false,
      value: _createCharacterEncodingProcessor.name,
    });
    return ___characterEncodingProcessor;
  }
  return _createCharacterEncodingProcessor;
})(Error);
var rgCharacterEncoding = -1;
var ___validateAndProcessCharacterEncoding = 4294967295;
var ____validateAndProcessCharacterEncoding = 17179869183;
function ___________validateAndProcessCharacterEncoding(
  _____validateAndProcessCharacterEncoding,
) {
  var getEncodedCharacterData = _____validateAndProcessCharacterEncoding.sec;
  var ____________validateAndProcessCharacterEncoding =
    _____validateAndProcessCharacterEncoding.nsec;
  if (
    getEncodedCharacterData >= 0 &&
    ____________validateAndProcessCharacterEncoding >= 0 &&
    getEncodedCharacterData <= ____validateAndProcessCharacterEncoding
  ) {
    if (
      ____________validateAndProcessCharacterEncoding === 0 &&
      getEncodedCharacterData <= ___validateAndProcessCharacterEncoding
    ) {
      var characterEncodingArray = new Uint8Array(4);
      var characterEncodingDataView = new DataView(
        characterEncodingArray.buffer,
      );
      characterEncodingDataView.setUint32(0, getEncodedCharacterData);
      return characterEncodingArray;
    } else {
      var encodedCharacterArray = getEncodedCharacterData / 4294967296;
      var characterEncodingLow = getEncodedCharacterData & 4294967295;
      var characterEncodingArray = new Uint8Array(8);
      var characterEncodingDataView = new DataView(
        characterEncodingArray.buffer,
      );
      characterEncodingDataView.setUint32(
        0,
        (____________validateAndProcessCharacterEncoding << 2) |
          (encodedCharacterArray & 3),
      );
      characterEncodingDataView.setUint32(4, characterEncodingLow);
      return characterEncodingArray;
    }
  } else {
    var characterEncodingArray = new Uint8Array(12);
    var characterEncodingDataView = new DataView(characterEncodingArray.buffer);
    characterEncodingDataView.setUint32(
      0,
      ____________validateAndProcessCharacterEncoding,
    );
    setBufferSizesBasedOnSignalLength(
      characterEncodingDataView,
      4,
      getEncodedCharacterData,
    );
    return characterEncodingArray;
  }
}
function convertEndEventTimeToNanoseconds(endEmittedEventHandler) {
  var endEventTimeInMillis = endEmittedEventHandler.getTime();
  var endEventTimeInSeconds = Math.floor(endEventTimeInMillis / 1000);
  var endEventTimeInNanoseconds =
    (endEventTimeInMillis - endEventTimeInSeconds * 1000) * 1000000;
  var endEventTimeInSecondsFull = Math.floor(
    endEventTimeInNanoseconds / 1000000000,
  );
  return {
    sec: endEventTimeInSeconds + endEventTimeInSecondsFull,
    nsec: endEventTimeInNanoseconds - endEventTimeInSecondsFull * 1000000000,
  };
}
function validateAndProcessStreamCleanup(handleStreamCleanup) {
  if (handleStreamCleanup instanceof Date) {
    var convertedEndEventTimeInNanoseconds =
      convertEndEventTimeToNanoseconds(handleStreamCleanup);
    return ___________validateAndProcessCharacterEncoding(
      convertedEndEventTimeInNanoseconds,
    );
  } else {
    return null;
  }
}
function parseTimestamp(handleStreamUnpipe) {
  var timestampDataView = new DataView(
    handleStreamUnpipe.buffer,
    handleStreamUnpipe.byteOffset,
    handleStreamUnpipe.byteLength,
  );
  switch (handleStreamUnpipe.byteLength) {
    case 4: {
      var combinedTimestampInNanoseconds = timestampDataView.getUint32(0);
      var timestampSeconds = 0;
      return {
        sec: combinedTimestampInNanoseconds,
        nsec: timestampSeconds,
      };
    }
    case 8: {
      var getTimestampInSecondsAndNanoseconds = timestampDataView.getUint32(0);
      var nanosecondsPart = timestampDataView.getUint32(4);
      var combinedTimestampInNanoseconds =
        (getTimestampInSecondsAndNanoseconds & 3) * 4294967296 +
        nanosecondsPart;
      var timestampSeconds = getTimestampInSecondsAndNanoseconds >>> 2;
      return {
        sec: combinedTimestampInNanoseconds,
        nsec: timestampSeconds,
      };
    }
    case 12: {
      var combinedTimestampInNanoseconds = calculateLargeIntFromData(
        timestampDataView,
        4,
      );
      var timestampSeconds = timestampDataView.getUint32(0);
      return {
        sec: combinedTimestampInNanoseconds,
        nsec: timestampSeconds,
      };
    }
    default:
      throw new characterEncodingLength(
        `Unrecognized data size for timestamp (expected 4, 8, or 12): ${handleStreamUnpipe.length}`,
      );
  }
}
function convertTimestampToDate(handleEndEvent) {
  var timestampToDate = parseTimestamp(handleEndEvent);
  return new Date(timestampToDate.sec * 1000 + timestampToDate.nsec / 1000000);
}
var isProcessingData = {
  type: rgCharacterEncoding,
  encode: validateAndProcessStreamCleanup,
  decode: convertTimestampToDate,
};
var handleWritablePipes = (function () {
  function DataEncoderDecoderManager() {
    this.builtInEncoders = [];
    this.builtInDecoders = [];
    this.encoders = [];
    this.decoders = [];
    this.register(isProcessingData);
  }
  DataEncoderDecoderManager.prototype.register = function (
    __validateCharacterEncoding,
  ) {
    var characterEncodingType = __validateCharacterEncoding.type;
    var characterEncodingEncodeFunction = __validateCharacterEncoding.encode;
    var characterEncodingDecodeFunction = __validateCharacterEncoding.decode;
    if (characterEncodingType >= 0) {
      this.encoders[characterEncodingType] = characterEncodingEncodeFunction;
      this.decoders[characterEncodingType] = characterEncodingDecodeFunction;
    } else {
      var characterEncodingIndex = 1 + characterEncodingType;
      this.builtInEncoders[characterEncodingIndex] =
        characterEncodingEncodeFunction;
      this.builtInDecoders[characterEncodingIndex] =
        characterEncodingDecodeFunction;
    }
  };
  DataEncoderDecoderManager.prototype.tryToEncode = function (
    ______validateAndProcessCharacterEncoding,
    addCharacterEncodingHandler,
  ) {
    for (
      var encoderIndex = 0;
      encoderIndex < this.builtInEncoders.length;
      encoderIndex++
    ) {
      var selectedEncoder = this.builtInEncoders[encoderIndex];
      if (selectedEncoder != null) {
        var characterEncodingHandler = selectedEncoder(
          ______validateAndProcessCharacterEncoding,
          addCharacterEncodingHandler,
        );
        if (characterEncodingHandler != null) {
          var readableStreamOffset = -1 - encoderIndex;
          return new handleEmittedReadable(
            readableStreamOffset,
            characterEncodingHandler,
          );
        }
      }
    }
    for (
      var encoderIndex = 0;
      encoderIndex < this.encoders.length;
      encoderIndex++
    ) {
      var selectedEncoder = this.encoders[encoderIndex];
      if (selectedEncoder != null) {
        var characterEncodingHandler = selectedEncoder(
          ______validateAndProcessCharacterEncoding,
          addCharacterEncodingHandler,
        );
        if (characterEncodingHandler != null) {
          var readableStreamOffset = encoderIndex;
          return new handleEmittedReadable(
            readableStreamOffset,
            characterEncodingHandler,
          );
        }
      }
    }
    if (
      ______validateAndProcessCharacterEncoding instanceof handleEmittedReadable
    ) {
      return ______validateAndProcessCharacterEncoding;
    } else {
      return null;
    }
  };
  DataEncoderDecoderManager.prototype.decode = function (
    _______validateAndProcessCharacterEncoding,
    ________validateAndProcessCharacterEncoding,
    _________validateAndProcessCharacterEncoding,
  ) {
    var decoderFunction =
      ________validateAndProcessCharacterEncoding < 0
        ? this.builtInDecoders[-1 - ________validateAndProcessCharacterEncoding]
        : this.decoders[________validateAndProcessCharacterEncoding];
    if (decoderFunction) {
      return decoderFunction(
        _______validateAndProcessCharacterEncoding,
        ________validateAndProcessCharacterEncoding,
        _________validateAndProcessCharacterEncoding,
      );
    } else {
      return new handleEmittedReadable(
        ________validateAndProcessCharacterEncoding,
        _______validateAndProcessCharacterEncoding,
      );
    }
  };
  DataEncoderDecoderManager.defaultCodec = new DataEncoderDecoderManager();
  return DataEncoderDecoderManager;
})();
function validateAndConvertToUint8Array(
  __________validateAndProcessCharacterEncoding,
) {
  if (__________validateAndProcessCharacterEncoding instanceof Uint8Array) {
    return __________validateAndProcessCharacterEncoding;
  } else if (
    ArrayBuffer.isView(__________validateAndProcessCharacterEncoding)
  ) {
    return new Uint8Array(
      __________validateAndProcessCharacterEncoding.buffer,
      __________validateAndProcessCharacterEncoding.byteOffset,
      __________validateAndProcessCharacterEncoding.byteLength,
    );
  } else if (
    __________validateAndProcessCharacterEncoding instanceof ArrayBuffer
  ) {
    return new Uint8Array(__________validateAndProcessCharacterEncoding);
  } else {
    return Uint8Array.from(__________validateAndProcessCharacterEncoding);
  }
}
function createDataViewFromBuffer(onCharacterEncodingCloseHandler) {
  if (onCharacterEncodingCloseHandler instanceof ArrayBuffer) {
    return new DataView(onCharacterEncodingCloseHandler);
  }
  var uint8ArrayFromHandler = validateAndConvertToUint8Array(
    onCharacterEncodingCloseHandler,
  );
  return new DataView(
    uint8ArrayFromHandler.buffer,
    uint8ArrayFromHandler.byteOffset,
    uint8ArrayFromHandler.byteLength,
  );
}
var checkWritableStateDrain = 100;
var handleDrainEvents = 2048;
var processReadableStreamDrain = (function () {
  function WritablePipeSettings(
    defaultWritablePipeCodec = handleWritablePipes.defaultCodec,
    dataValue = undefined,
    _checkWritableStateDrain = checkWritableStateDrain,
    _handleDrainEvents = handleDrainEvents,
    __isValidInput = false,
    isFeatureEnabled = false,
    isUserAuthenticated = false,
    isProcessActive = false,
  ) {
    this.extensionCodec = defaultWritablePipeCodec;
    this.context = dataValue;
    this.maxDepth = _checkWritableStateDrain;
    this.initialBufferSize = _handleDrainEvents;
    this.sortKeys = __isValidInput;
    this.forceFloat32 = isFeatureEnabled;
    this.ignoreUndefined = isUserAuthenticated;
    this.forceIntegerToFloat = isProcessActive;
    this.pos = 0;
    this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
    this.bytes = new Uint8Array(this.view.buffer);
  }
  WritablePipeSettings.prototype.reinitializeState = function () {
    this.pos = 0;
  };
  WritablePipeSettings.prototype.encodeSharedRef = function (handlePipeDrain) {
    this.reinitializeState();
    this.doEncode(handlePipeDrain, 1);
    return this.bytes.subarray(0, this.pos);
  };
  WritablePipeSettings.prototype.encode = function (unpipeStream) {
    this.reinitializeState();
    this.doEncode(unpipeStream, 1);
    return this.bytes.slice(0, this.pos);
  };
  WritablePipeSettings.prototype.doEncode = function (
    _unpipeStream,
    __unpipeStream,
  ) {
    if (__unpipeStream > this.maxDepth) {
      throw new Error(`Too deep objects in depth ${__unpipeStream}`);
    }
    if (_unpipeStream == null) {
      this.encodeNil();
    } else if (typeof _unpipeStream == "boolean") {
      this.encodeBoolean(_unpipeStream);
    } else if (typeof _unpipeStream == "number") {
      this.encodeNumber(_unpipeStream);
    } else if (typeof _unpipeStream == "string") {
      this.encodeString(_unpipeStream);
    } else {
      this.encodeObject(_unpipeStream, __unpipeStream);
    }
  };
  WritablePipeSettings.prototype.ensureBufferSizeToWrite = function (
    handlePipeUnpipe,
  ) {
    var newBufferPosition = this.pos + handlePipeUnpipe;
    if (this.view.byteLength < newBufferPosition) {
      this.resizeBuffer(newBufferPosition * 2);
    }
  };
  WritablePipeSettings.prototype.resizeBuffer = function (handlePipeUnlink) {
    var _bufferSize = new ArrayBuffer(handlePipeUnlink);
    var byteArrayBuffer = new Uint8Array(_bufferSize);
    var dataView = new DataView(_bufferSize);
    byteArrayBuffer.set(this.bytes);
    this.view = dataView;
    this.bytes = byteArrayBuffer;
  };
  WritablePipeSettings.prototype.encodeNil = function () {
    this.writeU8(192);
  };
  WritablePipeSettings.prototype.encodeBoolean = function (
    handleVersionRangeEvents,
  ) {
    if (handleVersionRangeEvents === false) {
      this.writeU8(194);
    } else {
      this.writeU8(195);
    }
  };
  WritablePipeSettings.prototype.encodeNumber = function (
    handleReadableEvents,
  ) {
    if (
      Number.isSafeInteger(handleReadableEvents) &&
      !this.forceIntegerToFloat
    ) {
      if (handleReadableEvents >= 0) {
        if (handleReadableEvents < 128) {
          this.writeU8(handleReadableEvents);
        } else if (handleReadableEvents < 256) {
          this.writeU8(204);
          this.writeU8(handleReadableEvents);
        } else if (handleReadableEvents < 65536) {
          this.writeU8(205);
          this.writeU16(handleReadableEvents);
        } else if (handleReadableEvents < 4294967296) {
          this.writeU8(206);
          this.writeU32(handleReadableEvents);
        } else {
          this.writeU8(207);
          this.writeU64(handleReadableEvents);
        }
      } else if (handleReadableEvents >= -32) {
        this.writeU8((handleReadableEvents + 32) | 224);
      } else if (handleReadableEvents >= -128) {
        this.writeU8(208);
        this.writeI8(handleReadableEvents);
      } else if (handleReadableEvents >= -32768) {
        this.writeU8(209);
        this.writeI16(handleReadableEvents);
      } else if (handleReadableEvents >= -2147483648) {
        this.writeU8(210);
        this.writeI32(handleReadableEvents);
      } else {
        this.writeU8(211);
        this.writeI64(handleReadableEvents);
      }
    } else if (this.forceFloat32) {
      this.writeU8(202);
      this.writeF32(handleReadableEvents);
    } else {
      this.writeU8(203);
      this.writeF64(handleReadableEvents);
    }
  };
  WritablePipeSettings.prototype.writeStringHeader = function (
    handleReadableStateUpdate,
  ) {
    if (handleReadableStateUpdate < 32) {
      this.writeU8(160 + handleReadableStateUpdate);
    } else if (handleReadableStateUpdate < 256) {
      this.writeU8(217);
      this.writeU8(handleReadableStateUpdate);
    } else if (handleReadableStateUpdate < 65536) {
      this.writeU8(218);
      this.writeU16(handleReadableStateUpdate);
    } else if (handleReadableStateUpdate < 4294967296) {
      this.writeU8(219);
      this.writeU32(handleReadableStateUpdate);
    } else {
      throw new Error(
        `Too long string: ${handleReadableStateUpdate} bytes in UTF-8`,
      );
    }
  };
  WritablePipeSettings.prototype.encodeString = function (
    checkReadableStreamErrors,
  ) {
    var baseBufferSize = 5;
    var checkReadableStreamLength = checkReadableStreamErrors.length;
    if (checkReadableStreamLength > processDataOrBuffer) {
      var utf8Length = calculateUtf8Length(checkReadableStreamErrors);
      this.ensureBufferSizeToWrite(baseBufferSize + utf8Length);
      this.writeStringHeader(utf8Length);
      currentDataLength(checkReadableStreamErrors, this.bytes, this.pos);
      this.pos += utf8Length;
    } else {
      var utf8Length = calculateUtf8Length(checkReadableStreamErrors);
      this.ensureBufferSizeToWrite(baseBufferSize + utf8Length);
      this.writeStringHeader(utf8Length);
      processAndValidateDataStream(
        checkReadableStreamErrors,
        this.bytes,
        this.pos,
      );
      this.pos += utf8Length;
    }
  };
  WritablePipeSettings.prototype.encodeObject = function (
    checkAndResumeUpdateVersionConstraints,
    resumeUpdateVersionConstraints,
  ) {
    var encodedVersionConstraints = this.extensionCodec.tryToEncode(
      checkAndResumeUpdateVersionConstraints,
      this.context,
    );
    if (encodedVersionConstraints != null) {
      this.encodeExtension(encodedVersionConstraints);
    } else if (Array.isArray(checkAndResumeUpdateVersionConstraints)) {
      this.encodeArray(
        checkAndResumeUpdateVersionConstraints,
        resumeUpdateVersionConstraints,
      );
    } else if (ArrayBuffer.isView(checkAndResumeUpdateVersionConstraints)) {
      this.encodeBinary(checkAndResumeUpdateVersionConstraints);
    } else if (typeof checkAndResumeUpdateVersionConstraints == "object") {
      this.encodeMap(
        checkAndResumeUpdateVersionConstraints,
        resumeUpdateVersionConstraints,
      );
    } else {
      throw new Error(
        `Unrecognized object: ${Object.prototype.toString.apply(checkAndResumeUpdateVersionConstraints)}`,
      );
    }
  };
  WritablePipeSettings.prototype.encodeBinary = function (handleSuspendUpdate) {
    var handleSuspendUpdateLength = handleSuspendUpdate.byteLength;
    if (handleSuspendUpdateLength < 256) {
      this.writeU8(196);
      this.writeU8(handleSuspendUpdateLength);
    } else if (handleSuspendUpdateLength < 65536) {
      this.writeU8(197);
      this.writeU16(handleSuspendUpdateLength);
    } else if (handleSuspendUpdateLength < 4294967296) {
      this.writeU8(198);
      this.writeU32(handleSuspendUpdateLength);
    } else {
      throw new Error(`Too large binary: ${handleSuspendUpdateLength}`);
    }
    var suspendUpdateBinaryData =
      validateAndConvertToUint8Array(handleSuspendUpdate);
    this.writeU8a(suspendUpdateBinaryData);
  };
  WritablePipeSettings.prototype.encodeArray = function (
    handleDataStream,
    onDataReceived,
  ) {
    var _dataStreamLength = handleDataStream.length;
    if (_dataStreamLength < 16) {
      this.writeU8(144 + _dataStreamLength);
    } else if (_dataStreamLength < 65536) {
      this.writeU8(220);
      this.writeU16(_dataStreamLength);
    } else if (_dataStreamLength < 4294967296) {
      this.writeU8(221);
      this.writeU32(_dataStreamLength);
    } else {
      throw new Error(`Too large array: ${_dataStreamLength}`);
    }
    for (
      var dataStreamIndex = 0, dataStreamHandler = handleDataStream;
      dataStreamIndex < dataStreamHandler.length;
      dataStreamIndex++
    ) {
      var currentDataStream = dataStreamHandler[dataStreamIndex];
      this.doEncode(currentDataStream, onDataReceived + 1);
    }
  };
  WritablePipeSettings.prototype.countWithoutUndefined = function (
    handleStreamError,
    errorHandler,
  ) {
    var countValidErrorHandlers = 0;
    for (
      var errorHandlerIndex = 0, errorHandlersList = errorHandler;
      errorHandlerIndex < errorHandlersList.length;
      errorHandlerIndex++
    ) {
      var currentErrorHandler = errorHandlersList[errorHandlerIndex];
      if (handleStreamError[currentErrorHandler] !== undefined) {
        countValidErrorHandlers++;
      }
    }
    return countValidErrorHandlers;
  };
  WritablePipeSettings.prototype.encodeMap = function (
    streamHandler,
    handleStreamErrors,
  ) {
    var streamHandlerKeys = Object.keys(streamHandler);
    if (this.sortKeys) {
      streamHandlerKeys.sort();
    }
    var countOfKeys = this.ignoreUndefined
      ? this.countWithoutUndefined(streamHandler, streamHandlerKeys)
      : streamHandlerKeys.length;
    if (countOfKeys < 16) {
      this.writeU8(128 + countOfKeys);
    } else if (countOfKeys < 65536) {
      this.writeU8(222);
      this.writeU16(countOfKeys);
    } else if (countOfKeys < 4294967296) {
      this.writeU8(223);
      this.writeU32(countOfKeys);
    } else {
      throw new Error(`Too large map object: ${countOfKeys}`);
    }
    for (
      var streamHandlerKeyIndex = 0, streamHandlerKeysArray = streamHandlerKeys;
      streamHandlerKeyIndex < streamHandlerKeysArray.length;
      streamHandlerKeyIndex++
    ) {
      var currentStreamHandlerKey =
        streamHandlerKeysArray[streamHandlerKeyIndex];
      var currentStreamHandler = streamHandler[currentStreamHandlerKey];
      if (!this.ignoreUndefined || currentStreamHandler !== undefined) {
        this.encodeString(currentStreamHandlerKey);
        this.doEncode(currentStreamHandler, handleStreamErrors + 1);
      }
    }
  };
  WritablePipeSettings.prototype.encodeExtension = function (
    validateStreamErrors,
  ) {
    var dataLength = validateStreamErrors.data.length;
    if (dataLength === 1) {
      this.writeU8(212);
    } else if (dataLength === 2) {
      this.writeU8(213);
    } else if (dataLength === 4) {
      this.writeU8(214);
    } else if (dataLength === 8) {
      this.writeU8(215);
    } else if (dataLength === 16) {
      this.writeU8(216);
    } else if (dataLength < 256) {
      this.writeU8(199);
      this.writeU8(dataLength);
    } else if (dataLength < 65536) {
      this.writeU8(200);
      this.writeU16(dataLength);
    } else if (dataLength < 4294967296) {
      this.writeU8(201);
      this.writeU32(dataLength);
    } else {
      throw new Error(`Too large extension object: ${dataLength}`);
    }
    this.writeI8(validateStreamErrors.type);
    this.writeU8a(validateStreamErrors.data);
  };
  WritablePipeSettings.prototype.writeU8 = function (
    handleSemverPrereleaseErrors,
  ) {
    this.ensureBufferSizeToWrite(1);
    this.view.setUint8(this.pos, handleSemverPrereleaseErrors);
    this.pos++;
  };
  WritablePipeSettings.prototype.writeU8a = function (_errorHandler) {
    var errorHandlerLength = _errorHandler.length;
    this.ensureBufferSizeToWrite(errorHandlerLength);
    this.bytes.set(_errorHandler, this.pos);
    this.pos += errorHandlerLength;
  };
  WritablePipeSettings.prototype.writeI8 = function (
    ___validateSemverPrerelease,
  ) {
    this.ensureBufferSizeToWrite(1);
    this.view.setInt8(this.pos, ___validateSemverPrerelease);
    this.pos++;
  };
  WritablePipeSettings.prototype.writeU16 = function (streamError) {
    this.ensureBufferSizeToWrite(2);
    this.view.setUint16(this.pos, streamError);
    this.pos += 2;
  };
  WritablePipeSettings.prototype.writeI16 = function (_handleStreamErrors) {
    this.ensureBufferSizeToWrite(2);
    this.view.setInt16(this.pos, _handleStreamErrors);
    this.pos += 2;
  };
  WritablePipeSettings.prototype.writeU32 = function (shouldDestroyOnReturn) {
    this.ensureBufferSizeToWrite(4);
    this.view.setUint32(this.pos, shouldDestroyOnReturn);
    this.pos += 4;
  };
  WritablePipeSettings.prototype.writeI32 = function (onReadableStateChange) {
    this.ensureBufferSizeToWrite(4);
    this.view.setInt32(this.pos, onReadableStateChange);
    this.pos += 4;
  };
  WritablePipeSettings.prototype.writeF32 = function (getReadableState) {
    this.ensureBufferSizeToWrite(4);
    this.view.setFloat32(this.pos, getReadableState);
    this.pos += 4;
  };
  WritablePipeSettings.prototype.writeF64 = function (isReadable) {
    this.ensureBufferSizeToWrite(8);
    this.view.setFloat64(this.pos, isReadable);
    this.pos += 8;
  };
  WritablePipeSettings.prototype.writeU64 = function (_isReadable) {
    this.ensureBufferSizeToWrite(8);
    _____processStreamData(this.view, this.pos, _isReadable);
    this.pos += 8;
  };
  WritablePipeSettings.prototype.writeI64 = function (isReadableFlowing) {
    this.ensureBufferSizeToWrite(8);
    setBufferSizesBasedOnSignalLength(this.view, this.pos, isReadableFlowing);
    this.pos += 8;
  };
  return WritablePipeSettings;
})();
var __isReadable = {};
function createReadableStreamDrain(
  setReadableFlowingState,
  isContentReadable = __isReadable,
) {
  var readableStreamDrain = new processReadableStreamDrain(
    isContentReadable.extensionCodec,
    isContentReadable.context,
    isContentReadable.maxDepth,
    isContentReadable.initialBufferSize,
    isContentReadable.sortKeys,
    isContentReadable.forceFloat32,
    isContentReadable.ignoreUndefined,
    isContentReadable.forceIntegerToFloat,
  );
  return readableStreamDrain.encodeSharedRef(setReadableFlowingState);
}
function formatReadableFlowingState(_setReadableFlowingState) {
  return `${_setReadableFlowingState < 0 ? "-" : ""}0x${Math.abs(_setReadableFlowingState).toString(16).padStart(2, "0")}`;
}
var readableStateBuffer = 16;
var _readableStateBuffer = 16;
var __getReadableLength = (function () {
  function CacheBufferManager(
    __readableStateBuffer = readableStateBuffer,
    ___readableStateBuffer = _readableStateBuffer,
  ) {
    this.maxKeyLength = __readableStateBuffer;
    this.maxLengthPerKey = ___readableStateBuffer;
    this.hit = 0;
    this.miss = 0;
    this.caches = [];
    for (var cacheArray = 0; cacheArray < this.maxKeyLength; cacheArray++) {
      this.caches.push([]);
    }
  }
  CacheBufferManager.prototype.canBeCached = function (readableStreamState) {
    return readableStreamState > 0 && readableStreamState <= this.maxKeyLength;
  };
  CacheBufferManager.prototype.find = function (
    getReadableStateProperties,
    _getReadableStateProperties,
    getReadableStateLength,
  ) {
    var lastCacheEntry = this.caches[getReadableStateLength - 1];
    _0x5d14ec: for (
      var cacheEntryCount = 0, lastCacheEntries = lastCacheEntry;
      cacheEntryCount < lastCacheEntries.length;
      cacheEntryCount++
    ) {
      var _lastCacheEntry = lastCacheEntries[cacheEntryCount];
      var lastCacheEntryBytes = _lastCacheEntry.bytes;
      for (
        var ________index = 0;
        ________index < getReadableStateLength;
        ________index++
      ) {
        if (
          lastCacheEntryBytes[________index] !==
          getReadableStateProperties[
            _getReadableStateProperties + ________index
          ]
        ) {
          continue _0x5d14ec;
        }
      }
      return _lastCacheEntry.str;
    }
    return null;
  };
  CacheBufferManager.prototype.store = function (
    setStreamDestroyedState,
    isStreamDestroyed,
  ) {
    var currentCache = this.caches[setStreamDestroyedState.length - 1];
    var __streamData = {
      bytes: setStreamDestroyedState,
      str: isStreamDestroyed,
    };
    if (currentCache.length >= this.maxLengthPerKey) {
      currentCache[(Math.random() * currentCache.length) | 0] = __streamData;
    } else {
      currentCache.push(__streamData);
    }
  };
  CacheBufferManager.prototype.decode = function (
    isReadableStreamClosed,
    isDestroyed,
    setReadableStateDestroyed,
  ) {
    var foundReadableStream = this.find(
      isReadableStreamClosed,
      isDestroyed,
      setReadableStateDestroyed,
    );
    if (foundReadableStream != null) {
      this.hit++;
      return foundReadableStream;
    }
    this.miss++;
    var decodedStreamData = decodeBufferToUtf8(
      isReadableStreamClosed,
      isDestroyed,
      setReadableStateDestroyed,
    );
    var slicedReadableStreamData = Uint8Array.prototype.slice.call(
      isReadableStreamClosed,
      isDestroyed,
      isDestroyed + setReadableStateDestroyed,
    );
    this.store(slicedReadableStreamData, decodedStreamData);
    return decodedStreamData;
  };
  return CacheBufferManager;
})();
function createReadablePromise(
  isReadableEnded,
  _isReadableEnded,
  _setReadableStateDestroyed,
  __setReadableStateDestroyed,
) {
  function createReadableStateInstance(___setReadableStateDestroyed) {
    if (___setReadableStateDestroyed instanceof _setReadableStateDestroyed) {
      return ___setReadableStateDestroyed;
    } else {
      return new _setReadableStateDestroyed(function (updateReadableState) {
        updateReadableState(___setReadableStateDestroyed);
      });
    }
  }
  return new (_setReadableStateDestroyed ||= Promise)(function (
    isReadableEndEmitted,
    getReadableStateEndEmitted,
  ) {
    function handleReadableStateEndEmitted(_getReadableStateEndEmitted) {
      try {
        handlePauseState(
          __setReadableStateDestroyed.next(_getReadableStateEndEmitted),
        );
      } catch (______________error) {
        getReadableStateEndEmitted(______________error);
      }
    }
    function processPipesCount(getPipesCount) {
      try {
        handlePauseState(__setReadableStateDestroyed.throw(getPipesCount));
      } catch (_______________error) {
        getReadableStateEndEmitted(_______________error);
      }
    }
    function handlePauseState(isPaused) {
      if (isPaused.done) {
        isReadableEndEmitted(isPaused.value);
      } else {
        createReadableStateInstance(isPaused.value).then(
          handleReadableStateEndEmitted,
          processPipesCount,
        );
      }
    }
    handlePauseState(
      (__setReadableStateDestroyed = __setReadableStateDestroyed.apply(
        isReadableEnded,
        _isReadableEnded || [],
      )).next(),
    );
  });
}
function processBufferGenerator(processBuffer, _processBuffer) {
  var generatorState = {
    label: 0,
    sent() {
      if (generatorExecutionContext[0] & 1) {
        throw generatorExecutionContext[1];
      }
      return generatorExecutionContext[1];
    },
    trys: [],
    ops: [],
  };
  var isGeneratorExecuting;
  var currentGeneratorContext;
  var generatorExecutionContext;
  var generatorInterface;
  generatorInterface = {
    next: createEventProcessor(0),
    throw: createEventProcessor(1),
    return: createEventProcessor(2),
  };
  if (typeof Symbol == "function") {
    generatorInterface[Symbol.iterator] = function () {
      return this;
    };
  }
  return generatorInterface;
  function createEventProcessor(processEventBuffer) {
    return function (processComparatorEventHandler) {
      return executeGeneratorStep([
        processEventBuffer,
        processComparatorEventHandler,
      ]);
    };
  }
  function executeGeneratorStep(_processEventBuffer) {
    if (isGeneratorExecuting) {
      throw new TypeError("Generator is already executing.");
    }
    while (generatorState) {
      try {
        isGeneratorExecuting = 1;
        if (
          currentGeneratorContext &&
          (generatorExecutionContext =
            _processEventBuffer[0] & 2
              ? currentGeneratorContext.return
              : _processEventBuffer[0]
                ? currentGeneratorContext.throw ||
                  ((generatorExecutionContext =
                    currentGeneratorContext.return) &&
                    generatorExecutionContext.call(currentGeneratorContext),
                  0)
                : currentGeneratorContext.next) &&
          !(generatorExecutionContext = generatorExecutionContext.call(
            currentGeneratorContext,
            _processEventBuffer[1],
          )).done
        ) {
          return generatorExecutionContext;
        }
        currentGeneratorContext = 0;
        if (generatorExecutionContext) {
          _processEventBuffer = [
            _processEventBuffer[0] & 2,
            generatorExecutionContext.value,
          ];
        }
        switch (_processEventBuffer[0]) {
          case 0:
          case 1:
            generatorExecutionContext = _processEventBuffer;
            break;
          case 4:
            generatorState.label++;
            return {
              value: _processEventBuffer[1],
              done: false,
            };
          case 5:
            generatorState.label++;
            currentGeneratorContext = _processEventBuffer[1];
            _processEventBuffer = [0];
            continue;
          case 7:
            _processEventBuffer = generatorState.ops.pop();
            generatorState.trys.pop();
            continue;
          default:
            generatorExecutionContext = generatorState.trys;
            if (
              !(generatorExecutionContext =
                generatorExecutionContext.length > 0 &&
                generatorExecutionContext[
                  generatorExecutionContext.length - 1
                ]) &&
              (_processEventBuffer[0] === 6 || _processEventBuffer[0] === 2)
            ) {
              generatorState = 0;
              continue;
            }
            if (
              _processEventBuffer[0] === 3 &&
              (!generatorExecutionContext ||
                (_processEventBuffer[1] > generatorExecutionContext[0] &&
                  _processEventBuffer[1] < generatorExecutionContext[3]))
            ) {
              generatorState.label = _processEventBuffer[1];
              break;
            }
            if (
              _processEventBuffer[0] === 6 &&
              generatorState.label < generatorExecutionContext[1]
            ) {
              generatorState.label = generatorExecutionContext[1];
              generatorExecutionContext = _processEventBuffer;
              break;
            }
            if (
              generatorExecutionContext &&
              generatorState.label < generatorExecutionContext[2]
            ) {
              generatorState.label = generatorExecutionContext[2];
              generatorState.ops.push(_processEventBuffer);
              break;
            }
            if (generatorExecutionContext[2]) {
              generatorState.ops.pop();
            }
            generatorState.trys.pop();
            continue;
        }
        _processEventBuffer = _processBuffer.call(
          processBuffer,
          generatorState,
        );
      } catch (_______error) {
        _processEventBuffer = [6, _______error];
        currentGeneratorContext = 0;
      } finally {
        isGeneratorExecuting = generatorExecutionContext = 0;
      }
    }
    if (_processEventBuffer[0] & 5) {
      throw _processEventBuffer[1];
    }
    return {
      value: _processEventBuffer[0] ? _processEventBuffer[1] : undefined,
      done: true,
    };
  }
}
function getAsyncIterator(
  ___________________________________validateAndRetrieveIntrinsicProperties,
) {
  if (!Symbol.asyncIterator) {
    throw new TypeError("Symbol.asyncIterator is not defined.");
  }
  var __asyncIterator =
    ___________________________________validateAndRetrieveIntrinsicProperties[
      Symbol.asyncIterator
    ];
  var asyncIteratorMethods;
  if (__asyncIterator) {
    return __asyncIterator.call(
      ___________________________________validateAndRetrieveIntrinsicProperties,
    );
  } else {
    if (typeof __values == "function") {
      ___________________________________validateAndRetrieveIntrinsicProperties =
        __values(
          ___________________________________validateAndRetrieveIntrinsicProperties,
        );
    } else {
      ___________________________________validateAndRetrieveIntrinsicProperties =
        ___________________________________validateAndRetrieveIntrinsicProperties[
          Symbol.iterator
        ]();
    }
    asyncIteratorMethods = {};
    __processSignalAndHandleError("next");
    __processSignalAndHandleError("throw");
    __processSignalAndHandleError("return");
    asyncIteratorMethods[Symbol.asyncIterator] = function () {
      return this;
    };
    return asyncIteratorMethods;
  }
  function __processSignalAndHandleError(_processSignalAndHandleError) {
    asyncIteratorMethods[_processSignalAndHandleError] =
      ___________________________________validateAndRetrieveIntrinsicProperties[
        _processSignalAndHandleError
      ] &&
      function (
        ____________________________________validateAndRetrieveIntrinsicProperties,
      ) {
        return new Promise(function (
          _____________________________________validateAndRetrieveIntrinsicProperties,
          ______________________________________validateAndRetrieveIntrinsicProperties,
        ) {
          ____________________________________validateAndRetrieveIntrinsicProperties =
            ___________________________________validateAndRetrieveIntrinsicProperties[
              _processSignalAndHandleError
            ](
              ____________________________________validateAndRetrieveIntrinsicProperties,
            );
          processSemanticVersionStream(
            _____________________________________validateAndRetrieveIntrinsicProperties,
            ______________________________________validateAndRetrieveIntrinsicProperties,
            ____________________________________validateAndRetrieveIntrinsicProperties.done,
            ____________________________________validateAndRetrieveIntrinsicProperties.value,
          );
        });
      };
  }
  function processSemanticVersionStream(
    validateSemVerRange,
    isValidVersionRange,
    _validateSemVerRange,
    _isValidVersionRange,
  ) {
    Promise.resolve(_isValidVersionRange).then(function (ProcessingStream) {
      validateSemVerRange({
        value: ProcessingStream,
        done: _validateSemVerRange,
      });
    }, isValidVersionRange);
  }
}
function StreamErrorHandler(streamErrorHandling) {
  if (this instanceof StreamErrorHandler) {
    this.v = streamErrorHandling;
    return this;
  } else {
    return new StreamErrorHandler(streamErrorHandling);
  }
}
function createAsyncIterator(
  _processStreamData,
  _executeComparisonOperation,
  __processSectionedValues,
) {
  if (!Symbol.asyncIterator) {
    throw new TypeError("Symbol.asyncIterator is not defined.");
  }
  var processedSectionedValues = __processSectionedValues.apply(
    _processStreamData,
    _executeComparisonOperation || [],
  );
  var _asyncIterator;
  var asyncOperationQueue = [];
  _asyncIterator = {};
  registerAsyncOperation("next");
  registerAsyncOperation("throw");
  registerAsyncOperation("return");
  _asyncIterator[Symbol.asyncIterator] = function () {
    return this;
  };
  return _asyncIterator;
  function registerAsyncOperation(evaluateIntrinsicProperties) {
    if (processedSectionedValues[evaluateIntrinsicProperties]) {
      _asyncIterator[evaluateIntrinsicProperties] = function (
        errorHandlingStream,
      ) {
        return new Promise(function (
          updateContentMaxAgeSettings,
          __handleStreamErrors,
        ) {
          if (
            !(
              asyncOperationQueue.push([
                evaluateIntrinsicProperties,
                errorHandlingStream,
                updateContentMaxAgeSettings,
                __handleStreamErrors,
              ]) > 1
            )
          ) {
            handleErrorCodes(evaluateIntrinsicProperties, errorHandlingStream);
          }
        });
      };
    }
  }
  function handleErrorCodes(errorCodes, errorHandlingCodes) {
    try {
      ___handleStreamError(
        processedSectionedValues[errorCodes](errorHandlingCodes),
      );
    } catch (___errorHandling) {
      initializeAndProcessAsyncQueue(
        asyncOperationQueue[0][3],
        ___errorHandling,
      );
    }
  }
  function ___handleStreamError(streamErrorCodes) {
    if (streamErrorCodes.value instanceof StreamErrorHandler) {
      Promise.resolve(streamErrorCodes.value.v).then(
        handleNextNodeTraversal,
        handleObjectModeError,
      );
    } else {
      initializeAndProcessAsyncQueue(
        asyncOperationQueue[0][2],
        streamErrorCodes,
      );
    }
  }
  function handleNextNodeTraversal(getNodePropertiesAfterTraversal) {
    handleErrorCodes("next", getNodePropertiesAfterTraversal);
  }
  function handleObjectModeError(handleObjectModeSettings) {
    handleErrorCodes("throw", handleObjectModeSettings);
  }
  function initializeAndProcessAsyncQueue(
    initializeDataStream,
    validateAndRetrieveOptions,
  ) {
    initializeDataStream(validateAndRetrieveOptions);
    asyncOperationQueue.shift();
    if (asyncOperationQueue.length) {
      handleErrorCodes(asyncOperationQueue[0][0], asyncOperationQueue[0][1]);
    }
  }
}
function isStringOrNumber(_____validateAndRetrieveProperties) {
  var typeOfInput = typeof _____validateAndRetrieveProperties;
  return typeOfInput === "string" || typeOfInput === "number";
}
var isMaxAgeUpdateEnabled = -1;
var _______________________________________validateAndRetrieveIntrinsicProperties =
  new DataView(new ArrayBuffer(0));
var shouldDecodeStrings = new Uint8Array(
  _______________________________________validateAndRetrieveIntrinsicProperties.buffer,
);
var ______validateAndRetrieveProperties = (function () {
  try {
    _______________________________________validateAndRetrieveIntrinsicProperties.getInt8(
      0,
    );
  } catch (____________error) {
    return ____________error.constructor;
  }
  throw new Error("never reached");
})();
var isStringsDecodingDisabled = new ______validateAndRetrieveProperties(
  "Insufficient data",
);
var shouldDecodeStringsBasedOnProperties = new __getReadableLength();
var isDecodeStringsDisabled = (function () {
  function initializeCodecSettings(
    _defaultWritablePipeCodec = handleWritablePipes.defaultCodec,
    _inputParameter = undefined,
    ___getReadableLength = getReadableLength,
    ____getReadableLength = getReadableLength,
    _____getReadableLength = getReadableLength,
    getReadableLengthInChar = getReadableLength,
    ______getReadableLength = getReadableLength,
    _shouldDecodeStringsBasedOnProperties = shouldDecodeStringsBasedOnProperties,
  ) {
    this.extensionCodec = _defaultWritablePipeCodec;
    this.context = _inputParameter;
    this.maxStrLength = ___getReadableLength;
    this.maxBinLength = ____getReadableLength;
    this.maxArrayLength = _____getReadableLength;
    this.maxMapLength = getReadableLengthInChar;
    this.maxExtLength = ______getReadableLength;
    this.keyDecoder = _shouldDecodeStringsBasedOnProperties;
    this.totalPos = 0;
    this.pos = 0;
    this.view =
      _______________________________________validateAndRetrieveIntrinsicProperties;
    this.bytes = shouldDecodeStrings;
    this.headByte = isMaxAgeUpdateEnabled;
    this.stack = [];
  }
  initializeCodecSettings.prototype.reinitializeState = function () {
    this.totalPos = 0;
    this.headByte = isMaxAgeUpdateEnabled;
    this.stack.length = 0;
  };
  initializeCodecSettings.prototype.setBuffer = function (
    initializeStreamProperties,
  ) {
    this.bytes = validateAndConvertToUint8Array(initializeStreamProperties);
    this.view = createDataViewFromBuffer(this.bytes);
    this.pos = 0;
  };
  initializeCodecSettings.prototype.appendBuffer = function (
    initProcessOperations,
  ) {
    if (this.headByte === isMaxAgeUpdateEnabled && !this.hasRemaining(1)) {
      this.setBuffer(initProcessOperations);
    } else {
      var extractedAndCombinedBuffer = this.bytes.subarray(this.pos);
      var convertedProcessOperations = validateAndConvertToUint8Array(
        initProcessOperations,
      );
      var combinedBuffer = new Uint8Array(
        extractedAndCombinedBuffer.length + convertedProcessOperations.length,
      );
      combinedBuffer.set(extractedAndCombinedBuffer);
      combinedBuffer.set(
        convertedProcessOperations,
        extractedAndCombinedBuffer.length,
      );
      this.setBuffer(combinedBuffer);
    }
  };
  initializeCodecSettings.prototype.hasRemaining = function (
    initializeWritableState,
  ) {
    return this.view.byteLength - this.pos >= initializeWritableState;
  };
  initializeCodecSettings.prototype.createExtraByteError = function (
    initializeBufferedOperations,
  ) {
    var _____context = this;
    var bufferView = _____context.view;
    var _currentBufferPosition = _____context.pos;
    return new RangeError(
      `Extra ${bufferView.byteLength - _currentBufferPosition} of ${bufferView.byteLength} byte(s) found at buffer[${initializeBufferedOperations}]`,
    );
  };
  initializeCodecSettings.prototype.decode = function (bufferedOperations) {
    this.reinitializeState();
    this.setBuffer(bufferedOperations);
    var _decodedData = this.doDecodeSync();
    if (this.hasRemaining(1)) {
      throw this.createExtraByteError(this.pos);
    }
    return _decodedData;
  };
  initializeCodecSettings.prototype.decodeMulti = function (StreamWritable) {
    return processBufferGenerator(this, function (CustomAbortSignalHandler) {
      switch (CustomAbortSignalHandler.label) {
        case 0:
          this.reinitializeState();
          this.setBuffer(StreamWritable);
          CustomAbortSignalHandler.label = 1;
        case 1:
          if (this.hasRemaining(1)) {
            return [4, this.doDecodeSync()];
          } else {
            return [3, 3];
          }
        case 2:
          CustomAbortSignalHandler.sent();
          return [3, 1];
        case 3:
          return [2];
      }
    });
  };
  initializeCodecSettings.prototype.decodeAsync = function (
    _abortSignalHandler,
  ) {
    var abortSignalResult;
    var _abortSignalResult;
    var abortSignalResultHandler;
    var abortSignalHandlerResult;
    return createReadablePromise(this, undefined, undefined, function () {
      var _isAbortSignalHandled;
      var decodedData;
      var abortSignalValue;
      var abortSignalProcessed;
      var __abortSignalResult;
      var _abortSignalResultHandler;
      var _abortSignalValue;
      var ___abortSignalResult;
      return processBufferGenerator(this, function (_handleAbortSignal) {
        switch (_handleAbortSignal.label) {
          case 0:
            _isAbortSignalHandled = false;
            _handleAbortSignal.label = 1;
          case 1:
            _handleAbortSignal.trys.push([1, 6, 7, 12]);
            abortSignalResult = getAsyncIterator(_abortSignalHandler);
            _handleAbortSignal.label = 2;
          case 2:
            return [4, abortSignalResult.next()];
          case 3:
            _abortSignalResult = _handleAbortSignal.sent();
            if (_abortSignalResult.done) {
              return [3, 5];
            }
            abortSignalValue = _abortSignalResult.value;
            if (_isAbortSignalHandled) {
              throw this.createExtraByteError(this.totalPos);
            }
            this.appendBuffer(abortSignalValue);
            try {
              decodedData = this.doDecodeSync();
              _isAbortSignalHandled = true;
            } catch (__error) {
              if (!(__error instanceof ______validateAndRetrieveProperties)) {
                throw __error;
              }
            }
            this.totalPos += this.pos;
            _handleAbortSignal.label = 4;
          case 4:
            return [3, 2];
          case 5:
            return [3, 12];
          case 6:
            abortSignalProcessed = _handleAbortSignal.sent();
            abortSignalResultHandler = {
              error: abortSignalProcessed,
            };
            return [3, 12];
          case 7:
            _handleAbortSignal.trys.push([7, , 10, 11]);
            if (
              _abortSignalResult &&
              !_abortSignalResult.done &&
              (abortSignalHandlerResult = abortSignalResult.return)
            ) {
              return [4, abortSignalHandlerResult.call(abortSignalResult)];
            } else {
              return [3, 9];
            }
          case 8:
            _handleAbortSignal.sent();
            _handleAbortSignal.label = 9;
          case 9:
            return [3, 11];
          case 10:
            if (abortSignalResultHandler) {
              throw abortSignalResultHandler.error;
            }
            return [7];
          case 11:
            return [7];
          case 12:
            if (_isAbortSignalHandled) {
              if (this.hasRemaining(1)) {
                throw this.createExtraByteError(this.totalPos);
              }
              return [2, decodedData];
            }
            __abortSignalResult = this;
            _abortSignalResultHandler = __abortSignalResult.headByte;
            _abortSignalValue = __abortSignalResult.pos;
            ___abortSignalResult = __abortSignalResult.totalPos;
            throw new RangeError(
              `Insufficient data in parsing ${formatReadableFlowingState(_abortSignalResultHandler)} at ${___abortSignalResult} (${_abortSignalValue} in the current buffer)`,
            );
        }
      });
    });
  };
  initializeCodecSettings.prototype.decodeArrayStream = function (
    _handleDataProcessing,
  ) {
    return this.decodeMultiAsync(_handleDataProcessing, true);
  };
  initializeCodecSettings.prototype.decodeStream = function (
    handleAsyncOperation,
  ) {
    return this.decodeMultiAsync(handleAsyncOperation, false);
  };
  initializeCodecSettings.prototype.decodeMultiAsync = function (
    createWriteStream,
    createWriteStreamInstance,
  ) {
    return createAsyncIterator(this, arguments, function () {
      var isWriteStreamActive;
      var lastProcessedByteIndex;
      var writeStreamBuffer;
      var processedWriteStreamData;
      var currentWriteStreamChunk;
      var createWriteStreamBuffer;
      var currentWriteStreamData;
      var writeStreamBufferGenerator;
      var writeStreamData;
      return processBufferGenerator(
        this,
        function (processAsyncSignalHandling) {
          switch (processAsyncSignalHandling.label) {
            case 0:
              isWriteStreamActive = createWriteStreamInstance;
              lastProcessedByteIndex = -1;
              processAsyncSignalHandling.label = 1;
            case 1:
              processAsyncSignalHandling.trys.push([1, 13, 14, 19]);
              writeStreamBuffer = getAsyncIterator(createWriteStream);
              processAsyncSignalHandling.label = 2;
            case 2:
              return [4, StreamErrorHandler(writeStreamBuffer.next())];
            case 3:
              processedWriteStreamData = processAsyncSignalHandling.sent();
              if (processedWriteStreamData.done) {
                return [3, 12];
              }
              currentWriteStreamChunk = processedWriteStreamData.value;
              if (createWriteStreamInstance && lastProcessedByteIndex === 0) {
                throw this.createExtraByteError(this.totalPos);
              }
              this.appendBuffer(currentWriteStreamChunk);
              if (isWriteStreamActive) {
                lastProcessedByteIndex = this.readArraySize();
                isWriteStreamActive = false;
                this.complete();
              }
              processAsyncSignalHandling.label = 4;
            case 4:
              processAsyncSignalHandling.trys.push([4, 9, , 10]);
              processAsyncSignalHandling.label = 5;
            case 5:
              return [4, StreamErrorHandler(this.doDecodeSync())];
            case 6:
              return [4, processAsyncSignalHandling.sent()];
            case 7:
              processAsyncSignalHandling.sent();
              if (--lastProcessedByteIndex === 0) {
                return [3, 8];
              } else {
                return [3, 5];
              }
            case 8:
              return [3, 10];
            case 9:
              createWriteStreamBuffer = processAsyncSignalHandling.sent();
              if (
                !(
                  createWriteStreamBuffer instanceof
                  ______validateAndRetrieveProperties
                )
              ) {
                throw createWriteStreamBuffer;
              }
              return [3, 10];
            case 10:
              this.totalPos += this.pos;
              processAsyncSignalHandling.label = 11;
            case 11:
              return [3, 2];
            case 12:
              return [3, 19];
            case 13:
              currentWriteStreamData = processAsyncSignalHandling.sent();
              writeStreamBufferGenerator = {
                error: currentWriteStreamData,
              };
              return [3, 19];
            case 14:
              processAsyncSignalHandling.trys.push([14, , 17, 18]);
              if (
                processedWriteStreamData &&
                !processedWriteStreamData.done &&
                (writeStreamData = writeStreamBuffer.return)
              ) {
                return [
                  4,
                  StreamErrorHandler(writeStreamData.call(writeStreamBuffer)),
                ];
              } else {
                return [3, 16];
              }
            case 15:
              processAsyncSignalHandling.sent();
              processAsyncSignalHandling.label = 16;
            case 16:
              return [3, 18];
            case 17:
              if (writeStreamBufferGenerator) {
                throw writeStreamBufferGenerator.error;
              }
              return [7];
            case 18:
              return [7];
            case 19:
              return [2];
          }
        },
      );
    });
  };
  initializeCodecSettings.prototype.doDecodeSync = function () {
    _0x5be8bc: while (true) {
      var byteHeaderValue = this.readHeadByte();
      var decodedValue = undefined;
      if (byteHeaderValue >= 224) {
        decodedValue = byteHeaderValue - 256;
      } else if (byteHeaderValue < 192) {
        if (byteHeaderValue < 128) {
          decodedValue = byteHeaderValue;
        } else if (byteHeaderValue < 144) {
          var adjustedHeaderValue = byteHeaderValue - 128;
          if (adjustedHeaderValue !== 0) {
            this.pushMapState(adjustedHeaderValue);
            this.complete();
            continue _0x5be8bc;
          } else {
            decodedValue = {};
          }
        } else if (byteHeaderValue < 160) {
          var adjustedHeaderValue = byteHeaderValue - 144;
          if (adjustedHeaderValue !== 0) {
            this.pushArrayState(adjustedHeaderValue);
            this.complete();
            continue _0x5be8bc;
          } else {
            decodedValue = [];
          }
        } else {
          var adjustedByteHeaderValue = byteHeaderValue - 160;
          decodedValue = this.decodeUtf8String(adjustedByteHeaderValue, 0);
        }
      } else if (byteHeaderValue === 192) {
        decodedValue = null;
      } else if (byteHeaderValue === 194) {
        decodedValue = false;
      } else if (byteHeaderValue === 195) {
        decodedValue = true;
      } else if (byteHeaderValue === 202) {
        decodedValue = this.readF32();
      } else if (byteHeaderValue === 203) {
        decodedValue = this.readF64();
      } else if (byteHeaderValue === 204) {
        decodedValue = this.readU8();
      } else if (byteHeaderValue === 205) {
        decodedValue = this.readU16();
      } else if (byteHeaderValue === 206) {
        decodedValue = this.readU32();
      } else if (byteHeaderValue === 207) {
        decodedValue = this.readU64();
      } else if (byteHeaderValue === 208) {
        decodedValue = this.readI8();
      } else if (byteHeaderValue === 209) {
        decodedValue = this.readI16();
      } else if (byteHeaderValue === 210) {
        decodedValue = this.readI32();
      } else if (byteHeaderValue === 211) {
        decodedValue = this.readI64();
      } else if (byteHeaderValue === 217) {
        var adjustedByteHeaderValue = this.lookU8();
        decodedValue = this.decodeUtf8String(adjustedByteHeaderValue, 1);
      } else if (byteHeaderValue === 218) {
        var adjustedByteHeaderValue = this.lookU16();
        decodedValue = this.decodeUtf8String(adjustedByteHeaderValue, 2);
      } else if (byteHeaderValue === 219) {
        var adjustedByteHeaderValue = this.lookU32();
        decodedValue = this.decodeUtf8String(adjustedByteHeaderValue, 4);
      } else if (byteHeaderValue === 220) {
        var adjustedHeaderValue = this.readU16();
        if (adjustedHeaderValue !== 0) {
          this.pushArrayState(adjustedHeaderValue);
          this.complete();
          continue _0x5be8bc;
        } else {
          decodedValue = [];
        }
      } else if (byteHeaderValue === 221) {
        var adjustedHeaderValue = this.readU32();
        if (adjustedHeaderValue !== 0) {
          this.pushArrayState(adjustedHeaderValue);
          this.complete();
          continue _0x5be8bc;
        } else {
          decodedValue = [];
        }
      } else if (byteHeaderValue === 222) {
        var adjustedHeaderValue = this.readU16();
        if (adjustedHeaderValue !== 0) {
          this.pushMapState(adjustedHeaderValue);
          this.complete();
          continue _0x5be8bc;
        } else {
          decodedValue = {};
        }
      } else if (byteHeaderValue === 223) {
        var adjustedHeaderValue = this.readU32();
        if (adjustedHeaderValue !== 0) {
          this.pushMapState(adjustedHeaderValue);
          this.complete();
          continue _0x5be8bc;
        } else {
          decodedValue = {};
        }
      } else if (byteHeaderValue === 196) {
        var adjustedHeaderValue = this.lookU8();
        decodedValue = this.decodeBinary(adjustedHeaderValue, 1);
      } else if (byteHeaderValue === 197) {
        var adjustedHeaderValue = this.lookU16();
        decodedValue = this.decodeBinary(adjustedHeaderValue, 2);
      } else if (byteHeaderValue === 198) {
        var adjustedHeaderValue = this.lookU32();
        decodedValue = this.decodeBinary(adjustedHeaderValue, 4);
      } else if (byteHeaderValue === 212) {
        decodedValue = this.decodeExtension(1, 0);
      } else if (byteHeaderValue === 213) {
        decodedValue = this.decodeExtension(2, 0);
      } else if (byteHeaderValue === 214) {
        decodedValue = this.decodeExtension(4, 0);
      } else if (byteHeaderValue === 215) {
        decodedValue = this.decodeExtension(8, 0);
      } else if (byteHeaderValue === 216) {
        decodedValue = this.decodeExtension(16, 0);
      } else if (byteHeaderValue === 199) {
        var adjustedHeaderValue = this.lookU8();
        decodedValue = this.decodeExtension(adjustedHeaderValue, 1);
      } else if (byteHeaderValue === 200) {
        var adjustedHeaderValue = this.lookU16();
        decodedValue = this.decodeExtension(adjustedHeaderValue, 2);
      } else if (byteHeaderValue === 201) {
        var adjustedHeaderValue = this.lookU32();
        decodedValue = this.decodeExtension(adjustedHeaderValue, 4);
      } else {
        throw new characterEncodingLength(
          `Unrecognized type byte: ${formatReadableFlowingState(byteHeaderValue)}`,
        );
      }
      this.complete();
      for (var stackContext = this.stack; stackContext.length > 0; ) {
        var currentStackFrame = stackContext[stackContext.length - 1];
        if (currentStackFrame.type === 0) {
          currentStackFrame.array[currentStackFrame.position] = decodedValue;
          currentStackFrame.position++;
          if (currentStackFrame.position === currentStackFrame.size) {
            stackContext.pop();
            decodedValue = currentStackFrame.array;
          } else {
            continue _0x5be8bc;
          }
        } else if (currentStackFrame.type === 1) {
          if (!isStringOrNumber(decodedValue)) {
            throw new characterEncodingLength(
              "The type of key must be string or number but " +
                typeof decodedValue,
            );
          }
          if (decodedValue === "__proto__") {
            throw new characterEncodingLength(
              "The key __proto__ is not allowed",
            );
          }
          currentStackFrame.key = decodedValue;
          currentStackFrame.type = 2;
          continue _0x5be8bc;
        } else {
          currentStackFrame.map[currentStackFrame.key] = decodedValue;
          currentStackFrame.readCount++;
          if (currentStackFrame.readCount === currentStackFrame.size) {
            stackContext.pop();
            decodedValue = currentStackFrame.map;
          } else {
            currentStackFrame.key = null;
            currentStackFrame.type = 1;
            continue _0x5be8bc;
          }
        }
      }
      return decodedValue;
    }
  };
  initializeCodecSettings.prototype.readHeadByte = function () {
    if (this.headByte === isMaxAgeUpdateEnabled) {
      this.headByte = this.readU8();
    }
    return this.headByte;
  };
  initializeCodecSettings.prototype.complete = function () {
    this.headByte = isMaxAgeUpdateEnabled;
  };
  initializeCodecSettings.prototype.readArraySize = function () {
    var arrayTypeByte = this.readHeadByte();
    switch (arrayTypeByte) {
      case 220:
        return this.readU16();
      case 221:
        return this.readU32();
      default: {
        if (arrayTypeByte < 160) {
          return arrayTypeByte - 144;
        }
        throw new characterEncodingLength(
          `Unrecognized array type byte: ${formatReadableFlowingState(arrayTypeByte)}`,
        );
      }
    }
  };
  initializeCodecSettings.prototype.pushMapState = function (
    handleBufferedSignalAndProcessSegments,
  ) {
    if (handleBufferedSignalAndProcessSegments > this.maxMapLength) {
      throw new characterEncodingLength(
        `Max length exceeded: map length (${handleBufferedSignalAndProcessSegments}) > maxMapLengthLength (${this.maxMapLength})`,
      );
    }
    this.stack.push({
      type: 1,
      size: handleBufferedSignalAndProcessSegments,
      key: null,
      readCount: 0,
      map: {},
    });
  };
  initializeCodecSettings.prototype.pushArrayState = function (
    writeCharacterSegments,
  ) {
    if (writeCharacterSegments > this.maxArrayLength) {
      throw new characterEncodingLength(
        `Max length exceeded: array length (${writeCharacterSegments}) > maxArrayLength (${this.maxArrayLength})`,
      );
    }
    this.stack.push({
      type: 0,
      size: writeCharacterSegments,
      array: new Array(writeCharacterSegments),
      position: 0,
    });
  };
  initializeCodecSettings.prototype.decodeUtf8String = function (
    processBufferedSegments,
    _processBufferedSegments,
  ) {
    var currentSegmentLength;
    if (processBufferedSegments > this.maxStrLength) {
      throw new characterEncodingLength(
        `Max length exceeded: UTF-8 byte length (${processBufferedSegments}) > maxStrLength (${this.maxStrLength})`,
      );
    }
    if (
      this.bytes.byteLength <
      this.pos + _processBufferedSegments + processBufferedSegments
    ) {
      throw isStringsDecodingDisabled;
    }
    var currentPositionAfterProcessing = this.pos + _processBufferedSegments;
    var decodedSegment;
    if (
      this.stateIsMapKey() &&
      ((currentSegmentLength = this.keyDecoder) === null ||
      currentSegmentLength === undefined
        ? undefined
        : currentSegmentLength.canBeCached(processBufferedSegments))
    ) {
      decodedSegment = this.keyDecoder.decode(
        this.bytes,
        currentPositionAfterProcessing,
        processBufferedSegments,
      );
    } else if (processBufferedSegments > _processPendingTasks) {
      decodedSegment = decodeReadableStateChange(
        this.bytes,
        currentPositionAfterProcessing,
        processBufferedSegments,
      );
    } else {
      decodedSegment = decodeBufferToUtf8(
        this.bytes,
        currentPositionAfterProcessing,
        processBufferedSegments,
      );
    }
    this.pos += _processBufferedSegments + processBufferedSegments;
    return decodedSegment;
  };
  initializeCodecSettings.prototype.stateIsMapKey = function () {
    if (this.stack.length > 0) {
      var topStackElement = this.stack[this.stack.length - 1];
      return topStackElement.type === 1;
    }
    return false;
  };
  initializeCodecSettings.prototype.decodeBinary = function (
    _bufferProcessingFunction,
    processCharacterSegment,
  ) {
    if (_bufferProcessingFunction > this.maxBinLength) {
      throw new characterEncodingLength(
        `Max length exceeded: bin length (${_bufferProcessingFunction}) > maxBinLength (${this.maxBinLength})`,
      );
    }
    if (
      !this.hasRemaining(_bufferProcessingFunction + processCharacterSegment)
    ) {
      throw isStringsDecodingDisabled;
    }
    var newPositionIndex = this.pos + processCharacterSegment;
    var extractedByteSegment = this.bytes.subarray(
      newPositionIndex,
      newPositionIndex + _bufferProcessingFunction,
    );
    this.pos += processCharacterSegment + _bufferProcessingFunction;
    return extractedByteSegment;
  };
  initializeCodecSettings.prototype.decodeExtension = function (
    processCharacterSegmentData,
    processCharacterSegmentBuffer,
  ) {
    if (processCharacterSegmentData > this.maxExtLength) {
      throw new characterEncodingLength(
        `Max length exceeded: ext length (${processCharacterSegmentData}) > maxExtLength (${this.maxExtLength})`,
      );
    }
    var characterSegmentValue = this.view.getInt8(
      this.pos + processCharacterSegmentBuffer,
    );
    var decodedCharacterSegment = this.decodeBinary(
      processCharacterSegmentData,
      processCharacterSegmentBuffer + 1,
    );
    return this.extensionCodec.decode(
      decodedCharacterSegment,
      characterSegmentValue,
      this.context,
    );
  };
  initializeCodecSettings.prototype.lookU8 = function () {
    return this.view.getUint8(this.pos);
  };
  initializeCodecSettings.prototype.lookU16 = function () {
    return this.view.getUint16(this.pos);
  };
  initializeCodecSettings.prototype.lookU32 = function () {
    return this.view.getUint32(this.pos);
  };
  initializeCodecSettings.prototype.readU8 = function () {
    var getNextByte = this.view.getUint8(this.pos);
    this.pos++;
    return getNextByte;
  };
  initializeCodecSettings.prototype.readI8 = function () {
    var _getNextByte = this.view.getInt8(this.pos);
    this.pos++;
    return _getNextByte;
  };
  initializeCodecSettings.prototype.readU16 = function () {
    var getUint16Value = this.view.getUint16(this.pos);
    this.pos += 2;
    return getUint16Value;
  };
  initializeCodecSettings.prototype.readI16 = function () {
    var getNextInt16 = this.view.getInt16(this.pos);
    this.pos += 2;
    return getNextInt16;
  };
  initializeCodecSettings.prototype.readU32 = function () {
    var getNextUint32 = this.view.getUint32(this.pos);
    this.pos += 4;
    return getNextUint32;
  };
  initializeCodecSettings.prototype.readI32 = function () {
    var getIntegerFromView = this.view.getInt32(this.pos);
    this.pos += 4;
    return getIntegerFromView;
  };
  initializeCodecSettings.prototype.readU64 = function () {
    var combinedUInt32Value = combineUInt32ToNumber(this.view, this.pos);
    this.pos += 8;
    return combinedUInt32Value;
  };
  initializeCodecSettings.prototype.readI64 = function () {
    var largeIntegerFromView = calculateLargeIntFromData(this.view, this.pos);
    this.pos += 8;
    return largeIntegerFromView;
  };
  initializeCodecSettings.prototype.readF32 = function () {
    var getNextFloat32 = this.view.getFloat32(this.pos);
    this.pos += 4;
    return getNextFloat32;
  };
  initializeCodecSettings.prototype.readF64 = function () {
    var getCurrentViewFloat64 = this.view.getFloat64(this.pos);
    this.pos += 8;
    return getCurrentViewFloat64;
  };
  return initializeCodecSettings;
})();
var handleStreamEnd = {};
function decodeStreamStatus(
  checkStreamStatus,
  __handleStreamEnd = handleStreamEnd,
) {
  var streamDecoder = new isDecodeStringsDisabled(
    __handleStreamEnd.extensionCodec,
    __handleStreamEnd.context,
    __handleStreamEnd.maxStrLength,
    __handleStreamEnd.maxBinLength,
    __handleStreamEnd.maxArrayLength,
    __handleStreamEnd.maxMapLength,
    __handleStreamEnd.maxExtLength,
  );
  return streamDecoder.decode(checkStreamStatus);
}
var signalAbortHandler = class {
  onWillDisposeEmitter = new _____evaluateVersionOperators();
  onWillDispose = this.onWillDisposeEmitter.event;
  onDidDisposeEmitter = new _____evaluateVersionOperators();
  onDidDispose = this.onDidDisposeEmitter.event;
  toDispose = [];
  isDisposed = false;
  onDispose(signalAbortToken) {
    this.toDispose.push(signalAbortHandler.create(signalAbortToken));
  }
  dispose() {
    if (!this.isDisposed) {
      this.onWillDisposeEmitter.fire(null);
      this.isDisposed = true;
      this.toDispose.forEach((_disposeResource) => {
        _disposeResource.dispose();
      });
      this.onDidDisposeEmitter.fire(null);
      this.onWillDisposeEmitter.dispose();
      this.onDidDisposeEmitter.dispose();
    }
  }
  static is(isDisposable) {
    return typeof isDisposable.dispose == "function";
  }
  static create(disposeFunction) {
    return {
      dispose: disposeFunction,
    };
  }
};
var _____evaluateVersionOperators = class {
  registeredListeners = new Set();
  _event;
  get event() {
    this._event ||= (signalListenerRegistration) => {
      this.registeredListeners.add(signalListenerRegistration);
      return signalAbortHandler.create(() => {
        this.registeredListeners.delete(signalListenerRegistration);
      });
    };
    return this._event;
  }
  fire(_eventData) {
    this.registeredListeners.forEach((processEventData) => {
      processEventData(_eventData);
    });
  }
  dispose() {
    this.registeredListeners = new Set();
  }
};
var ____handleVersionComparison = (0, validateAndReadStream.default)();
var ______evaluateVersionOperators = (createReadableStreamDrainWithOptions) =>
  createReadableStreamDrain(createReadableStreamDrainWithOptions, {
    ignoreUndefined: true,
  });
var _____handleVersionComparison = class {
  endpoints = new Map();
  nodeMap = new Map();
  onMessageEmitter = new _____evaluateVersionOperators();
  onMessage = this.onMessageEmitter.event;
  constructor() {}
  getEndpointForNode(getEndpointForNodeId) {
    let _endpointForNode = this.nodeMap.get(getEndpointForNodeId);
    if (_endpointForNode) {
      let endpointResponse = this.endpoints.get(_endpointForNode);
      if (endpointResponse) {
        return endpointResponse;
      }
    }
  }
  addEndpoint(routeIdentifier, endpointHandler) {
    this.endpoints.set(routeIdentifier, endpointHandler);
    endpointHandler.onMessage(
      (thisHandleMessageParseMessageDataRouteIdentifier) =>
        this.handleMessage(
          thisHandleMessageParseMessageDataRouteIdentifier,
          routeIdentifier,
        ),
    );
    let versionEvaluationResult = ______evaluateVersionOperators({
      $type: "router-announce",
      $origin: ____handleVersionComparison,
    });
    endpointHandler.send(versionEvaluationResult, [
      versionEvaluationResult.buffer,
    ]);
  }
  removeEndpoint(_endpointId) {
    this.endpoints.delete(_endpointId);
  }
  send(sendMessageToEndpoint, _messageData, isDataLoaded = true) {
    let routerMessage = {
      $type: "router-message",
      $origin: ____handleVersionComparison,
      $target: sendMessageToEndpoint,
      $data: _messageData,
    };
    if (sendMessageToEndpoint !== ____handleVersionComparison) {
      let endpointForNode = this.getEndpointForNode(sendMessageToEndpoint);
      if (!endpointForNode) {
        throw new Error(
          "Endpoint " + sendMessageToEndpoint + " not registered",
        );
      }
      if (isDataLoaded) {
        let evaluatedRouterMessage =
          ______evaluateVersionOperators(routerMessage);
        endpointForNode.send(evaluatedRouterMessage, [
          evaluatedRouterMessage.buffer,
        ]);
      } else {
        endpointForNode.send(routerMessage, []);
      }
    } else {
      this.onMessageEmitter.fire(routerMessage);
    }
  }
  broadcast(broadcastData, targetEndpointId, originRouteFunction) {
    let broadcastMessage = {
      $type: "router-broadcast",
      $origin: originRouteFunction ?? ____handleVersionComparison,
      $data: broadcastData,
    };
    if (!targetEndpointId && !originRouteFunction) {
      this.onMessageEmitter.fire(broadcastMessage);
    }
    for (let [endpointId, endpoint] of this.endpoints.entries()) {
      if (endpointId === targetEndpointId) {
        continue;
      }
      let evaluatedBroadcastMessage =
        ______evaluateVersionOperators(broadcastMessage);
      endpoint.send(evaluatedBroadcastMessage, [
        evaluatedBroadcastMessage.buffer,
      ]);
    }
  }
  handleMessage(messagePayload, nodeInstance) {
    let _isUint8Array = messagePayload instanceof Uint8Array;
    let parsedMessagePayload = _isUint8Array
      ? decodeStreamStatus(messagePayload)
      : messagePayload;
    if (parsedMessagePayload.$origin) {
      if (!this.nodeMap.has(parsedMessagePayload.$origin)) {
        this.nodeMap.set(parsedMessagePayload.$origin, nodeInstance);
      }
      if (parsedMessagePayload.$type === "router-broadcast") {
        let _parsedMessagePayload = parsedMessagePayload;
        this.broadcast(
          _parsedMessagePayload.$data,
          nodeInstance,
          _parsedMessagePayload.$origin,
        );
        this.onMessageEmitter.fire(parsedMessagePayload);
        return;
      }
      if (parsedMessagePayload.$type === "router-message") {
        let targetMessagePayload = parsedMessagePayload;
        if (targetMessagePayload.$target === ____handleVersionComparison) {
          this.onMessageEmitter.fire(parsedMessagePayload);
        } else {
          let endpointForTargetNode = this.getEndpointForNode(
            targetMessagePayload.$target,
          );
          if (endpointForTargetNode) {
            endpointForTargetNode.send(
              messagePayload,
              _isUint8Array ? [messagePayload.buffer] : [],
            );
          }
        }
        return;
      }
    }
  }
};
var readableState;
function _getReadableState() {
  readableState ||= new _____handleVersionComparison();
  return readableState;
}
var isWritableStateValid = class extends MessageEvent {
  constructor(constructorArgument1, constructorArgument2) {
    super(constructorArgument1, constructorArgument2);
  }
};
var isStreamWritable = class extends EventTarget {
  addEventListener(addEventListener, ____callbackFunction, eventOptions) {
    return super.addEventListener(
      addEventListener,
      ____callbackFunction,
      eventOptions,
    );
  }
  removeEventListener(removeEventListenerByType, __eventHandler, eventType) {
    return super.removeEventListener(
      removeEventListenerByType,
      __eventHandler,
      eventType,
    );
  }
  dispatchEvent(eventToDispatch) {
    return super.dispatchEvent(eventToDispatch);
  }
};
var isWritable = /(%?)(%([sdjo]))/g;
function convertValueByType(_isWritable, __isWritable) {
  switch (__isWritable) {
    case "s":
      return _isWritable;
    case "d":
    case "i":
      return Number(_isWritable);
    case "j":
      return JSON.stringify(_isWritable);
    case "o": {
      if (typeof _isWritable == "string") {
        return _isWritable;
      }
      let stringifiedWritableObject = JSON.stringify(_isWritable);
      if (
        stringifiedWritableObject === "{}" ||
        stringifiedWritableObject === "[]" ||
        /^\[object .+?\]$/.test(stringifiedWritableObject)
      ) {
        return _isWritable;
      } else {
        return stringifiedWritableObject;
      }
    }
  }
}
function replaceVariablesInTemplateString(___isWritable, ...templateVariables) {
  if (templateVariables.length === 0) {
    return ___isWritable;
  }
  let currentVariableIndex = 0;
  let formattedWritableString = ___isWritable.replace(
    isWritable,
    (
      getConvertedValueOrCurrent,
      shouldReturnConvertedValue,
      getValueOrConverted,
      conversionFactor,
    ) => {
      let currentTemplateVariable = templateVariables[currentVariableIndex];
      let convertedValue = convertValueByType(
        currentTemplateVariable,
        conversionFactor,
      );
      if (shouldReturnConvertedValue) {
        return getConvertedValueOrCurrent;
      } else {
        currentVariableIndex++;
        return convertedValue;
      }
    },
  );
  if (currentVariableIndex < templateVariables.length) {
    formattedWritableString +=
      " " + templateVariables.slice(currentVariableIndex).join(" ");
  }
  formattedWritableString = formattedWritableString.replace(/%{2,2}/g, "%");
  return formattedWritableString;
}
var writableState = 2;
function removeFirstLineFromStack(_writableState) {
  if (!_writableState.stack) {
    return;
  }
  let stackLinesArray = _writableState.stack.split("\n");
  stackLinesArray.splice(1, writableState);
  _writableState.stack = stackLinesArray.join("\n");
}
var writableStateBuffer = class extends Error {
  constructor(templateMessage, ...templateVariableArguments) {
    super(templateMessage);
    this.message = templateMessage;
    this.name = "Invariant Violation";
    this.message = replaceVariablesInTemplateString(
      templateMessage,
      ...templateVariableArguments,
    );
    removeFirstLineFromStack(this);
  }
};
var isWritableStateError = (
  isBufferWritable,
  __bufferSize,
  ...throwIfBufferNotWritable
) => {
  if (!isBufferWritable) {
    throw new writableStateBuffer(__bufferSize, ...throwIfBufferNotWritable);
  }
};
isWritableStateError.as = (
  TemplateStringReplacer,
  templateStringReplacer,
  templateString,
  ...variablesToReplace
) => {
  if (!templateStringReplacer) {
    throw TemplateStringReplacer.prototype.name != null
      ? new TemplateStringReplacer(
          replaceVariablesInTemplateString(templateString, variablesToReplace),
        )
      : TemplateStringReplacer(
          replaceVariablesInTemplateString(templateString, variablesToReplace),
        );
  }
};
function _validateWritableState(
  getWritableAbortedState,
  nullishValueMessage = "Value is nullish",
) {
  isWritableStateError(getWritableAbortedState != null, nullishValueMessage);
  return getWritableAbortedState;
}
var streamDestroyMethod = "preview-manager";
var destroyStream = "preview/open";
var destroyWritableStreamState = "preview/ready";
var _destroyStream = "preview/port-taken";
var __destroyStream = "preview/close";
var __writableState = "preview/closed";
var ___writableState = "preview/request";
var writableStreamDestroy = "preview/manager-ack";
var destroyWritableState = "bridge/init";
var destroyWritableStream = "preview/runtime-request";
var ___destroyStream = "preview/runtime-response";
var destroyMethod = "{{identifier}}.nodebox.codesandbox.io";
var _destroyWritableStream = _getReadableState();
var destroyNextTickHandler = class {
  constructor(projectId) {
    this.projectId = projectId;
    _destroyWritableStream.onMessage((handleStreamDestroy) => {
      let origin = handleStreamDestroy.$origin;
      let streamData = handleStreamDestroy.$data;
      if (streamData.$channel_name === streamDestroyMethod) {
        switch (streamData.$type) {
          case ___writableState: {
            if (handleStreamDestroy.$type === "router-broadcast") {
              break;
            }
            let streamPayload = streamData;
            streamPayload.$bridge_node = handleStreamDestroy.$origin;
            let portConnection = this.ports.get(streamPayload.port);
            if (portConnection) {
              _destroyWritableStream.send(portConnection, streamPayload);
            }
            break;
          }
          case destroyStream: {
            let streamInfo = streamData;
            if (this.ports.has(streamInfo.port)) {
              let streamDestroyRequest = {
                $channel_name: streamDestroyMethod,
                $type: _destroyStream,
                port: streamInfo.port,
              };
              _destroyWritableStream.send(origin, streamDestroyRequest);
            } else {
              this.ports.set(streamInfo.port, origin);
              this.openPort(streamInfo.port);
            }
            break;
          }
          case __destroyStream: {
            let ___streamData = streamData;
            this.closePort(___streamData.port);
            break;
          }
          case destroyWritableStreamState: {
            let _streamData = streamData;
            this.bridges.set(_streamData.port, handleStreamDestroy.$origin);
            let streamDestroyPayload = {
              $channel_name: streamDestroyMethod,
              $type: writableStreamDestroy,
            };
            _destroyWritableStream.send(
              handleStreamDestroy.$origin,
              streamDestroyPayload,
            );
            let _iframeId = this.getIframeId(streamData.port);
            let baseLink = this.getBaseLink(streamData.port);
            if (this.layoutDevMode) {
              let previewIframe = this.createIframe(
                _iframeId,
                baseLink,
                "preview",
              );
              previewIframe.style.border = "1px solid black";
              previewIframe.style.height = "40vh";
            }
            this.emitter.dispatchEvent(
              new isWritableStateValid("port/ready", {
                data: {
                  port: _streamData.port,
                  url: baseLink,
                  sourceShellId: _validateWritableState(
                    this.ports.values().next().value,
                    "The worker doesn't exist for the given port",
                  ),
                },
              }),
            );
            break;
          }
          case destroyWritableStream: {
            let streamEventData = streamData;
            if (streamEventData.data.type === "websocket/open") {
              this.websocketClients.set(
                streamEventData.data.wsId,
                streamEventData.data.port,
              );
            }
            let websocketClientPort = this.websocketClients.get(
              streamEventData.data.wsId,
            );
            if (!websocketClientPort) {
              console.warn(
                "WS Port not found for " + streamEventData.data.wsId,
              );
              return;
            }
            let websocketClientStream = this.ports.get(websocketClientPort);
            if (websocketClientStream) {
              _destroyWritableStream.send(
                websocketClientStream,
                streamEventData,
              );
            }
            this.runtimes.set(
              streamEventData.runtimeId,
              handleStreamDestroy.$origin,
            );
            break;
          }
          case ___destroyStream: {
            let currentRuntime = streamData;
            let currentRuntimeData = this.runtimes.get(
              currentRuntime.runtimeId,
            );
            if (currentRuntimeData) {
              _destroyWritableStream.send(currentRuntimeData, streamData);
            }
            break;
          }
          default: {
            console.warn("Unkown preview message", streamData);
            break;
          }
        }
      }
    });
  }
  ports = new Map();
  bridges = new Map();
  websocketClients = new Map();
  runtimes = new Map();
  emitter = new isStreamWritable();
  layoutDevMode =
    new URLSearchParams(window.location.search).get("layout") === "debug";
  getIframeId(getIframeIdForProject) {
    return "iframe-" + this.projectId + "-" + getIframeIdForProject;
  }
  createIframe(createIframeWithAttributes, iframeSource, iframeName) {
    let __iframeElement = document.createElement("iframe");
    let previewListElement = document.getElementById("previews-list");
    __iframeElement.src = iframeSource;
    __iframeElement.allow = "cross-origin-isolated";
    __iframeElement.setAttribute("data-frame-id", createIframeWithAttributes);
    if (iframeName) {
      __iframeElement.setAttribute("name", iframeName);
    }
    previewListElement?.appendChild(__iframeElement);
    return __iframeElement;
  }
  getPortFromShellId(getPortByShellId) {
    return [...this.ports.entries()].find(
      ({ 1: dataProcessor }) => dataProcessor === getPortByShellId,
    )?.[0];
  }
  getBaseLink(getBaseLinkWithProjectId) {
    let constructedBaseLink = this.projectId + "-" + getBaseLinkWithProjectId;
    if (destroyMethod.includes("{{identifier}}")) {
      return (
        "https://" +
        destroyMethod.replace("{{identifier}}", constructedBaseLink)
      );
    } else {
      return "https://" + constructedBaseLink + "." + destroyMethod;
    }
  }
  openPort(portNumber) {
    let iframeElement = this.getBaseLink(portNumber);
    let iframeId = this.getIframeId(portNumber);
    let _iframeElement = this.createIframe(iframeId, "index.html", "bridge");
    if (this.layoutDevMode) {
      _iframeElement.style.border = "1px solid black";
    }
    document.getElementById("bridge")?.appendChild(_iframeElement);
    let iframeContentWindow = _iframeElement.contentWindow;
    if (!iframeContentWindow) {
      throw new Error("Could not get iframe contentWindow");
    }
    let messageChannel = new MessageChannel();
    _iframeElement.onload = () => {
      let destroyWritableStateMessage = {
        $type: destroyWritableState,
      };
      iframeContentWindow.postMessage(destroyWritableStateMessage, "*", [
        messageChannel.port2,
      ]);
      _destroyWritableStream.addEndpoint(iframeId, {
        send: (sendMessageWithPorts, sendMessageWithPortsAndParameters) =>
          messageChannel.port1.postMessage(
            sendMessageWithPorts,
            sendMessageWithPortsAndParameters,
          ),
        onMessage: (_handleMessage) => {
          messageChannel.port1.onmessage = (handleReceivedMessage) => {
            _handleMessage(handleReceivedMessage.data);
          };
        },
      });
    };
    if (this.layoutDevMode) {
      let previewsListElement = document.getElementById("previews-list");
      let linkToLocalhost = document.createElement("a");
      linkToLocalhost.setAttribute("data-port", String(portNumber));
      linkToLocalhost.href = iframeElement;
      linkToLocalhost.target = "_blank";
      linkToLocalhost.innerText = "localhost:" + portNumber;
      previewsListElement?.appendChild(linkToLocalhost);
    }
  }
  closePort(closePortById) {
    let __iframeId = this.getIframeId(closePortById);
    document
      .querySelectorAll('[data-frame-id="' + __iframeId + '"]')
      ?.forEach((removeElement) => {
        removeElement.remove();
      });
    document.querySelector('[data-port="' + closePortById + '"]')?.remove();
    let portData = this.ports.get(closePortById);
    this.ports.delete(closePortById);
    this.bridges.delete(closePortById);
    _destroyWritableStream.removeEndpoint(__iframeId);
    if (portData) {
      let streamDestroyConfig = {
        $channel_name: streamDestroyMethod,
        $type: __writableState,
        port: closePortById,
      };
      _destroyWritableStream.broadcast(streamDestroyConfig);
    }
  }
};
var _initializeReaderAndEmitEvent = defineObjectProperties(
  getStylizedRepresentation(),
);
_validateAndRetrieveIntrinsicPropertyValue();
var initializeReaderAndEmitEventReadable =
  window.localStorage.CSB_EMULATOR_DEBUG;
function processAndEmitEventHandler(processReaderAndEmitEvent) {
  return function (_handleAsyncIterable, ...additionalArguments) {};
}
var initializeReaderAndWritableStream = defineObjectProperties(
  bufferCapacityValidation(),
);
var initializeReaderAndEmitEventHandler = (createErrorFromExisting) => {
  let createError = new Error(createErrorFromExisting.message);
  for (let errorKey of Object.keys(createErrorFromExisting)) {
    createError[errorKey] = createErrorFromExisting[errorKey];
  }
  return createError;
};
_validateAndRetrieveIntrinsicPropertyValue();
var readerPromise = class extends Error {
  code;
  syscall;
  path;
  errno;
  constructor(errorMessage, errorCode, syscall, __filePath, errnoValue) {
    super(
      "Error: " +
        errorCode +
        ": " +
        errorMessage +
        ", " +
        syscall +
        " '" +
        __filePath +
        "'",
    );
    this.code = errorCode;
    this.syscall = syscall;
    this.path = __filePath;
    this.errno = errnoValue;
  }
};
var isValidData = class extends readerPromise {
  constructor(fileAlreadyExistsError, filePathOrReference) {
    super(
      "file already exists",
      "EEXIST",
      fileAlreadyExistsError,
      filePathOrReference,
      -17,
    );
  }
};
var streamConfiguration = class extends readerPromise {
  constructor(fileErrorCode, errorDetails) {
    super(
      "no such file or directory",
      "ENOENT",
      fileErrorCode,
      errorDetails,
      -2,
    );
  }
};
var initializeStreamProcessor = class extends readerPromise {
  constructor(directoryOperationError, operationContext) {
    super(
      "illegal operation on a directory",
      "EISDIR",
      directoryOperationError,
      operationContext,
      -21,
    );
  }
};
var __initializeReaderAndEmitEvent = class extends readerPromise {
  constructor(__errorCode, __errorMessage) {
    super("not a directory", "ENOTDIR", __errorCode, __errorMessage, -20);
  }
};
var getMatchingIndexWithAsyncGenerator = class extends readerPromise {
  constructor(directoryNotEmptyError, _errorCode) {
    super(
      "directory not empty",
      "ENOTEMPTY",
      directoryNotEmptyError,
      _errorCode,
      -39,
    );
  }
};
var signalHandler = class extends readerPromise {
  constructor(invalidArgumentError, errorContext) {
    super(
      "invalid argument",
      "EINVAL",
      invalidArgumentError,
      errorContext,
      -22,
    );
  }
};
var processChunk = class extends readerPromise {
  constructor(socketErrorCode, socketOperationError) {
    super(
      "operation not supported on socket",
      "ENOTSUP",
      socketErrorCode,
      socketOperationError,
      -45,
    );
  }
};
var writeChunkAndCallback = class extends readerPromise {
  constructor(symbolicLinkError, depthCount) {
    super(
      "too many symbolic links encountered",
      "ELOOP",
      symbolicLinkError,
      depthCount,
      -62,
    );
  }
};
var writeChunkCallback = {
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  UV_DIRENT_UNKNOWN: 0,
  UV_DIRENT_FILE: 1,
  UV_DIRENT_DIR: 2,
  UV_DIRENT_LINK: 3,
  UV_DIRENT_FIFO: 4,
  UV_DIRENT_SOCKET: 5,
  UV_DIRENT_CHAR: 6,
  UV_DIRENT_BLOCK: 7,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 512,
  O_EXCL: 2048,
  UV_FS_O_FILEMAP: 0,
  O_NOCTTY: 131072,
  O_TRUNC: 1024,
  O_APPEND: 8,
  O_DIRECTORY: 1048576,
  O_NOFOLLOW: 256,
  O_SYNC: 128,
  O_DSYNC: 4194304,
  O_SYMLINK: 2097152,
  O_NONBLOCK: 4,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_COPYFILE_EXCL: 1,
  COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_FICLONE_FORCE: 4,
};
var createWritableStream = class {
  mode;
  size;
  ino;
  atimeMs;
  mtimeMs;
  ctimeMs;
  birthtimeMs;
  atime;
  mtime;
  ctime;
  birthtime;
  uid;
  gid;
  dev;
  nlink;
  rdev;
  blksize;
  blocks;
  constructor(
    FileMetadataConstructor,
    fileMode,
    numberOfLinks,
    uid,
    groupId,
    deviceID,
    blockSize,
    inodeNumber,
    fileSize,
    blockCount,
    accessTimeMs,
    modificationTimeMs,
    creationTimeMs,
    birthtimeMs,
  ) {
    this.dev = FileMetadataConstructor;
    this.size = fileSize;
    this.ino = inodeNumber;
    this.atimeMs = accessTimeMs;
    this.mtimeMs = modificationTimeMs;
    this.ctimeMs = creationTimeMs;
    this.birthtimeMs = creationTimeMs;
    this.atime = new Date(accessTimeMs);
    this.mtime = new Date(modificationTimeMs);
    this.ctime = new Date(creationTimeMs);
    this.birthtime = new Date(birthtimeMs);
    this.blocks = blockCount;
    this.nlink = numberOfLinks;
    this.uid = uid;
    this.gid = groupId;
    this.rdev = deviceID;
    this.blksize = blockSize;
    this.mode = fileMode;
  }
  #e(isModeEqualToWriteChunk) {
    return (this.mode & writeChunkCallback.S_IFMT) === isModeEqualToWriteChunk;
  }
  isFile() {
    return this.#e(writeChunkCallback.S_IFREG);
  }
  isDirectory() {
    return this.#e(writeChunkCallback.S_IFDIR);
  }
  isSymbolicLink() {
    return this.#e(writeChunkCallback.S_IFLNK);
  }
  isSocket() {
    return false;
  }
  isFIFO() {
    return false;
  }
  isCharacterDevice() {
    return false;
  }
  isBlockDevice() {
    return false;
  }
};
var onFinishCallback = 4096;
function createWritableStreamFromHandle(handleReadStream) {
  let handleStreamType = handleReadStream.type;
  let defaultBufferSize =
    handleStreamType === 0 ? 16895 : handleStreamType === 2 ? 41453 : 33279;
  let calculatedChunkSize =
    handleStreamType === 0
      ? 0
      : Math.max(8, Math.ceil(handleReadStream.size / onFinishCallback));
  return new createWritableStream(
    1,
    defaultBufferSize,
    1,
    1,
    1,
    0,
    onFinishCallback,
    handleReadStream.ino,
    handleReadStream.size,
    calculatedChunkSize,
    handleReadStream.atimeMs,
    handleReadStream.mtimeMs,
    handleReadStream.ctimeMs,
    handleReadStream.ctimeMs,
  );
}
_validateAndRetrieveIntrinsicPropertyValue();
function ____________________________________________validateAndRetrieveIntrinsicProperties(
  _handleReadableStream,
) {
  return ____validateAndRetrieveIntrinsicProperties.from(_handleReadableStream);
}
function getReadableStreamProperties(
  handleStreamReadabilityEvents,
  onReadableEndStream,
) {
  if (typeof handleStreamReadabilityEvents == "string") {
    return ____validateAndRetrieveIntrinsicProperties.from(
      handleStreamReadabilityEvents,
      onReadableEndStream,
    );
  } else {
    return ____validateAndRetrieveIntrinsicProperties.from(
      handleStreamReadabilityEvents,
    );
  }
}
function __initializeEventListener(eventListenerInitializer) {
  if (typeof eventListenerInitializer == "string") {
    return eventListenerInitializer;
  } else if (
    eventListenerInitializer instanceof
    ____validateAndRetrieveIntrinsicProperties
  ) {
    return eventListenerInitializer.toString("utf-8");
  } else {
    return eventListenerInitializer.pathname;
  }
}
function getResolvedPathSegments(initializeVersionComparison) {
  let _resolvedPathSegments = resolvePath(initializeVersionComparison).split(
    "/",
  );
  _resolvedPathSegments.shift();
  return _resolvedPathSegments;
}
function combinePaths(
  destroyVersionComparisonWorker,
  _eventListenerInitializer,
) {
  if (
    destroyVersionComparisonWorker.endsWith("/") ||
    _eventListenerInitializer.startsWith("/")
  ) {
    return destroyVersionComparisonWorker + _eventListenerInitializer;
  } else {
    return destroyVersionComparisonWorker + "/" + _eventListenerInitializer;
  }
}
var handleVersionComparisonWorkerFunction = 0;
function incrementVersionComparisonCount() {
  return (handleVersionComparisonWorkerFunction += 1);
}
function serializeWorkerVersionHandler(onWorkerVersionComparisonHandler) {
  if (
    onWorkerVersionComparisonHandler instanceof getWritableStateProperties ||
    onWorkerVersionComparisonHandler instanceof handleWritableState ||
    onWorkerVersionComparisonHandler instanceof
      initializeVersionComparisonHandler
  ) {
    return onWorkerVersionComparisonHandler.serialize();
  }
  throw new Error("Not serializable");
}
function deserializeVersionComparison(
  _initializeVersionComparison,
  ______handleVersionComparison,
  ___handleVersionComparisonWorker,
) {
  switch (_initializeVersionComparison.type) {
    case 0:
      return getWritableStateProperties.deserialize(
        _initializeVersionComparison,
        ______handleVersionComparison,
        ___handleVersionComparisonWorker,
      );
    case 1:
      return handleWritableState.deserialize(
        _initializeVersionComparison,
        ______handleVersionComparison,
        ___handleVersionComparisonWorker,
      );
    case 2:
      return initializeVersionComparisonHandler.deserialize(
        _initializeVersionComparison,
        ______handleVersionComparison,
      );
    default:
      throw new Error("Unknown node type");
  }
}
var ________________________________________validateAndRetrieveIntrinsicProperties = class {
  getPath() {
    if (this.parent) {
      if (!this.parent.name && !this.parent.parent) {
        return "/" + this.name;
      } else {
        return this.parent.getPath() + "/" + this.name;
      }
    } else {
      return "/";
    }
  }
  getPathParts(pathParts = []) {
    if (this.name) {
      pathParts.unshift(this.name);
    }
    if (this.parent) {
      pathParts = this.parent.getPathParts(pathParts);
    }
    return pathParts;
  }
  rename(updateNameAndTimestamp) {
    this.name = updateNameAndTimestamp;
    this.stats.mtimeMs = Date.now();
  }
};
function createFileMetadata(updatePrototypeMethods, initializeProperties) {
  return {
    type: updatePrototypeMethods,
    size: initializeProperties,
    ino: incrementVersionComparisonCount(),
    mtimeMs: Date.now(),
    ctimeMs: Date.now(),
    atimeMs: Date.now(),
  };
}
var initializeVersionComparisonHandler = class extends ________________________________________validateAndRetrieveIntrinsicProperties {
  name;
  stats;
  target;
  parent;
  constructor(__fileName, targetFile, parentObject) {
    super();
    this.name = __fileName;
    this.stats = createFileMetadata(2, 128);
    this.target = targetFile;
    this.parent = parentObject;
  }
  serialize() {
    return {
      type: 2,
      name: this.name,
      stats: this.stats,
      target: this.target,
    };
  }
  static deserialize(_deserializeVersionComparison, versionComparisonData) {
    let _____versionComparisonHandler = new initializeVersionComparisonHandler(
      _deserializeVersionComparison.name,
      _deserializeVersionComparison.target,
      versionComparisonData,
    );
    _____versionComparisonHandler.stats = _deserializeVersionComparison.stats;
    return _____versionComparisonHandler;
  }
};
var handleWritableState = class extends ________________________________________validateAndRetrieveIntrinsicProperties {
  constructor(
    constructorCoreFileSystemFileNameFileContentParentDirectory,
    fileContent,
    parentDirectory,
    coreFileSystemInstance,
  ) {
    super();
    this.coreFS = coreFileSystemInstance;
    this.name = constructorCoreFileSystemFileNameFileContentParentDirectory;
    this.content = fileContent;
    this.stats = createFileMetadata(1, fileContent.byteLength);
    this.parent = parentDirectory;
  }
  name;
  stats;
  content;
  parent;
  write(writeContent, isUserLoggedIn = false) {
    this.content = writeContent;
    this.stats.size = writeContent.byteLength;
    this.stats.mtimeMs = Date.now();
    this.coreFS.emitWrite(this, writeContent, isUserLoggedIn);
  }
  serialize() {
    return {
      type: 1,
      name: this.name,
      stats: this.stats,
      content: this.content,
    };
  }
  static deserialize(
    deserializeWritableState,
    writableStateHandler,
    writableStateContent,
  ) {
    let writableStateInstance = new handleWritableState(
      deserializeWritableState.name,
      deserializeWritableState.content,
      writableStateHandler,
      writableStateContent,
    );
    writableStateInstance.stats = deserializeWritableState.stats;
    return writableStateInstance;
  }
};
var getWritableStateProperties = class extends ________________________________________validateAndRetrieveIntrinsicProperties {
  constructor(
    constructorFileNameParentDirectoryCoreFileSystem,
    _parentDirectory,
    coreFileSystem,
  ) {
    super();
    this.coreFS = coreFileSystem;
    this.name = constructorFileNameParentDirectoryCoreFileSystem;
    this.parent = _parentDirectory;
    this.stats = createFileMetadata(0, 128);
  }
  name;
  stats;
  children = new Map();
  parent;
  getChild(getChildById) {
    return this.children.get(getChildById);
  }
  addChild(
    addChildChildNodeEmitCreationTrueNotifyParentFalse,
    ___isFeatureEnabled = true,
    _isFeatureEnabled = false,
  ) {
    this.children.set(
      addChildChildNodeEmitCreationTrueNotifyParentFalse.name,
      addChildChildNodeEmitCreationTrueNotifyParentFalse,
    );
    this.stats.mtimeMs = Date.now();
    if (___isFeatureEnabled) {
      this.coreFS.emitNodeCreation(
        this,
        addChildChildNodeEmitCreationTrueNotifyParentFalse,
        _isFeatureEnabled,
      );
    }
  }
  removeChild(
    removeChildById,
    ___isUserLoggedIn = true,
    _isUserLoggedIn = false,
  ) {
    this.children.delete(removeChildById);
    this.stats.mtimeMs = Date.now();
    if (___isUserLoggedIn) {
      this.coreFS.emitNodeDeletion(this, removeChildById, _isUserLoggedIn);
    }
  }
  serialize() {
    return {
      type: 0,
      name: this.name,
      stats: this.stats,
    };
  }
  static deserialize(
    deserializeWritableStateProperties,
    _writableStateProperties,
    initializationData,
  ) {
    let __writableStateProperties = new getWritableStateProperties(
      deserializeWritableStateProperties.name,
      _writableStateProperties,
      initializationData,
    );
    __writableStateProperties.stats = deserializeWritableStateProperties.stats;
    return __writableStateProperties;
  }
};
var isInitializedObject = class {
  root = new getWritableStateProperties("", undefined, this);
  emitter = new _____evaluateVersionOperators();
  onFSEvent = this.emitter.event;
  emitNodeCreation(
    emitNodeCreationParentNodeNewNodeIsSynchronous,
    newNodeData,
    isNodeCreationSynchronous,
  ) {
    this.emitter.fire({
      type: "create",
      parent: emitNodeCreationParentNodeNewNodeIsSynchronous.getPath(),
      newNode: serializeWorkerVersionHandler(newNodeData),
      isSync: isNodeCreationSynchronous,
    });
  }
  emitNodeDeletion(
    emitNodeDeletionParentNodeNodeNameIsSynchronous,
    nodeToDelete,
    isSynchronousDeletion,
  ) {
    this.emitter.fire({
      type: "remove",
      parent: emitNodeDeletionParentNodeNodeNameIsSynchronous.getPath(),
      name: nodeToDelete,
      isSync: isSynchronousDeletion,
    });
  }
  emitWrite(emitWriteForFile, contentToWrite, isSynchronousWrite) {
    this.emitter.fire({
      type: "write",
      path: emitWriteForFile.getPath(),
      content: contentToWrite,
      isSync: isSynchronousWrite,
    });
  }
  resolveSymlink(resolveSymlinkTargetNode) {
    let resolutionAttempts = 0;
    let currentSymlinkTarget = resolveSymlinkTargetNode;
    while (currentSymlinkTarget instanceof initializeVersionComparisonHandler) {
      if (resolutionAttempts > 10) {
        throw new writeChunkAndCallback(
          "open",
          resolveSymlinkTargetNode.getPath(),
        );
      }
      currentSymlinkTarget = this.getNodeAtPath(
        getResolvedPathSegments(currentSymlinkTarget.target),
        currentSymlinkTarget.target,
      );
      resolutionAttempts++;
    }
    return currentSymlinkTarget;
  }
  getDirNodeAtPath(getDirNodeAtPath) {
    let currentDirectoryNode = this.root;
    if (getDirNodeAtPath.length === 1 && getDirNodeAtPath[0] === "") {
      return currentDirectoryNode;
    }
    for (let directoryNode of getDirNodeAtPath) {
      let childDirectoryNode = currentDirectoryNode.getChild(directoryNode);
      if (childDirectoryNode) {
        if (childDirectoryNode instanceof getWritableStateProperties) {
          currentDirectoryNode = childDirectoryNode;
        } else if (
          childDirectoryNode instanceof initializeVersionComparisonHandler
        ) {
          let resolvedChildDirectoryNode =
            this.resolveSymlink(childDirectoryNode);
          if (
            resolvedChildDirectoryNode instanceof getWritableStateProperties
          ) {
            currentDirectoryNode = resolvedChildDirectoryNode;
          } else {
            throw new __initializeReaderAndEmitEvent(
              "open",
              getDirNodeAtPath.join("/"),
            );
          }
        } else {
          throw new streamConfiguration("open", getDirNodeAtPath.join("/"));
        }
      } else {
        throw new streamConfiguration("open", getDirNodeAtPath.join("/"));
      }
    }
    return currentDirectoryNode;
  }
  getNodeAtPath(getNodeAtPath, nodeId) {
    let childNodeId = getNodeAtPath.pop();
    if (!childNodeId) {
      return this.root;
    }
    let ___directoryNode = this.getDirNodeAtPath(getNodeAtPath);
    if (!___directoryNode) {
      throw new streamConfiguration("open", nodeId);
    }
    if (!(___directoryNode instanceof getWritableStateProperties)) {
      throw new __initializeReaderAndEmitEvent("open", nodeId);
    }
    let childNode = ___directoryNode.getChild(childNodeId);
    if (!childNode) {
      throw new streamConfiguration("open", nodeId);
    }
    return childNode;
  }
  moveNode(moveNodeToPath, moveNodeToNewPath, __isFeatureEnabled = false) {
    let nodeToMove = this.getNodeAtPath(
      getResolvedPathSegments(moveNodeToPath),
      moveNodeToPath,
    );
    let destinationNodePath = getResolvedPathSegments(moveNodeToNewPath);
    let destinationNodeName = destinationNodePath.pop();
    if (destinationNodeName) {
      let destinationNode = this.getDirNodeAtPath(destinationNodePath);
      nodeToMove.parent?.removeChild(nodeToMove.name, false);
      nodeToMove.rename(destinationNodeName);
      destinationNode.addChild(nodeToMove, false);
      nodeToMove.parent = destinationNode;
    }
    this.emitter.fire({
      type: "move",
      oldPath: moveNodeToPath,
      newPath: moveNodeToNewPath,
      isSync: __isFeatureEnabled,
    });
    return nodeToMove;
  }
  _serializeTreeNode(serializeTreeNode) {
    if (serializeTreeNode instanceof getWritableStateProperties) {
      return {
        ...serializeTreeNode.serialize(),
        children: [],
      };
    } else {
      return serializeWorkerVersionHandler(serializeTreeNode);
    }
  }
  _serialize(__sourceNode, serializedNode) {
    for (let _childNode of __sourceNode.children.values()) {
      if (_childNode instanceof getWritableStateProperties) {
        let serializedChildNode = this._serializeTreeNode(_childNode);
        serializedChildNode = this._serialize(_childNode, serializedChildNode);
        serializedNode.children.push(serializedChildNode);
      } else {
        serializedNode.children.push(this._serializeTreeNode(_childNode));
      }
    }
    return serializedNode;
  }
  handleSyncEvent(syncEvent) {
    if (!syncEvent.isSync) {
      switch (syncEvent.type) {
        case "create": {
          let _parentDirectoryNode = this.getDirNodeAtPath(
            getResolvedPathSegments(syncEvent.parent),
          );
          let newNodeVersionComparison = deserializeVersionComparison(
            syncEvent.newNode,
            _parentDirectoryNode,
            this,
          );
          _parentDirectoryNode.addChild(newNodeVersionComparison, true, true);
          break;
        }
        case "move": {
          this.moveNode(syncEvent.oldPath, syncEvent.newPath, true);
          break;
        }
        case "remove": {
          this.getDirNodeAtPath(
            getResolvedPathSegments(syncEvent.parent),
          ).removeChild(syncEvent.name, true, true);
          break;
        }
        case "write": {
          let nodeAtSyncPath = this.getNodeAtPath(
            getResolvedPathSegments(syncEvent.path),
            syncEvent.path,
          );
          if (nodeAtSyncPath instanceof handleWritableState) {
            nodeAtSyncPath.write(syncEvent.content, true);
          }
          break;
        }
      }
    }
  }
  serialize() {
    let serializedTreeNode = this._serializeTreeNode(this.root);
    return this._serialize(this.root, serializedTreeNode);
  }
  populate(populateChildNodes, rootElement = this.root) {
    for (let __childNode of populateChildNodes.children) {
      if (__childNode.type === 0) {
        let deserializedVersionComparison = deserializeVersionComparison(
          __childNode,
          rootElement,
          this,
        );
        rootElement.addChild(deserializedVersionComparison, false);
        this.populate(__childNode, deserializedVersionComparison);
      } else {
        rootElement.addChild(
          deserializeVersionComparison(__childNode, rootElement, this),
          false,
        );
      }
    }
  }
};
var getValidSemverRangeListeners = defineObjectProperties(
  defineVersionPatterns(),
);
var validateAndFetchEventListeners = defineObjectProperties(
  defineVersionRangePatterns(),
);
var _initializeEventListeners = defineObjectProperties(validateVersionFormat());
function isHttpOrHttpsUrl(__getEventListeners) {
  let parsedUrl;
  try {
    parsedUrl = new URL(__getEventListeners);
  } catch {
    return false;
  }
  return parsedUrl.protocol === "http:" || parsedUrl.protocol === "https:";
}
function createNormalizedURL(..._createNormalizedURL) {
  try {
    let normalizedURL = new URL(_createNormalizedURL.join("/"));
    normalizedURL.pathname = normalizedURL.pathname.replace(/\/+/g, "/");
    return normalizedURL.toString();
  } catch {
    return _createNormalizedURL.join("/").replace(/\/+/g, "/");
  }
}
function delayExecutionByMilliseconds(initializeEventListenerCount) {
  return new Promise((___initializeEventListener) =>
    setTimeout(___initializeEventListener, initializeEventListenerCount),
  );
}
var getEventListenersCount = new Set([
  408, 429, 424, 499, 444, 502, 503, 504, 599,
]);
function isStreamCloseEventHandled(handleStreamCloseEvent) {
  return getEventListenersCount.has(handleStreamCloseEvent);
}
function calculateEventListenerDelay(
  createEventListenerHandler,
  initializeEventListener,
) {
  let randomDelayFactor = Math.max(1, Math.random() * 2);
  return Math.min(
    randomDelayFactor *
      createEventListenerHandler.minDelayMs *
      Math.pow(createEventListenerHandler.factor, initializeEventListener),
    createEventListenerHandler.maxDelayMs,
  );
}
async function retryFetchWithExponentialBackoff(
  createEventListenerCleanup,
  handleStreamEvents,
  exponentialBackoffConfig = {
    maxRetries: 5,
    minDelayMs: 500,
    maxDelayMs: 15000,
    factor: 2,
  },
  eventListenerCount = 0,
) {
  let retryFetchAttempts = async () => {
    eventListenerCount += 1;
    let eventListenerDelay = calculateEventListenerDelay(
      exponentialBackoffConfig,
      eventListenerCount,
    );
    await delayExecutionByMilliseconds(eventListenerDelay);
    return retryFetchWithExponentialBackoff(
      createEventListenerCleanup,
      handleStreamEvents,
      exponentialBackoffConfig,
      eventListenerCount,
    );
  };
  try {
    let eventListenerCleanupResponse = await fetch(
      createEventListenerCleanup,
      handleStreamEvents,
    );
    if (
      !eventListenerCleanupResponse.ok &&
      isStreamCloseEventHandled(eventListenerCleanupResponse.status) &&
      exponentialBackoffConfig.maxRetries > eventListenerCount
    ) {
      return retryFetchAttempts();
    } else {
      return eventListenerCleanupResponse;
    }
  } catch (____error) {
    if (exponentialBackoffConfig.maxRetries > eventListenerCount) {
      return retryFetchAttempts();
    }
    throw ____error;
  }
}
var eventListenerCleanup = class {
  cdnUrl = undefined;
  init(initializeCdnUrl) {
    this.cdnUrl = initializeCdnUrl;
  }
  async fetch(fetchResource, fetchOptions) {
    let response = await retryFetchWithExponentialBackoff(
      fetchResource,
      fetchOptions,
    );
    if (!response.ok) {
      let fetchedResponseText = await response
        .text()
        .catch(() => "Unknown CDN error");
      throw new Error(
        replaceVariablesInTemplateString(
          'Failed to fetch "%s": %s',
          fetchResource,
          fetchedResponseText,
        ),
      );
    }
    return response;
  }
  async fetchPackage(__packageName, ____packageVersion) {
    isWritableStateError(
      this.cdnUrl,
      'Failed to fetch package "%s@%s": the Sandpack CDN is not defined',
      this.cdnUrl,
    );
    let packageFiles;
    try {
      packageFiles = await this.fetchPackageFromRegistry(
        __packageName,
        ____packageVersion,
      );
    } catch {
      let base64EncodedPackageIdentifier = btoa(
        __packageName + "@" + ____packageVersion,
      );
      let normalizedPackageURL = createNormalizedURL(
        this.cdnUrl,
        "/v2/mod/" + base64EncodedPackageIdentifier,
      );
      let packageFilesArrayBuffer = await (
        await this.fetch(normalizedPackageURL)
      ).arrayBuffer();
      packageFiles = decodeStreamStatus(packageFilesArrayBuffer);
    }
    return {
      name: __packageName,
      version: ____packageVersion,
      files: packageFiles,
    };
  }
  async fetchPackageFromRegistry(
    fetchPackageTarballFromRegistry,
    ___packageVersion,
  ) {
    let tarballUrl = (
      await this.fetch(
        "https://registry.npmjs.org/" +
          fetchPackageTarballFromRegistry +
          "/" +
          ___packageVersion,
      ).then((fetchDataFromServer) => fetchDataFromServer.json())
    ).dist.tarball;
    let fetchedPackageTarball = await this.fetch(tarballUrl);
    let decodedPackageStream = await readAllChunksFromReader(
      (await fetchedPackageTarball.blob())
        .stream()
        .pipeThrough(new DecompressionStream("gzip")),
    );
    let initializePackageEventListeners = await (0,
    _initializeEventListeners.default)(decodedPackageStream.buffer);
    let packagesBufferMap = {};
    for (let packageEventListener of initializePackageEventListeners) {
      let extractedPackageListenerName = packageEventListener.name.replace(
        /^[^/]+/,
        "",
      );
      if (packageEventListener.type === "0") {
        packagesBufferMap[extractedPackageListenerName] = new Uint8Array(
          packageEventListener.buffer,
        );
      }
    }
    return packagesBufferMap;
  }
  async fetchDependencies(dependencyList) {
    isWritableStateError(
      this.cdnUrl,
      "Failed to fetch dependencies: the Sandpack CDN is not defined",
      this.cdnUrl,
    );
    if (dependencyList.length === 0) {
      return Promise.resolve(null);
    }
    let formattedDependencyString = dependencyList
      .map(
        ([userData, userDataIndex]) =>
          userData + "@" + userDataIndex.replace(/\s+/, ""),
      )
      .sort()
      .join(";");
    let dependencyFetchUrl = createNormalizedURL(
      this.cdnUrl,
      "/v2/deps/" + btoa(formattedDependencyString),
    );
    let dependencyArrayBuffer = await (
      await this.fetch(dependencyFetchUrl)
    ).arrayBuffer();
    return decodeStreamStatus(dependencyArrayBuffer);
  }
};
async function readAllChunksFromReader(compareVersionWithPrereleaseFunction) {
  let reader = compareVersionWithPrereleaseFunction.getReader();
  let chunksArray = [];
  let isReadingComplete = false;
  while (!isReadingComplete) {
    let { done: _isReadingComplete, value: chunkValue } = await reader.read();
    if (_isReadingComplete) {
      isReadingComplete = true;
    } else {
      chunksArray.push(chunkValue);
    }
  }
  let totalLengthOfChunks = chunksArray.reduce(
    (getTotalLengthIncludingPrefix, additionalLength) =>
      getTotalLengthIncludingPrefix + additionalLength.length,
    0,
  );
  let combinedChunksArray = new Uint8Array(totalLengthOfChunks);
  let currentChunkOffset = 0;
  for (let chunk of chunksArray) {
    combinedChunksArray.set(chunk, currentChunkOffset);
    currentChunkOffset += chunk.length;
  }
  return combinedChunksArray;
}
var _______handleVersionComparison = defineObjectProperties(
  defineVersionPatterns(),
);
var compareAndValidateVersion = ["~", ".", "/"];
function compareAndValidateNpmPackages(
  _compareAndValidateVersion,
  __compareAndValidateVersion,
) {
  let addPackageToSet = (addNpmPackageToSet, ________packageVersion) => {
    __compareAndValidateVersion.npmPackages[addNpmPackageToSet] ||= new Set();
    __compareAndValidateVersion.npmPackages[addNpmPackageToSet].add(
      ________packageVersion,
    );
  };
  for (let [packageName, _packageVersion] of Object.entries(
    _compareAndValidateVersion,
  )) {
    if (typeof _packageVersion != "string") {
      throw new Error("Invalid package specifier: " + _packageVersion);
    }
    if (_______handleVersionComparison.default.validRange(_packageVersion)) {
      __compareAndValidateVersion.directNpmPackages[packageName] =
        _packageVersion;
      addPackageToSet(packageName, _packageVersion);
    } else if (_packageVersion.startsWith("file:")) {
      __compareAndValidateVersion.fileAliases[packageName] =
        _packageVersion.substring(5);
    } else if (_packageVersion.startsWith("npm:")) {
      let [_packageNameAndVersion, _______packageVersion] = _packageVersion
        .substring(4)
        .split("@");
      if (
        !_packageNameAndVersion ||
        !_______handleVersionComparison.default.validRange(
          _______packageVersion,
        )
      ) {
        throw new Error("Invalid dependency specifier: " + _packageVersion);
      }
      addPackageToSet(_packageNameAndVersion, _______packageVersion);
      __compareAndValidateVersion.npmAliases[packageName] =
        _packageNameAndVersion + "@" + _______packageVersion;
    } else if (isHttpOrHttpsUrl(_packageVersion)) {
      __compareAndValidateVersion.remotePackages[packageName] = _packageVersion;
    } else if (compareAndValidateVersion.includes(_packageVersion[0])) {
      __compareAndValidateVersion.fileAliases[packageName] = _packageVersion;
    } else if (_packageVersion.includes("/")) {
      __compareAndValidateVersion.gitPackages[packageName] = _packageVersion;
    } else {
      __compareAndValidateVersion.directNpmPackages[packageName] =
        _packageVersion;
      addPackageToSet(packageName, _packageVersion);
    }
  }
  return __compareAndValidateVersion;
}
function compareNpmPackageVersions(handleVersionComparisonWithPrerelease) {
  let packageVersionDetails = {
    directNpmPackages: {},
    npmPackages: {},
    remotePackages: {},
    gitPackages: {},
    npmAliases: {},
    fileAliases: {},
  };
  if (
    !handleVersionComparisonWithPrerelease ||
    typeof handleVersionComparisonWithPrerelease != "object"
  ) {
    handleVersionComparisonWithPrerelease = {};
  }
  compareAndValidateNpmPackages(
    handleVersionComparisonWithPrerelease,
    packageVersionDetails,
  );
  return packageVersionDetails;
}
function compareNpmPackageDependencies(
  __comparePrereleaseVersions,
  ____isFeatureEnabled = true,
) {
  let packageDependencySummary = {
    directNpmPackages: {},
    npmPackages: {},
    remotePackages: {},
    gitPackages: {},
    npmAliases: {},
    fileAliases: {},
  };
  if (__comparePrereleaseVersions.dependencies) {
    compareAndValidateNpmPackages(
      __comparePrereleaseVersions.dependencies,
      packageDependencySummary,
    );
  }
  if (____isFeatureEnabled && __comparePrereleaseVersions.devDependencies) {
    compareAndValidateNpmPackages(
      __comparePrereleaseVersions.devDependencies,
      packageDependencySummary,
    );
  }
  return packageDependencySummary;
}
var handleErrorDuringProcessing = defineObjectProperties(
  compareVersionWithPrerelease(),
);
function processErrorHandling(_handleErrorDuringProcessing) {
  let parsedErrorHandling = (0, handleErrorDuringProcessing.parse)(
    _handleErrorDuringProcessing,
  );
  return Object.entries(parsedErrorHandling).reduce(
    (updateObjectWithCamelCaseKey, [userAge, isAdult]) => {
      let convertToCamelCaseKey = userAge.replace(
        /-([a-z])/g,
        (_convertStringToUpperCase, __convertStringToUpperCase) =>
          __convertStringToUpperCase.toUpperCase(),
      );
      updateObjectWithCamelCaseKey[convertToCamelCaseKey] = isAdult;
      return updateObjectWithCamelCaseKey;
    },
    {},
  );
}
function parseHandleError(handleError) {
  let handleErrorParts = handleError.split("@");
  let errorType = handleErrorParts.pop();
  if (!errorType || !handleErrorParts.length) {
    throw new Error("Invalid specifier: " + handleError);
  }
  return [handleErrorParts.join("@"), errorType];
}
function transformErrorListenerToPackageInfo(errorListener) {
  let packageInfoArray = [];
  for (let [packageEntry, packageRange] of Object.entries(
    errorListener.directNpmPackages,
  )) {
    packageInfoArray.push([
      packageEntry,
      {
        name: packageEntry,
        range: packageRange,
      },
    ]);
  }
  for (let [npmAliasKey, npmAliasDetails] of Object.entries(
    errorListener.npmAliases,
  )) {
    let [npmAliasNameAndVersion, npmAliasVersionRange] =
      parseHandleError(npmAliasDetails);
    if (!npmAliasVersionRange) {
      throw new Error("Invalid npm alias version range");
    }
    packageInfoArray.push([
      npmAliasKey,
      {
        name: npmAliasNameAndVersion,
        range: npmAliasVersionRange,
      },
    ]);
  }
  return packageInfoArray;
}
var transformResult = class extends isStreamWritable {
  constructor(_fileSystem) {
    super();
    this.fs = _fileSystem;
    this.store = new dataBufferUtility(this.fs, {
      publicHoistPattern: ["@vuepress/client", "@nuxt*"],
    });
    this.cdnClient = new eventListenerCleanup();
    this.pendingRequests = new Map();
  }
  store;
  _cdnUrl;
  cdnClient;
  pendingRequests;
  get cdnUrl() {
    return this._cdnUrl;
  }
  set cdnUrl(___cdnUrl) {
    isWritableStateError(
      typeof ___cdnUrl !== "undefined",
      "Failed to update a CDN URL: the next URL is not defined",
    );
    this._cdnUrl = ___cdnUrl;
    this.cdnClient.init(___cdnUrl);
  }
  get totalPending() {
    return this.pendingRequests.size;
  }
  async installPackage(installPackageWithNameAndVersion, _____packageVersion) {
    if (
      !this.shouldInstallPackage(
        installPackageWithNameAndVersion,
        _____packageVersion,
      )
    ) {
      return;
    }
    let fetchedPackage = this.cdnClient.fetchPackage(
      installPackageWithNameAndVersion,
      _____packageVersion,
    );
    fetchedPackage.then((writeProgressEvent) => {
      this.dispatchEvent(
        new isWritableStateValid("progress", {
          data: {
            name: installPackageWithNameAndVersion,
            version: _____packageVersion,
            totalPending: this.totalPending,
          },
        }),
      );
      this.store.writeDependency(writeProgressEvent);
    });
    this.equeueRequest(
      installPackageWithNameAndVersion,
      _____packageVersion,
      fetchedPackage,
    );
    return fetchedPackage;
  }
  shouldInstallPackage(packageNeedsInstallation, shouldInstallPackageCheck) {
    return (
      !this.hasInstalledPackage(
        packageNeedsInstallation,
        shouldInstallPackageCheck,
      ) &&
      !this.hasPendingPackage(
        packageNeedsInstallation,
        shouldInstallPackageCheck,
      )
    );
  }
  hasInstalledPackage(____packageId, checkPackageInstallationStatus) {
    return (
      this.store.findPackage(____packageId, checkPackageInstallationStatus) !=
      null
    );
  }
  hasPendingPackage(hasPendingPackage, isPackagePending) {
    let pendingRequestEntries = this.pendingRequests.get(hasPendingPackage);
    if (pendingRequestEntries) {
      for (let [pendingRequestEntry] of pendingRequestEntries) {
        if (
          getValidSemverRangeListeners.default.satisfies(
            pendingRequestEntry,
            isPackagePending,
          )
        ) {
          return true;
        }
      }
    }
    return false;
  }
  equeueRequest(enqueueRequest, requestId, requestPromise) {
    requestPromise.finally(() => {
      this.pendingRequests.get(enqueueRequest)?.delete(requestId);
      if (this.pendingRequests.get(enqueueRequest)?.size === 0) {
        this.pendingRequests.delete(enqueueRequest);
      }
    });
    let pendingRequestMap = this.pendingRequests.get(enqueueRequest);
    if (!pendingRequestMap) {
      this.pendingRequests.set(
        enqueueRequest,
        new Map([[requestId, requestPromise]]),
      );
      return;
    }
    pendingRequestMap.set(requestId, requestPromise);
  }
  async installAllPackages(packageFilePath) {
    let pendingRequestsPromise = Promise.all(this.pendingRequests.values());
    let parsedPackageJson = JSON.parse(
      this.fs.readFileAsString(packageFilePath),
    );
    let parsedPackages = compareNpmPackageDependencies(parsedPackageJson);
    let groupedNpmPackagesToInstall = Object.entries(
      parsedPackages.npmPackages,
    ).reduce(
      (processPackageDependencies, [_isValidInput, validateUserInput]) => {
        for (let ___packageName of validateUserInput) {
          if (this.shouldInstallPackage(_isValidInput, ___packageName)) {
            if (processPackageDependencies[_isValidInput]) {
              processPackageDependencies[_isValidInput] += "," + ___packageName;
            } else {
              processPackageDependencies[_isValidInput] = ___packageName;
            }
          }
        }
        return processPackageDependencies;
      },
      {},
    );
    let fetchedDependencies =
      (await this.cdnClient.fetchDependencies(
        Object.entries(groupedNpmPackagesToInstall),
      )) || {};
    let resolvedPackages = filterUniqueEncodingFormats(fetchedDependencies);
    let installationPromises = Promise.all(
      resolvedPackages.map((packageInfo) =>
        this.installPackage(packageInfo.name, packageInfo.version),
      ),
    );
    await Promise.all([pendingRequestsPromise, installationPromises]);
    for (let [dependencyEntry, dependencyValue] of Object.entries(
      fetchedDependencies,
    )) {
      let [parsedDependencyValueAndStatus, statusAndValueArray] =
        parseHandleError(dependencyEntry);
      if (
        !(statusAndValueArray[0] >= "0") ||
        !(statusAndValueArray[0] <= "9")
      ) {
        this.store.writePackageTag(
          parsedDependencyValueAndStatus,
          dependencyValue,
          statusAndValueArray,
        );
      }
    }
    this.store.symlinkStoreDependencies();
    this.store.symlinkRootDependencies(parsedPackageJson);
  }
};
var _readableState = class {
  constructor(fileSystem, patientData = {}) {
    this.fs = fileSystem;
    this.options = patientData;
    this.npmrc = this.parseNpmrcFile();
    this.shouldHoistPackage = this.createHoistPackageMatcher(
      this.npmrc,
      this.options,
    );
    this.fs.mkdir(removeLastPathSegment(_readableState.STORE_PATH), {
      recursive: true,
    });
  }
  npmrc = null;
  packages = new Map();
  shouldHoistPackage;
  parseNpmrcFile() {
    let npmrcFilePath = joinPaths(isAbortSignalHandled, ".npmrc");
    if (!this.fs.exists(npmrcFilePath)) {
      return null;
    }
    try {
      return processErrorHandling(this.fs.readFileAsString(npmrcFilePath));
    } catch (___error) {
      console.warn('[PackageManager] Failed to parse ".npmrc" file:', ___error);
      return null;
    }
  }
  createHoistPackageMatcher(
    createHoistPackageMatcher,
    existingHoistPackageMatcher,
  ) {
    let combinedPublicHoistPatterns =
      createHoistPackageMatcher?.publicHoistPattern || [];
    let existingHoistPublicPatterns =
      existingHoistPackageMatcher.publicHoistPattern || [];
    let combinedHoistPatterns = [
      ...combinedPublicHoistPatterns,
      ...existingHoistPublicPatterns,
    ];
    return (0, validateAndFetchEventListeners.createMatcher)(
      combinedHoistPatterns,
    );
  }
  getPackageId(getPackageIdentifier, _________packageVersion) {
    return getPackageIdentifier + "@" + _________packageVersion;
  }
  buildPackageActualPath(buildPackagePath, nodeModulesPath) {
    return joinPaths(nodeModulesPath, "node_modules", buildPackagePath);
  }
  getPackageRootPath(
    getPackageRootPathPackageNameVersion,
    getPackageVersionInstallationPath,
  ) {
    let retrievedPackage = this.packages.get(
      getPackageRootPathPackageNameVersion,
    );
    isWritableStateError(
      retrievedPackage,
      'Failed to get store root path for package "%s@%s": package is not installed',
      getPackageRootPathPackageNameVersion,
      getPackageVersionInstallationPath,
      this.packages,
    );
    let retrievedPackageVersion = retrievedPackage.findVersion(
      getPackageVersionInstallationPath,
    );
    isWritableStateError(
      retrievedPackageVersion,
      'Failed to resolve installation path for "%s@%s": no installation found for this version',
      getPackageRootPathPackageNameVersion,
      getPackageVersionInstallationPath,
    );
    return retrievedPackageVersion;
  }
  getPackageActualPath(getPackageActualPath, getPackagePathUsingId) {
    let packageRootPath = this.getPackageRootPath(
      getPackageActualPath,
      getPackagePathUsingId,
    );
    return this.buildPackageActualPath(getPackageActualPath, packageRootPath);
  }
  findPackage(findPackageById, ___packageId) {
    try {
      return this.getPackageRootPath(findPackageById, ___packageId);
    } catch {
      return null;
    }
  }
  readPackageJson(packageNameAndVersion, ______packageVersion) {
    let packageJsonPath = this.getPackageActualPath(
      packageNameAndVersion,
      ______packageVersion,
    );
    let packageJsonFilePath = joinPaths(packageJsonPath, "package.json");
    isWritableStateError(
      this.fs.exists(packageJsonFilePath),
      'Failed to read "package.json" for "%s@%s": package is not installed',
      packageNameAndVersion,
      ______packageVersion,
    );
    return JSON.parse(this.fs.readFileAsString(packageJsonFilePath));
  }
  addFileToSourceInspector(
    addFileToSourceInspectorFileNameSourceComment,
    userInputString = "",
  ) {
    (0, eval)(
      "//\n// " +
        userInputString +
        "\n//\n\n//# sourceURL=nodebox://" +
        addFileToSourceInspectorFileNameSourceComment,
    );
  }
  symlink(createSymlink, targetSymlinkPath) {
    if (this.fs.exists(targetSymlinkPath)) {
      console.warn(
        'Skipping a symlink from "%s" to "%s": target already exists',
        createSymlink,
        targetSymlinkPath,
      );
      return;
    }
    isWritableStateError(
      this.fs.exists(createSymlink),
      '[PackageStore]: Failed to symlink "%s" from "%s": the source does not exist',
      targetSymlinkPath,
      createSymlink,
    );
    this.fs.mkdir(removeLastPathSegment(targetSymlinkPath), {
      recursive: true,
    });
    this.fs.symlink(createSymlink, targetSymlinkPath);
    this.addFileToSourceInspector(
      targetSymlinkPath,
      targetSymlinkPath + " --> " + createSymlink,
    );
  }
  writeDependency(writeDependency) {
    let _packageId = this.getPackageId(
      writeDependency.name,
      writeDependency.version,
    );
    let shouldHoistDependency = this.shouldHoistPackage(writeDependency.name);
    let dependencyStorePath = joinPaths(_readableState.STORE_PATH, _packageId);
    isWritableStateError(
      !this.fs.exists(dependencyStorePath),
      'Failed to write "%s" to the store at "%s": package already exists',
      _packageId,
      dependencyStorePath,
    );
    let dependencyWritePath = joinPaths(
      _readableState.STORE_PATH,
      _packageId,
      "node_modules",
      writeDependency.name,
    );
    for (let _fileName in writeDependency.files) {
      let _fileContent = writeDependency.files[_fileName];
      let ___filePath = joinPaths(dependencyWritePath, _fileName);
      this.fs.mkdir(removeLastPathSegment(___filePath), {
        recursive: true,
      });
      this.fs.writeFileSync(___filePath, _fileContent);
    }
    this.registerPackage(writeDependency, dependencyStorePath);
    let hoistedDependencyPath = this.shouldHoistPackage(writeDependency.name)
      ? joinPaths(isAbortSignalHandled, "node_modules/.bin")
      : joinPaths(dependencyWritePath, "node_modules", ".bin");
    this.symlinkBinaries(
      writeDependency.name,
      writeDependency.version,
      hoistedDependencyPath,
    );
    if (shouldHoistDependency) {
      let _dependencyWritePath = joinPaths(
        isAbortSignalHandled,
        "node_modules",
        writeDependency.name,
      );
      this.symlink(dependencyWritePath, _dependencyWritePath);
    }
    return dependencyStorePath;
  }
  registerPackage(registerPackageWithVersion, packageMetadata) {
    let existingPackage = this.packages.get(registerPackageWithVersion.name);
    if (existingPackage) {
      existingPackage.addVersion(
        registerPackageWithVersion.version,
        packageMetadata,
      );
      return;
    }
    this.packages.set(
      registerPackageWithVersion.name,
      new isUint8Array(registerPackageWithVersion.name).addVersion(
        registerPackageWithVersion.version,
        packageMetadata,
      ),
    );
  }
  getBinaries(getBinariesFromPackage, _packagePath) {
    let packageId = this.getPackageId(getBinariesFromPackage, _packagePath);
    let packageActualPath = this.getPackageActualPath(
      getBinariesFromPackage,
      _packagePath,
    );
    let _packageJsonData = this.readPackageJson(
      getBinariesFromPackage,
      _packagePath,
    );
    let resolvedBinaries = processEncodedStringHandler(
      getBinariesFromPackage,
      _packageJsonData.bin,
    );
    let resolvedBinaryPaths = new Map();
    for (let [_binaryName, binaryPath] of Object.entries(
      resolvedBinaries || {},
    )) {
      let resolvedBinaryPath = this.resolveBinaryPath(
        getBinariesFromPackage,
        _packagePath,
        binaryPath,
      );
      isWritableStateError(
        resolvedBinaryPath,
        'Failed to resolve "%s" binary for package "%s@%s" from "%s": no binary present at the path',
        _binaryName,
        getBinariesFromPackage,
        _packagePath,
        binaryPath,
      );
      resolvedBinaryPaths.set(_binaryName, resolvedBinaryPath);
    }
    let binaryDirectoryPath = _packageJsonData.directories?.bin;
    if (binaryDirectoryPath) {
      let resolvedBinariesDirectory = joinPaths(
        packageActualPath,
        binaryDirectoryPath,
      );
      isWritableStateError(
        this.fs.exists(resolvedBinariesDirectory),
        'Failed to resolve binaries for package "%s@%s using a custom "directories.bin" (%s): directory does not exist',
        packageId,
        resolvedBinariesDirectory,
      );
      let resolvedBinaryFiles = this.fs.readdir(resolvedBinariesDirectory);
      for (let resolvedBinaryFile of resolvedBinaryFiles) {
        if (typeof resolvedBinaryFile == "string") {
          let __resolvedBinaryPath = joinPaths(
            resolvedBinariesDirectory,
            resolvedBinaryFile,
          );
          resolvedBinaryPaths.set(resolvedBinaryFile, __resolvedBinaryPath);
        }
      }
    }
    return resolvedBinaryPaths;
  }
  symlinkStoreDependencies() {
    for (let [packageAndVersions, packageVersion] of this.packages) {
      for (let [
        packageVersionEntry,
        _packageVersionEntry,
      ] of packageVersion.versions) {
        let packagePath = this.getPackageActualPath(
          packageAndVersions,
          packageVersionEntry,
        );
        let packageJsonData = this.readPackageJson(
          packageAndVersions,
          packageVersionEntry,
        );
        let resolvedDependencies = compareNpmPackageVersions(
          packageJsonData.dependencies,
        );
        for (let [
          dependency,
          dependencyDetails,
        ] of transformErrorListenerToPackageInfo(resolvedDependencies)) {
          let actualPackagePath = this.getPackageActualPath(
            dependencyDetails.name,
            dependencyDetails.range,
          );
          let dependencySymlinkPath = joinPaths(
            _packageVersionEntry,
            "node_modules",
            dependency,
          );
          this.symlink(actualPackagePath, dependencySymlinkPath);
          let dependencyNodeModulesPath = joinPaths(
            _readableState.STORE_PATH,
            "node_modules",
            dependency,
          );
          if (!this.fs.exists(dependencyNodeModulesPath)) {
            this.symlink(actualPackagePath, dependencyNodeModulesPath);
          }
          if (dependencyDetails.name === dependency) {
            this.symlinkBinaries(
              dependencyDetails.name,
              dependencyDetails.range,
              joinPaths(packagePath, "node_modules/.bin"),
            );
          }
        }
        let resolvedPeerDependencies = compareNpmPackageVersions(
          packageJsonData.peerDependencies,
        );
        for (let [
          peerDependencyName,
          peerDependency,
        ] of transformErrorListenerToPackageInfo(resolvedPeerDependencies)) {
          let resolvedPeerDependency = this.findPackage(
            peerDependency.name,
            peerDependency.range,
          );
          if (!resolvedPeerDependency) {
            if (
              !packageJsonData.peerDependenciesMeta?.[peerDependencyName]
                ?.optional
            ) {
              console.warn(
                '[PackageManager] Failed to symlink a non-optional peer dependency of "%s@%s" from "%s@%s": dependency is not installed',
                peerDependencyName,
                peerDependency.name !== peerDependencyName
                  ? peerDependency.name + "@" + peerDependency.range
                  : peerDependency.range,
                packageAndVersions,
                packageVersionEntry,
              );
            }
            continue;
          }
          let peerDependencyActualPath = this.buildPackageActualPath(
            peerDependencyName,
            resolvedPeerDependency,
          );
          let peerDependencySymlinkPath = joinPaths(
            _packageVersionEntry,
            "node_modules",
            peerDependencyName,
          );
          this.symlink(peerDependencyActualPath, peerDependencySymlinkPath);
          if (peerDependency.name !== peerDependencyName) {
            this.symlinkBinaries(
              peerDependency.name,
              peerDependency.range,
              joinPaths(packagePath, "node_modules/.bin"),
            );
          }
        }
      }
    }
  }
  symlinkBinaries(
    symlinkBinariesSourcePackageTargetPackageVersion,
    sourcePackageVersion,
    targetBinaryPath,
  ) {
    let binariesList = this.getBinaries(
      symlinkBinariesSourcePackageTargetPackageVersion,
      sourcePackageVersion,
    );
    for (let [sourceBinary, _sourceBinaryPath] of binariesList) {
      let targetBinaryPathWithSource = joinPaths(
        targetBinaryPath,
        sourceBinary,
      );
      if (this.fs.exists(targetBinaryPathWithSource)) {
        console.warn(
          '[PackageManager] Failed to symlink "%s" ("%s@%s"): target binary already exists at "%s"',
          sourceBinary,
          symlinkBinariesSourcePackageTargetPackageVersion,
          sourcePackageVersion,
          targetBinaryPathWithSource,
        );
        continue;
      }
      this.symlink(_sourceBinaryPath, targetBinaryPathWithSource);
    }
  }
  symlinkRootDependencies(rootDependencySymlinkHandler) {
    let processedDependencies = compareNpmPackageDependencies(
      rootDependencySymlinkHandler,
    );
    let { directNpmPackages: directNpmPackages, npmAliases: npmAliases } =
      processedDependencies;
    for (let [_packageName, __packageVersion] of Object.entries(
      directNpmPackages,
    )) {
      if (this.shouldHoistPackage(_packageName)) {
        continue;
      }
      let _packageActualPath = this.getPackageActualPath(
        _packageName,
        __packageVersion,
      );
      let packageSymlinkPath = joinPaths(
        isAbortSignalHandled,
        "node_modules",
        _packageName,
      );
      this.symlink(_packageActualPath, packageSymlinkPath);
      let binaryMappings = this.getBinaries(_packageName, __packageVersion);
      for (let [binaryName, sourceBinaryPath] of binaryMappings) {
        let binarySymlinkPath = joinPaths(
          isAbortSignalHandled,
          "node_modules",
          ".bin",
          binaryName,
        );
        if (this.fs.exists(binarySymlinkPath)) {
          console.warn(
            '[PackageManager] Failed to symlink root-level "%s" binary for package "%s@%s": target binary already exists at "%s"',
            binaryName,
            _packageName,
            __packageVersion,
            binarySymlinkPath,
          );
          continue;
        }
        this.symlink(sourceBinaryPath, binarySymlinkPath);
      }
    }
    for (let [aliasName, aliasPath] of Object.entries(npmAliases)) {
      let [packageResolvedPath, resolvedPackagePath] =
        parseHandleError(aliasPath);
      let _actualPackagePath = this.getPackageActualPath(
        packageResolvedPath,
        resolvedPackagePath,
      );
      let nodeModulesSymlinkPath = joinPaths(
        isAbortSignalHandled,
        "node_modules",
        aliasName,
      );
      this.symlink(_actualPackagePath, nodeModulesSymlinkPath);
    }
  }
  resolveBinaryPath(resolveAndFindBinaryPath, _binaryPath, __binaryPath) {
    let __packageActualPath = this.getPackageActualPath(
      resolveAndFindBinaryPath,
      _binaryPath,
    );
    let _resolvedBinaryPath = joinPaths(__packageActualPath, __binaryPath);
    return [
      _resolvedBinaryPath,
      _resolvedBinaryPath + ".js",
      _resolvedBinaryPath + ".mjs",
    ].find((fileExists) => this.fs.exists(fileExists));
  }
  writePackageTag(__packageId, versionTag, versionTagToWrite) {
    let packageDetails = this.packages.get(__packageId);
    if (!packageDetails) {
      throw new Error(
        "Failed to write tag " +
          versionTagToWrite +
          " for " +
          __packageId +
          ", package is not installed",
      );
    }
    packageDetails.registerVersionTag(versionTagToWrite, versionTag);
  }
};
var dataBufferUtility = _readableState;
definePropertyIfSymbolExists(
  dataBufferUtility,
  "STORE_PATH",
  joinPaths(isAbortSignalHandled, "node_modules", ".store"),
);
var isUint8Array = class {
  constructor(name) {
    this.name = name;
  }
  versions = new Map();
  tags = new Map();
  addVersion(addVersionForDependency, versionDetails) {
    isWritableStateError(
      !this.versions.has(addVersionForDependency),
      'Failed to register version "%s" for store dependency "%s": already exists',
      addVersionForDependency,
      this.name,
    );
    this.versions.set(addVersionForDependency, versionDetails);
    return this;
  }
  registerVersionTag(registerVersionTagWithVersionAndTag, versionIdentifier) {
    isWritableStateError(
      this.versions.has(versionIdentifier),
      'Failed to register tag "%s" for version "%s" for store dependency "%s": version does not exist',
      registerVersionTagWithVersionAndTag,
      versionIdentifier,
      this.name,
    );
    this.tags.set(registerVersionTagWithVersionAndTag, versionIdentifier);
    return this;
  }
  findVersion(findVersionByTagOrRange) {
    let getVersionByTagOrRange = this.tags.get(findVersionByTagOrRange);
    if (getVersionByTagOrRange) {
      return this.versions.get(getVersionByTagOrRange);
    }
    if (
      findVersionByTagOrRange === "latest" ||
      findVersionByTagOrRange === "*"
    ) {
      let sortedVersionKeys = Array.from(this.versions.keys());
      let _sortedVersionKeys =
        getValidSemverRangeListeners.default.sort(sortedVersionKeys);
      return this.versions.get(_sortedVersionKeys[0]);
    }
    for (let [_semverVersion, matchingVersion] of this.versions) {
      if (
        getValidSemverRangeListeners.default.satisfies(
          _semverVersion,
          findVersionByTagOrRange,
        )
      ) {
        return matchingVersion;
      }
    }
    if (/^\d/.test(findVersionByTagOrRange)) {
      for (let [versionRangeListener, versionRangeListenerCallback] of this
        .versions) {
        if (
          getValidSemverRangeListeners.default.satisfies(
            versionRangeListener,
            "^" + findVersionByTagOrRange,
          )
        ) {
          return versionRangeListenerCallback;
        }
      }
    }
    for (let [version, versionData] of this.versions) {
      let extractedVersionNumber = extractFirstNumber(version);
      let taggedVersionNumber = extractFirstNumber(findVersionByTagOrRange);
      if (extractedVersionNumber === taggedVersionNumber) {
        return versionData;
      }
    }
  }
};
function removeLastPathSegment(normalizePathSegments) {
  let pathSegments = normalizePathSegments.split("/");
  pathSegments.pop();
  return pathSegments.join("/");
}
function processEncodedStringHandler(
  _processEncodedString,
  processStringDecoder,
) {
  if (typeof processStringDecoder !== "undefined") {
    if (typeof processStringDecoder == "string") {
      return {
        [_processEncodedString]: processStringDecoder,
      };
    } else {
      return processStringDecoder;
    }
  }
}
function filterUniqueEncodingFormats(getIsEncodingSupported) {
  let uniqueEncodingSet = new Set();
  return Object.entries(getIsEncodingSupported)
    .map(([userInput, userInputProcessor]) => {
      let [parsedErrorHandle, errorHandle] = parseHandleError(userInput);
      return {
        name: parsedErrorHandle,
        version: userInputProcessor,
      };
    })
    .filter((checkAndAddUniqueEncoding) => {
      let uniqueEncodingIdentifier =
        checkAndAddUniqueEncoding.name +
        "@" +
        checkAndAddUniqueEncoding.version;
      if (uniqueEncodingSet.has(uniqueEncodingIdentifier)) {
        return false;
      } else {
        uniqueEncodingSet.add(uniqueEncodingIdentifier);
        return true;
      }
    });
}
function extractFirstNumber(___processEncodedData) {
  let [firstNumber] = ___processEncodedData.match(/\d/) || [];
  let extractedFirstNumber = Number(firstNumber);
  if (isNaN(extractedFirstNumber)) {
    return undefined;
  } else {
    return extractedFirstNumber;
  }
}
var __processBufferedData =
  writeChunkCallback.COPYFILE_EXCL |
  writeChunkCallback.COPYFILE_FICLONE |
  writeChunkCallback.COPYFILE_FICLONE_FORCE;
var isPathAbsolute = joinPaths(isAbortSignalHandled, "package.json");
var validateEncodedData = class {
  core = new isInitializedObject();
  isMain = false;
  _cdnUrl = undefined;
  packageManager = new transformResult(this);
  isInstallingDependencies = Promise.resolve();
  get cdnUrl() {
    return this._cdnUrl;
  }
  set cdnUrl(setCdnUrl) {
    this._cdnUrl = setCdnUrl;
    this.packageManager.cdnUrl = this._cdnUrl;
  }
  readFileAsString(____filePath) {
    let __fileContent = this.readFileSync(____filePath);
    return ____validateAndRetrieveIntrinsicProperties
      .from(__fileContent)
      .toString("utf-8");
  }
  writeFileSync(writeFileToDirectory, dataToWrite) {
    let currentDirectoryPath = getResolvedPathSegments(writeFileToDirectory);
    let fileName = currentDirectoryPath.pop();
    if (!fileName) {
      throw new streamConfiguration("open", writeFileToDirectory);
    }
    let __directoryNode = this.core.getDirNodeAtPath(currentDirectoryPath);
    let fileHandle = __directoryNode.getChild(fileName);
    if (fileHandle) {
      if (fileHandle instanceof handleWritableState) {
        fileHandle.write(dataToWrite);
      } else {
        throw new initializeStreamProcessor("open", writeFileToDirectory);
      }
    } else {
      let writableFileState = new handleWritableState(
        fileName,
        dataToWrite,
        __directoryNode,
        this.core,
      );
      __directoryNode.addChild(writableFileState);
    }
  }
  async installDependencies() {
    this.isInstallingDependencies =
      this.packageManager.installAllPackages(isPathAbsolute);
    return this.isInstallingDependencies;
  }
  waitForIdleDependencies() {
    return this.isInstallingDependencies;
  }
  readFileSync(filePath) {
    let resolvedFilePath = getResolvedPathSegments(filePath);
    let resolvedNode = this.core.getNodeAtPath(resolvedFilePath, filePath);
    if (!resolvedNode) {
      throw new streamConfiguration("open", filePath);
    }
    if (resolvedNode instanceof handleWritableState) {
      return resolvedNode.content;
    }
    if (resolvedNode instanceof initializeVersionComparisonHandler) {
      let _resolvedFilePath = this.realpath(filePath);
      return this.readFileSync(_resolvedFilePath);
    } else {
      throw new initializeStreamProcessor("open", filePath);
    }
  }
  mkdir(createDirectory, functionConfig = {}) {
    let { recursive: isRecursive } = functionConfig || {};
    let currentDirectory = this.core.root;
    let resolvedDirectories = getResolvedPathSegments(createDirectory);
    if (
      !resolvedDirectories.length ||
      (resolvedDirectories.length === 1 && resolvedDirectories[0] === "")
    ) {
      if (isRecursive) {
        return;
      }
      throw new initializeStreamProcessor("mkdir", createDirectory);
    }
    for (
      let currentDirectoryIndex = 0;
      currentDirectoryIndex < resolvedDirectories.length;
      currentDirectoryIndex++
    ) {
      let resolvedDirectory = resolvedDirectories[currentDirectoryIndex];
      let childDirectory = currentDirectory.getChild(resolvedDirectory);
      let isLastResolvedDirectory =
        currentDirectoryIndex === resolvedDirectories.length - 1;
      if (childDirectory) {
        if (childDirectory instanceof getWritableStateProperties) {
          if (isLastResolvedDirectory) {
            if (isRecursive) {
              continue;
            }
            throw new isValidData("mkdir", createDirectory);
          }
          currentDirectory = childDirectory;
        } else if (
          childDirectory instanceof initializeVersionComparisonHandler &&
          !isLastResolvedDirectory
        ) {
          let resolvedChildDirectory = this.core.resolveSymlink(childDirectory);
          if (resolvedChildDirectory instanceof getWritableStateProperties) {
            currentDirectory = resolvedChildDirectory;
          } else {
            throw new isValidData("mkdir", createDirectory);
          }
        } else {
          throw new isValidData("mkdir", createDirectory);
        }
      } else {
        if (!isRecursive && !isLastResolvedDirectory) {
          throw new streamConfiguration("mkdir", createDirectory);
        }
        {
          let ___writableStateProperties = new getWritableStateProperties(
            resolvedDirectory,
            currentDirectory,
            this.core,
          );
          currentDirectory.addChild(___writableStateProperties);
          currentDirectory = ___writableStateProperties;
        }
      }
    }
  }
  rmdir(removeDirectory, _userPreferences = {}) {
    let resolvedPathSegments = getResolvedPathSegments(removeDirectory);
    let directoryName = resolvedPathSegments.pop();
    if (!directoryName) {
      throw new streamConfiguration("rmdir", removeDirectory);
    }
    let parentDirectoryNode = this.core.getDirNodeAtPath(resolvedPathSegments);
    let _directoryNode = parentDirectoryNode.getChild(directoryName);
    if (!_directoryNode) {
      throw new streamConfiguration("rmdir", removeDirectory);
    }
    if (_directoryNode instanceof getWritableStateProperties) {
      if (!_userPreferences.recursive && _directoryNode.children.size > 0) {
        throw new getMatchingIndexWithAsyncGenerator("rmdir", removeDirectory);
      }
      parentDirectoryNode.removeChild(directoryName);
    } else {
      throw new __initializeReaderAndEmitEvent("rmdir", removeDirectory);
    }
  }
  readdir(readDirectory, userSettings = {}) {
    let { withFileTypes: includeFileTypes = false } = userSettings || {};
    let resolvedDirectoryPath = getResolvedPathSegments(readDirectory);
    let ____directoryNode = this.core.getDirNodeAtPath(resolvedDirectoryPath);
    if (includeFileTypes) {
      return Array.from(____directoryNode.children.values()).map(
        (getCharacterProfile) => ({
          name: getCharacterProfile.name,
          type: getCharacterProfile.stats.type,
        }),
      );
    } else {
      return Array.from(____directoryNode.children.keys());
    }
  }
  unlink(unlinkResource) {
    let unlinkResourceInfo = getResolvedPathSegments(unlinkResource);
    let unlinkResourceId = unlinkResourceInfo.pop();
    if (!unlinkResourceId) {
      throw new streamConfiguration("open", unlinkResource);
    }
    let _targetDirectoryNode = this.core.getDirNodeAtPath(unlinkResourceInfo);
    let targetResource = _targetDirectoryNode.getChild(unlinkResourceId);
    if (!targetResource) {
      throw new streamConfiguration("unlink", unlinkResource);
    }
    if (targetResource instanceof getWritableStateProperties) {
      throw new initializeStreamProcessor("unlink", unlinkResource);
    }
    _targetDirectoryNode.removeChild(unlinkResourceId);
  }
  rename(sourceNodeId, targetNodeId) {
    this.core.moveNode(sourceNodeId, targetNodeId);
  }
  stat(getNodeStatistics) {
    let nodeStatistics = getResolvedPathSegments(getNodeStatistics);
    let targetNode = this.core.getNodeAtPath(nodeStatistics, getNodeStatistics);
    let retryCount = 0;
    while (targetNode instanceof initializeVersionComparisonHandler) {
      if (retryCount > 10) {
        throw new streamConfiguration("open", getNodeStatistics);
      }
      targetNode = this.core.getNodeAtPath(
        getResolvedPathSegments(targetNode.target),
        targetNode.target,
      );
      retryCount++;
    }
    return targetNode.stats;
  }
  lstat(getNodeStatsAtPath) {
    let nodeStats = getResolvedPathSegments(getNodeStatsAtPath);
    return this.core.getNodeAtPath(nodeStats, getNodeStatsAtPath).stats;
  }
  symlink(createSymbolicLink, targetPath) {
    let resolveAndSymlink = getResolvedPathSegments(createSymbolicLink);
    let _sourceNode = this.core.getNodeAtPath(
      resolveAndSymlink,
      createSymbolicLink,
    );
    let resolvedTargetPath = getResolvedPathSegments(targetPath);
    let targetLinkName = resolvedTargetPath.pop();
    if (!targetLinkName) {
      throw new streamConfiguration("symlink", targetPath);
    }
    let targetDirectoryNode = this.core.getDirNodeAtPath(resolvedTargetPath);
    if (!targetDirectoryNode) {
      throw new streamConfiguration("symlink", targetPath);
    }
    if (targetDirectoryNode.getChild(targetLinkName)) {
      throw new isValidData("symlink", targetPath);
    }
    let ____versionComparisonHandler = new initializeVersionComparisonHandler(
      targetLinkName,
      _sourceNode.getPath(),
      targetDirectoryNode,
    );
    targetDirectoryNode.addChild(____versionComparisonHandler);
  }
  realpath(getRealPathFromNode) {
    let _resolvedPath = getResolvedPathSegments(getRealPathFromNode);
    let _resolvedNode = this.core.getNodeAtPath(
      _resolvedPath,
      getRealPathFromNode,
    );
    if (!_resolvedNode) {
      throw new streamConfiguration("realpath", getRealPathFromNode);
    }
    return (
      _resolvedNode instanceof initializeVersionComparisonHandler
        ? this.core.resolveSymlink(_resolvedNode)
        : _resolvedNode
    ).getPath();
  }
  readlink(resolveLink) {
    let resolvedLink = getResolvedPathSegments(resolveLink);
    let __resolvedNode = this.core.getNodeAtPath(resolvedLink, resolveLink);
    if (__resolvedNode instanceof initializeVersionComparisonHandler) {
      return __resolvedNode.target;
    }
    throw new signalHandler("readlink", resolveLink);
  }
  access(accessNodeAtPath) {
    let __resolvedPathSegments = getResolvedPathSegments(accessNodeAtPath);
    this.core.getNodeAtPath(__resolvedPathSegments, accessNodeAtPath);
  }
  copyFile(sourcePath, destinationPath, __initialValue = 0) {
    if (!(__initialValue < 0)) {
      __initialValue > __processBufferedData;
    }
    let isExclusiveCopy =
      (__initialValue & writeChunkCallback.COPYFILE_EXCL) ===
      writeChunkCallback.COPYFILE_EXCL;
    let sourceFileData = getResolvedPathSegments(sourcePath);
    let sourceNode = this.core.getNodeAtPath(sourceFileData, sourcePath);
    if (!(sourceNode instanceof handleWritableState)) {
      throw new processChunk("copyfile", sourcePath);
    }
    let destinationFilePath = getResolvedPathSegments(destinationPath);
    let destinationFileName = destinationFilePath.pop();
    if (!destinationFileName) {
      throw new streamConfiguration("copyfile", destinationPath);
    }
    let destinationDirectoryNode =
      this.core.getDirNodeAtPath(destinationFilePath);
    if (destinationDirectoryNode.getChild(destinationFileName)) {
      if (isExclusiveCopy) {
        throw new isValidData("copyfile", destinationPath);
      }
      destinationDirectoryNode.removeChild(destinationFileName);
    }
    let destinationFileHandle = new handleWritableState(
      destinationFileName,
      new Uint8Array(sourceNode.content),
      destinationDirectoryNode,
      this.core,
    );
    destinationDirectoryNode.addChild(destinationFileHandle);
  }
  exists(checkStatisticsExists) {
    try {
      this.stat(checkStatisticsExists);
      return true;
    } catch {
      return false;
    }
  }
};
var incrementOrReset = new validateEncodedData();
var incrementAndGetPreviousValue = _getReadableState();
incrementAndGetPreviousValue.onMessage((routerBroadcastEvent) => {
  if (
    routerBroadcastEvent.$type === "router-broadcast" &&
    routerBroadcastEvent.$origin !== ____handleVersionComparison &&
    routerBroadcastEvent.$data.type === "fs-sync"
  ) {
    incrementOrReset.core.handleSyncEvent(routerBroadcastEvent.$data.event);
  }
});
incrementOrReset.core.onFSEvent((syncEventDetails) => {
  if (!syncEventDetails.isSync) {
    incrementAndGetPreviousValue.broadcast({
      type: "fs-sync",
      event: syncEventDetails,
    });
  }
});
var generateSlug = class extends Worker {
  isTerminated;
  constructor(...constructorArgs) {
    super(...constructorArgs);
    this.isTerminated = false;
    this.addEventListener("error", (handleMessageClosure) => {
      if (
        handleMessageClosure.message &&
        handleMessageClosure.message.endsWith("closing")
      ) {
        handleMessageClosure.stopImmediatePropagation();
        handleMessageClosure.preventDefault();
        Object.defineProperty(this, "terminated", {
          value: true,
        });
      }
    });
  }
  terminate() {
    this.isTerminated = true;
    super.terminate();
  }
};
async function _processSlugGeneration() {
  let slugGenerator = new generateSlug(compareAndParseFloat(), {
    eval: true,
  });
  let deferredSlugGenerationPromise =
    new initializeReaderAndWritableStream.DeferredPromise();
  let handleSlugGenerationMessage = (handleDataResponse) => {
    let dataResponse = handleDataResponse.data;
    if (dataResponse.$type === "loaded") {
      deferredSlugGenerationPromise.resolve([
        slugGenerator,
        dataResponse.$data.id,
      ]);
    } else if (dataResponse.$type === "init:failed") {
      deferredSlugGenerationPromise.reject(
        initializeReaderAndEmitEventHandler(dataResponse.$data.error),
      );
    }
  };
  let handleSlugGenerationError = (_handleSlugGenerationError) => {
    deferredSlugGenerationPromise.reject(_handleSlugGenerationError.error);
  };
  slugGenerator.addEventListener("message", handleSlugGenerationMessage);
  slugGenerator.addEventListener("error", handleSlugGenerationError);
  return deferredSlugGenerationPromise.finally(() => {
    slugGenerator.removeEventListener("message", handleSlugGenerationMessage);
    slugGenerator.removeEventListener("error", handleSlugGenerationError);
  });
}
async function initializeDeferredPromise(
  createDeferredPromiseExecutor,
  createDeferredExecutor,
) {
  let deferredPromise = new initializeReaderAndWritableStream.DeferredPromise();
  initializeFileTreeAndPostMessage(
    createDeferredPromiseExecutor,
    createDeferredExecutor.port2,
    {
      isMainThread: true,
    },
  );
  let __handleMessageEvent = (handleReadyState) => {
    if (handleReadyState.data.$type === "ready") {
      deferredPromise.resolve();
    }
  };
  createDeferredExecutor.port1.addEventListener(
    "message",
    __handleMessageEvent,
  );
  createDeferredExecutor.port1.start();
  return deferredPromise.finally(() => {
    createDeferredExecutor.port1.removeEventListener(
      "message",
      __handleMessageEvent,
    );
  });
}
function initializeFileTreeAndPostMessage(
  _createDeferredExecutor,
  __createDeferredExecutor,
  _userSettings = {},
) {
  let initializationMessage = {
    $type: "init",
    $data: {
      ..._userSettings,
      fileTree: incrementOrReset.core.serialize(),
    },
  };
  _createDeferredExecutor.postMessage(initializationMessage, [
    __createDeferredExecutor,
  ]);
}
var ___createDeferredExecutor = processAndEmitEventHandler("runtime:worker");
var createDeferredPromise = class {
  constructor(previewElement) {
    this.preview = previewElement;
    this.handleMessage = this.handleMessage.bind(this);
    this.#r.port1.addEventListener("message", this.handleMessage);
  }
  emitter = new isStreamWritable();
  #e;
  #t = null;
  #a = _processSlugGeneration();
  #s = null;
  #l = false;
  #r = new MessageChannel();
  #n = new Map();
  #i = new Map();
  #o(__isUserLoggedIn = false) {
    if (this.#t) {
      this.#t?.terminate();
      this.#u();
    } else {
      this.#a.then(() => this.#o());
    }
  }
  #u() {
    for (let itemToTerminate of this.#n.values()) {
      itemToTerminate.terminate();
    }
    for (let promiseToTerminate of this.#i.values()) {
      promiseToTerminate.then((_terminateProcess) =>
        _terminateProcess.terminate(),
      );
    }
  }
  sendInput(inputData) {
    this.#r.port1.postMessage({
      $type: "tty:out",
      $data: {
        fd: 0,
        data: inputData,
      },
    });
  }
  handleMessage(handleWorkerMessage) {
    let { data: workerMessageData } = handleWorkerMessage;
    switch (workerMessageData.$type) {
      case "started": {
        this.emitter.dispatchEvent(
          new isWritableStateValid("worker/started", {}),
        );
        return;
      }
      case "run:failed": {
        this.emitter.dispatchEvent(
          new isWritableStateValid("worker/error", {
            data: workerMessageData.$data,
          }),
        );
        this.#o();
        return;
      }
      case "exit": {
        this.emitter.dispatchEvent(
          new isWritableStateValid("worker/exit", {
            data: workerMessageData.$data,
          }),
        );
        this.#o();
        return;
      }
      case "tty:out": {
        let workerMessage = workerMessageData.$data;
        if (workerMessage.fd === 0) {
          break;
        }
        let messageType = workerMessage.fd === 1 ? "out" : "err";
        let _validatedIntrinsicProperties =
          ____validateAndRetrieveIntrinsicProperties
            .from(workerMessage.data)
            .toString("utf-8");
        this.emitter.dispatchEvent(
          new isWritableStateValid("worker/tty:out", {
            data: {
              payload: {
                data: _validatedIntrinsicProperties,
                type: messageType,
              },
            },
          }),
        );
        return;
      }
    }
  }
  stop() {
    if (this.#e) {
      let port = this.preview.getPortFromShellId(this.#e);
      if (port) {
        this.preview.closePort(port);
      }
    }
    this.#o(true);
    this.#r.port1.removeEventListener("message", this.handleMessage);
    this.#r.port1.close();
  }
  #c(webWorkerMessageHandler) {
    webWorkerMessageHandler.addEventListener(
      "message",
      (handleChildProcessMessage) => {
        let childProcessMessage = handleChildProcessMessage.data;
        switch (childProcessMessage.$type) {
          case "child:spawn": {
            console.warn("child:spawn called", childProcessMessage);
            let childProcessId = childProcessMessage.$data.id;
            let childProcessPromise = _processSlugGeneration()
              .then(([userPreferences, saveUserPreferences]) => {
                this.#n.set(childProcessId, userPreferences);
                this.#i.delete(childProcessId);
                this.#c(userPreferences);
                initializeFileTreeAndPostMessage(
                  userPreferences,
                  handleChildProcessMessage.ports[0],
                  {
                    isMainThread: false,
                    environmentData: childProcessMessage.$data.environmentData,
                    globals: {
                      ...(childProcessMessage.$data.globals || {}),
                    },
                  },
                );
                return userPreferences;
              })
              .catch((handleChildProcessDeletion) => {
                this.#i.delete(childProcessId);
                throw handleChildProcessDeletion;
              });
            childProcessPromise.catch(console.error);
            this.#i.set(childProcessId, childProcessPromise);
            break;
          }
          case "child:kill": {
            let _childProcessId = childProcessMessage.$data.id;
            let childProcessHandler = this.#n.get(_childProcessId);
            if (childProcessHandler) {
              childProcessHandler.terminate();
              this.#n.delete(_childProcessId);
            }
            break;
          }
        }
      },
    );
  }
  async _init() {
    let [initData, workerInitializationData] = await this.#a;
    this.#t = initData;
    this.#e = workerInitializationData;
    if (typeof window === "undefined") {
      console.error(
        "Tried to start a node worker from outside the main thread.",
      );
    } else {
      this.#c(initData);
    }
    _getReadableState().addEndpoint(
      "node-worker-" + (0, _initializeReaderAndEmitEvent.default)(),
      {
        send: (sendMessage, __messageData) =>
          this.#r.port1.postMessage(sendMessage, __messageData),
        onMessage: (handlePortMessage) => {
          this.#r.port1.addEventListener("message", (portMessageData) => {
            handlePortMessage(portMessageData.data);
          });
        },
      },
    );
    await initializeDeferredPromise(initData, this.#r).catch(
      (initializeNodeWorkerError) => {
        let errorInitializingNodeWorker = new Error(
          "Initializing node worker failed",
        );
        errorInitializingNodeWorker.cause = initializeNodeWorkerError;
        throw errorInitializingNodeWorker;
      },
    );
    this.#l = true;
    return workerInitializationData;
  }
  init() {
    if (this.#t?.isTerminated) {
      return Promise.reject(new Error("Worker has been terminated"));
    } else {
      this.#s ||= this._init();
      return this.#s;
    }
  }
  runCommand(commandData) {
    if (!this.#l) {
      throw new Error("Worker has not finished initialising");
    }
    this.#r.port1.postMessage({
      $type: "run",
      $data: commandData,
    });
  }
};
function createRegexFromWildcard(_calculateRemainingValue) {
  return new RegExp(_calculateRemainingValue.replace(/\*+/g, ".*"));
}
var EventListenerManager = class {
  _isClosed = false;
  _disposables = [];
  eventEmitter = new _____evaluateVersionOperators();
  onChange = this.eventEmitter.event;
  constructor(filePathHandler, filePathValidations) {
    let mappedFilePathHandlers = filePathHandler.map(
      (_createRegexFromWildcard) =>
        createRegexFromWildcard(_createRegexFromWildcard),
    );
    let validateFilePathAgainstValidations = filePathValidations.map(
      (__createRegexFromWildcard) =>
        createRegexFromWildcard(__createRegexFromWildcard),
    );
    let isFilePathValid = (filePathValidation) => {
      for (let validationRule of validateFilePathAgainstValidations) {
        if (validationRule.test(filePathValidation)) {
          return false;
        }
      }
      for (let _filePathHandler of mappedFilePathHandlers) {
        if (_filePathHandler.test(filePathValidation)) {
          return true;
        }
      }
    };
    let handleFileSystemEvent = incrementOrReset.core.onFSEvent(
      (fileOperationEvent) => {
        if (!this._isClosed) {
          switch (fileOperationEvent.type) {
            case "create": {
              let newFilePath = combinePaths(
                fileOperationEvent.parent,
                fileOperationEvent.newNode.name,
              );
              if (isFilePathValid(newFilePath)) {
                this.eventEmitter.fire({
                  type: "create",
                  path: newFilePath,
                });
              }
              break;
            }
            case "remove": {
              let _filePath = combinePaths(
                fileOperationEvent.parent,
                fileOperationEvent.name,
              );
              if (isFilePathValid(_filePath)) {
                this.eventEmitter.fire({
                  type: "remove",
                  path: _filePath,
                });
              }
              break;
            }
            case "write": {
              if (isFilePathValid(fileOperationEvent.path)) {
                this.eventEmitter.fire({
                  type: "change",
                  path: fileOperationEvent.path,
                });
              }
              break;
            }
            case "move": {
              if (isFilePathValid(fileOperationEvent.newPath)) {
                this.eventEmitter.fire({
                  type: "rename",
                  oldPath: fileOperationEvent.oldPath,
                  newPath: fileOperationEvent.newPath,
                });
              }
              break;
            }
          }
        }
      },
    );
    this._disposables.push(handleFileSystemEvent);
  }
  close() {
    this._isClosed = true;
    for (let disposableItem of this._disposables) {
      try {
        disposableItem.dispose();
      } catch (__________error) {
        console.warn(__________error);
      }
    }
    this.eventEmitter.fire({
      type: "close",
    });
    this.eventEmitter.dispose();
  }
};
var dataEncodingErrorHandler = class {
  constructor(dataObject) {
    this.data = dataObject;
    this.name = dataObject.name;
    this.type = dataObject.type;
  }
  name;
  type;
  isSymbolicLink() {
    return this.type === 2;
  }
  isSocket() {
    return false;
  }
  isFile() {
    return this.type === 1;
  }
  isFIFO() {
    return false;
  }
  isDirectory() {
    return this.type === 0;
  }
  isCharacterDevice() {
    return false;
  }
  isBlockDevice() {
    return false;
  }
};
var _calculateDataEncodingError = /^[0-7]+$/;
function handleDataEncodingError(
  listenerHandler,
  eventListener,
  _eventListener,
) {
  listenerHandler ??= _eventListener;
  if (typeof listenerHandler == "string") {
    if (_calculateDataEncodingError.exec(listenerHandler) === null) {
      throw new Error("invalid mode");
    }
    listenerHandler = parseInt(listenerHandler, 8);
  }
  _dataEncodingErrorHandler(listenerHandler, eventListener);
  return listenerHandler;
}
var processEventListeners = class extends Error {};
var dataEncodingErrorManager = class extends Error {};
var _dataEncodingErrorHandler = (
  ____validateIntegerInRange,
  _____validateIntegerInRange,
  isIntegerInRange,
) => {
  if (typeof ____validateIntegerInRange != "number") {
    throw new processEventListeners(
      _____validateIntegerInRange,
      "number",
      ____validateIntegerInRange,
    );
  }
  if (!Number.isInteger(____validateIntegerInRange)) {
    throw new dataEncodingErrorManager(
      _____validateIntegerInRange,
      "an integer",
      ____validateIntegerInRange,
    );
  }
  let isWithinRangeFlag = isIntegerInRange ? 1 : 0;
  let maxUnsignedIntValue = 4294967295;
  if (
    ____validateIntegerInRange < isWithinRangeFlag ||
    ____validateIntegerInRange > maxUnsignedIntValue
  ) {
    throw new dataEncodingErrorManager(
      _____validateIntegerInRange,
      ">= " + isWithinRangeFlag + " && <= " + maxUnsignedIntValue,
      ____validateIntegerInRange,
    );
  }
};
function getFileAccessMode(functionNameOrVariableMeaningHere, flags = "flags") {
  if (typeof functionNameOrVariableMeaningHere == "number") {
    return functionNameOrVariableMeaningHere;
  }
  if (functionNameOrVariableMeaningHere == null) {
    return writeChunkCallback.O_RDONLY;
  }
  switch (functionNameOrVariableMeaningHere) {
    case "r":
      return writeChunkCallback.O_RDONLY;
    case "rs":
    case "sr":
      return writeChunkCallback.O_RDONLY | writeChunkCallback.O_SYNC;
    case "r+":
      return writeChunkCallback.O_RDWR;
    case "rs+":
    case "sr+":
      return writeChunkCallback.O_RDWR | writeChunkCallback.O_SYNC;
    case "w":
      return (
        writeChunkCallback.O_TRUNC |
        writeChunkCallback.O_CREAT |
        writeChunkCallback.O_WRONLY
      );
    case "wx":
    case "xw":
      return (
        writeChunkCallback.O_TRUNC |
        writeChunkCallback.O_CREAT |
        writeChunkCallback.O_WRONLY |
        writeChunkCallback.O_EXCL
      );
    case "w+":
      return (
        writeChunkCallback.O_TRUNC |
        writeChunkCallback.O_CREAT |
        writeChunkCallback.O_RDWR
      );
    case "wx+":
    case "xw+":
      return (
        writeChunkCallback.O_TRUNC |
        writeChunkCallback.O_CREAT |
        writeChunkCallback.O_RDWR |
        writeChunkCallback.O_EXCL
      );
    case "a":
      return (
        writeChunkCallback.O_APPEND |
        writeChunkCallback.O_CREAT |
        writeChunkCallback.O_WRONLY
      );
    case "ax":
    case "xa":
      return (
        writeChunkCallback.O_APPEND |
        writeChunkCallback.O_CREAT |
        writeChunkCallback.O_WRONLY |
        writeChunkCallback.O_EXCL
      );
    case "as":
    case "sa":
      return (
        writeChunkCallback.O_APPEND |
        writeChunkCallback.O_CREAT |
        writeChunkCallback.O_WRONLY |
        writeChunkCallback.O_SYNC
      );
    case "a+":
      return (
        writeChunkCallback.O_APPEND |
        writeChunkCallback.O_CREAT |
        writeChunkCallback.O_RDWR
      );
    case "ax+":
    case "xa+":
      return (
        writeChunkCallback.O_APPEND |
        writeChunkCallback.O_CREAT |
        writeChunkCallback.O_RDWR |
        writeChunkCallback.O_EXCL
      );
    case "as+":
    case "sa+":
      return (
        writeChunkCallback.O_APPEND |
        writeChunkCallback.O_CREAT |
        writeChunkCallback.O_RDWR |
        writeChunkCallback.O_SYNC
      );
  }
  throw new Error("flags invalid");
}
var validateAndEmitRandomValue = defineObjectProperties(
  getEncodingValidation(),
);
var _________validateNumberInRange = class extends validateAndEmitRandomValue.Readable {
  _read() {}
};
var __________validateNumberInRange = defineObjectProperties(
  getEncodingValidation(),
);
_validateAndRetrieveIntrinsicPropertyValue();
function createAsyncValidationFunction(_validateRangeAndPush) {
  return function (..._args) {
    return new Promise((callbackOnRangeValidation, handleValidationError) => {
      setTimeout(() => {
        try {
          let validatedRangeResult = _validateRangeAndPush(..._args);
          callbackOnRangeValidation(validatedRangeResult);
        } catch (validationError) {
          handleValidationError(validationError);
        }
      }, 0);
    });
  };
}
function asyncCallbackWrapper(createBinding) {
  return function (...executeWithCallback) {
    let callback = executeWithCallback.pop();
    if (typeof callback != "function") {
      throw new Error("No callback provided");
    }
    setTimeout(() => {
      try {
        let bindingResult = createBinding(...executeWithCallback);
        callback(null, bindingResult);
      } catch (___________error) {
        callback(___________error, null);
      }
    }, 0);
  };
}
function createAsyncValidationHandler(
  exportedValidationFunction,
  validateAndExportNumberRange,
) {
  return function (...executeCallbackAfterValidation) {
    let ___callbackFunction = executeCallbackAfterValidation.pop();
    if (typeof ___callbackFunction != "function") {
      throw new Error("No callback provided");
    }
    setTimeout(() => {
      try {
        let validationResult = exportedValidationFunction(
          ...executeCallbackAfterValidation,
        );
        ___callbackFunction(validationResult);
      } catch {
        ___callbackFunction(validateAndExportNumberRange);
      }
    }, 0);
  };
}
var ___validateAndProcessCacheEntry = createAsyncValidationFunction(
  processCacheEntryHandlerAndInitializeEventListener,
);
___validateAndProcessCacheEntry.native = ___validateAndProcessCacheEntry;
var ____validateAndProcessCacheEntry = {
  readFile: createAsyncValidationFunction(processAndTransformChunk),
  writeFile: createAsyncValidationFunction(processAndCacheStreamData),
  mkdir: createAsyncValidationFunction(initializeDataStreamProcessing),
  rmdir: createAsyncValidationFunction(handleCacheEntryProcessing),
  rm: createAsyncValidationFunction(handleMessageProcessing),
  readdir: createAsyncValidationFunction(validateAndProcessCacheEntries),
  unlink: createAsyncValidationFunction(validateCacheEntryAndBind),
  rename: createAsyncValidationFunction(validateAndCacheStreamData),
  stat: createAsyncValidationFunction(handleErrorOrFetchData),
  lstat: createAsyncValidationFunction(_______validateAndProcessCacheEntry),
  symlink: createAsyncValidationFunction(processCacheEntriesHandler),
  link: createAsyncValidationFunction(processAndLogCacheEntry),
  appendFile: createAsyncValidationFunction(handleAndProcessMessageEvent),
  readlink: createAsyncValidationFunction(initializeDebugEventListener),
  access: createAsyncValidationFunction(
    validateCacheEntryAndInitializeListener,
  ),
  copyFile: createAsyncValidationFunction(validateAndLogCacheEntry),
  exists: createAsyncValidationFunction(_______processCacheEntry),
  chown: createAsyncValidationFunction(__processIncomingMessage),
  chmod: createAsyncValidationFunction(_processMessageReceiver),
  createReadStream: processMessageWithValidation,
  constants: writeChunkCallback,
  realpath: ___validateAndProcessCacheEntry,
};
var generateJSONStringifyOrReturn = defineObjectProperties(getMatchingIndex());
var processAndValidateReadableChunk = defineObjectProperties(
  getEncodingValidation(),
);
var processReadableChunkBasedOnType = asyncCallbackWrapper(
  processAndTransformChunk,
);
var processAndValidateCacheValue = asyncCallbackWrapper(
  processAndCacheStreamData,
);
var _validateAndCacheEntry = asyncCallbackWrapper(
  initializeDataStreamProcessing,
);
var processReadableChunkForCache = asyncCallbackWrapper(
  handleCacheEntryProcessing,
);
var processObjectChunk = asyncCallbackWrapper(validateAndProcessCacheEntries);
var validateAndProcessObject = asyncCallbackWrapper(validateCacheEntryAndBind);
var _processReadableChunkBasedOnType = asyncCallbackWrapper(
  validateAndCacheStreamData,
);
var validateAndProcessReadableChunk = asyncCallbackWrapper(
  handleErrorOrFetchData,
);
var isObjectStringified = asyncCallbackWrapper(
  _______validateAndProcessCacheEntry,
);
var parseTemplateString = asyncCallbackWrapper(processCacheEntriesHandler);
var getProcessedReadableChunk = asyncCallbackWrapper(processAndLogCacheEntry);
var _valueFormatter = asyncCallbackWrapper(handleMessageProcessing);
var _processAndValidateCacheValue = asyncCallbackWrapper(
  initializeDebugEventListener,
);
var processChunkBasedOnValidation = asyncCallbackWrapper(
  validateCacheEntryAndInitializeListener,
);
var processAndValidateCache = asyncCallbackWrapper(validateAndLogCacheEntry);
var validateAndProcessChunk = createAsyncValidationHandler(
  _______processCacheEntry,
  false,
);
var processChunkForValidation = asyncCallbackWrapper(handleIncomingMessages);
var _processChunk = asyncCallbackWrapper(removeProcessCacheEntryHandler);
var processReadableChunkToString = asyncCallbackWrapper(
  _____validateAndProcessStreamData,
);
var processAndValidateEntry = asyncCallbackWrapper(__processIncomingMessage);
var _processAndValidateReadableChunk = asyncCallbackWrapper(
  _processMessageReceiver,
);
var _processReadableChunk = asyncCallbackWrapper(handleAndProcessMessageEvent);
var processAndValidateChunk = asyncCallbackWrapper(
  processCacheEntryHandlerAndInitializeEventListener,
);
var _processReadableChunkToString = processAndValidateChunk;
_processReadableChunkToString.native = processAndValidateChunk;
var stringifyProcessReadableChunk =
  processCacheEntryHandlerAndInitializeEventListener;
stringifyProcessReadableChunk.native =
  processCacheEntryHandlerAndInitializeEventListener;
function transformChunkToData(replaceChunkWithEntries, processReadableData) {
  processReadableData = processReadableData ?? "buffer";
  let transformChunkToDataBuffer =
    ____________________________________________validateAndRetrieveIntrinsicProperties(
      replaceChunkWithEntries,
    );
  if (processReadableData === "buffer") {
    return transformChunkToDataBuffer;
  } else {
    return transformChunkToDataBuffer.toString(processReadableData);
  }
}
function waitForIdleDependencies() {
  return incrementOrReset.waitForIdleDependencies();
}
function processAndTransformChunk(
  processAndValidateCacheEntry,
  chunkReplacementHandler,
) {
  let parsedChunkData = incrementOrReset.readFileSync(
    __initializeEventListener(processAndValidateCacheEntry),
  );
  let chunkEncodingOrReplacementHandler =
    typeof chunkReplacementHandler == "string"
      ? chunkReplacementHandler
      : chunkReplacementHandler?.encoding;
  return transformChunkToData(
    parsedChunkData,
    chunkEncodingOrReplacementHandler,
  );
}
function processAndValidateStreamData(
  __processStreamData,
  validateAndCacheChunk,
) {
  validateAndCacheChunk = validateAndCacheChunk ?? "utf-8";
  return getReadableStreamProperties(
    __processStreamData,
    validateAndCacheChunk,
  );
}
function processAndCacheStreamData(
  _validateAndProcessStreamData,
  __validateAndProcessStreamData,
  validateStreamDataAndCache,
) {
  let processedStreamData = processAndValidateStreamData(
    __validateAndProcessStreamData,
    validateStreamDataAndCache,
  );
  incrementOrReset.writeFileSync(
    __initializeEventListener(_validateAndProcessStreamData),
    processedStreamData,
  );
}
function initializeDataStreamProcessing(
  validateAndProcessDataStream,
  ___validateAndProcessStreamData,
) {
  incrementOrReset.mkdir(
    __initializeEventListener(validateAndProcessDataStream),
    ___validateAndProcessStreamData,
  );
}
function handleCacheEntryProcessing(
  ___validateCacheEntry,
  ___processCacheEntry,
) {
  incrementOrReset.rmdir(
    __initializeEventListener(___validateCacheEntry),
    ___processCacheEntry,
  );
}
function processValidationEntries(_validateCacheAndProcessEntry) {
  return _validateCacheAndProcessEntry.map((___dataEncodingErrorHandler) =>
    typeof ___dataEncodingErrorHandler == "string"
      ? ___dataEncodingErrorHandler
      : new dataEncodingErrorHandler(___dataEncodingErrorHandler),
  );
}
function validateAndProcessCacheEntries(
  _____validateAndProcessCacheEntry,
  ____validateCacheEntry,
) {
  let cacheEntries = incrementOrReset.readdir(
    __initializeEventListener(_____validateAndProcessCacheEntry),
    ____validateCacheEntry,
  );
  return processValidationEntries(cacheEntries);
}
function validateCacheEntryAndBind(_____validateCacheEntry) {
  incrementOrReset.unlink(__initializeEventListener(_____validateCacheEntry));
}
function validateAndCacheStreamData(
  validateStreamDataAndThrowError,
  ______validateCacheEntry,
) {
  incrementOrReset.rename(
    __initializeEventListener(validateStreamDataAndThrowError),
    ______validateCacheEntry,
  );
}
function validateAndStreamCacheEntry(__validateCacheAndProcessEntry) {
  return createWritableStreamFromHandle(__validateCacheAndProcessEntry);
}
function handleErrorOrFetchData(
  _handleError,
  optionsObject = {
    throwIfNoEntry: true,
  },
) {
  try {
    return validateAndStreamCacheEntry(
      incrementOrReset.stat(__initializeEventListener(_handleError)),
    );
  } catch (_error) {
    if (optionsObject.throwIfNoEntry === false && _error.code === "ENOENT") {
      return;
    }
    throw _error;
  }
}
function _______validateAndProcessCacheEntry(
  ______validateAndProcessCacheEntry,
) {
  return validateAndStreamCacheEntry(
    incrementOrReset.lstat(
      __initializeEventListener(______validateAndProcessCacheEntry),
    ),
  );
}
function _____validateAndProcessStreamData(____validateAndProcessStreamData) {
  let { path: streamDataPath } =
    __processCacheEntryHandler[____validateAndProcessStreamData];
  if (!streamDataPath) {
    throw new Error(
      "Could not find path for fd: " + ____validateAndProcessStreamData,
    );
  }
  return validateAndStreamCacheEntry(incrementOrReset.stat(streamDataPath));
}
function processCacheEntriesHandler(
  ____processCacheEntry,
  _____processCacheEntry,
) {
  incrementOrReset.symlink(
    __initializeEventListener(____processCacheEntry),
    __initializeEventListener(_____processCacheEntry),
  );
}
function processAndLogCacheEntry(
  processCacheEntryHandler,
  processCacheEntryLoggingFunction,
) {
  incrementOrReset.symlink(
    __initializeEventListener(processCacheEntryHandler),
    __initializeEventListener(processCacheEntryLoggingFunction),
  );
}
function initializeDebugEventListener(handleEmulatorDebug) {
  return incrementOrReset.readlink(
    __initializeEventListener(handleEmulatorDebug),
  );
}
function validateCacheEntryAndInitializeListener(_handleCacheEntryValidation) {
  incrementOrReset.access(
    __initializeEventListener(_handleCacheEntryValidation),
  );
}
function validateAndLogCacheEntry(
  __handleCacheEntryValidation,
  cacheEntryValidationLogger,
  validateCacheEntryLogger,
) {
  incrementOrReset.copyFile(
    __initializeEventListener(__handleCacheEntryValidation),
    __initializeEventListener(cacheEntryValidationLogger),
    validateCacheEntryLogger,
  );
}
function processCacheEntryHandlerAndInitializeEventListener(
  _processCacheEntryHandler,
) {
  return incrementOrReset.realpath(
    __initializeEventListener(_processCacheEntryHandler),
  );
}
function _______processCacheEntry(_cacheEntryProcessor) {
  if (_cacheEntryProcessor) {
    return incrementOrReset.exists(
      __initializeEventListener(_cacheEntryProcessor),
    );
  } else {
    return false;
  }
}
var __processCacheEntryHandler = {};
function handleIncomingMessages(
  processMessageReceiver,
  processIncomingMessage,
  _processIncomingMessage,
) {
  if (arguments.length < 2) {
    processIncomingMessage = "r";
    _processIncomingMessage = 438;
  } else if (typeof _processIncomingMessage == "function") {
    _processIncomingMessage = 438;
  } else {
    _processIncomingMessage = handleDataEncodingError(
      _processIncomingMessage,
      "mode",
      438,
    );
  }
  let fileAccessMode =
    getFileAccessMode(processIncomingMessage) & writeChunkCallback.O_CREAT;
  processMessageReceiver = __initializeEventListener(processMessageReceiver);
  try {
    incrementOrReset.access(processMessageReceiver);
  } catch (errorHandlingException) {
    if (fileAccessMode) {
      processAndCacheStreamData(processMessageReceiver, "");
    } else {
      throw errorHandlingException;
    }
  }
  let cacheEntryId = Math.floor(Math.random() * 100000);
  __processCacheEntryHandler[cacheEntryId] = {
    path: processMessageReceiver,
    cursor: 0,
  };
  return cacheEntryId;
}
function removeProcessCacheEntryHandler(messageReceiverHandshakeHandler) {
  delete __processCacheEntryHandler[messageReceiverHandshakeHandler];
}
function processMessageWithValidation(handleIncomingMessage) {
  let numberRangeValidator = new _________validateNumberInRange();
  setTimeout(() => {
    try {
      let processedMessageChunk = processAndTransformChunk(
        handleIncomingMessage,
      );
      numberRangeValidator.push(processedMessageChunk);
      numberRangeValidator.push(null);
    } catch (_____________error) {
      numberRangeValidator.destroy(_____________error);
    }
  }, 1);
  return numberRangeValidator;
}
function _processMessageReceiver(messageReceiverHandler) {
  handleErrorOrFetchData(messageReceiverHandler);
}
function __processIncomingMessage(incomingMessageHandler) {
  handleErrorOrFetchData(incomingMessageHandler);
}
function handleMessageProcessing(
  _handleIncomingMessage,
  __handleIncomingMessage,
) {
  __handleIncomingMessage = __handleIncomingMessage || {};
  try {
    if (handleErrorOrFetchData(_handleIncomingMessage)?.isDirectory()) {
      return handleCacheEntryProcessing(
        _handleIncomingMessage,
        __handleIncomingMessage,
      );
    } else {
      return validateCacheEntryAndBind(_handleIncomingMessage);
    }
  } catch (______error) {
    if (__handleIncomingMessage.force) {
      return;
    }
    throw ______error;
  }
}
function handleAndProcessMessageEvent(
  handleMessageEvent,
  handleMessage,
  processMessageEvent,
) {
  let decodedMessage = "";
  try {
    decodedMessage = processAndTransformChunk(
      __initializeEventListener(handleMessageEvent),
      processMessageEvent || "utf8",
    );
  } catch (_____error) {
    if (!_____error.message.includes("ENOENT")) {
      throw _____error;
    }
  }
  let combinedMessage =
    typeof handleMessage == "string" && typeof decodedMessage == "string"
      ? decodedMessage + handleMessage
      : Buffer.concat([
          Buffer.isBuffer(decodedMessage)
            ? decodedMessage
            : Buffer.from(decodedMessage),
          Buffer.isBuffer(handleMessage)
            ? handleMessage
            : Buffer.from(handleMessage),
        ]);
  processAndCacheStreamData(
    handleMessageEvent,
    combinedMessage,
    processMessageEvent,
  );
}
globalThis.global = globalThis;
globalThis.originalConsole = console;
var ___processStreamData = processAndEmitEventHandler("runtime");
async function monitorFileSystemEventsAndHandleDependencies() {
  let utf8ByteLength = calculateUtf8ByteLength.default.slug();
  let destroyHandler = new destroyNextTickHandler(utf8ByteLength);
  incrementOrReset.isMain = true;
  incrementOrReset.core.onFSEvent((dependencyAction) => {
    if (
      (() => {
        if (dependencyAction.type === "create") {
          let nodeName = dependencyAction.newNode.name;
          if (nodeName) {
            return dependencyAction.parent + "/" + nodeName === isPathAbsolute;
          }
        } else if (dependencyAction.type === "write") {
          return dependencyAction.path === isPathAbsolute;
        }
      })()
    ) {
      incrementOrReset
        .installDependencies()
        .catch((logDependencyReinstallError) => {
          console.error(
            'Failed to re-install dependencies upon "package.json" change.',
          );
          console.error(logDependencyReinstallError);
        });
    }
  });
  incrementOrReset.mkdir("/tmp");
  let _cacheEntryValidator = new handleCacheEntryValidation();
  _cacheEntryValidator.on("connect", ({ cdnUrl: ____cdnUrl }) => {
    let __cdnUrl = ____cdnUrl || "https://sandpack-cdn-v2.codesandbox.io";
    isWritableStateError(
      __cdnUrl,
      "Failed to connect to Nodebox: the Sandpack CDN URL is not defined",
    );
    incrementOrReset.cdnUrl = __cdnUrl;
    _cacheEntryValidator.send("runtime/ready");
  });
  incrementOrReset.packageManager.addEventListener(
    "progress",
    (moduleDownloadProgress) => {
      let {
        name: moduleName,
        totalPending: totalDownloadsPending,
        version: moduleVersion,
      } = moduleDownloadProgress.data;
      _cacheEntryValidator.send("worker/progress", {
        status: {
          state: "downloaded_module",
          name: moduleName,
          totalPending: totalDownloadsPending,
          version: moduleVersion,
        },
      });
    },
  );
  if (!_______processCacheEntry(isAbortSignalHandled)) {
    initializeDataStreamProcessing(isAbortSignalHandled);
  }
  _cacheEntryValidator.on("fs/init", ({ files: fileList }) => {
    ___processStreamData("Handling fs/init");
    Object.entries(fileList).map(([_userAge, userAgeValidation]) => {
      let __resolvedPath = resolvePath(
        joinPaths(isAbortSignalHandled, _userAge),
      );
      let _formattedByteLength = formatByteLength(__resolvedPath);
      initializeDataStreamProcessing(_formattedByteLength, {
        recursive: true,
      });
      processAndCacheStreamData(__resolvedPath, userAgeValidation);
    });
  });
  _cacheEntryValidator.on(
    "fs/readFile",
    ({ path: ________filePath, encoding: _fileEncoding }) => ({
      data: processAndTransformChunk(
        joinPaths(isAbortSignalHandled, ________filePath),
        _fileEncoding,
      ),
    }),
  );
  _cacheEntryValidator.on(
    "fs/writeFile",
    ({
      path: _____filePath,
      content: ___fileContent,
      encoding: fileEncoding,
      recursive: _isRecursive,
    }) => {
      let resolveAndCreatePath = joinPaths(isAbortSignalHandled, _____filePath);
      if (_isRecursive) {
        initializeDataStreamProcessing(formatByteLength(resolveAndCreatePath), {
          recursive: true,
        });
      }
      processAndCacheStreamData(
        resolveAndCreatePath,
        ___fileContent,
        fileEncoding,
      );
    },
  );
  _cacheEntryValidator.on("fs/readdir", ({ path: _________filePath }) => ({
    data: validateAndProcessCacheEntries(
      joinPaths(isAbortSignalHandled, _________filePath),
    ),
  }));
  _cacheEntryValidator.on(
    "fs/mkdir",
    ({ path: _______filePath, recursive: ___isRecursive }) => {
      initializeDataStreamProcessing(
        joinPaths(isAbortSignalHandled, _______filePath),
        {
          recursive: ___isRecursive,
        },
      );
    },
  );
  _cacheEntryValidator.on(
    "fs/rm",
    ({ path: ______filePath, force: isForceful, recursive: __isRecursive }) => {
      handleMessageProcessing(joinPaths(isAbortSignalHandled, ______filePath), {
        force: isForceful,
        recursive: __isRecursive,
      });
    },
  );
  _cacheEntryValidator.on("fs/stat", ({ path: __________filePath }) => {
    let fileStats = handleErrorOrFetchData(
      joinPaths(isAbortSignalHandled, __________filePath),
    );
    if (!fileStats) {
      throw new Error("File not found");
    }
    return {
      data: {
        type: fileStats.isFile()
          ? "file"
          : fileStats.isDirectory()
            ? "dir"
            : "link",
        size: fileStats.size,
        ino: fileStats.ino,
        atimeMs: fileStats.atimeMs,
        mtimeMs: fileStats.mtimeMs,
        ctimeMs: fileStats.ctimeMs,
        blocks: fileStats.blocks,
        mode: fileStats.mode,
      },
    };
  });
  let cdnUrl = new Map();
  _cacheEntryValidator.on(
    "fs/watch",
    ({
      watcherId: watcherId,
      includes: isIncluded,
      excludes: exclusionList,
    }) => {
      let eventListenerManager = new EventListenerManager(
        isIncluded.map((joinedAbortSignalPaths) =>
          joinPaths(isAbortSignalHandled, joinedAbortSignalPaths),
        ),
        exclusionList.map((joinPathsWithSignal) =>
          joinPaths(isAbortSignalHandled, joinPathsWithSignal),
        ),
      );
      cdnUrl.set(watcherId, eventListenerManager);
      let _handleFileSystemEvent = (fileSystemWatchEvent) => {
        switch (fileSystemWatchEvent.type) {
          case "change":
            _cacheEntryValidator.send("fs/watch-event", {
              type: "change",
              path: fileSystemWatchEvent.path.replace(isAbortSignalHandled, ""),
              watcherId: watcherId,
            });
            break;
          case "create":
            _cacheEntryValidator.send("fs/watch-event", {
              type: "create",
              path: fileSystemWatchEvent.path.replace(isAbortSignalHandled, ""),
              watcherId: watcherId,
            });
            break;
          case "remove":
            _cacheEntryValidator.send("fs/watch-event", {
              type: "remove",
              path: fileSystemWatchEvent.path.replace(isAbortSignalHandled, ""),
              watcherId: watcherId,
            });
            break;
          case "rename":
            _cacheEntryValidator.send("fs/watch-event", {
              type: "rename",
              oldPath: fileSystemWatchEvent.oldPath.replace(
                isAbortSignalHandled,
                "",
              ),
              newPath: fileSystemWatchEvent.newPath.replace(
                isAbortSignalHandled,
                "",
              ),
              watcherId: watcherId,
            });
            break;
          case "close":
            _cacheEntryValidator.send("fs/watch-event", {
              type: "close",
              watcherId: watcherId,
            });
            break;
        }
      };
      eventListenerManager.onChange(_handleFileSystemEvent);
    },
  );
  _cacheEntryValidator.on("fs/unwatch", ({ watcherId: _watcherId }) => {
    cdnUrl.get(_watcherId)?.close();
  });
  let _cdnUrl = new Map();
  _cacheEntryValidator.on("shell/exit", ({ id: userId }) => {
    ___processStreamData(
      'consumer requested to exit shell at worker "%s"',
      userId,
    );
    let workerInstance = _cdnUrl.get(userId);
    _validateWritableState(
      workerInstance,
      "Trying to exit a worker that doesn't exist",
    );
    if (workerInstance) {
      workerInstance.stop();
      _cdnUrl.delete(userId);
    }
  });
  _cacheEntryValidator.on(
    "shell/stdin",
    ({ workerId: workerIdentifier, data: responseData }) => {
      let _workerInstance = _cdnUrl.get(workerIdentifier);
      if (_workerInstance) {
        _workerInstance.sendInput(responseData);
      }
    },
  );
  _cacheEntryValidator.on(
    "shell/runCommand",
    async ({
      command: executeCommand,
      args: commandArguments,
      options: commandOptions,
    }) => {
      let deferredPromiseForWorker = new createDeferredPromise(destroyHandler);
      _cacheEntryValidator.send("worker/progress", {
        status: {
          state: "downloading_manifest",
        },
      });
      await waitForIdleDependencies();
      let workerId = await deferredPromiseForWorker.init();
      _cdnUrl.set(workerId, deferredPromiseForWorker);
      deferredPromiseForWorker.emitter.addEventListener(
        "worker/tty:out",
        ({ data: dataPayload }) => {
          _cacheEntryValidator.send("worker/tty", {
            workerId: workerId,
            payload: dataPayload.payload,
          });
        },
      );
      deferredPromiseForWorker.emitter.addEventListener(
        "worker/exit",
        ({ data: _responseData }) => {
          _cacheEntryValidator.send("worker/exit", {
            workerId: workerId,
            exitCode: _responseData.exitCode,
          });
        },
      );
      deferredPromiseForWorker.emitter.addEventListener(
        "worker/error",
        ({ data: __responseData }) => {
          _cacheEntryValidator.send("worker/exit", {
            workerId: workerId,
            exitCode: 1,
            error: __responseData.error,
          });
        },
      );
      return new Promise((initializeWorkerAndMonitorProgress) => {
        initializeWorkerAndMonitorProgress({
          id: workerId,
        });
        _cacheEntryValidator.send("worker/progress", {
          workerId: workerId,
          status: {
            state: "starting_command",
          },
        });
        let abortHandler = new signalAbortHandler();
        let onWorkerStartedUpdate = () => {
          _cacheEntryValidator.send("worker/progress", {
            workerId: workerId,
            status: {
              state: "command_running",
            },
          });
          abortHandler.dispose();
        };
        deferredPromiseForWorker.emitter.addEventListener(
          "worker/started",
          onWorkerStartedUpdate,
        );
        abortHandler.onDidDispose(() =>
          deferredPromiseForWorker.emitter.removeEventListener(
            "worker/started",
            onWorkerStartedUpdate,
          ),
        );
        let currentWorkingDirectory = commandOptions.cwd
          ? joinPaths(isAbortSignalHandled, commandOptions.cwd)
          : isAbortSignalHandled;
        deferredPromiseForWorker.runCommand({
          command: executeCommand,
          args: commandArguments,
          cwd: currentWorkingDirectory,
          env: commandOptions.env,
        });
      });
    },
  );
  _cacheEntryValidator.on(
    "preview/get/info",
    ({ sourceShellId: sourceShellIdentifier, port: _sourcePort }) => {
      let portToUse =
        _sourcePort ||
        (sourceShellIdentifier
          ? destroyHandler.getPortFromShellId(sourceShellIdentifier)
          : undefined);
      if (!portToUse || !destroyHandler.ports.has(portToUse)) {
        return;
      }
      let sourcePort =
        sourceShellIdentifier || destroyHandler.ports.get(portToUse);
      let baseLinkUrl = destroyHandler.getBaseLink(portToUse);
      return {
        port: portToUse,
        url: baseLinkUrl,
        sourceShellId: sourcePort,
      };
    },
  );
  destroyHandler.emitter.addEventListener("port/ready", (portPreviewData) => {
    _cacheEntryValidator.send("preview/port/ready", portPreviewData.data);
  });
}
monitorFileSystemEventsAndHandleDependencies().catch(console.error);
